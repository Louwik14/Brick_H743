
build/.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	38800400 	.word	0x38800400
 8000004:	0800041d 	.word	0x0800041d
 8000008:	0800041f 	.word	0x0800041f
 800000c:	0800041f 	.word	0x0800041f
 8000010:	0800041f 	.word	0x0800041f
 8000014:	0800041f 	.word	0x0800041f
 8000018:	0800041f 	.word	0x0800041f
 800001c:	0800041f 	.word	0x0800041f
 8000020:	0800041f 	.word	0x0800041f
 8000024:	0800041f 	.word	0x0800041f
 8000028:	0800041f 	.word	0x0800041f
 800002c:	08006be9 	.word	0x08006be9
 8000030:	0800041f 	.word	0x0800041f
 8000034:	0800041f 	.word	0x0800041f
 8000038:	0800041f 	.word	0x0800041f
 800003c:	0800041f 	.word	0x0800041f
 8000040:	0800041f 	.word	0x0800041f
 8000044:	0800041f 	.word	0x0800041f
 8000048:	0800041f 	.word	0x0800041f
 800004c:	0800041f 	.word	0x0800041f
 8000050:	0800041f 	.word	0x0800041f
 8000054:	0800041f 	.word	0x0800041f
 8000058:	0800041f 	.word	0x0800041f
 800005c:	0800041f 	.word	0x0800041f
 8000060:	0800041f 	.word	0x0800041f
 8000064:	0800041f 	.word	0x0800041f
 8000068:	0800041f 	.word	0x0800041f
 800006c:	08002ab9 	.word	0x08002ab9
 8000070:	08002af1 	.word	0x08002af1
 8000074:	08002b2d 	.word	0x08002b2d
 8000078:	08002b69 	.word	0x08002b69
 800007c:	08002ba5 	.word	0x08002ba5
 8000080:	08002bdd 	.word	0x08002bdd
 8000084:	08002c19 	.word	0x08002c19
 8000088:	08002689 	.word	0x08002689
 800008c:	0800041f 	.word	0x0800041f
 8000090:	0800041f 	.word	0x0800041f
 8000094:	0800041f 	.word	0x0800041f
 8000098:	0800041f 	.word	0x0800041f
 800009c:	0800041f 	.word	0x0800041f
 80000a0:	0800041f 	.word	0x0800041f
 80000a4:	0800041f 	.word	0x0800041f
 80000a8:	0800041f 	.word	0x0800041f
 80000ac:	0800041f 	.word	0x0800041f
 80000b0:	08001e09 	.word	0x08001e09
 80000b4:	0800041f 	.word	0x0800041f
 80000b8:	0800041f 	.word	0x0800041f
 80000bc:	0800041f 	.word	0x0800041f
 80000c0:	0800041f 	.word	0x0800041f
 80000c4:	0800041f 	.word	0x0800041f
 80000c8:	0800041f 	.word	0x0800041f
 80000cc:	08004dc9 	.word	0x08004dc9
 80000d0:	08004e31 	.word	0x08004e31
 80000d4:	0800041f 	.word	0x0800041f
 80000d8:	0800041f 	.word	0x0800041f
 80000dc:	08001de1 	.word	0x08001de1
 80000e0:	0800041f 	.word	0x0800041f
 80000e4:	0800041f 	.word	0x0800041f
 80000e8:	0800041f 	.word	0x0800041f
 80000ec:	08001e29 	.word	0x08001e29
 80000f0:	08001e45 	.word	0x08001e45
 80000f4:	08001e6d 	.word	0x08001e6d
 80000f8:	08001e89 	.word	0x08001e89
 80000fc:	08002c55 	.word	0x08002c55
 8000100:	0800041f 	.word	0x0800041f
 8000104:	08001db9 	.word	0x08001db9
 8000108:	0800041f 	.word	0x0800041f
 800010c:	08004e99 	.word	0x08004e99
 8000110:	0800041f 	.word	0x0800041f
 8000114:	0800041f 	.word	0x0800041f
 8000118:	0800041f 	.word	0x0800041f
 800011c:	0800041f 	.word	0x0800041f
 8000120:	08002c91 	.word	0x08002c91
 8000124:	08002cc9 	.word	0x08002cc9
 8000128:	08002d05 	.word	0x08002d05
 800012c:	08002d41 	.word	0x08002d41
 8000130:	08002d7d 	.word	0x08002d7d
 8000134:	0800041f 	.word	0x0800041f
 8000138:	0800041f 	.word	0x0800041f
 800013c:	0800041f 	.word	0x0800041f
 8000140:	0800041f 	.word	0x0800041f
 8000144:	0800041f 	.word	0x0800041f
 8000148:	0800041f 	.word	0x0800041f
 800014c:	0800041f 	.word	0x0800041f
 8000150:	08002db5 	.word	0x08002db5
 8000154:	08002df1 	.word	0x08002df1
 8000158:	08002e2d 	.word	0x08002e2d
 800015c:	0800041f 	.word	0x0800041f
 8000160:	08003141 	.word	0x08003141
 8000164:	08003315 	.word	0x08003315
 8000168:	0800041f 	.word	0x0800041f
 800016c:	0800041f 	.word	0x0800041f
 8000170:	0800041f 	.word	0x0800041f
 8000174:	08004195 	.word	0x08004195
 8000178:	0800041f 	.word	0x0800041f
 800017c:	0800041f 	.word	0x0800041f
 8000180:	0800041f 	.word	0x0800041f
 8000184:	0800041f 	.word	0x0800041f
 8000188:	0800041f 	.word	0x0800041f
 800018c:	0800041f 	.word	0x0800041f
 8000190:	08004f01 	.word	0x08004f01
 8000194:	08004f69 	.word	0x08004f69
 8000198:	08004fd1 	.word	0x08004fd1
 800019c:	0800041f 	.word	0x0800041f
 80001a0:	0800041f 	.word	0x0800041f
 80001a4:	0800041f 	.word	0x0800041f
 80001a8:	0800041f 	.word	0x0800041f
 80001ac:	0800041f 	.word	0x0800041f
 80001b0:	0800041f 	.word	0x0800041f
 80001b4:	0800041f 	.word	0x0800041f
 80001b8:	0800041f 	.word	0x0800041f
 80001bc:	0800041f 	.word	0x0800041f
 80001c0:	0800041f 	.word	0x0800041f
 80001c4:	0800041f 	.word	0x0800041f
 80001c8:	0800041f 	.word	0x0800041f
 80001cc:	0800041f 	.word	0x0800041f
 80001d0:	0800041f 	.word	0x0800041f
 80001d4:	0800416d 	.word	0x0800416d
 80001d8:	0800041f 	.word	0x0800041f
 80001dc:	0800041f 	.word	0x0800041f
 80001e0:	0800041f 	.word	0x0800041f
 80001e4:	0800041f 	.word	0x0800041f
 80001e8:	0800041f 	.word	0x0800041f
 80001ec:	0800041f 	.word	0x0800041f
 80001f0:	0800041f 	.word	0x0800041f
 80001f4:	0800041f 	.word	0x0800041f
 80001f8:	0800041f 	.word	0x0800041f
 80001fc:	0800041f 	.word	0x0800041f
 8000200:	0800041f 	.word	0x0800041f
 8000204:	0800041f 	.word	0x0800041f
 8000208:	0800041f 	.word	0x0800041f
 800020c:	0800041f 	.word	0x0800041f
 8000210:	0800041f 	.word	0x0800041f
 8000214:	0800041f 	.word	0x0800041f
 8000218:	0800041f 	.word	0x0800041f
 800021c:	0800041f 	.word	0x0800041f
 8000220:	0800041f 	.word	0x0800041f
 8000224:	0800041f 	.word	0x0800041f
 8000228:	0800041f 	.word	0x0800041f
 800022c:	0800041f 	.word	0x0800041f
 8000230:	0800041f 	.word	0x0800041f
 8000234:	0800041f 	.word	0x0800041f
 8000238:	0800041f 	.word	0x0800041f
 800023c:	080026b9 	.word	0x080026b9
 8000240:	0800041f 	.word	0x0800041f
 8000244:	08002799 	.word	0x08002799
 8000248:	080027d1 	.word	0x080027d1
 800024c:	0800280d 	.word	0x0800280d
 8000250:	08002849 	.word	0x08002849
 8000254:	08002885 	.word	0x08002885
 8000258:	080028c1 	.word	0x080028c1
 800025c:	080028fd 	.word	0x080028fd
 8000260:	08002939 	.word	0x08002939
 8000264:	0800041f 	.word	0x0800041f
 8000268:	0800041f 	.word	0x0800041f
 800026c:	0800041f 	.word	0x0800041f
 8000270:	0800041f 	.word	0x0800041f
 8000274:	0800041f 	.word	0x0800041f
 8000278:	0800041f 	.word	0x0800041f
 800027c:	0800041f 	.word	0x0800041f
 8000280:	0800041f 	.word	0x0800041f
 8000284:	0800041f 	.word	0x0800041f
 8000288:	0800041f 	.word	0x0800041f
 800028c:	0800041f 	.word	0x0800041f
 8000290:	0800041f 	.word	0x0800041f
 8000294:	0800041f 	.word	0x0800041f
 8000298:	0800041f 	.word	0x0800041f
 800029c:	0800041f 	.word	0x0800041f
 80002a0:	0800041f 	.word	0x0800041f
 80002a4:	0800041f 	.word	0x0800041f
 80002a8:	0800041f 	.word	0x0800041f
 80002ac:	0800041f 	.word	0x0800041f
 80002b0:	0800041f 	.word	0x0800041f
 80002b4:	0800041f 	.word	0x0800041f
 80002b8:	0800041f 	.word	0x0800041f
 80002bc:	0800041f 	.word	0x0800041f
 80002c0:	0800041f 	.word	0x0800041f
 80002c4:	0800041f 	.word	0x0800041f
 80002c8:	0800041f 	.word	0x0800041f
 80002cc:	0800041f 	.word	0x0800041f
 80002d0:	0800041f 	.word	0x0800041f
 80002d4:	0800041f 	.word	0x0800041f
 80002d8:	0800041f 	.word	0x0800041f
 80002dc:	0800041f 	.word	0x0800041f

Disassembly of section .text:

08000300 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000300:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000302:	4837      	ldr	r0, [pc, #220]	; (80003e0 <_crt0_entry+0xe0>)
                msr     MSP, r0
 8000304:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000308:	4836      	ldr	r0, [pc, #216]	; (80003e4 <_crt0_entry+0xe4>)
                msr     PSP, r0
 800030a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 800030e:	4836      	ldr	r0, [pc, #216]	; (80003e8 <_crt0_entry+0xe8>)
                ldr     r1, =SCB_VTOR
 8000310:	4936      	ldr	r1, [pc, #216]	; (80003ec <_crt0_entry+0xec>)
                str     r0, [r1]
 8000312:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 8000314:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 8000318:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 800031c:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 8000320:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000324:	6008      	str	r0, [r1, #0]
                dsb
 8000326:	f3bf 8f4f 	dsb	sy
                isb
 800032a:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 800032e:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 8000332:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 8000336:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 800033a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800033e:	6008      	str	r0, [r1, #0]
                dsb
 8000340:	f3bf 8f4f 	dsb	sy
                isb
 8000344:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 8000348:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 800034c:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000350:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 8000354:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000358:	6008      	str	r0, [r1, #0]
#endif

                /* CONTROL register initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 800035a:	2002      	movs	r0, #2
                msr     CONTROL, r0
 800035c:	f380 8814 	msr	CONTROL, r0
                isb
 8000360:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 8000364:	f000 fb6c 	bl	8000a40 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000368:	f005 fb32 	bl	80059d0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800036c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000370:	491f      	ldr	r1, [pc, #124]	; (80003f0 <_crt0_entry+0xf0>)
                ldr     r2, =__main_stack_end__
 8000372:	4a1b      	ldr	r2, [pc, #108]	; (80003e0 <_crt0_entry+0xe0>)
.Lmsloop:
                cmp     r1, r2
 8000374:	4291      	cmp	r1, r2
                itt     lo
 8000376:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000378:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lmsloop
 800037c:	e7fa      	bcc.n	8000374 <_crt0_entry+0x74>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800037e:	491d      	ldr	r1, [pc, #116]	; (80003f4 <_crt0_entry+0xf4>)
                ldr     r2, =__process_stack_end__
 8000380:	4a18      	ldr	r2, [pc, #96]	; (80003e4 <_crt0_entry+0xe4>)
.Lpsloop:
                cmp     r1, r2
 8000382:	4291      	cmp	r1, r2
                itt     lo
 8000384:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000386:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lpsloop
 800038a:	e7fa      	bcc.n	8000382 <_crt0_entry+0x82>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 800038c:	491a      	ldr	r1, [pc, #104]	; (80003f8 <_crt0_entry+0xf8>)
                ldr     r2, =__data_base__
 800038e:	4a1b      	ldr	r2, [pc, #108]	; (80003fc <_crt0_entry+0xfc>)
                ldr     r3, =__data_end__
 8000390:	4b1b      	ldr	r3, [pc, #108]	; (8000400 <_crt0_entry+0x100>)
.Ldloop:
                cmp     r2, r3
 8000392:	429a      	cmp	r2, r3
                ittt    lo
 8000394:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000396:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800039a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     .Ldloop
 800039e:	e7f8      	bcc.n	8000392 <_crt0_entry+0x92>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 80003a0:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 80003a2:	4918      	ldr	r1, [pc, #96]	; (8000404 <_crt0_entry+0x104>)
                ldr     r2, =__bss_end__
 80003a4:	4a18      	ldr	r2, [pc, #96]	; (8000408 <_crt0_entry+0x108>)
.Lbloop:
                cmp     r1, r2
 80003a6:	4291      	cmp	r1, r2
                itt     lo
 80003a8:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80003aa:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lbloop
 80003ae:	e7fa      	bcc.n	80003a6 <_crt0_entry+0xa6>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 80003b0:	f000 fba2 	bl	8000af8 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 80003b4:	f000 fb9c 	bl	8000af0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 80003b8:	4c14      	ldr	r4, [pc, #80]	; (800040c <_crt0_entry+0x10c>)
                ldr     r5, =__init_array_end__
 80003ba:	4d15      	ldr	r5, [pc, #84]	; (8000410 <_crt0_entry+0x110>)
.Linitloop:
                cmp     r4, r5
 80003bc:	42ac      	cmp	r4, r5
                bge     .Lendinitloop
 80003be:	da03      	bge.n	80003c8 <_crt0_entry+0xc8>
                ldr     r1, [r4], #4
 80003c0:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80003c4:	4788      	blx	r1
                b       .Linitloop
 80003c6:	e7f9      	b.n	80003bc <_crt0_entry+0xbc>
.Lendinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80003c8:	f006 fc82 	bl	8006cd0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80003cc:	4c11      	ldr	r4, [pc, #68]	; (8000414 <_crt0_entry+0x114>)
                ldr     r5, =__fini_array_end__
 80003ce:	4d12      	ldr	r5, [pc, #72]	; (8000418 <_crt0_entry+0x118>)
.Lfiniloop:
                cmp     r4, r5
 80003d0:	42ac      	cmp	r4, r5
                bge     .Lendfiniloop
 80003d2:	da03      	bge.n	80003dc <_crt0_entry+0xdc>
                ldr     r1, [r4], #4
 80003d4:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80003d8:	4788      	blx	r1
                b       .Lfiniloop
 80003da:	e7f9      	b.n	80003d0 <_crt0_entry+0xd0>
.Lendfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80003dc:	f000 bb8a 	b.w	8000af4 <__default_exit>
                ldr     r0, =__main_stack_end__
 80003e0:	38800400 	.word	0x38800400
                ldr     r0, =__process_stack_end__
 80003e4:	38800800 	.word	0x38800800
                ldr     r0, =_vectors
 80003e8:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 80003ec:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 80003f0:	38800000 	.word	0x38800000
                ldr     r1, =__process_stack_base__
 80003f4:	38800400 	.word	0x38800400
                ldr     r1, =__textdata_base__
 80003f8:	08015dd8 	.word	0x08015dd8
                ldr     r2, =__data_base__
 80003fc:	24000000 	.word	0x24000000
                ldr     r3, =__data_end__
 8000400:	240006ec 	.word	0x240006ec
                ldr     r1, =__bss_base__
 8000404:	24000700 	.word	0x24000700
                ldr     r2, =__bss_end__
 8000408:	240061c0 	.word	0x240061c0
                ldr     r4, =__init_array_base__
 800040c:	080002e0 	.word	0x080002e0
                ldr     r5, =__init_array_end__
 8000410:	080002e0 	.word	0x080002e0
                ldr     r4, =__fini_array_base__
 8000414:	080002e0 	.word	0x080002e0
                ldr     r5, =__fini_array_end__
 8000418:	080002e0 	.word	0x080002e0

0800041c <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 800041c:	e770      	b.n	8000300 <_crt0_entry>

0800041e <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800041e:	f000 f800 	bl	8000422 <_unhandled_exception>

08000422 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000422:	e7fe      	b.n	8000422 <_unhandled_exception>

08000424 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000424:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                /* Saving FPU context.*/
                vpush   {s16-s31}
 8000428:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 800042c:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
 8000430:	f8d0 d00c 	ldr.w	sp, [r0, #12]
#endif

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
 8000434:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8000438:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800043c <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 800043c:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 800043e:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 8000442:	4628      	mov	r0, r5
                blx     r4
 8000444:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 8000446:	2000      	movs	r0, #0
                bl      chThdExit
 8000448:	f006 f882 	bl	8006550 <chThdExit>
1:              b       1b
 800044c:	e7fe      	b.n	800044c <__port_thread_start+0x10>

0800044e <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 800044e:	f005 ff07 	bl	8006260 <chSchDoPreemption>

08000452 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000452:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
1:              b       1b
 8000454:	e7fe      	b.n	8000454 <__port_exit_from_isr+0x2>
	...

08000458 <__aeabi_uldivmod>:
 8000458:	b953      	cbnz	r3, 8000470 <__aeabi_uldivmod+0x18>
 800045a:	b94a      	cbnz	r2, 8000470 <__aeabi_uldivmod+0x18>
 800045c:	2900      	cmp	r1, #0
 800045e:	bf08      	it	eq
 8000460:	2800      	cmpeq	r0, #0
 8000462:	bf1c      	itt	ne
 8000464:	f04f 31ff 	movne.w	r1, #4294967295
 8000468:	f04f 30ff 	movne.w	r0, #4294967295
 800046c:	f000 b80c 	b.w	8000488 <__aeabi_idiv0>
 8000470:	f1ad 0c08 	sub.w	ip, sp, #8
 8000474:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000478:	f00e f804 	bl	800e484 <__udivmoddi4>
 800047c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000480:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000484:	b004      	add	sp, #16
 8000486:	4770      	bx	lr

08000488 <__aeabi_idiv0>:
 8000488:	4770      	bx	lr
 800048a:	bf00      	nop
	...
 80004a0:	eba2 0003 	sub.w	r0, r2, r3
 80004a4:	4770      	bx	lr
 80004a6:	bf00      	nop

080004a8 <strcmp>:
 80004a8:	7802      	ldrb	r2, [r0, #0]
 80004aa:	780b      	ldrb	r3, [r1, #0]
 80004ac:	2a01      	cmp	r2, #1
 80004ae:	bf28      	it	cs
 80004b0:	429a      	cmpcs	r2, r3
 80004b2:	d1f5      	bne.n	80004a0 <__aeabi_idiv0+0x18>
 80004b4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 80004b8:	ea40 0401 	orr.w	r4, r0, r1
 80004bc:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80004c0:	f06f 0c00 	mvn.w	ip, #0
 80004c4:	ea4f 7244 	mov.w	r2, r4, lsl #29
 80004c8:	b312      	cbz	r2, 8000510 <strcmp+0x68>
 80004ca:	ea80 0401 	eor.w	r4, r0, r1
 80004ce:	f014 0f07 	tst.w	r4, #7
 80004d2:	d16a      	bne.n	80005aa <strcmp+0x102>
 80004d4:	f000 0407 	and.w	r4, r0, #7
 80004d8:	f020 0007 	bic.w	r0, r0, #7
 80004dc:	f004 0503 	and.w	r5, r4, #3
 80004e0:	f021 0107 	bic.w	r1, r1, #7
 80004e4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80004e8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80004ec:	f014 0f04 	tst.w	r4, #4
 80004f0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80004f4:	fa0c f405 	lsl.w	r4, ip, r5
 80004f8:	ea62 0204 	orn	r2, r2, r4
 80004fc:	ea66 0604 	orn	r6, r6, r4
 8000500:	d00a      	beq.n	8000518 <strcmp+0x70>
 8000502:	ea63 0304 	orn	r3, r3, r4
 8000506:	4662      	mov	r2, ip
 8000508:	ea67 0704 	orn	r7, r7, r4
 800050c:	4666      	mov	r6, ip
 800050e:	e003      	b.n	8000518 <strcmp+0x70>
 8000510:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000514:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000518:	fa82 f54c 	uadd8	r5, r2, ip
 800051c:	ea82 0406 	eor.w	r4, r2, r6
 8000520:	faa4 f48c 	sel	r4, r4, ip
 8000524:	bb6c      	cbnz	r4, 8000582 <strcmp+0xda>
 8000526:	fa83 f54c 	uadd8	r5, r3, ip
 800052a:	ea83 0507 	eor.w	r5, r3, r7
 800052e:	faa5 f58c 	sel	r5, r5, ip
 8000532:	b995      	cbnz	r5, 800055a <strcmp+0xb2>
 8000534:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8000538:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 800053c:	fa82 f54c 	uadd8	r5, r2, ip
 8000540:	ea82 0406 	eor.w	r4, r2, r6
 8000544:	faa4 f48c 	sel	r4, r4, ip
 8000548:	fa83 f54c 	uadd8	r5, r3, ip
 800054c:	ea83 0507 	eor.w	r5, r3, r7
 8000550:	faa5 f58c 	sel	r5, r5, ip
 8000554:	4325      	orrs	r5, r4
 8000556:	d0db      	beq.n	8000510 <strcmp+0x68>
 8000558:	b99c      	cbnz	r4, 8000582 <strcmp+0xda>
 800055a:	ba2d      	rev	r5, r5
 800055c:	fab5 f485 	clz	r4, r5
 8000560:	f024 0407 	bic.w	r4, r4, #7
 8000564:	fa27 f104 	lsr.w	r1, r7, r4
 8000568:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800056c:	fa23 f304 	lsr.w	r3, r3, r4
 8000570:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000574:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000578:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800057c:	eba0 0001 	sub.w	r0, r0, r1
 8000580:	4770      	bx	lr
 8000582:	ba24      	rev	r4, r4
 8000584:	fab4 f484 	clz	r4, r4
 8000588:	f024 0407 	bic.w	r4, r4, #7
 800058c:	fa26 f104 	lsr.w	r1, r6, r4
 8000590:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000594:	fa22 f204 	lsr.w	r2, r2, r4
 8000598:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800059c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80005a0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80005a4:	eba0 0001 	sub.w	r0, r0, r1
 80005a8:	4770      	bx	lr
 80005aa:	f014 0f03 	tst.w	r4, #3
 80005ae:	d13c      	bne.n	800062a <strcmp+0x182>
 80005b0:	f010 0403 	ands.w	r4, r0, #3
 80005b4:	d128      	bne.n	8000608 <strcmp+0x160>
 80005b6:	f850 2b08 	ldr.w	r2, [r0], #8
 80005ba:	f851 3b08 	ldr.w	r3, [r1], #8
 80005be:	fa82 f54c 	uadd8	r5, r2, ip
 80005c2:	ea82 0503 	eor.w	r5, r2, r3
 80005c6:	faa5 f58c 	sel	r5, r5, ip
 80005ca:	b95d      	cbnz	r5, 80005e4 <strcmp+0x13c>
 80005cc:	f850 2c04 	ldr.w	r2, [r0, #-4]
 80005d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80005d4:	fa82 f54c 	uadd8	r5, r2, ip
 80005d8:	ea82 0503 	eor.w	r5, r2, r3
 80005dc:	faa5 f58c 	sel	r5, r5, ip
 80005e0:	2d00      	cmp	r5, #0
 80005e2:	d0e8      	beq.n	80005b6 <strcmp+0x10e>
 80005e4:	ba2d      	rev	r5, r5
 80005e6:	fab5 f485 	clz	r4, r5
 80005ea:	f024 0407 	bic.w	r4, r4, #7
 80005ee:	fa23 f104 	lsr.w	r1, r3, r4
 80005f2:	fa22 f204 	lsr.w	r2, r2, r4
 80005f6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80005fa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80005fe:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000602:	eba0 0001 	sub.w	r0, r0, r1
 8000606:	4770      	bx	lr
 8000608:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800060c:	f020 0003 	bic.w	r0, r0, #3
 8000610:	f850 2b08 	ldr.w	r2, [r0], #8
 8000614:	f021 0103 	bic.w	r1, r1, #3
 8000618:	f851 3b08 	ldr.w	r3, [r1], #8
 800061c:	fa0c f404 	lsl.w	r4, ip, r4
 8000620:	ea62 0204 	orn	r2, r2, r4
 8000624:	ea63 0304 	orn	r3, r3, r4
 8000628:	e7c9      	b.n	80005be <strcmp+0x116>
 800062a:	f010 0403 	ands.w	r4, r0, #3
 800062e:	d01a      	beq.n	8000666 <strcmp+0x1be>
 8000630:	eba1 0104 	sub.w	r1, r1, r4
 8000634:	f020 0003 	bic.w	r0, r0, #3
 8000638:	07e4      	lsls	r4, r4, #31
 800063a:	f850 2b04 	ldr.w	r2, [r0], #4
 800063e:	d006      	beq.n	800064e <strcmp+0x1a6>
 8000640:	d20f      	bcs.n	8000662 <strcmp+0x1ba>
 8000642:	788b      	ldrb	r3, [r1, #2]
 8000644:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8000648:	1ae4      	subs	r4, r4, r3
 800064a:	d106      	bne.n	800065a <strcmp+0x1b2>
 800064c:	b12b      	cbz	r3, 800065a <strcmp+0x1b2>
 800064e:	78cb      	ldrb	r3, [r1, #3]
 8000650:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8000654:	1ae4      	subs	r4, r4, r3
 8000656:	d100      	bne.n	800065a <strcmp+0x1b2>
 8000658:	b91b      	cbnz	r3, 8000662 <strcmp+0x1ba>
 800065a:	4620      	mov	r0, r4
 800065c:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000660:	4770      	bx	lr
 8000662:	f101 0104 	add.w	r1, r1, #4
 8000666:	f850 2b04 	ldr.w	r2, [r0], #4
 800066a:	07cc      	lsls	r4, r1, #31
 800066c:	f021 0103 	bic.w	r1, r1, #3
 8000670:	f851 3b04 	ldr.w	r3, [r1], #4
 8000674:	d848      	bhi.n	8000708 <strcmp+0x260>
 8000676:	d224      	bcs.n	80006c2 <strcmp+0x21a>
 8000678:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800067c:	fa82 f54c 	uadd8	r5, r2, ip
 8000680:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000684:	faa5 f58c 	sel	r5, r5, ip
 8000688:	d10a      	bne.n	80006a0 <strcmp+0x1f8>
 800068a:	b965      	cbnz	r5, 80006a6 <strcmp+0x1fe>
 800068c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000690:	ea84 0402 	eor.w	r4, r4, r2
 8000694:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000698:	d10e      	bne.n	80006b8 <strcmp+0x210>
 800069a:	f850 2b04 	ldr.w	r2, [r0], #4
 800069e:	e7eb      	b.n	8000678 <strcmp+0x1d0>
 80006a0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80006a4:	e055      	b.n	8000752 <strcmp+0x2aa>
 80006a6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 80006aa:	d14d      	bne.n	8000748 <strcmp+0x2a0>
 80006ac:	7808      	ldrb	r0, [r1, #0]
 80006ae:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006b2:	f1c0 0000 	rsb	r0, r0, #0
 80006b6:	4770      	bx	lr
 80006b8:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80006bc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80006c0:	e047      	b.n	8000752 <strcmp+0x2aa>
 80006c2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 80006c6:	fa82 f54c 	uadd8	r5, r2, ip
 80006ca:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 80006ce:	faa5 f58c 	sel	r5, r5, ip
 80006d2:	d10a      	bne.n	80006ea <strcmp+0x242>
 80006d4:	b965      	cbnz	r5, 80006f0 <strcmp+0x248>
 80006d6:	f851 3b04 	ldr.w	r3, [r1], #4
 80006da:	ea84 0402 	eor.w	r4, r4, r2
 80006de:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 80006e2:	d10c      	bne.n	80006fe <strcmp+0x256>
 80006e4:	f850 2b04 	ldr.w	r2, [r0], #4
 80006e8:	e7eb      	b.n	80006c2 <strcmp+0x21a>
 80006ea:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80006ee:	e030      	b.n	8000752 <strcmp+0x2aa>
 80006f0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 80006f4:	d128      	bne.n	8000748 <strcmp+0x2a0>
 80006f6:	880b      	ldrh	r3, [r1, #0]
 80006f8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80006fc:	e029      	b.n	8000752 <strcmp+0x2aa>
 80006fe:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000702:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000706:	e024      	b.n	8000752 <strcmp+0x2aa>
 8000708:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800070c:	fa82 f54c 	uadd8	r5, r2, ip
 8000710:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000714:	faa5 f58c 	sel	r5, r5, ip
 8000718:	d10a      	bne.n	8000730 <strcmp+0x288>
 800071a:	b965      	cbnz	r5, 8000736 <strcmp+0x28e>
 800071c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000720:	ea84 0402 	eor.w	r4, r4, r2
 8000724:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8000728:	d109      	bne.n	800073e <strcmp+0x296>
 800072a:	f850 2b04 	ldr.w	r2, [r0], #4
 800072e:	e7eb      	b.n	8000708 <strcmp+0x260>
 8000730:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000734:	e00d      	b.n	8000752 <strcmp+0x2aa>
 8000736:	f015 0fff 	tst.w	r5, #255	; 0xff
 800073a:	d105      	bne.n	8000748 <strcmp+0x2a0>
 800073c:	680b      	ldr	r3, [r1, #0]
 800073e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8000742:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000746:	e004      	b.n	8000752 <strcmp+0x2aa>
 8000748:	f04f 0000 	mov.w	r0, #0
 800074c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000750:	4770      	bx	lr
 8000752:	ba12      	rev	r2, r2
 8000754:	ba1b      	rev	r3, r3
 8000756:	fa82 f44c 	uadd8	r4, r2, ip
 800075a:	ea82 0403 	eor.w	r4, r2, r3
 800075e:	faa4 f58c 	sel	r5, r4, ip
 8000762:	fab5 f485 	clz	r4, r5
 8000766:	fa02 f204 	lsl.w	r2, r2, r4
 800076a:	fa03 f304 	lsl.w	r3, r3, r4
 800076e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000772:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000776:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800077a:	4770      	bx	lr

0800077c <memcpy>:
 800077c:	4684      	mov	ip, r0
 800077e:	ea41 0300 	orr.w	r3, r1, r0
 8000782:	f013 0303 	ands.w	r3, r3, #3
 8000786:	d16d      	bne.n	8000864 <memcpy+0xe8>
 8000788:	3a40      	subs	r2, #64	; 0x40
 800078a:	d341      	bcc.n	8000810 <memcpy+0x94>
 800078c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000790:	f840 3b04 	str.w	r3, [r0], #4
 8000794:	f851 3b04 	ldr.w	r3, [r1], #4
 8000798:	f840 3b04 	str.w	r3, [r0], #4
 800079c:	f851 3b04 	ldr.w	r3, [r1], #4
 80007a0:	f840 3b04 	str.w	r3, [r0], #4
 80007a4:	f851 3b04 	ldr.w	r3, [r1], #4
 80007a8:	f840 3b04 	str.w	r3, [r0], #4
 80007ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80007b0:	f840 3b04 	str.w	r3, [r0], #4
 80007b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80007b8:	f840 3b04 	str.w	r3, [r0], #4
 80007bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80007c0:	f840 3b04 	str.w	r3, [r0], #4
 80007c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80007c8:	f840 3b04 	str.w	r3, [r0], #4
 80007cc:	f851 3b04 	ldr.w	r3, [r1], #4
 80007d0:	f840 3b04 	str.w	r3, [r0], #4
 80007d4:	f851 3b04 	ldr.w	r3, [r1], #4
 80007d8:	f840 3b04 	str.w	r3, [r0], #4
 80007dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80007e0:	f840 3b04 	str.w	r3, [r0], #4
 80007e4:	f851 3b04 	ldr.w	r3, [r1], #4
 80007e8:	f840 3b04 	str.w	r3, [r0], #4
 80007ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80007f0:	f840 3b04 	str.w	r3, [r0], #4
 80007f4:	f851 3b04 	ldr.w	r3, [r1], #4
 80007f8:	f840 3b04 	str.w	r3, [r0], #4
 80007fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000800:	f840 3b04 	str.w	r3, [r0], #4
 8000804:	f851 3b04 	ldr.w	r3, [r1], #4
 8000808:	f840 3b04 	str.w	r3, [r0], #4
 800080c:	3a40      	subs	r2, #64	; 0x40
 800080e:	d2bd      	bcs.n	800078c <memcpy+0x10>
 8000810:	3230      	adds	r2, #48	; 0x30
 8000812:	d311      	bcc.n	8000838 <memcpy+0xbc>
 8000814:	f851 3b04 	ldr.w	r3, [r1], #4
 8000818:	f840 3b04 	str.w	r3, [r0], #4
 800081c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000820:	f840 3b04 	str.w	r3, [r0], #4
 8000824:	f851 3b04 	ldr.w	r3, [r1], #4
 8000828:	f840 3b04 	str.w	r3, [r0], #4
 800082c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000830:	f840 3b04 	str.w	r3, [r0], #4
 8000834:	3a10      	subs	r2, #16
 8000836:	d2ed      	bcs.n	8000814 <memcpy+0x98>
 8000838:	320c      	adds	r2, #12
 800083a:	d305      	bcc.n	8000848 <memcpy+0xcc>
 800083c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000840:	f840 3b04 	str.w	r3, [r0], #4
 8000844:	3a04      	subs	r2, #4
 8000846:	d2f9      	bcs.n	800083c <memcpy+0xc0>
 8000848:	3204      	adds	r2, #4
 800084a:	d008      	beq.n	800085e <memcpy+0xe2>
 800084c:	07d2      	lsls	r2, r2, #31
 800084e:	bf1c      	itt	ne
 8000850:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000854:	f800 3b01 	strbne.w	r3, [r0], #1
 8000858:	d301      	bcc.n	800085e <memcpy+0xe2>
 800085a:	880b      	ldrh	r3, [r1, #0]
 800085c:	8003      	strh	r3, [r0, #0]
 800085e:	4660      	mov	r0, ip
 8000860:	4770      	bx	lr
 8000862:	bf00      	nop
 8000864:	2a08      	cmp	r2, #8
 8000866:	d313      	bcc.n	8000890 <memcpy+0x114>
 8000868:	078b      	lsls	r3, r1, #30
 800086a:	d08d      	beq.n	8000788 <memcpy+0xc>
 800086c:	f010 0303 	ands.w	r3, r0, #3
 8000870:	d08a      	beq.n	8000788 <memcpy+0xc>
 8000872:	f1c3 0304 	rsb	r3, r3, #4
 8000876:	1ad2      	subs	r2, r2, r3
 8000878:	07db      	lsls	r3, r3, #31
 800087a:	bf1c      	itt	ne
 800087c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000880:	f800 3b01 	strbne.w	r3, [r0], #1
 8000884:	d380      	bcc.n	8000788 <memcpy+0xc>
 8000886:	f831 3b02 	ldrh.w	r3, [r1], #2
 800088a:	f820 3b02 	strh.w	r3, [r0], #2
 800088e:	e77b      	b.n	8000788 <memcpy+0xc>
 8000890:	3a04      	subs	r2, #4
 8000892:	d3d9      	bcc.n	8000848 <memcpy+0xcc>
 8000894:	3a01      	subs	r2, #1
 8000896:	f811 3b01 	ldrb.w	r3, [r1], #1
 800089a:	f800 3b01 	strb.w	r3, [r0], #1
 800089e:	d2f9      	bcs.n	8000894 <memcpy+0x118>
 80008a0:	780b      	ldrb	r3, [r1, #0]
 80008a2:	7003      	strb	r3, [r0, #0]
 80008a4:	784b      	ldrb	r3, [r1, #1]
 80008a6:	7043      	strb	r3, [r0, #1]
 80008a8:	788b      	ldrb	r3, [r1, #2]
 80008aa:	7083      	strb	r3, [r0, #2]
 80008ac:	4660      	mov	r0, ip
 80008ae:	4770      	bx	lr
	...

080008c0 <strlen>:
 80008c0:	f890 f000 	pld	[r0]
 80008c4:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 80008c8:	f020 0107 	bic.w	r1, r0, #7
 80008cc:	f06f 0c00 	mvn.w	ip, #0
 80008d0:	f010 0407 	ands.w	r4, r0, #7
 80008d4:	f891 f020 	pld	[r1, #32]
 80008d8:	f040 8049 	bne.w	800096e <strlen+0xae>
 80008dc:	f04f 0400 	mov.w	r4, #0
 80008e0:	f06f 0007 	mvn.w	r0, #7
 80008e4:	e9d1 2300 	ldrd	r2, r3, [r1]
 80008e8:	f891 f040 	pld	[r1, #64]	; 0x40
 80008ec:	f100 0008 	add.w	r0, r0, #8
 80008f0:	fa82 f24c 	uadd8	r2, r2, ip
 80008f4:	faa4 f28c 	sel	r2, r4, ip
 80008f8:	fa83 f34c 	uadd8	r3, r3, ip
 80008fc:	faa2 f38c 	sel	r3, r2, ip
 8000900:	bb4b      	cbnz	r3, 8000956 <strlen+0x96>
 8000902:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8000906:	fa82 f24c 	uadd8	r2, r2, ip
 800090a:	f100 0008 	add.w	r0, r0, #8
 800090e:	faa4 f28c 	sel	r2, r4, ip
 8000912:	fa83 f34c 	uadd8	r3, r3, ip
 8000916:	faa2 f38c 	sel	r3, r2, ip
 800091a:	b9e3      	cbnz	r3, 8000956 <strlen+0x96>
 800091c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 8000920:	fa82 f24c 	uadd8	r2, r2, ip
 8000924:	f100 0008 	add.w	r0, r0, #8
 8000928:	faa4 f28c 	sel	r2, r4, ip
 800092c:	fa83 f34c 	uadd8	r3, r3, ip
 8000930:	faa2 f38c 	sel	r3, r2, ip
 8000934:	b97b      	cbnz	r3, 8000956 <strlen+0x96>
 8000936:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 800093a:	f101 0120 	add.w	r1, r1, #32
 800093e:	fa82 f24c 	uadd8	r2, r2, ip
 8000942:	f100 0008 	add.w	r0, r0, #8
 8000946:	faa4 f28c 	sel	r2, r4, ip
 800094a:	fa83 f34c 	uadd8	r3, r3, ip
 800094e:	faa2 f38c 	sel	r3, r2, ip
 8000952:	2b00      	cmp	r3, #0
 8000954:	d0c6      	beq.n	80008e4 <strlen+0x24>
 8000956:	2a00      	cmp	r2, #0
 8000958:	bf04      	itt	eq
 800095a:	3004      	addeq	r0, #4
 800095c:	461a      	moveq	r2, r3
 800095e:	ba12      	rev	r2, r2
 8000960:	fab2 f282 	clz	r2, r2
 8000964:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 8000968:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800096c:	4770      	bx	lr
 800096e:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000972:	f004 0503 	and.w	r5, r4, #3
 8000976:	f1c4 0000 	rsb	r0, r4, #0
 800097a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 800097e:	f014 0f04 	tst.w	r4, #4
 8000982:	f891 f040 	pld	[r1, #64]	; 0x40
 8000986:	fa0c f505 	lsl.w	r5, ip, r5
 800098a:	ea62 0205 	orn	r2, r2, r5
 800098e:	bf1c      	itt	ne
 8000990:	ea63 0305 	ornne	r3, r3, r5
 8000994:	4662      	movne	r2, ip
 8000996:	f04f 0400 	mov.w	r4, #0
 800099a:	e7a9      	b.n	80008f0 <strlen+0x30>
 800099c:	0000      	movs	r0, r0
	...

080009a0 <memchr>:
 80009a0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80009a4:	2a10      	cmp	r2, #16
 80009a6:	db2b      	blt.n	8000a00 <memchr+0x60>
 80009a8:	f010 0f07 	tst.w	r0, #7
 80009ac:	d008      	beq.n	80009c0 <memchr+0x20>
 80009ae:	f810 3b01 	ldrb.w	r3, [r0], #1
 80009b2:	3a01      	subs	r2, #1
 80009b4:	428b      	cmp	r3, r1
 80009b6:	d02d      	beq.n	8000a14 <memchr+0x74>
 80009b8:	f010 0f07 	tst.w	r0, #7
 80009bc:	b342      	cbz	r2, 8000a10 <memchr+0x70>
 80009be:	d1f6      	bne.n	80009ae <memchr+0xe>
 80009c0:	b4f0      	push	{r4, r5, r6, r7}
 80009c2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80009c6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80009ca:	f022 0407 	bic.w	r4, r2, #7
 80009ce:	f07f 0700 	mvns.w	r7, #0
 80009d2:	2300      	movs	r3, #0
 80009d4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 80009d8:	3c08      	subs	r4, #8
 80009da:	ea85 0501 	eor.w	r5, r5, r1
 80009de:	ea86 0601 	eor.w	r6, r6, r1
 80009e2:	fa85 f547 	uadd8	r5, r5, r7
 80009e6:	faa3 f587 	sel	r5, r3, r7
 80009ea:	fa86 f647 	uadd8	r6, r6, r7
 80009ee:	faa5 f687 	sel	r6, r5, r7
 80009f2:	b98e      	cbnz	r6, 8000a18 <memchr+0x78>
 80009f4:	d1ee      	bne.n	80009d4 <memchr+0x34>
 80009f6:	bcf0      	pop	{r4, r5, r6, r7}
 80009f8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80009fc:	f002 0207 	and.w	r2, r2, #7
 8000a00:	b132      	cbz	r2, 8000a10 <memchr+0x70>
 8000a02:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000a06:	3a01      	subs	r2, #1
 8000a08:	ea83 0301 	eor.w	r3, r3, r1
 8000a0c:	b113      	cbz	r3, 8000a14 <memchr+0x74>
 8000a0e:	d1f8      	bne.n	8000a02 <memchr+0x62>
 8000a10:	2000      	movs	r0, #0
 8000a12:	4770      	bx	lr
 8000a14:	3801      	subs	r0, #1
 8000a16:	4770      	bx	lr
 8000a18:	2d00      	cmp	r5, #0
 8000a1a:	bf06      	itte	eq
 8000a1c:	4635      	moveq	r5, r6
 8000a1e:	3803      	subeq	r0, #3
 8000a20:	3807      	subne	r0, #7
 8000a22:	f015 0f01 	tst.w	r5, #1
 8000a26:	d107      	bne.n	8000a38 <memchr+0x98>
 8000a28:	3001      	adds	r0, #1
 8000a2a:	f415 7f80 	tst.w	r5, #256	; 0x100
 8000a2e:	bf02      	ittt	eq
 8000a30:	3001      	addeq	r0, #1
 8000a32:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000a36:	3001      	addeq	r0, #1
 8000a38:	bcf0      	pop	{r4, r5, r6, r7}
 8000a3a:	3801      	subs	r0, #1
 8000a3c:	4770      	bx	lr
 8000a3e:	bf00      	nop

08000a40 <__cpu_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __cpu_init(void) {
 8000a40:	b510      	push	{r4, lr}
 8000a42:	b084      	sub	sp, #16
   * Option A (MPU) : protège la section .ram_d2 (0x30040000, 32 KB) utilisée par les
   * buffers DMA audio/SPI. La région est explicitement non-cacheable et non-bufferable
   * pour garantir la cohérence D-Cache sans ajouter de clean/invalidate dans le pipeline
   * audio temps réel.
   */
  mpu.Enable           = MPU_REGION_ENABLE;
 8000a44:	2401      	movs	r4, #1
  HAL_MPU_Disable();
 8000a46:	f00d f839 	bl	800dabc <HAL_MPU_Disable>
  mpu.BaseAddress      = 0x30040000;
 8000a4a:	4926      	ldr	r1, [pc, #152]	; (8000ae4 <__cpu_init+0xa4>)
  mpu.Size             = MPU_REGION_SIZE_32KB;
 8000a4c:	4a26      	ldr	r2, [pc, #152]	; (8000ae8 <__cpu_init+0xa8>)
  mpu.IsCacheable      = MPU_ACCESS_NOT_CACHEABLE;
  mpu.IsShareable      = MPU_ACCESS_SHAREABLE;
  mpu.Number           = MPU_REGION_NUMBER0;
  mpu.TypeExtField     = MPU_TEX_LEVEL0;
  mpu.SubRegionDisable = 0x00;
  mpu.DisableExec      = MPU_INSTRUCTION_ACCESS_ENABLE;
 8000a4e:	f44f 7380 	mov.w	r3, #256	; 0x100

  HAL_MPU_ConfigRegion(&mpu);
 8000a52:	4668      	mov	r0, sp
  mpu.Enable           = MPU_REGION_ENABLE;
 8000a54:	f8ad 4000 	strh.w	r4, [sp]
  mpu.DisableExec      = MPU_INSTRUCTION_ACCESS_ENABLE;
 8000a58:	9303      	str	r3, [sp, #12]
  mpu.Size             = MPU_REGION_SIZE_32KB;
 8000a5a:	e9cd 1201 	strd	r1, r2, [sp, #4]
  HAL_MPU_ConfigRegion(&mpu);
 8000a5e:	f00d f84b 	bl	800daf8 <HAL_MPU_ConfigRegion>
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8000a62:	2004      	movs	r0, #4
 8000a64:	f00d f838 	bl	800dad8 <HAL_MPU_Enable>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000a68:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000a6c:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8000a70:	481e      	ldr	r0, [pc, #120]	; (8000aec <__cpu_init+0xac>)
 8000a72:	2200      	movs	r2, #0
 8000a74:	f8c0 2250 	str.w	r2, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000a78:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000a7c:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8000a80:	6943      	ldr	r3, [r0, #20]
 8000a82:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000a86:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000a88:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000a8c:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8000a90:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8000a94:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000a98:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000a9c:	f643 74e0 	movw	r4, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000aa0:	f3c3 3c4e 	ubfx	ip, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000aa4:	f3c3 0ec9 	ubfx	lr, r3, #3, #10
 8000aa8:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000aac:	ea0c 0104 	and.w	r1, ip, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000ab0:	4673      	mov	r3, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000ab2:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8000ab6:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000ab8:	f8c0 2260 	str.w	r2, [r0, #608]	; 0x260
      } while (ways-- != 0U);
 8000abc:	1c5a      	adds	r2, r3, #1
 8000abe:	d1f8      	bne.n	8000ab2 <__cpu_init+0x72>
    } while(sets-- != 0U);
 8000ac0:	f1ac 0c20 	sub.w	ip, ip, #32
 8000ac4:	f11c 0f20 	cmn.w	ip, #32
 8000ac8:	d1f0      	bne.n	8000aac <__cpu_init+0x6c>
 8000aca:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000ace:	6943      	ldr	r3, [r0, #20]
 8000ad0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000ad4:	6143      	str	r3, [r0, #20]
 8000ad6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000ada:	f3bf 8f6f 	isb	sy

  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000ade:	b004      	add	sp, #16
 8000ae0:	bd10      	pop	{r4, pc}
 8000ae2:	bf00      	nop
 8000ae4:	30040000 	.word	0x30040000
 8000ae8:	0300000e 	.word	0x0300000e
 8000aec:	e000ed00 	.word	0xe000ed00

08000af0 <__late_init>:
 8000af0:	4770      	bx	lr
 8000af2:	bf00      	nop

08000af4 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8000af4:	e7fe      	b.n	8000af4 <__default_exit>
 8000af6:	bf00      	nop

08000af8 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000af8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000afa:	4d2b      	ldr	r5, [pc, #172]	; (8000ba8 <__init_ram_areas+0xb0>)
 8000afc:	4f2b      	ldr	r7, [pc, #172]	; (8000bac <__init_ram_areas+0xb4>)
 8000afe:	492c      	ldr	r1, [pc, #176]	; (8000bb0 <__init_ram_areas+0xb8>)
 8000b00:	f105 0470 	add.w	r4, r5, #112	; 0x70
 8000b04:	482b      	ldr	r0, [pc, #172]	; (8000bb4 <__init_ram_areas+0xbc>)
 8000b06:	4a2c      	ldr	r2, [pc, #176]	; (8000bb8 <__init_ram_areas+0xc0>)
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000b08:	4288      	cmp	r0, r1
 8000b0a:	d20d      	bcs.n	8000b28 <__init_ram_areas+0x30>
 8000b0c:	3a04      	subs	r2, #4
 8000b0e:	4603      	mov	r3, r0
      *p = *tp;
 8000b10:	f852 6f04 	ldr.w	r6, [r2, #4]!
 8000b14:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 8000b18:	428b      	cmp	r3, r1
 8000b1a:	d3f9      	bcc.n	8000b10 <__init_ram_areas+0x18>
      p++;
 8000b1c:	1e4b      	subs	r3, r1, #1
 8000b1e:	1a1b      	subs	r3, r3, r0
 8000b20:	f023 0303 	bic.w	r3, r3, #3
 8000b24:	3304      	adds	r3, #4
 8000b26:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000b28:	42b8      	cmp	r0, r7
 8000b2a:	d207      	bcs.n	8000b3c <__init_ram_areas+0x44>
      *p = 0;
 8000b2c:	3f01      	subs	r7, #1
 8000b2e:	2100      	movs	r1, #0
 8000b30:	1a3f      	subs	r7, r7, r0
 8000b32:	f027 0203 	bic.w	r2, r7, #3
 8000b36:	3204      	adds	r2, #4
 8000b38:	f00d fe54 	bl	800e7e4 <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000b3c:	42a5      	cmp	r5, r4
 8000b3e:	d005      	beq.n	8000b4c <__init_ram_areas+0x54>
    uint32_t *p = rap->init_area;
 8000b40:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    while (p < rap->no_init_area) {
 8000b44:	e9d5 1706 	ldrd	r1, r7, [r5, #24]
 8000b48:	3510      	adds	r5, #16
 8000b4a:	e7dd      	b.n	8000b08 <__init_ram_areas+0x10>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

     SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8000b4c:	481b      	ldr	r0, [pc, #108]	; (8000bbc <__init_ram_areas+0xc4>)
 8000b4e:	2300      	movs	r3, #0
 8000b50:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8000b54:	f3bf 8f4f 	dsb	sy
   __DSB();

    ccsidr = SCB->CCSIDR;
 8000b58:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
                                            /* clean D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 8000b5c:	f643 76e0 	movw	r6, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000b60:	f3c5 344e 	ubfx	r4, r5, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000b64:	f3c5 05c9 	ubfx	r5, r5, #3, #10
 8000b68:	0164      	lsls	r4, r4, #5
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 8000b6a:	ea04 0106 	and.w	r1, r4, r6
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000b6e:	462b      	mov	r3, r5
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 8000b70:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8000b74:	3b01      	subs	r3, #1
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 8000b76:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
      } while (ways-- != 0U);
 8000b7a:	1c5a      	adds	r2, r3, #1
 8000b7c:	d1f8      	bne.n	8000b70 <__init_ram_areas+0x78>
    } while(sets-- != 0U);
 8000b7e:	3c20      	subs	r4, #32
 8000b80:	f114 0f20 	cmn.w	r4, #32
 8000b84:	d1f1      	bne.n	8000b6a <__init_ram_areas+0x72>
 8000b86:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000b8a:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 8000b8e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000b92:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;
 8000b96:	2300      	movs	r3, #0
 8000b98:	f8c0 3250 	str.w	r3, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000b9c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000ba0:	f3bf 8f6f 	isb	sy
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 8000ba4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000ba6:	bf00      	nop
 8000ba8:	080149bc 	.word	0x080149bc
 8000bac:	240061c0 	.word	0x240061c0
 8000bb0:	240061c0 	.word	0x240061c0
 8000bb4:	240061c0 	.word	0x240061c0
 8000bb8:	080164c4 	.word	0x080164c4
 8000bbc:	e000ed00 	.word	0xe000ed00

08000bc0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000bc0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8000bc2:	f001 f999 	bl	8001ef8 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 8000bc6:	f002 fa45 	bl	8003054 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 8000bca:	f000 fa07 	bl	8000fdc <adcInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 8000bce:	f000 fa49 	bl	8001064 <i2cInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8000bd2:	f000 fa7d 	bl	80010d0 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000bd6:	f000 fd1b 	bl	8001610 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
 8000bda:	f000 fcc5 	bl	8001568 <sdcInit>
#endif
#if (HAL_USE_SIO == TRUE) || defined(__DOXYGEN__)
  sioInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8000bde:	f000 fd55 	bl	800168c <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8000be2:	f000 fda9 	bl	8001738 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8000be6:	f000 fd4f 	bl	8001688 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000bea:	f005 f807 	bl	8005bfc <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8000bee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stInit();
 8000bf2:	f000 b801 	b.w	8000bf8 <stInit>
 8000bf6:	bf00      	nop

08000bf8 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 8000bf8:	f004 bd30 	b.w	800565c <st_lld_init>

08000bfc <stGetCounter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000bfc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000c00:	6a58      	ldr	r0, [r3, #36]	; 0x24
 * @api
 */
systime_t stGetCounter(void) {

  return st_lld_get_counter();
}
 8000c02:	4770      	bx	lr

08000c04 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8000c08:	2100      	movs	r1, #0
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c0a:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c0c:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000c0e:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c10:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 8000c12:	4770      	bx	lr

08000c14 <stStopAlarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8000c14:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000c18:	2200      	movs	r2, #0
 8000c1a:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8000c1c:	4770      	bx	lr
 8000c1e:	bf00      	nop

08000c20 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c20:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000c24:	6358      	str	r0, [r3, #52]	; 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 8000c26:	4770      	bx	lr

08000c28 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000c28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000c2a:	4615      	mov	r5, r2
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8000c2c:	6882      	ldr	r2, [r0, #8]
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000c2e:	4604      	mov	r4, r0
 8000c30:	460b      	mov	r3, r1
  if (n > iqGetFullI(iqp)) {
 8000c32:	42aa      	cmp	r2, r5
 8000c34:	d200      	bcs.n	8000c38 <iq_read+0x10>
    n = iqGetFullI(iqp);
 8000c36:	6885      	ldr	r5, [r0, #8]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000c38:	69a1      	ldr	r1, [r4, #24]
 8000c3a:	6926      	ldr	r6, [r4, #16]
 8000c3c:	1a76      	subs	r6, r6, r1
  /*lint -restore*/
  if (n < s1) {
 8000c3e:	42b5      	cmp	r5, r6
 8000c40:	d318      	bcc.n	8000c74 <iq_read+0x4c>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr += n;
  }
  else if (n > s1) {
 8000c42:	d80a      	bhi.n	8000c5a <iq_read+0x32>
    s2 = n - s1;
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
    iqp->q_rdptr = iqp->q_buffer + s2;
  }
  else {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000c44:	462a      	mov	r2, r5
 8000c46:	4618      	mov	r0, r3
 8000c48:	f7ff fd98 	bl	800077c <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8000c4c:	68e2      	ldr	r2, [r4, #12]
  }

  iqp->q_counter -= n;
 8000c4e:	68a3      	ldr	r3, [r4, #8]
  return n;
}
 8000c50:	4628      	mov	r0, r5
    iqp->q_rdptr += n;
 8000c52:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 8000c54:	1b5b      	subs	r3, r3, r5
 8000c56:	60a3      	str	r3, [r4, #8]
}
 8000c58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    s2 = n - s1;
 8000c5a:	1baf      	subs	r7, r5, r6
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000c5c:	4632      	mov	r2, r6
 8000c5e:	4618      	mov	r0, r3
 8000c60:	f7ff fd8c 	bl	800077c <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000c64:	463a      	mov	r2, r7
 8000c66:	4430      	add	r0, r6
 8000c68:	68e1      	ldr	r1, [r4, #12]
 8000c6a:	f7ff fd87 	bl	800077c <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000c6e:	68e2      	ldr	r2, [r4, #12]
 8000c70:	443a      	add	r2, r7
 8000c72:	e7ec      	b.n	8000c4e <iq_read+0x26>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000c74:	462a      	mov	r2, r5
 8000c76:	4618      	mov	r0, r3
 8000c78:	f7ff fd80 	bl	800077c <memcpy>
    iqp->q_rdptr += n;
 8000c7c:	69a2      	ldr	r2, [r4, #24]
 8000c7e:	442a      	add	r2, r5
 8000c80:	e7e5      	b.n	8000c4e <iq_read+0x26>
 8000c82:	bf00      	nop

08000c84 <oq_write>:
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8000c84:	6883      	ldr	r3, [r0, #8]
 8000c86:	4293      	cmp	r3, r2
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8000c88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000c8c:	4604      	mov	r4, r0
 8000c8e:	4688      	mov	r8, r1
  if (n > oqGetEmptyI(oqp)) {
 8000c90:	d212      	bcs.n	8000cb8 <oq_write+0x34>
    n = oqGetEmptyI(oqp);
 8000c92:	6885      	ldr	r5, [r0, #8]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000c94:	e9d4 6004 	ldrd	r6, r0, [r4, #16]
 8000c98:	1a36      	subs	r6, r6, r0
  /*lint -restore*/
  if (n < s1) {
 8000c9a:	42b5      	cmp	r5, r6
 8000c9c:	d312      	bcc.n	8000cc4 <oq_write+0x40>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr += n;
  }
  else if (n > s1) {
 8000c9e:	d818      	bhi.n	8000cd2 <oq_write+0x4e>
    s2 = n - s1;
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
    oqp->q_wrptr = oqp->q_buffer + s2;
  }
  else {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000ca0:	462a      	mov	r2, r5
 8000ca2:	4641      	mov	r1, r8
 8000ca4:	f7ff fd6a 	bl	800077c <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8000ca8:	68e2      	ldr	r2, [r4, #12]
  }

  oqp->q_counter -= n;
 8000caa:	68a3      	ldr	r3, [r4, #8]
  return n;
}
 8000cac:	4628      	mov	r0, r5
    oqp->q_wrptr += n;
 8000cae:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 8000cb0:	1b5b      	subs	r3, r3, r5
 8000cb2:	60a3      	str	r3, [r4, #8]
}
 8000cb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000cb8:	e9d4 6004 	ldrd	r6, r0, [r4, #16]
 8000cbc:	4615      	mov	r5, r2
 8000cbe:	1a36      	subs	r6, r6, r0
  if (n < s1) {
 8000cc0:	42b5      	cmp	r5, r6
 8000cc2:	d2ec      	bcs.n	8000c9e <oq_write+0x1a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000cc4:	462a      	mov	r2, r5
 8000cc6:	4641      	mov	r1, r8
 8000cc8:	f7ff fd58 	bl	800077c <memcpy>
    oqp->q_wrptr += n;
 8000ccc:	6962      	ldr	r2, [r4, #20]
 8000cce:	442a      	add	r2, r5
 8000cd0:	e7eb      	b.n	8000caa <oq_write+0x26>
    s2 = n - s1;
 8000cd2:	1baf      	subs	r7, r5, r6
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000cd4:	4632      	mov	r2, r6
 8000cd6:	4641      	mov	r1, r8
 8000cd8:	f7ff fd50 	bl	800077c <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000cdc:	463a      	mov	r2, r7
 8000cde:	eb08 0106 	add.w	r1, r8, r6
 8000ce2:	68e0      	ldr	r0, [r4, #12]
 8000ce4:	f7ff fd4a 	bl	800077c <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000ce8:	68e2      	ldr	r2, [r4, #12]
 8000cea:	443a      	add	r2, r7
 8000cec:	e7dd      	b.n	8000caa <oq_write+0x26>
 8000cee:	bf00      	nop

08000cf0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8000cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000cf2:	4604      	mov	r4, r0
 8000cf4:	460d      	mov	r5, r1
 8000cf6:	461f      	mov	r7, r3
 8000cf8:	4616      	mov	r6, r2
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chThdQueueObjectInit(tqp);
 8000cfa:	f005 fcb1 	bl	8006660 <chThdQueueObjectInit>
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8000cfe:	9b06      	ldr	r3, [sp, #24]
  iqp->q_top     = bp + size;
 8000d00:	442e      	add	r6, r5
  iqp->q_notify  = infy;
 8000d02:	61e7      	str	r7, [r4, #28]
  iqp->q_link    = link;
 8000d04:	6223      	str	r3, [r4, #32]
  iqp->q_counter = 0;
 8000d06:	2300      	movs	r3, #0
  iqp->q_buffer  = bp;
 8000d08:	e9c4 5603 	strd	r5, r6, [r4, #12]
  iqp->q_wrptr   = bp;
 8000d0c:	e9c4 5505 	strd	r5, r5, [r4, #20]
  iqp->q_counter = 0;
 8000d10:	60a3      	str	r3, [r4, #8]
}
 8000d12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000d14 <iqPutI>:
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8000d14:	e9d0 3205 	ldrd	r3, r2, [r0, #20]
 8000d18:	4293      	cmp	r3, r2
 8000d1a:	d011      	beq.n	8000d40 <iqPutI+0x2c>
    iqp->q_counter++;
 8000d1c:	6882      	ldr	r2, [r0, #8]
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8000d1e:	b510      	push	{r4, lr}
    iqp->q_counter++;
 8000d20:	3201      	adds	r2, #1
    *iqp->q_wrptr++ = b;
 8000d22:	1c5c      	adds	r4, r3, #1
    iqp->q_counter++;
 8000d24:	6082      	str	r2, [r0, #8]
    *iqp->q_wrptr++ = b;
 8000d26:	6144      	str	r4, [r0, #20]
 8000d28:	7019      	strb	r1, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000d2a:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 8000d2e:	429a      	cmp	r2, r3
 8000d30:	d301      	bcc.n	8000d36 <iqPutI+0x22>
      iqp->q_wrptr = iqp->q_buffer;
 8000d32:	68c3      	ldr	r3, [r0, #12]
 8000d34:	6143      	str	r3, [r0, #20]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 8000d36:	2100      	movs	r1, #0
 8000d38:	f005 fcaa 	bl	8006690 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);

    return MSG_OK;
 8000d3c:	2000      	movs	r0, #0
  }

  return MSG_TIMEOUT;
}
 8000d3e:	bd10      	pop	{r4, pc}
  if (!iqIsFullI(iqp)) {
 8000d40:	6882      	ldr	r2, [r0, #8]
 8000d42:	2a00      	cmp	r2, #0
 8000d44:	d0ea      	beq.n	8000d1c <iqPutI+0x8>
  return MSG_TIMEOUT;
 8000d46:	f04f 30ff 	mov.w	r0, #4294967295
}
 8000d4a:	4770      	bx	lr

08000d4c <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000d4c:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000d4e:	2330      	movs	r3, #48	; 0x30
 8000d50:	4605      	mov	r5, r0
 8000d52:	460e      	mov	r6, r1
 8000d54:	f383 8811 	msr	BASEPRI, r3
}
 8000d58:	e003      	b.n	8000d62 <iqGetTimeout+0x16>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000d5a:	f005 fc85 	bl	8006668 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000d5e:	2800      	cmp	r0, #0
 8000d60:	db19      	blt.n	8000d96 <iqGetTimeout+0x4a>
  while (iqIsEmptyI(iqp)) {
 8000d62:	68ac      	ldr	r4, [r5, #8]
 8000d64:	4631      	mov	r1, r6
 8000d66:	4628      	mov	r0, r5
 8000d68:	2c00      	cmp	r4, #0
 8000d6a:	d0f6      	beq.n	8000d5a <iqGetTimeout+0xe>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8000d6c:	68ab      	ldr	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 8000d6e:	69a9      	ldr	r1, [r5, #24]
  iqp->q_counter--;
 8000d70:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
 8000d72:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8000d74:	60ab      	str	r3, [r5, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d76:	692b      	ldr	r3, [r5, #16]
  b = *iqp->q_rdptr++;
 8000d78:	61aa      	str	r2, [r5, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d7a:	429a      	cmp	r2, r3
  b = *iqp->q_rdptr++;
 8000d7c:	780c      	ldrb	r4, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d7e:	d301      	bcc.n	8000d84 <iqGetTimeout+0x38>
    iqp->q_rdptr = iqp->q_buffer;
 8000d80:	68eb      	ldr	r3, [r5, #12]
 8000d82:	61ab      	str	r3, [r5, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8000d84:	69eb      	ldr	r3, [r5, #28]
 8000d86:	b10b      	cbz	r3, 8000d8c <iqGetTimeout+0x40>
    iqp->q_notify(iqp);
 8000d88:	4628      	mov	r0, r5
 8000d8a:	4798      	blx	r3
 8000d8c:	2300      	movs	r3, #0
 8000d8e:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 8000d92:	4620      	mov	r0, r4
}
 8000d94:	bd70      	pop	{r4, r5, r6, pc}
 8000d96:	f384 8811 	msr	BASEPRI, r4
 8000d9a:	bd70      	pop	{r4, r5, r6, pc}

08000d9c <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8000d9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000da0:	b083      	sub	sp, #12
 8000da2:	469a      	mov	sl, r3
  qnotify_t nfy = iqp->q_notify;
 8000da4:	69c6      	ldr	r6, [r0, #28]
 8000da6:	2730      	movs	r7, #48	; 0x30
                     size_t n, sysinterval_t timeout) {
 8000da8:	9201      	str	r2, [sp, #4]
 8000daa:	f387 8811 	msr	BASEPRI, r7

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000dae:	b1ca      	cbz	r2, 8000de4 <iqReadTimeout+0x48>
 8000db0:	4683      	mov	fp, r0
 8000db2:	460d      	mov	r5, r1
 8000db4:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8000db8:	f04f 0800 	mov.w	r8, #0
    size_t done;

    done = iq_read(iqp, bp, n);
 8000dbc:	464a      	mov	r2, r9
 8000dbe:	4629      	mov	r1, r5
 8000dc0:	4658      	mov	r0, fp
 8000dc2:	f7ff ff31 	bl	8000c28 <iq_read>
 8000dc6:	4604      	mov	r4, r0
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
        nfy(iqp);
 8000dc8:	4658      	mov	r0, fp
    if (done == (size_t)0) {
 8000dca:	b194      	cbz	r4, 8000df2 <iqReadTimeout+0x56>
      if (nfy != NULL) {
 8000dcc:	b106      	cbz	r6, 8000dd0 <iqReadTimeout+0x34>
        nfy(iqp);
 8000dce:	47b0      	blx	r6
 8000dd0:	f388 8811 	msr	BASEPRI, r8
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8000dd4:	eba9 0904 	sub.w	r9, r9, r4
      bp += done;
 8000dd8:	4425      	add	r5, r4
 8000dda:	f387 8811 	msr	BASEPRI, r7
  while (n > 0U) {
 8000dde:	f1b9 0f00 	cmp.w	r9, #0
 8000de2:	d1eb      	bne.n	8000dbc <iqReadTimeout+0x20>
 8000de4:	9801      	ldr	r0, [sp, #4]
 8000de6:	2300      	movs	r3, #0
 8000de8:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8000dec:	b003      	add	sp, #12
 8000dee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000df2:	4651      	mov	r1, sl
 8000df4:	f005 fc38 	bl	8006668 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8000df8:	2800      	cmp	r0, #0
 8000dfa:	d0df      	beq.n	8000dbc <iqReadTimeout+0x20>
  return max - n;
 8000dfc:	9b01      	ldr	r3, [sp, #4]
 8000dfe:	eba3 0009 	sub.w	r0, r3, r9
 8000e02:	2300      	movs	r3, #0
 8000e04:	f383 8811 	msr	BASEPRI, r3
}
 8000e08:	b003      	add	sp, #12
 8000e0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000e0e:	bf00      	nop

08000e10 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8000e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e12:	4604      	mov	r4, r0
 8000e14:	460d      	mov	r5, r1
 8000e16:	4616      	mov	r6, r2
 8000e18:	461f      	mov	r7, r3
  chThdQueueObjectInit(tqp);
 8000e1a:	f005 fc21 	bl	8006660 <chThdQueueObjectInit>
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000e1e:	9b06      	ldr	r3, [sp, #24]
  oqp->q_counter = size;
 8000e20:	60a6      	str	r6, [r4, #8]
  oqp->q_top     = bp + size;
 8000e22:	442e      	add	r6, r5
  oqp->q_notify  = onfy;
 8000e24:	61e7      	str	r7, [r4, #28]
  oqp->q_link    = link;
 8000e26:	6223      	str	r3, [r4, #32]
  oqp->q_buffer  = bp;
 8000e28:	e9c4 5603 	strd	r5, r6, [r4, #12]
  oqp->q_wrptr   = bp;
 8000e2c:	e9c4 5505 	strd	r5, r5, [r4, #20]
}
 8000e30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e32:	bf00      	nop

08000e34 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000e34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e36:	2330      	movs	r3, #48	; 0x30
 8000e38:	4604      	mov	r4, r0
 8000e3a:	460f      	mov	r7, r1
 8000e3c:	4616      	mov	r6, r2
 8000e3e:	f383 8811 	msr	BASEPRI, r3
}
 8000e42:	e003      	b.n	8000e4c <oqPutTimeout+0x18>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000e44:	f005 fc10 	bl	8006668 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000e48:	2800      	cmp	r0, #0
 8000e4a:	db19      	blt.n	8000e80 <oqPutTimeout+0x4c>
  while (oqIsFullI(oqp)) {
 8000e4c:	68a5      	ldr	r5, [r4, #8]
 8000e4e:	4631      	mov	r1, r6
 8000e50:	4620      	mov	r0, r4
 8000e52:	2d00      	cmp	r5, #0
 8000e54:	d0f6      	beq.n	8000e44 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000e56:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000e58:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000e5a:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000e5c:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000e5e:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8000e60:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000e62:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000e64:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8000e68:	429a      	cmp	r2, r3
 8000e6a:	d301      	bcc.n	8000e70 <oqPutTimeout+0x3c>
    oqp->q_wrptr = oqp->q_buffer;
 8000e6c:	68e3      	ldr	r3, [r4, #12]
 8000e6e:	6163      	str	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000e70:	69e3      	ldr	r3, [r4, #28]
 8000e72:	b10b      	cbz	r3, 8000e78 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 8000e74:	4620      	mov	r0, r4
 8000e76:	4798      	blx	r3
 8000e78:	2000      	movs	r0, #0
 8000e7a:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000e7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e80:	f385 8811 	msr	BASEPRI, r5
 8000e84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e86:	bf00      	nop

08000e88 <oqGetI>:
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8000e88:	e9d0 2305 	ldrd	r2, r3, [r0, #20]
 8000e8c:	429a      	cmp	r2, r3
 8000e8e:	d010      	beq.n	8000eb2 <oqGetI+0x2a>
    uint8_t b;

    oqp->q_counter++;
 8000e90:	6882      	ldr	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 8000e92:	1c59      	adds	r1, r3, #1
    oqp->q_counter++;
 8000e94:	3201      	adds	r2, #1
msg_t oqGetI(output_queue_t *oqp) {
 8000e96:	b510      	push	{r4, lr}
    b = *oqp->q_rdptr++;
 8000e98:	6181      	str	r1, [r0, #24]
    oqp->q_counter++;
 8000e9a:	6082      	str	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 8000e9c:	781c      	ldrb	r4, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000e9e:	6903      	ldr	r3, [r0, #16]
 8000ea0:	4299      	cmp	r1, r3
 8000ea2:	d301      	bcc.n	8000ea8 <oqGetI+0x20>
      oqp->q_rdptr = oqp->q_buffer;
 8000ea4:	68c3      	ldr	r3, [r0, #12]
 8000ea6:	6183      	str	r3, [r0, #24]
  chThdDequeueNextI(tqp, msg);
 8000ea8:	2100      	movs	r1, #0
 8000eaa:	f005 fbf1 	bl	8006690 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

    return (msg_t)b;
 8000eae:	4620      	mov	r0, r4
  }

  return MSG_TIMEOUT;
}
 8000eb0:	bd10      	pop	{r4, pc}
  if (!oqIsEmptyI(oqp)) {
 8000eb2:	6882      	ldr	r2, [r0, #8]
 8000eb4:	2a00      	cmp	r2, #0
 8000eb6:	d0eb      	beq.n	8000e90 <oqGetI+0x8>
  return MSG_TIMEOUT;
 8000eb8:	f04f 30ff 	mov.w	r0, #4294967295
}
 8000ebc:	4770      	bx	lr
 8000ebe:	bf00      	nop

08000ec0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000ec0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000ec4:	b083      	sub	sp, #12
 8000ec6:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 8000ec8:	69c6      	ldr	r6, [r0, #28]
 8000eca:	2730      	movs	r7, #48	; 0x30
                      size_t n, sysinterval_t timeout) {
 8000ecc:	9201      	str	r2, [sp, #4]
 8000ece:	f387 8811 	msr	BASEPRI, r7

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000ed2:	b1ca      	cbz	r2, 8000f08 <oqWriteTimeout+0x48>
 8000ed4:	4683      	mov	fp, r0
 8000ed6:	460d      	mov	r5, r1
 8000ed8:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8000edc:	f04f 0800 	mov.w	r8, #0
    size_t done;

    done = oq_write(oqp, bp, n);
 8000ee0:	464a      	mov	r2, r9
 8000ee2:	4629      	mov	r1, r5
 8000ee4:	4658      	mov	r0, fp
 8000ee6:	f7ff fecd 	bl	8000c84 <oq_write>
 8000eea:	4604      	mov	r4, r0
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
        nfy(oqp);
 8000eec:	4658      	mov	r0, fp
    if (done == (size_t)0) {
 8000eee:	b194      	cbz	r4, 8000f16 <oqWriteTimeout+0x56>
      if (nfy != NULL) {
 8000ef0:	b106      	cbz	r6, 8000ef4 <oqWriteTimeout+0x34>
        nfy(oqp);
 8000ef2:	47b0      	blx	r6
 8000ef4:	f388 8811 	msr	BASEPRI, r8
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8000ef8:	eba9 0904 	sub.w	r9, r9, r4
      bp += done;
 8000efc:	4425      	add	r5, r4
 8000efe:	f387 8811 	msr	BASEPRI, r7
  while (n > 0U) {
 8000f02:	f1b9 0f00 	cmp.w	r9, #0
 8000f06:	d1eb      	bne.n	8000ee0 <oqWriteTimeout+0x20>
 8000f08:	9801      	ldr	r0, [sp, #4]
 8000f0a:	2300      	movs	r3, #0
 8000f0c:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8000f10:	b003      	add	sp, #12
 8000f12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000f16:	4651      	mov	r1, sl
 8000f18:	f005 fba6 	bl	8006668 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8000f1c:	2800      	cmp	r0, #0
 8000f1e:	d0df      	beq.n	8000ee0 <oqWriteTimeout+0x20>
  return max - n;
 8000f20:	9b01      	ldr	r3, [sp, #4]
 8000f22:	eba3 0009 	sub.w	r0, r3, r9
 8000f26:	2300      	movs	r3, #0
 8000f28:	f383 8811 	msr	BASEPRI, r3
}
 8000f2c:	b003      	add	sp, #12
 8000f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f32:	bf00      	nop

08000f34 <_mmcsd_get_slice>:
  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 8000f34:	f001 0c1f 	and.w	ip, r1, #31
 8000f38:	2301      	movs	r3, #1
  endidx   = end / 32U;
 8000f3a:	0949      	lsrs	r1, r1, #5
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 8000f3c:	f10c 0c01 	add.w	ip, ip, #1

  /* One or two pieces?*/
  if (startidx < endidx) {
 8000f40:	ebb1 1f52 	cmp.w	r1, r2, lsr #5
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 8000f44:	fa03 f30c 	lsl.w	r3, r3, ip
                          uint32_t start) {
 8000f48:	b510      	push	{r4, lr}
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 8000f4a:	f103 33ff 	add.w	r3, r3, #4294967295
  startidx = start / 32U;
 8000f4e:	ea4f 1452 	mov.w	r4, r2, lsr #5
  startoff = start % 32U;
 8000f52:	f002 0e1f 	and.w	lr, r2, #31
  if (startidx < endidx) {
 8000f56:	d805      	bhi.n	8000f64 <_mmcsd_get_slice+0x30>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8000f58:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 8000f5c:	4018      	ands	r0, r3
 8000f5e:	fa20 f00e 	lsr.w	r0, r0, lr
}
 8000f62:	bd10      	pop	{r4, pc}
           ((data[endidx] & endmask) << (32U - startoff));
 8000f64:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000f68:	f850 2024 	ldr.w	r2, [r0, r4, lsl #2]
           ((data[endidx] & endmask) << (32U - startoff));
 8000f6c:	ea03 0001 	and.w	r0, r3, r1
 8000f70:	f1ce 0120 	rsb	r1, lr, #32
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000f74:	fa22 f30e 	lsr.w	r3, r2, lr
           ((data[endidx] & endmask) << (32U - startoff));
 8000f78:	4088      	lsls	r0, r1
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000f7a:	4318      	orrs	r0, r3
}
 8000f7c:	bd10      	pop	{r4, pc}
 8000f7e:	bf00      	nop

08000f80 <_mmcsd_get_capacity>:
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8000f80:	68c3      	ldr	r3, [r0, #12]
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8000f82:	0f9b      	lsrs	r3, r3, #30
 8000f84:	d008      	beq.n	8000f98 <_mmcsd_get_capacity+0x18>
           ((data[endidx] & endmask) << (32U - startoff));
 8000f86:	6883      	ldr	r3, [r0, #8]
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000f88:	88c2      	ldrh	r2, [r0, #6]
           ((data[endidx] & endmask) << (32U - startoff));
 8000f8a:	0418      	lsls	r0, r3, #16
 8000f8c:	f400 107c 	and.w	r0, r0, #4128768	; 0x3f0000
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000f90:	4310      	orrs	r0, r2
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8000f92:	3001      	adds	r0, #1
 8000f94:	0280      	lsls	r0, r0, #10
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
}
 8000f96:	4770      	bx	lr
           ((data[endidx] & endmask) << (32U - startoff));
 8000f98:	6882      	ldr	r2, [r0, #8]
 8000f9a:	f640 73fc 	movw	r3, #4092	; 0xffc
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000f9e:	6841      	ldr	r1, [r0, #4]
           ((data[endidx] & endmask) << (32U - startoff));
 8000fa0:	ea03 0082 	and.w	r0, r3, r2, lsl #2
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8000fa4:	f3c2 4203 	ubfx	r2, r2, #16, #4
 8000fa8:	f3c1 33c2 	ubfx	r3, r1, #15, #3
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000fac:	ea40 7091 	orr.w	r0, r0, r1, lsr #30
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8000fb0:	3a09      	subs	r2, #9
 8000fb2:	3302      	adds	r3, #2
 8000fb4:	3001      	adds	r0, #1
 8000fb6:	4098      	lsls	r0, r3
 8000fb8:	4090      	lsls	r0, r2
 8000fba:	4770      	bx	lr

08000fbc <_mmcsd_get_capacity_ext>:
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 8000fbc:	f890 30d6 	ldrb.w	r3, [r0, #214]	; 0xd6
  return ((uint32_t)ext_csd[215] << 24U) +
 8000fc0:	f890 10d7 	ldrb.w	r1, [r0, #215]	; 0xd7
         ((uint32_t)ext_csd[214] << 16U) +
 8000fc4:	041b      	lsls	r3, r3, #16
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 8000fc6:	f890 20d4 	ldrb.w	r2, [r0, #212]	; 0xd4
         ((uint32_t)ext_csd[213] << 8U)  +
 8000fca:	f890 00d5 	ldrb.w	r0, [r0, #213]	; 0xd5
  return ((uint32_t)ext_csd[215] << 24U) +
 8000fce:	eb03 6301 	add.w	r3, r3, r1, lsl #24
         ((uint32_t)ext_csd[213] << 8U)  +
 8000fd2:	4413      	add	r3, r2
}
 8000fd4:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8000fd8:	4770      	bx	lr
 8000fda:	bf00      	nop

08000fdc <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 8000fdc:	f001 b8fa 	b.w	80021d4 <adc_lld_init>

08000fe0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 8000fe0:	4603      	mov	r3, r0

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8000fe2:	2200      	movs	r2, #0
  adcp->state    = ADC_STOP;
 8000fe4:	2101      	movs	r1, #1
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8000fe6:	3018      	adds	r0, #24
  adcp->samples  = NULL;
  adcp->depth    = 0;
  adcp->grpp     = NULL;
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8000fe8:	615a      	str	r2, [r3, #20]
  adcp->state    = ADC_STOP;
 8000fea:	7019      	strb	r1, [r3, #0]
  adcp->samples  = NULL;
 8000fec:	e9c3 2201 	strd	r2, r2, [r3, #4]
  adcp->grpp     = NULL;
 8000ff0:	e9c3 2203 	strd	r2, r2, [r3, #12]
 8000ff4:	f005 bbec 	b.w	80067d0 <chMtxObjectInit>

08000ff8 <adcStart>:
 *                      the implementation the value can be @p NULL.
 * @return              The operation status.
 *
 * @api
 */
msg_t adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8000ff8:	b510      	push	{r4, lr}
 8000ffa:	2330      	movs	r3, #48	; 0x30
 8000ffc:	4604      	mov	r4, r0
 8000ffe:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 8001002:	6041      	str	r1, [r0, #4]

#if defined(ADC_LLD_ENHANCED_API)
  msg = adc_lld_start(adcp);
 8001004:	f001 f970 	bl	80022e8 <adc_lld_start>
 8001008:	2300      	movs	r3, #0
  if (msg == HAL_RET_SUCCESS) {
    adcp->state = ADC_READY;
 800100a:	4298      	cmp	r0, r3
 800100c:	bf14      	ite	ne
 800100e:	2201      	movne	r2, #1
 8001010:	2202      	moveq	r2, #2
 8001012:	7022      	strb	r2, [r4, #0]
 8001014:	f383 8811 	msr	BASEPRI, r3
#endif

  osalSysUnlock();

  return msg;
}
 8001018:	bd10      	pop	{r4, pc}
 800101a:	bf00      	nop

0800101c <adcStop>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @api
 */
void adcStop(ADCDriver *adcp) {
 800101c:	b510      	push	{r4, lr}
 800101e:	2330      	movs	r3, #48	; 0x30
 8001020:	4604      	mov	r4, r0
 8001022:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();

  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");

  adc_lld_stop(adcp);
 8001026:	f001 f9ff 	bl	8002428 <adc_lld_stop>
  adcp->config = NULL;
 800102a:	2300      	movs	r3, #0
  adcp->state  = ADC_STOP;
 800102c:	2201      	movs	r2, #1
  adcp->config = NULL;
 800102e:	6063      	str	r3, [r4, #4]
  adcp->state  = ADC_STOP;
 8001030:	7022      	strb	r2, [r4, #0]
 8001032:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlock();
}
 8001036:	bd10      	pop	{r4, pc}

08001038 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8001038:	b510      	push	{r4, lr}
 800103a:	2430      	movs	r4, #48	; 0x30
 800103c:	f384 8811 	msr	BASEPRI, r4
  adcp->state    = ADC_ACTIVE;
 8001040:	4604      	mov	r4, r0
  adcp->samples  = samples;
 8001042:	6082      	str	r2, [r0, #8]
  adcp->state    = ADC_ACTIVE;
 8001044:	2203      	movs	r2, #3
  adcp->grpp     = grpp;
 8001046:	e9c0 3103 	strd	r3, r1, [r0, #12]
  adcp->state    = ADC_ACTIVE;
 800104a:	f804 2b14 	strb.w	r2, [r4], #20
  adc_lld_start_conversion(adcp);
 800104e:	f001 fa45 	bl	80024dc <adc_lld_start_conversion>
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 8001052:	f04f 31ff 	mov.w	r1, #4294967295
 8001056:	4620      	mov	r0, r4
 8001058:	f005 faea 	bl	8006630 <chThdSuspendTimeoutS>
 800105c:	2300      	movs	r3, #0
 800105e:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(adcp->thread == NULL, "already waiting");
  adcStartConversionI(adcp, grpp, samples, depth);
  msg = osalThreadSuspendS(&adcp->thread);
  osalSysUnlock();
  return msg;
}
 8001062:	bd10      	pop	{r4, pc}

08001064 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 8001064:	f002 b9b6 	b.w	80033d4 <i2c_lld_init>

08001068 <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
 8001068:	4603      	mov	r3, r0

  i2cp->state  = I2C_STOP;
 800106a:	2101      	movs	r1, #1
  i2cp->config = NULL;
 800106c:	2200      	movs	r2, #0
  chMtxObjectInit(mp);
 800106e:	300c      	adds	r0, #12
  i2cp->state  = I2C_STOP;
 8001070:	7019      	strb	r1, [r3, #0]
  i2cp->config = NULL;
 8001072:	605a      	str	r2, [r3, #4]
 8001074:	f005 bbac 	b.w	80067d0 <chMtxObjectInit>

08001078 <i2cStart>:
 * @param[in] config    pointer to the @p I2CConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 8001078:	b510      	push	{r4, lr}
 800107a:	2330      	movs	r3, #48	; 0x30
 800107c:	4604      	mov	r4, r0
 800107e:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2cp->config = config;
 8001082:	6041      	str	r1, [r0, #4]
  }
  else {
    i2cp->state = I2C_STOP;
  }
#else
  i2c_lld_start(i2cp);
 8001084:	f002 f9c0 	bl	8003408 <i2c_lld_start>
  i2cp->state = I2C_READY;
 8001088:	2302      	movs	r3, #2
 800108a:	2000      	movs	r0, #0
 800108c:	7023      	strb	r3, [r4, #0]
 800108e:	f380 8811 	msr	BASEPRI, r0
#endif

  osalSysUnlock();

  return msg;
}
 8001092:	bd10      	pop	{r4, pc}

08001094 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               sysinterval_t timeout) {
 8001094:	b570      	push	{r4, r5, r6, lr}
 8001096:	b084      	sub	sp, #16
 8001098:	4604      	mov	r4, r0
 800109a:	f04f 0c30 	mov.w	ip, #48	; 0x30
 800109e:	9d08      	ldr	r5, [sp, #32]
 80010a0:	f38c 8811 	msr	BASEPRI, ip
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80010a4:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  i2cp->state = I2C_ACTIVE_TX;
 80010a6:	f04f 0c03 	mov.w	ip, #3
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80010aa:	9602      	str	r6, [sp, #8]
 80010ac:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80010ae:	e9cd 5600 	strd	r5, r6, [sp]
  i2cp->errors = I2C_NO_ERROR;
 80010b2:	2500      	movs	r5, #0
  i2cp->state = I2C_ACTIVE_TX;
 80010b4:	f880 c000 	strb.w	ip, [r0]
  i2cp->errors = I2C_NO_ERROR;
 80010b8:	6085      	str	r5, [r0, #8]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80010ba:	f002 fa0f 	bl	80034dc <i2c_lld_master_transmit_timeout>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 80010be:	1c43      	adds	r3, r0, #1
 80010c0:	bf14      	ite	ne
 80010c2:	2302      	movne	r3, #2
 80010c4:	2305      	moveq	r3, #5
 80010c6:	7023      	strb	r3, [r4, #0]
 80010c8:	f385 8811 	msr	BASEPRI, r5
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
 80010cc:	b004      	add	sp, #16
 80010ce:	bd70      	pop	{r4, r5, r6, pc}

080010d0 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 80010d0:	f004 bb04 	b.w	80056dc <pwm_lld_init>

080010d4 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 80010d4:	2300      	movs	r3, #0
  pwmp->state    = PWM_STOP;
 80010d6:	2201      	movs	r2, #1
  pwmp->config   = NULL;
 80010d8:	6043      	str	r3, [r0, #4]
  pwmp->state    = PWM_STOP;
 80010da:	7002      	strb	r2, [r0, #0]
  pwmp->enabled  = 0;
 80010dc:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 80010de:	7403      	strb	r3, [r0, #16]
#if defined(PWM_DRIVER_EXT_INIT_HOOK)
  PWM_DRIVER_EXT_INIT_HOOK(pwmp);
#endif
}
 80010e0:	4770      	bx	lr
 80010e2:	bf00      	nop

080010e4 <sdcGetInfo>:
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 80010e4:	7903      	ldrb	r3, [r0, #4]
 80010e6:	2b05      	cmp	r3, #5
 80010e8:	d106      	bne.n	80010f8 <sdcGetInfo+0x14>
    return HAL_FAILED;
  }

  bdip->blk_num = sdcp->capacity;
 80010ea:	6a82      	ldr	r2, [r0, #40]	; 0x28
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 80010ec:	f44f 7300 	mov.w	r3, #512	; 0x200

  return HAL_SUCCESS;
 80010f0:	2000      	movs	r0, #0
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 80010f2:	e9c1 3200 	strd	r3, r2, [r1]
  return HAL_SUCCESS;
 80010f6:	4770      	bx	lr
    return HAL_FAILED;
 80010f8:	2001      	movs	r0, #1
}
 80010fa:	4770      	bx	lr

080010fc <_sdc_wait_for_transfer_state_internal>:
                                                  bool crc_check) {
 80010fc:	b570      	push	{r4, r5, r6, lr}
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 80010fe:	4e12      	ldr	r6, [pc, #72]	; (8001148 <_sdc_wait_for_transfer_state_internal+0x4c>)
                                                  bool crc_check) {
 8001100:	b082      	sub	sp, #8
 8001102:	4604      	mov	r4, r0
 8001104:	460d      	mov	r5, r1
 8001106:	e011      	b.n	800112c <_sdc_wait_for_transfer_state_internal+0x30>
      cmd_fail = sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS, sdcp->rca, resp);
 8001108:	f003 f9bc 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 800110c:	4603      	mov	r3, r0
  chThdSleep(delay);
 800110e:	200a      	movs	r0, #10
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 8001110:	b9bb      	cbnz	r3, 8001142 <_sdc_wait_for_transfer_state_internal+0x46>
 8001112:	9a01      	ldr	r2, [sp, #4]
    switch (MMCSD_R1_STS(resp[0])) {
 8001114:	f3c2 2143 	ubfx	r1, r2, #9, #4
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 8001118:	4232      	tst	r2, r6
    switch (MMCSD_R1_STS(resp[0])) {
 800111a:	f1a1 0205 	sub.w	r2, r1, #5
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 800111e:	d10f      	bne.n	8001140 <_sdc_wait_for_transfer_state_internal+0x44>
    switch (MMCSD_R1_STS(resp[0])) {
 8001120:	2904      	cmp	r1, #4
 8001122:	d00e      	beq.n	8001142 <_sdc_wait_for_transfer_state_internal+0x46>
 8001124:	2a02      	cmp	r2, #2
 8001126:	d80b      	bhi.n	8001140 <_sdc_wait_for_transfer_state_internal+0x44>
 8001128:	f005 fa6c 	bl	8006604 <chThdSleep>
      cmd_fail = sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_SEND_STATUS, sdcp->rca, resp);
 800112c:	ab01      	add	r3, sp, #4
 800112e:	210d      	movs	r1, #13
 8001130:	4620      	mov	r0, r4
      cmd_fail = sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS, sdcp->rca, resp);
 8001132:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    if (crc_check) {
 8001134:	2d00      	cmp	r5, #0
 8001136:	d1e7      	bne.n	8001108 <_sdc_wait_for_transfer_state_internal+0xc>
      cmd_fail = sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_SEND_STATUS, sdcp->rca, resp);
 8001138:	f003 f98e 	bl	8004458 <sdc_lld_send_cmd_short>
 800113c:	4603      	mov	r3, r0
 800113e:	e7e6      	b.n	800110e <_sdc_wait_for_transfer_state_internal+0x12>
    switch (MMCSD_R1_STS(resp[0])) {
 8001140:	2301      	movs	r3, #1
}
 8001142:	4618      	mov	r0, r3
 8001144:	b002      	add	sp, #8
 8001146:	bd70      	pop	{r4, r5, r6, pc}
 8001148:	fdffe008 	.word	0xfdffe008

0800114c <sdcRead>:
  if ((startblk + n - 1U) > sdcp->capacity) {
 800114c:	f103 3cff 	add.w	ip, r3, #4294967295
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8001150:	b538      	push	{r3, r4, r5, lr}
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001152:	448c      	add	ip, r1
 8001154:	6a85      	ldr	r5, [r0, #40]	; 0x28
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8001156:	4604      	mov	r4, r0
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001158:	45ac      	cmp	ip, r5
 800115a:	d905      	bls.n	8001168 <sdcRead+0x1c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 800115c:	6b43      	ldr	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 800115e:	2001      	movs	r0, #1
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8001160:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001164:	6363      	str	r3, [r4, #52]	; 0x34
}
 8001166:	bd38      	pop	{r3, r4, r5, pc}
  sdcp->state = BLK_READING;
 8001168:	f04f 0c06 	mov.w	ip, #6
 800116c:	f880 c004 	strb.w	ip, [r0, #4]
  status = sdc_lld_read(sdcp, startblk, buf, n);
 8001170:	f003 fba6 	bl	80048c0 <sdc_lld_read>
  sdcp->state = BLK_READY;
 8001174:	2305      	movs	r3, #5
 8001176:	7123      	strb	r3, [r4, #4]
}
 8001178:	bd38      	pop	{r3, r4, r5, pc}
 800117a:	bf00      	nop

0800117c <sdcWrite>:
  if ((startblk + n - 1U) > sdcp->capacity) {
 800117c:	f103 3cff 	add.w	ip, r3, #4294967295
              const uint8_t *buf, uint32_t n) {
 8001180:	b538      	push	{r3, r4, r5, lr}
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001182:	448c      	add	ip, r1
 8001184:	6a85      	ldr	r5, [r0, #40]	; 0x28
              const uint8_t *buf, uint32_t n) {
 8001186:	4604      	mov	r4, r0
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001188:	45ac      	cmp	ip, r5
 800118a:	d905      	bls.n	8001198 <sdcWrite+0x1c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 800118c:	6b43      	ldr	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 800118e:	2001      	movs	r0, #1
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8001190:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001194:	6363      	str	r3, [r4, #52]	; 0x34
}
 8001196:	bd38      	pop	{r3, r4, r5, pc}
  sdcp->state = BLK_WRITING;
 8001198:	f04f 0c07 	mov.w	ip, #7
 800119c:	f880 c004 	strb.w	ip, [r0, #4]
  status = sdc_lld_write(sdcp, startblk, buf, n);
 80011a0:	f003 fbb6 	bl	8004910 <sdc_lld_write>
  sdcp->state = BLK_READY;
 80011a4:	2305      	movs	r3, #5
 80011a6:	7123      	strb	r3, [r4, #4]
}
 80011a8:	bd38      	pop	{r3, r4, r5, pc}
 80011aa:	bf00      	nop

080011ac <sdcSync>:
bool sdcSync(SDCDriver *sdcp) {
 80011ac:	b538      	push	{r3, r4, r5, lr}
  if (sdcp->state != BLK_READY) {
 80011ae:	7905      	ldrb	r5, [r0, #4]
 80011b0:	2d05      	cmp	r5, #5
 80011b2:	d001      	beq.n	80011b8 <sdcSync+0xc>
    return HAL_FAILED;
 80011b4:	2001      	movs	r0, #1
}
 80011b6:	bd38      	pop	{r3, r4, r5, pc}
  sdcp->state = BLK_SYNCING;
 80011b8:	2308      	movs	r3, #8
 80011ba:	4604      	mov	r4, r0
 80011bc:	7103      	strb	r3, [r0, #4]
  result = sdc_lld_sync(sdcp);
 80011be:	f003 fbcd 	bl	800495c <sdc_lld_sync>
  sdcp->state = BLK_READY;
 80011c2:	7125      	strb	r5, [r4, #4]
}
 80011c4:	bd38      	pop	{r3, r4, r5, pc}
 80011c6:	bf00      	nop

080011c8 <sdcDisconnect>:
bool sdcDisconnect(SDCDriver *sdcp) {
 80011c8:	b538      	push	{r3, r4, r5, lr}
 80011ca:	2330      	movs	r3, #48	; 0x30
 80011cc:	f383 8811 	msr	BASEPRI, r3
  if (sdcp->state == BLK_ACTIVE) {
 80011d0:	7903      	ldrb	r3, [r0, #4]
 80011d2:	2b02      	cmp	r3, #2
 80011d4:	d010      	beq.n	80011f8 <sdcDisconnect+0x30>
  sdcp->state = BLK_DISCONNECTING;
 80011d6:	2204      	movs	r2, #4
 80011d8:	4604      	mov	r4, r0
 80011da:	2300      	movs	r3, #0
 80011dc:	7102      	strb	r2, [r0, #4]
 80011de:	f383 8811 	msr	BASEPRI, r3
  return _sdc_wait_for_transfer_state_internal(sdcp, true);
 80011e2:	2101      	movs	r1, #1
 80011e4:	f7ff ff8a 	bl	80010fc <_sdc_wait_for_transfer_state_internal>
  if (_sdc_wait_for_transfer_state(sdcp)) {
 80011e8:	4605      	mov	r5, r0
    sdc_lld_stop_clk(sdcp);
 80011ea:	4620      	mov	r0, r4
  sdc_lld_stop_clk(sdcp);
 80011ec:	f003 f910 	bl	8004410 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 80011f0:	2302      	movs	r3, #2
}
 80011f2:	4628      	mov	r0, r5
  sdcp->state = BLK_ACTIVE;
 80011f4:	7123      	strb	r3, [r4, #4]
}
 80011f6:	bd38      	pop	{r3, r4, r5, pc}
 80011f8:	2500      	movs	r5, #0
 80011fa:	f385 8811 	msr	BASEPRI, r5
 80011fe:	4628      	mov	r0, r5
 8001200:	bd38      	pop	{r3, r4, r5, pc}
 8001202:	bf00      	nop

08001204 <sdcConnect>:
  sdcp->state = BLK_CONNECTING;
 8001204:	2303      	movs	r3, #3
bool sdcConnect(SDCDriver *sdcp) {
 8001206:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  sdcp->state = BLK_CONNECTING;
 800120a:	7103      	strb	r3, [r0, #4]
bool sdcConnect(SDCDriver *sdcp) {
 800120c:	b084      	sub	sp, #16
 800120e:	4604      	mov	r4, r0
  sdc_lld_start_clk(sdcp);
 8001210:	f003 f8a0 	bl	8004354 <sdc_lld_start_clk>
  sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8001214:	2200      	movs	r2, #0
 8001216:	4620      	mov	r0, r4
 8001218:	4611      	mov	r1, r2
 800121a:	f003 f911 	bl	8004440 <sdc_lld_send_cmd_none>
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 800121e:	ab03      	add	r3, sp, #12
 8001220:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 8001224:	2108      	movs	r1, #8
 8001226:	4620      	mov	r0, r4
 8001228:	f003 f92c 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 800122c:	b9e8      	cbnz	r0, 800126a <sdcConnect+0x66>
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 800122e:	9b03      	ldr	r3, [sp, #12]
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 8001230:	2201      	movs	r2, #1
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8001232:	f3c3 2303 	ubfx	r3, r3, #8, #4
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 8001236:	6322      	str	r2, [r4, #48]	; 0x30
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8001238:	4293      	cmp	r3, r2
 800123a:	d009      	beq.n	8001250 <sdcConnect+0x4c>
  sdc_lld_stop_clk(sdcp);
 800123c:	4620      	mov	r0, r4
  return HAL_FAILED;
 800123e:	2501      	movs	r5, #1
  sdc_lld_stop_clk(sdcp);
 8001240:	f003 f8e6 	bl	8004410 <sdc_lld_stop_clk>
  return HAL_FAILED;
 8001244:	2302      	movs	r3, #2
}
 8001246:	4628      	mov	r0, r5
  sdcp->state = BLK_READY;
 8001248:	7123      	strb	r3, [r4, #4]
}
 800124a:	b004      	add	sp, #16
 800124c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001250:	4602      	mov	r2, r0
 8001252:	ab03      	add	r3, sp, #12
 8001254:	2137      	movs	r1, #55	; 0x37
 8001256:	4620      	mov	r0, r4
 8001258:	f003 f914 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 800125c:	2800      	cmp	r0, #0
 800125e:	d1ed      	bne.n	800123c <sdcConnect+0x38>
        MMCSD_R1_ERROR(resp[0])) {
 8001260:	9a03      	ldr	r2, [sp, #12]
 8001262:	4ba6      	ldr	r3, [pc, #664]	; (80014fc <sdcConnect+0x2f8>)
 8001264:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001266:	b18b      	cbz	r3, 800128c <sdcConnect+0x88>
 8001268:	e7e8      	b.n	800123c <sdcConnect+0x38>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 800126a:	ab03      	add	r3, sp, #12
 800126c:	2200      	movs	r2, #0
 800126e:	2137      	movs	r1, #55	; 0x37
 8001270:	4620      	mov	r0, r4
 8001272:	f003 f907 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 8001276:	2800      	cmp	r0, #0
 8001278:	d135      	bne.n	80012e6 <sdcConnect+0xe2>
        MMCSD_R1_ERROR(resp[0])) {
 800127a:	9b03      	ldr	r3, [sp, #12]
 800127c:	4a9f      	ldr	r2, [pc, #636]	; (80014fc <sdcConnect+0x2f8>)
 800127e:	401a      	ands	r2, r3
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001280:	bb8a      	cbnz	r2, 80012e6 <sdcConnect+0xe2>
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8001282:	4611      	mov	r1, r2
 8001284:	4620      	mov	r0, r4
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 8001286:	6322      	str	r2, [r4, #48]	; 0x30
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8001288:	f003 f8da 	bl	8004440 <sdc_lld_send_cmd_none>
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 800128c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800128e:	f003 030f 	and.w	r3, r3, #15
 8001292:	2b02      	cmp	r3, #2
 8001294:	d029      	beq.n	80012ea <sdcConnect+0xe6>
    ocr = SDC_INIT_OCR;
 8001296:	4f9a      	ldr	r7, [pc, #616]	; (8001500 <sdcConnect+0x2fc>)
 8001298:	2564      	movs	r5, #100	; 0x64
 800129a:	4a9a      	ldr	r2, [pc, #616]	; (8001504 <sdcConnect+0x300>)
        MMCSD_R1_ERROR(resp[0])) {
 800129c:	f8df 825c 	ldr.w	r8, [pc, #604]	; 80014fc <sdcConnect+0x2f8>
    ocr = SDC_INIT_OCR;
 80012a0:	2b01      	cmp	r3, #1
 80012a2:	bf18      	it	ne
 80012a4:	4617      	movne	r7, r2
  i = 0;
 80012a6:	e010      	b.n	80012ca <sdcConnect+0xc6>
        MMCSD_R1_ERROR(resp[0])) {
 80012a8:	9e03      	ldr	r6, [sp, #12]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80012aa:	ea16 0f08 	tst.w	r6, r8
 80012ae:	d1c5      	bne.n	800123c <sdcConnect+0x38>
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 80012b0:	f003 f8d2 	bl	8004458 <sdc_lld_send_cmd_short>
 80012b4:	4603      	mov	r3, r0
 80012b6:	2064      	movs	r0, #100	; 0x64
 80012b8:	2b00      	cmp	r3, #0
 80012ba:	d1bf      	bne.n	800123c <sdcConnect+0x38>
    if ((resp[0] & 0x80000000U) != 0U) {
 80012bc:	9b03      	ldr	r3, [sp, #12]
 80012be:	2b00      	cmp	r3, #0
 80012c0:	db28      	blt.n	8001314 <sdcConnect+0x110>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 80012c2:	3d01      	subs	r5, #1
 80012c4:	d0ba      	beq.n	800123c <sdcConnect+0x38>
 80012c6:	f005 f99d 	bl	8006604 <chThdSleep>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80012ca:	ab03      	add	r3, sp, #12
 80012cc:	2200      	movs	r2, #0
 80012ce:	2137      	movs	r1, #55	; 0x37
 80012d0:	4620      	mov	r0, r4
 80012d2:	f003 f8d7 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 80012d6:	4606      	mov	r6, r0
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 80012d8:	ab03      	add	r3, sp, #12
 80012da:	463a      	mov	r2, r7
 80012dc:	2129      	movs	r1, #41	; 0x29
 80012de:	4620      	mov	r0, r4
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80012e0:	2e00      	cmp	r6, #0
 80012e2:	d0e1      	beq.n	80012a8 <sdcConnect+0xa4>
 80012e4:	e7aa      	b.n	800123c <sdcConnect+0x38>
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 80012e6:	2302      	movs	r3, #2
 80012e8:	6323      	str	r3, [r4, #48]	; 0x30
bool sdcConnect(SDCDriver *sdcp) {
 80012ea:	2564      	movs	r5, #100	; 0x64
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 80012ec:	4e86      	ldr	r6, [pc, #536]	; (8001508 <sdcConnect+0x304>)
 80012ee:	e006      	b.n	80012fe <sdcConnect+0xfa>
    if ((resp[0] & 0x80000000U) != 0U) {
 80012f0:	9b03      	ldr	r3, [sp, #12]
 80012f2:	2b00      	cmp	r3, #0
 80012f4:	db0e      	blt.n	8001314 <sdcConnect+0x110>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 80012f6:	3d01      	subs	r5, #1
 80012f8:	d0a0      	beq.n	800123c <sdcConnect+0x38>
 80012fa:	f005 f983 	bl	8006604 <chThdSleep>
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 80012fe:	ab03      	add	r3, sp, #12
 8001300:	4632      	mov	r2, r6
 8001302:	2101      	movs	r1, #1
 8001304:	4620      	mov	r0, r4
 8001306:	f003 f8a7 	bl	8004458 <sdc_lld_send_cmd_short>
 800130a:	4603      	mov	r3, r0
 800130c:	2064      	movs	r0, #100	; 0x64
 800130e:	2b00      	cmp	r3, #0
 8001310:	d0ee      	beq.n	80012f0 <sdcConnect+0xec>
 8001312:	e793      	b.n	800123c <sdcConnect+0x38>
      if ((resp[0] & 0x40000000U) != 0U) {
 8001314:	005a      	lsls	r2, r3, #1
 8001316:	d503      	bpl.n	8001320 <sdcConnect+0x11c>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8001318:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800131a:	f043 0310 	orr.w	r3, r3, #16
 800131e:	6323      	str	r3, [r4, #48]	; 0x30
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 8001320:	f104 0308 	add.w	r3, r4, #8
 8001324:	2200      	movs	r2, #0
 8001326:	2102      	movs	r1, #2
 8001328:	4620      	mov	r0, r4
 800132a:	f003 f8c1 	bl	80044b0 <sdc_lld_send_cmd_long_crc>
 800132e:	2800      	cmp	r0, #0
 8001330:	d184      	bne.n	800123c <sdcConnect+0x38>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 8001332:	4602      	mov	r2, r0
 8001334:	f104 0338 	add.w	r3, r4, #56	; 0x38
 8001338:	2103      	movs	r1, #3
 800133a:	4620      	mov	r0, r4
 800133c:	f003 f8a2 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 8001340:	2800      	cmp	r0, #0
 8001342:	f47f af7b 	bne.w	800123c <sdcConnect+0x38>
                                sdcp->rca, sdcp->csd)) {
 8001346:	f104 0618 	add.w	r6, r4, #24
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 800134a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800134c:	2109      	movs	r1, #9
 800134e:	4620      	mov	r0, r4
 8001350:	4633      	mov	r3, r6
 8001352:	f003 f8ad 	bl	80044b0 <sdc_lld_send_cmd_long_crc>
 8001356:	2800      	cmp	r0, #0
 8001358:	f47f af70 	bne.w	800123c <sdcConnect+0x38>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 800135c:	ab02      	add	r3, sp, #8
 800135e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001360:	2107      	movs	r1, #7
 8001362:	4620      	mov	r0, r4
 8001364:	f003 f88e 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 8001368:	4605      	mov	r5, r0
 800136a:	2800      	cmp	r0, #0
 800136c:	f47f af66 	bne.w	800123c <sdcConnect+0x38>
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8001370:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001372:	f003 030f 	and.w	r3, r3, #15
 8001376:	2b02      	cmp	r3, #2
 8001378:	d065      	beq.n	8001446 <sdcConnect+0x242>
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 800137a:	227e      	movs	r2, #126	; 0x7e
 800137c:	217f      	movs	r1, #127	; 0x7f
 800137e:	4630      	mov	r0, r6
  uint8_t *tmp = sdcp->buf;
 8001380:	6be7      	ldr	r7, [r4, #60]	; 0x3c
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8001382:	f7ff fdd7 	bl	8000f34 <_mmcsd_get_slice>
 8001386:	b170      	cbz	r0, 80013a6 <sdcConnect+0x1a2>
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 8001388:	2306      	movs	r3, #6
 800138a:	2240      	movs	r2, #64	; 0x40
 800138c:	4639      	mov	r1, r7
 800138e:	4620      	mov	r0, r4
 8001390:	9500      	str	r5, [sp, #0]
 8001392:	f003 f8a9 	bl	80044e8 <sdc_lld_read_special>
 8001396:	2800      	cmp	r0, #0
 8001398:	f47f af50 	bne.w	800123c <sdcConnect+0x38>
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 800139c:	89bb      	ldrh	r3, [r7, #12]
 800139e:	ba5b      	rev16	r3, r3
 80013a0:	079b      	lsls	r3, r3, #30
 80013a2:	f100 8094 	bmi.w	80014ce <sdcConnect+0x2ca>
    *clk = SDC_CLK_25MHz;
 80013a6:	2100      	movs	r1, #0
  sdc_lld_set_data_clk(sdcp, clk);
 80013a8:	4620      	mov	r0, r4
 80013aa:	f002 fff7 	bl	800439c <sdc_lld_set_data_clk>
  return _sdc_wait_for_transfer_state_internal(sdcp, false);
 80013ae:	2100      	movs	r1, #0
 80013b0:	4620      	mov	r0, r4
 80013b2:	f7ff fea3 	bl	80010fc <_sdc_wait_for_transfer_state_internal>
  if (_sdc_wait_for_transfer_state_nocrc(sdcp) != HAL_SUCCESS) {
 80013b6:	4605      	mov	r5, r0
 80013b8:	2800      	cmp	r0, #0
 80013ba:	f47f af3f 	bne.w	800123c <sdcConnect+0x38>
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 80013be:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80013c0:	f003 030f 	and.w	r3, r3, #15
 80013c4:	2b02      	cmp	r3, #2
 80013c6:	d06b      	beq.n	80014a0 <sdcConnect+0x29c>
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 80013c8:	4630      	mov	r0, r6
 80013ca:	f7ff fdd9 	bl	8000f80 <_mmcsd_get_capacity>
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 80013ce:	62a0      	str	r0, [r4, #40]	; 0x28
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 80013d0:	ab02      	add	r3, sp, #8
 80013d2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80013d6:	2110      	movs	r1, #16
 80013d8:	4620      	mov	r0, r4
 80013da:	f003 f853 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 80013de:	4605      	mov	r5, r0
 80013e0:	2800      	cmp	r0, #0
 80013e2:	f47f af2b 	bne.w	800123c <sdcConnect+0x38>
      MMCSD_R1_ERROR(resp[0])) {
 80013e6:	9b02      	ldr	r3, [sp, #8]
 80013e8:	4e44      	ldr	r6, [pc, #272]	; (80014fc <sdcConnect+0x2f8>)
                                 MMCSD_BLOCK_SIZE, resp) ||
 80013ea:	4233      	tst	r3, r6
 80013ec:	f47f af26 	bne.w	800123c <sdcConnect+0x38>
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 80013f0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80013f2:	f013 0f0e 	tst.w	r3, #14
 80013f6:	f003 020f 	and.w	r2, r3, #15
 80013fa:	d133      	bne.n	8001464 <sdcConnect+0x260>
  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 80013fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80013fe:	7819      	ldrb	r1, [r3, #0]
 8001400:	b1f9      	cbz	r1, 8001442 <sdcConnect+0x23e>
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8001402:	2901      	cmp	r1, #1
 8001404:	f47f af1a 	bne.w	800123c <sdcConnect+0x38>
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
 8001408:	4620      	mov	r0, r4
 800140a:	f003 f807 	bl	800441c <sdc_lld_set_bus_mode>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 800140e:	ab03      	add	r3, sp, #12
 8001410:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001412:	2137      	movs	r1, #55	; 0x37
 8001414:	4620      	mov	r0, r4
 8001416:	f003 f835 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 800141a:	2800      	cmp	r0, #0
 800141c:	f47f af0e 	bne.w	800123c <sdcConnect+0x38>
        MMCSD_R1_ERROR(resp[0])) {
 8001420:	9b03      	ldr	r3, [sp, #12]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8001422:	4233      	tst	r3, r6
 8001424:	f47f af0a 	bne.w	800123c <sdcConnect+0x38>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8001428:	ab03      	add	r3, sp, #12
 800142a:	2202      	movs	r2, #2
 800142c:	2106      	movs	r1, #6
 800142e:	4620      	mov	r0, r4
 8001430:	f003 f828 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 8001434:	2800      	cmp	r0, #0
 8001436:	f47f af01 	bne.w	800123c <sdcConnect+0x38>
        MMCSD_R1_ERROR(resp[0])) {
 800143a:	9b03      	ldr	r3, [sp, #12]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 800143c:	4233      	tst	r3, r6
 800143e:	f47f aefd 	bne.w	800123c <sdcConnect+0x38>
  return HAL_SUCCESS;
 8001442:	2305      	movs	r3, #5
 8001444:	e6ff      	b.n	8001246 <sdcConnect+0x42>
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8001446:	ab03      	add	r3, sp, #12
 8001448:	4a30      	ldr	r2, [pc, #192]	; (800150c <sdcConnect+0x308>)
 800144a:	2106      	movs	r1, #6
 800144c:	4620      	mov	r0, r4
 800144e:	f003 f819 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 8001452:	2800      	cmp	r0, #0
 8001454:	d1a7      	bne.n	80013a6 <sdcConnect+0x1a2>
                                   MMCSD_R1_ERROR(resp[0]))) {
 8001456:	9b03      	ldr	r3, [sp, #12]
 8001458:	4928      	ldr	r1, [pc, #160]	; (80014fc <sdcConnect+0x2f8>)
 800145a:	4019      	ands	r1, r3
  *clk = SDC_CLK_25MHz;
 800145c:	fab1 f181 	clz	r1, r1
 8001460:	0949      	lsrs	r1, r1, #5
 8001462:	e7a1      	b.n	80013a8 <sdcConnect+0x1a4>
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8001464:	2a02      	cmp	r2, #2
 8001466:	f47f aee9 	bne.w	800123c <sdcConnect+0x38>
  switch (sdcp->config->bus_width) {
 800146a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800146c:	7819      	ldrb	r1, [r3, #0]
 800146e:	2901      	cmp	r1, #1
 8001470:	d041      	beq.n	80014f6 <sdcConnect+0x2f2>
 8001472:	2902      	cmp	r1, #2
 8001474:	d03d      	beq.n	80014f2 <sdcConnect+0x2ee>
 8001476:	2900      	cmp	r1, #0
 8001478:	d0e3      	beq.n	8001442 <sdcConnect+0x23e>
 800147a:	4e25      	ldr	r6, [pc, #148]	; (8001510 <sdcConnect+0x30c>)
  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
 800147c:	4620      	mov	r0, r4
 800147e:	f002 ffcd 	bl	800441c <sdc_lld_set_bus_mode>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8001482:	ab03      	add	r3, sp, #12
 8001484:	4632      	mov	r2, r6
 8001486:	2106      	movs	r1, #6
 8001488:	4620      	mov	r0, r4
 800148a:	f002 fffb 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 800148e:	2800      	cmp	r0, #0
 8001490:	f47f aed4 	bne.w	800123c <sdcConnect+0x38>
      MMCSD_R1_ERROR(resp[0])) {
 8001494:	9a03      	ldr	r2, [sp, #12]
 8001496:	4b19      	ldr	r3, [pc, #100]	; (80014fc <sdcConnect+0x2f8>)
 8001498:	4013      	ands	r3, r2
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800149a:	2b00      	cmp	r3, #0
 800149c:	d0d1      	beq.n	8001442 <sdcConnect+0x23e>
 800149e:	e6cd      	b.n	800123c <sdcConnect+0x38>
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 80014a0:	227e      	movs	r2, #126	; 0x7e
 80014a2:	217f      	movs	r1, #127	; 0x7f
 80014a4:	4630      	mov	r0, r6
 80014a6:	f7ff fd45 	bl	8000f34 <_mmcsd_get_slice>
 80014aa:	2801      	cmp	r0, #1
 80014ac:	d98c      	bls.n	80013c8 <sdcConnect+0x1c4>
      uint8_t *ext_csd = sdcp->buf;
 80014ae:	6be6      	ldr	r6, [r4, #60]	; 0x3c
      if (sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 80014b0:	2308      	movs	r3, #8
 80014b2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80014b6:	4620      	mov	r0, r4
 80014b8:	4631      	mov	r1, r6
 80014ba:	9500      	str	r5, [sp, #0]
 80014bc:	f003 f814 	bl	80044e8 <sdc_lld_read_special>
 80014c0:	2800      	cmp	r0, #0
 80014c2:	f47f aebb 	bne.w	800123c <sdcConnect+0x38>
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 80014c6:	4630      	mov	r0, r6
 80014c8:	f7ff fd78 	bl	8000fbc <_mmcsd_get_capacity_ext>
 80014cc:	e77f      	b.n	80013ce <sdcConnect+0x1ca>
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 80014ce:	4b11      	ldr	r3, [pc, #68]	; (8001514 <sdcConnect+0x310>)
 80014d0:	2240      	movs	r2, #64	; 0x40
 80014d2:	4639      	mov	r1, r7
 80014d4:	4620      	mov	r0, r4
 80014d6:	9300      	str	r3, [sp, #0]
 80014d8:	2306      	movs	r3, #6
 80014da:	f003 f805 	bl	80044e8 <sdc_lld_read_special>
 80014de:	2800      	cmp	r0, #0
 80014e0:	f47f aeac 	bne.w	800123c <sdcConnect+0x38>
        (uint32_t)buf[16];
 80014e4:	7c39      	ldrb	r1, [r7, #16]
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 80014e6:	f001 010f 	and.w	r1, r1, #15
  *clk = SDC_CLK_25MHz;
 80014ea:	390f      	subs	r1, #15
 80014ec:	bf18      	it	ne
 80014ee:	2101      	movne	r1, #1
 80014f0:	e75a      	b.n	80013a8 <sdcConnect+0x1a4>
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 80014f2:	4e09      	ldr	r6, [pc, #36]	; (8001518 <sdcConnect+0x314>)
 80014f4:	e7c2      	b.n	800147c <sdcConnect+0x278>
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 80014f6:	4e09      	ldr	r6, [pc, #36]	; (800151c <sdcConnect+0x318>)
 80014f8:	e7c0      	b.n	800147c <sdcConnect+0x278>
 80014fa:	bf00      	nop
 80014fc:	fdffe008 	.word	0xfdffe008
 8001500:	50ff8000 	.word	0x50ff8000
 8001504:	80100000 	.word	0x80100000
 8001508:	c0ff8000 	.word	0xc0ff8000
 800150c:	03b90100 	.word	0x03b90100
 8001510:	03b70000 	.word	0x03b70000
 8001514:	80fffff1 	.word	0x80fffff1
 8001518:	03b70200 	.word	0x03b70200
 800151c:	03b70100 	.word	0x03b70100

08001520 <_sdc_wait_for_transfer_state>:
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8001520:	b530      	push	{r4, r5, lr}
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 8001522:	4d10      	ldr	r5, [pc, #64]	; (8001564 <_sdc_wait_for_transfer_state+0x44>)
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8001524:	b083      	sub	sp, #12
 8001526:	4604      	mov	r4, r0
static bool _sdc_wait_for_transfer_state_internal(SDCDriver *sdcp,
 8001528:	e003      	b.n	8001532 <_sdc_wait_for_transfer_state+0x12>
    switch (MMCSD_R1_STS(resp[0])) {
 800152a:	2a02      	cmp	r2, #2
 800152c:	d816      	bhi.n	800155c <_sdc_wait_for_transfer_state+0x3c>
 800152e:	f005 f869 	bl	8006604 <chThdSleep>
      cmd_fail = sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS, sdcp->rca, resp);
 8001532:	ab01      	add	r3, sp, #4
 8001534:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001536:	210d      	movs	r1, #13
 8001538:	4620      	mov	r0, r4
 800153a:	f002 ffa3 	bl	8004484 <sdc_lld_send_cmd_short_crc>
 800153e:	4603      	mov	r3, r0
 8001540:	200a      	movs	r0, #10
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 8001542:	b943      	cbnz	r3, 8001556 <_sdc_wait_for_transfer_state+0x36>
 8001544:	9a01      	ldr	r2, [sp, #4]
    switch (MMCSD_R1_STS(resp[0])) {
 8001546:	f3c2 2143 	ubfx	r1, r2, #9, #4
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 800154a:	422a      	tst	r2, r5
    switch (MMCSD_R1_STS(resp[0])) {
 800154c:	f1a1 0205 	sub.w	r2, r1, #5
    if (cmd_fail || MMCSD_R1_ERROR(resp[0])) {
 8001550:	d104      	bne.n	800155c <_sdc_wait_for_transfer_state+0x3c>
    switch (MMCSD_R1_STS(resp[0])) {
 8001552:	2904      	cmp	r1, #4
 8001554:	d1e9      	bne.n	800152a <_sdc_wait_for_transfer_state+0xa>
}
 8001556:	4618      	mov	r0, r3
 8001558:	b003      	add	sp, #12
 800155a:	bd30      	pop	{r4, r5, pc}
    switch (MMCSD_R1_STS(resp[0])) {
 800155c:	2301      	movs	r3, #1
}
 800155e:	4618      	mov	r0, r3
 8001560:	b003      	add	sp, #12
 8001562:	bd30      	pop	{r4, r5, pc}
 8001564:	fdffe008 	.word	0xfdffe008

08001568 <sdcInit>:
  sdc_lld_init();
 8001568:	f002 beae 	b.w	80042c8 <sdc_lld_init>

0800156c <sdcObjectInit>:
  sdcp->errors   = SDC_NO_ERROR;
 800156c:	2300      	movs	r3, #0
  sdcp->vmt      = &sdc_vmt;
 800156e:	4904      	ldr	r1, [pc, #16]	; (8001580 <sdcObjectInit+0x14>)
  sdcp->state    = BLK_STOP;
 8001570:	2201      	movs	r2, #1
  sdcp->vmt      = &sdc_vmt;
 8001572:	6001      	str	r1, [r0, #0]
  sdcp->state    = BLK_STOP;
 8001574:	7102      	strb	r2, [r0, #4]
  sdcp->errors   = SDC_NO_ERROR;
 8001576:	6343      	str	r3, [r0, #52]	; 0x34
  sdcp->capacity = 0;
 8001578:	e9c0 330a 	strd	r3, r3, [r0, #40]	; 0x28
}
 800157c:	4770      	bx	lr
 800157e:	bf00      	nop
 8001580:	08014a3c 	.word	0x08014a3c

08001584 <sdcStart>:
msg_t sdcStart(SDCDriver *sdcp, const SDCConfig *config) {
 8001584:	b510      	push	{r4, lr}
 8001586:	2330      	movs	r3, #48	; 0x30
 8001588:	4604      	mov	r4, r0
 800158a:	f383 8811 	msr	BASEPRI, r3
  sdcp->config = config;
 800158e:	62c1      	str	r1, [r0, #44]	; 0x2c
  sdc_lld_start(sdcp);
 8001590:	f002 feb4 	bl	80042fc <sdc_lld_start>
  sdcp->state = BLK_ACTIVE;
 8001594:	2302      	movs	r3, #2
 8001596:	2000      	movs	r0, #0
 8001598:	7123      	strb	r3, [r4, #4]
 800159a:	f380 8811 	msr	BASEPRI, r0
}
 800159e:	bd10      	pop	{r4, pc}

080015a0 <sdcGetAndClearErrors>:
 80015a0:	2230      	movs	r2, #48	; 0x30
sdcflags_t sdcGetAndClearErrors(SDCDriver *sdcp) {
 80015a2:	4603      	mov	r3, r0
 80015a4:	f382 8811 	msr	BASEPRI, r2
  sdcp->errors = SDC_NO_ERROR;
 80015a8:	2200      	movs	r2, #0
  flags = sdcp->errors;
 80015aa:	6b40      	ldr	r0, [r0, #52]	; 0x34
  sdcp->errors = SDC_NO_ERROR;
 80015ac:	635a      	str	r2, [r3, #52]	; 0x34
 80015ae:	f382 8811 	msr	BASEPRI, r2
}
 80015b2:	4770      	bx	lr

080015b4 <_readt>:
}

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80015b4:	300c      	adds	r0, #12
 80015b6:	f7ff bbf1 	b.w	8000d9c <iqReadTimeout>
 80015ba:	bf00      	nop

080015bc <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80015bc:	f04f 33ff 	mov.w	r3, #4294967295
 80015c0:	300c      	adds	r0, #12
 80015c2:	f7ff bbeb 	b.w	8000d9c <iqReadTimeout>
 80015c6:	bf00      	nop

080015c8 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80015c8:	3030      	adds	r0, #48	; 0x30
 80015ca:	f7ff bc79 	b.w	8000ec0 <oqWriteTimeout>
 80015ce:	bf00      	nop

080015d0 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80015d0:	f04f 33ff 	mov.w	r3, #4294967295
 80015d4:	3030      	adds	r0, #48	; 0x30
 80015d6:	f7ff bc73 	b.w	8000ec0 <oqWriteTimeout>
 80015da:	bf00      	nop

080015dc <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80015dc:	300c      	adds	r0, #12
 80015de:	f7ff bbb5 	b.w	8000d4c <iqGetTimeout>
 80015e2:	bf00      	nop

080015e4 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80015e4:	f04f 31ff 	mov.w	r1, #4294967295
 80015e8:	300c      	adds	r0, #12
 80015ea:	f7ff bbaf 	b.w	8000d4c <iqGetTimeout>
 80015ee:	bf00      	nop

080015f0 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80015f0:	3030      	adds	r0, #48	; 0x30
 80015f2:	f7ff bc1f 	b.w	8000e34 <oqPutTimeout>
 80015f6:	bf00      	nop

080015f8 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80015f8:	f04f 32ff 	mov.w	r2, #4294967295
 80015fc:	3030      	adds	r0, #48	; 0x30
 80015fe:	f7ff bc19 	b.w	8000e34 <oqPutTimeout>
 8001602:	bf00      	nop

08001604 <_ctl>:
 8001604:	2901      	cmp	r1, #1
 8001606:	bf14      	ite	ne
 8001608:	f06f 0013 	mvnne.w	r0, #19
 800160c:	2000      	moveq	r0, #0
 800160e:	4770      	bx	lr

08001610 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8001610:	f004 b8ac 	b.w	800576c <sd_lld_init>

08001614 <sdObjectInit>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
 8001614:	4b04      	ldr	r3, [pc, #16]	; (8001628 <sdObjectInit+0x14>)
void sdObjectInit(SerialDriver *sdp) {
 8001616:	b510      	push	{r4, lr}
 8001618:	4604      	mov	r4, r0
  sdp->vmt = &vmt;
 800161a:	f840 3b04 	str.w	r3, [r0], #4
  chEvtObjectInit(esp);
 800161e:	f005 f979 	bl	8006914 <chEvtObjectInit>
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001622:	2301      	movs	r3, #1
 8001624:	7223      	strb	r3, [r4, #8]
}
 8001626:	bd10      	pop	{r4, pc}
 8001628:	08014a60 	.word	0x08014a60

0800162c <sdStart>:
 *                      configuration is used.
 * @return              The operation status.
 *
 * @api
 */
msg_t sdStart(SerialDriver *sdp, const SerialConfig *config) {
 800162c:	b510      	push	{r4, lr}
 800162e:	2330      	movs	r3, #48	; 0x30
 8001630:	4604      	mov	r4, r0
 8001632:	f383 8811 	msr	BASEPRI, r3
  }
  else {
    sdp->state = SD_STOP;
  }
#else
  sd_lld_start(sdp, config);
 8001636:	f004 f8c1 	bl	80057bc <sd_lld_start>
  sdp->state = SD_READY;
 800163a:	2302      	movs	r3, #2
 800163c:	2000      	movs	r0, #0
 800163e:	7223      	strb	r3, [r4, #8]
 8001640:	f380 8811 	msr	BASEPRI, r0
#endif

  osalSysUnlock();

  return msg;
}
 8001644:	bd10      	pop	{r4, pc}
 8001646:	bf00      	nop

08001648 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001648:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800164a:	6943      	ldr	r3, [r0, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 800164c:	4604      	mov	r4, r0
 800164e:	460d      	mov	r5, r1
  if (iqIsEmptyI(&sdp->iqueue))
 8001650:	b13b      	cbz	r3, 8001662 <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8001652:	4629      	mov	r1, r5
 8001654:	f104 000c 	add.w	r0, r4, #12
 8001658:	f7ff fb5c 	bl	8000d14 <iqPutI>
 800165c:	2800      	cmp	r0, #0
 800165e:	db0b      	blt.n	8001678 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
 8001660:	bd38      	pop	{r3, r4, r5, pc}
  chEvtBroadcastFlagsI(esp, flags);
 8001662:	2104      	movs	r1, #4
 8001664:	4408      	add	r0, r1
 8001666:	f005 f957 	bl	8006918 <chEvtBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 800166a:	4629      	mov	r1, r5
 800166c:	f104 000c 	add.w	r0, r4, #12
 8001670:	f7ff fb50 	bl	8000d14 <iqPutI>
 8001674:	2800      	cmp	r0, #0
 8001676:	daf3      	bge.n	8001660 <sdIncomingDataI+0x18>
 8001678:	1d20      	adds	r0, r4, #4
 800167a:	f44f 6100 	mov.w	r1, #2048	; 0x800
}
 800167e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001682:	f005 b949 	b.w	8006918 <chEvtBroadcastFlagsI>
 8001686:	bf00      	nop

08001688 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 8001688:	4770      	bx	lr
 800168a:	bf00      	nop

0800168c <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
 800168c:	f003 bcd4 	b.w	8005038 <spi_lld_init>

08001690 <spiObjectInit>:
 *
 * @param[out] spip             pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 8001690:	4603      	mov	r3, r0

  spip->state           = SPI_STOP;
  spip->config          = NULL;
 8001692:	2200      	movs	r2, #0
  spip->state           = SPI_STOP;
 8001694:	2101      	movs	r1, #1
  chMtxObjectInit(mp);
 8001696:	300c      	adds	r0, #12
 8001698:	7019      	strb	r1, [r3, #0]
#if SPI_USE_SYNCHRONIZATION == TRUE
  spip->sync_transfer   = NULL;
 800169a:	e9c3 2201 	strd	r2, r2, [r3, #4]
 800169e:	f005 b897 	b.w	80067d0 <chMtxObjectInit>
 80016a2:	bf00      	nop

080016a4 <spiStart>:
 * @param[in] config            pointer to the @p SPIConfig object
 * @return                      The operation status.
 *
 * @api
 */
msg_t spiStart(SPIDriver *spip, const SPIConfig *config) {
 80016a4:	b510      	push	{r4, lr}
 80016a6:	2330      	movs	r3, #48	; 0x30
 80016a8:	4604      	mov	r4, r0
 80016aa:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");

  spip->config = config;
 80016ae:	6041      	str	r1, [r0, #4]

  msg = spi_lld_start(spip);
 80016b0:	f003 fd4c 	bl	800514c <spi_lld_start>
 80016b4:	2300      	movs	r3, #0
  if (msg == HAL_RET_SUCCESS) {
    spip->state = SPI_READY;
 80016b6:	4298      	cmp	r0, r3
 80016b8:	bf14      	ite	ne
 80016ba:	2201      	movne	r2, #1
 80016bc:	2202      	moveq	r2, #2
 80016be:	7022      	strb	r2, [r4, #0]
 80016c0:	f383 8811 	msr	BASEPRI, r3
#if SPI_USE_ASSERT_ON_ERROR == TRUE
  osalDbgAssert(msg == HAL_RET_SUCCESS, "function failed");
#endif

  return msg;
}
 80016c4:	bd10      	pop	{r4, pc}
 80016c6:	bf00      	nop

080016c8 <spiSend>:
 * @retval MSG_TIMEOUT          if synchronization timed out.
 * @retval MSG_RESET            if the transfer has been stopped.
 *
 * @api
 */
msg_t spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 80016c8:	b510      	push	{r4, lr}
 80016ca:	2330      	movs	r3, #48	; 0x30
 80016cc:	4604      	mov	r4, r0
 80016ce:	f383 8811 	msr	BASEPRI, r3
  spip->state = SPI_ACTIVE;
 80016d2:	2303      	movs	r3, #3
 80016d4:	7003      	strb	r3, [r0, #0]
  msg = spi_lld_send(spip, n, txbuf);
 80016d6:	f003 ff55 	bl	8005584 <spi_lld_send>
  msg_t msg;

  osalSysLock();

  msg = spiStartSendI(spip, n, txbuf);
  if (msg == MSG_OK) {
 80016da:	b910      	cbnz	r0, 80016e2 <spiSend+0x1a>
  if (spip->state == SPI_ACTIVE) {
 80016dc:	7823      	ldrb	r3, [r4, #0]
 80016de:	2b03      	cmp	r3, #3
 80016e0:	d003      	beq.n	80016ea <spiSend+0x22>
 80016e2:	2300      	movs	r3, #0
 80016e4:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return msg;
}
 80016e8:	bd10      	pop	{r4, pc}
  return chThdSuspendTimeoutS(trp, timeout);
 80016ea:	f04f 31ff 	mov.w	r1, #4294967295
 80016ee:	f104 0008 	add.w	r0, r4, #8
 80016f2:	f004 ff9d 	bl	8006630 <chThdSuspendTimeoutS>
 80016f6:	2300      	movs	r3, #0
 80016f8:	f383 8811 	msr	BASEPRI, r3
 80016fc:	bd10      	pop	{r4, pc}
 80016fe:	bf00      	nop

08001700 <spiReceive>:
 * @retval MSG_TIMEOUT          if synchronization timed out.
 * @retval MSG_RESET            if the transfer has been stopped.
 *
 * @api
 */
msg_t spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 8001700:	b510      	push	{r4, lr}
 8001702:	2330      	movs	r3, #48	; 0x30
 8001704:	4604      	mov	r4, r0
 8001706:	f383 8811 	msr	BASEPRI, r3
  spip->state = SPI_ACTIVE;
 800170a:	2303      	movs	r3, #3
 800170c:	7003      	strb	r3, [r0, #0]
  msg = spi_lld_receive(spip, n, rxbuf);
 800170e:	f003 ff71 	bl	80055f4 <spi_lld_receive>
  msg_t msg;

  osalSysLock();

  msg = spiStartReceiveI(spip, n, rxbuf);
  if (msg == MSG_OK) {
 8001712:	b910      	cbnz	r0, 800171a <spiReceive+0x1a>
  if (spip->state == SPI_ACTIVE) {
 8001714:	7823      	ldrb	r3, [r4, #0]
 8001716:	2b03      	cmp	r3, #3
 8001718:	d003      	beq.n	8001722 <spiReceive+0x22>
 800171a:	2300      	movs	r3, #0
 800171c:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return msg;
}
 8001720:	bd10      	pop	{r4, pc}
 8001722:	f04f 31ff 	mov.w	r1, #4294967295
 8001726:	f104 0008 	add.w	r0, r4, #8
 800172a:	f004 ff81 	bl	8006630 <chThdSuspendTimeoutS>
 800172e:	2300      	movs	r3, #0
 8001730:	f383 8811 	msr	BASEPRI, r3
 8001734:	bd10      	pop	{r4, pc}
 8001736:	bf00      	nop

08001738 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 8001738:	f001 bfba 	b.w	80036b0 <usb_lld_init>

0800173c <usbObjectInit>:
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 800173c:	2301      	movs	r3, #1
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800173e:	2240      	movs	r2, #64	; 0x40
 8001740:	2100      	movs	r1, #0
void usbObjectInit(USBDriver *usbp) {
 8001742:	b510      	push	{r4, lr}
 8001744:	4604      	mov	r4, r0
  usbp->state        = USB_STOP;
 8001746:	f800 3b30 	strb.w	r3, [r0], #48
    usbp->in_params[i]  = NULL;
 800174a:	f00d f84b 	bl	800e7e4 <memset>
  usbp->config       = NULL;
 800174e:	2300      	movs	r3, #0
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8001750:	e9c4 3301 	strd	r3, r3, [r4, #4]
  usbp->receiving    = 0;
}
 8001754:	bd10      	pop	{r4, pc}
 8001756:	bf00      	nop

08001758 <usbStart>:
 * @param[in] config    pointer to the @p USBConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t usbStart(USBDriver *usbp, const USBConfig *config) {
 8001758:	b510      	push	{r4, lr}
 800175a:	2230      	movs	r2, #48	; 0x30
 800175c:	4604      	mov	r4, r0
 800175e:	460b      	mov	r3, r1
 8001760:	f382 8811 	msr	BASEPRI, r2
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");

  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8001764:	2224      	movs	r2, #36	; 0x24
  usbp->config = config;
 8001766:	6063      	str	r3, [r4, #4]
    usbp->epc[i] = NULL;
 8001768:	2100      	movs	r1, #0
 800176a:	300c      	adds	r0, #12
 800176c:	f00d f83a 	bl	800e7e4 <memset>
  }
  else {
    usbp->state = USB_STOP;
  }
#else
  usb_lld_start(usbp);
 8001770:	4620      	mov	r0, r4
 8001772:	f001 ffbb 	bl	80036ec <usb_lld_start>
  usbp->state = USB_READY;
 8001776:	2302      	movs	r3, #2
 8001778:	2000      	movs	r0, #0
 800177a:	7023      	strb	r3, [r4, #0]
 800177c:	f380 8811 	msr	BASEPRI, r0
#endif

  osalSysUnlock();

  return msg;
}
 8001780:	bd10      	pop	{r4, pc}
 8001782:	bf00      	nop

08001784 <usbInitEndpointI>:
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 8001784:	eb00 0c81 	add.w	ip, r0, r1, lsl #2

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8001788:	6953      	ldr	r3, [r2, #20]
  usbp->epc[ep] = epcp;
 800178a:	f8cc 200c 	str.w	r2, [ip, #12]
  if (epcp->in_state != NULL) {
 800178e:	b14b      	cbz	r3, 80017a4 <usbInitEndpointI+0x20>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8001790:	f04f 0c00 	mov.w	ip, #0
 8001794:	f8c3 c000 	str.w	ip, [r3]
 8001798:	f8c3 c004 	str.w	ip, [r3, #4]
 800179c:	f8c3 c008 	str.w	ip, [r3, #8]
 80017a0:	f8c3 c00c 	str.w	ip, [r3, #12]
  }
  if (epcp->out_state != NULL) {
 80017a4:	6993      	ldr	r3, [r2, #24]
 80017a6:	b123      	cbz	r3, 80017b2 <usbInitEndpointI+0x2e>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80017a8:	2200      	movs	r2, #0
 80017aa:	601a      	str	r2, [r3, #0]
 80017ac:	605a      	str	r2, [r3, #4]
 80017ae:	609a      	str	r2, [r3, #8]
 80017b0:	60da      	str	r2, [r3, #12]
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 80017b2:	f002 b8b9 	b.w	8003928 <usb_lld_init_endpoint>
 80017b6:	bf00      	nop

080017b8 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 80017b8:	b530      	push	{r4, r5, lr}
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80017ba:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80017be:	2401      	movs	r4, #1
  osp = usbp->epc[ep]->out_state;
 80017c0:	f8dc 500c 	ldr.w	r5, [ip, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80017c4:	408c      	lsls	r4, r1
 80017c6:	f8b0 c00a 	ldrh.w	ip, [r0, #10]
  osp = usbp->epc[ep]->out_state;
 80017ca:	69ad      	ldr	r5, [r5, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80017cc:	ea44 0c0c 	orr.w	ip, r4, ip
 80017d0:	f8a0 c00a 	strh.w	ip, [r0, #10]
  /*lint -restore*/
  osp->rxbuf  = buf;
 80017d4:	60aa      	str	r2, [r5, #8]
  osp->rxsize = n;
  osp->rxcnt  = 0;
 80017d6:	2200      	movs	r2, #0
 80017d8:	e9c5 3200 	strd	r3, r2, [r5]
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
}
 80017dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  usb_lld_start_out(usbp, ep);
 80017e0:	f002 b970 	b.w	8003ac4 <usb_lld_start_out>

080017e4 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 80017e4:	b530      	push	{r4, r5, lr}
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 80017e6:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80017ea:	2401      	movs	r4, #1
  isp = usbp->epc[ep]->in_state;
 80017ec:	f8dc 500c 	ldr.w	r5, [ip, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80017f0:	408c      	lsls	r4, r1
 80017f2:	f8b0 c008 	ldrh.w	ip, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 80017f6:	696d      	ldr	r5, [r5, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80017f8:	ea44 0c0c 	orr.w	ip, r4, ip
 80017fc:	f8a0 c008 	strh.w	ip, [r0, #8]
  /*lint -restore*/
  isp->txbuf  = buf;
 8001800:	60aa      	str	r2, [r5, #8]
  isp->txsize = n;
  isp->txcnt  = 0;
 8001802:	2200      	movs	r2, #0
 8001804:	e9c5 3200 	strd	r3, r2, [r5]
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 8001808:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  usb_lld_start_in(usbp, ep);
 800180c:	f002 b9ea 	b.w	8003be4 <usb_lld_start_in>

08001810 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8001810:	b570      	push	{r4, r5, r6, lr}
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8001812:	2302      	movs	r3, #2

  /* Resetting internal state.*/
  usbp->status        = 0;
 8001814:	2500      	movs	r5, #0
void _usb_reset(USBDriver *usbp) {
 8001816:	4604      	mov	r4, r0
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8001818:	2224      	movs	r2, #36	; 0x24
  usbp->state         = USB_READY;
 800181a:	7003      	strb	r3, [r0, #0]
    usbp->epc[i] = NULL;
 800181c:	4629      	mov	r1, r5
  usbp->status        = 0;
 800181e:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
    usbp->epc[i] = NULL;
 8001822:	300c      	adds	r0, #12
  usbp->transmitting  = 0;
 8001824:	f840 5c04 	str.w	r5, [r0, #-4]
    usbp->epc[i] = NULL;
 8001828:	f00c ffdc 	bl	800e7e4 <memset>

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_STP_WAITING;

  /* Low level reset.*/
  usb_lld_reset(usbp);
 800182c:	4620      	mov	r0, r4
  usbp->ep0state = USB_EP0_STP_WAITING;
 800182e:	f884 5070 	strb.w	r5, [r4, #112]	; 0x70
  usb_lld_reset(usbp);
 8001832:	f002 f805 	bl	8003840 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8001836:	6863      	ldr	r3, [r4, #4]
 8001838:	681b      	ldr	r3, [r3, #0]
 800183a:	b123      	cbz	r3, 8001846 <_usb_reset+0x36>
 800183c:	4629      	mov	r1, r5
 800183e:	4620      	mov	r0, r4
}
 8001840:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8001844:	4718      	bx	r3
}
 8001846:	bd70      	pop	{r4, r5, r6, pc}

08001848 <_usb_suspend>:
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {

  /* It could happen that multiple suspend events are triggered.*/
  if (usbp->state != USB_SUSPENDED) {
 8001848:	7803      	ldrb	r3, [r0, #0]
 800184a:	2b05      	cmp	r3, #5
 800184c:	d00d      	beq.n	800186a <_usb_suspend+0x22>

    /* State transition, saving the current state.*/
    usbp->saved_state = usbp->state;
    usbp->state       = USB_SUSPENDED;
 800184e:	2105      	movs	r1, #5

    /* Notification of suspend event.*/
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8001850:	6842      	ldr	r2, [r0, #4]
    usbp->saved_state = usbp->state;
 8001852:	f880 308c 	strb.w	r3, [r0, #140]	; 0x8c
    usbp->state       = USB_SUSPENDED;
 8001856:	7001      	strb	r1, [r0, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8001858:	6813      	ldr	r3, [r2, #0]
void _usb_suspend(USBDriver *usbp) {
 800185a:	b510      	push	{r4, lr}
 800185c:	4604      	mov	r4, r0
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800185e:	b10b      	cbz	r3, 8001864 <_usb_suspend+0x1c>
 8001860:	2104      	movs	r1, #4
 8001862:	4798      	blx	r3

    /* Terminating all pending transactions.*/
    usbp->transmitting  = 0;
 8001864:	2300      	movs	r3, #0
 8001866:	60a3      	str	r3, [r4, #8]
        }
      }
    }
  #endif
  }
}
 8001868:	bd10      	pop	{r4, pc}
 800186a:	4770      	bx	lr

0800186c <_usb_wakeup>:
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* It could happen that multiple waakeup events are triggered.*/
  if (usbp->state == USB_SUSPENDED) {
 800186c:	7801      	ldrb	r1, [r0, #0]
 800186e:	2905      	cmp	r1, #5
 8001870:	d000      	beq.n	8001874 <_usb_wakeup+0x8>
    usbp->state = usbp->saved_state;

    /* Notification of suspend event.*/
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
  }
}
 8001872:	4770      	bx	lr
    usbp->state = usbp->saved_state;
 8001874:	f890 c08c 	ldrb.w	ip, [r0, #140]	; 0x8c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8001878:	6842      	ldr	r2, [r0, #4]
    usbp->state = usbp->saved_state;
 800187a:	f880 c000 	strb.w	ip, [r0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800187e:	6813      	ldr	r3, [r2, #0]
 8001880:	2b00      	cmp	r3, #0
 8001882:	d0f6      	beq.n	8001872 <_usb_wakeup+0x6>
 8001884:	4718      	bx	r3
 8001886:	bf00      	nop

08001888 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8001888:	b570      	push	{r4, r5, r6, lr}
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 800188a:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800188e:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8001890:	b113      	cbz	r3, 8001898 <_usb_ep0setup+0x10>
    /* This is unexpected could require handling with a warning event.*/
    /* CHTODO: handling here.*/

    /* Resetting the EP0 state machine and going ahead.*/
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001892:	2300      	movs	r3, #0
 8001894:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
  }

  /* Reading the setup data into the driver buffer.*/
  usbReadSetup(usbp, ep, usbp->setup);
 8001898:	f104 0280 	add.w	r2, r4, #128	; 0x80
 800189c:	4620      	mov	r0, r4
 800189e:	f002 f907 	bl	8003ab0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80018a2:	6863      	ldr	r3, [r4, #4]
 80018a4:	689b      	ldr	r3, [r3, #8]
 80018a6:	b353      	cbz	r3, 80018fe <_usb_ep0setup+0x76>
      !(usbp->config->requests_hook_cb(usbp))) {
 80018a8:	4620      	mov	r0, r4
 80018aa:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 80018ac:	b338      	cbz	r0, 80018fe <_usb_ep0setup+0x76>
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80018ae:	6fa5      	ldr	r5, [r4, #120]	; 0x78
 80018b0:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  max = (size_t)get_hword(&usbp->setup[6]);
 80018b4:	f8b4 2086 	ldrh.w	r2, [r4, #134]	; 0x86
  if (usbp->ep0n > max) {
 80018b8:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80018ba:	bf2c      	ite	cs
 80018bc:	462a      	movcs	r2, r5
    usbp->ep0n = max;
 80018be:	67a2      	strcc	r2, [r4, #120]	; 0x78
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80018c0:	0619      	lsls	r1, r3, #24
 80018c2:	f100 80da 	bmi.w	8001a7a <_usb_ep0setup+0x1f2>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 80018c6:	2a00      	cmp	r2, #0
 80018c8:	f000 808d 	beq.w	80019e6 <_usb_ep0setup+0x15e>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_OUT_RX;
 80018cc:	2215      	movs	r2, #21
 80018ce:	2330      	movs	r3, #48	; 0x30
 80018d0:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 80018d4:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80018d8:	8962      	ldrh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 80018da:	4620      	mov	r0, r4
  osp = usbp->epc[ep]->out_state;
 80018dc:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80018de:	f042 0201 	orr.w	r2, r2, #1
  osp = usbp->epc[ep]->out_state;
 80018e2:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80018e4:	8162      	strh	r2, [r4, #10]
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 80018e6:	e9d4 511d 	ldrd	r5, r1, [r4, #116]	; 0x74
  osp->rxcnt  = 0;
 80018ea:	2400      	movs	r4, #0
  osp->rxsize = n;
 80018ec:	6019      	str	r1, [r3, #0]
  osp->rxbuf  = buf;
 80018ee:	609d      	str	r5, [r3, #8]
  usb_lld_start_out(usbp, ep);
 80018f0:	4621      	mov	r1, r4
  osp->rxcnt  = 0;
 80018f2:	605c      	str	r4, [r3, #4]
  usb_lld_start_out(usbp, ep);
 80018f4:	f002 f8e6 	bl	8003ac4 <usb_lld_start_out>
 80018f8:	f384 8811 	msr	BASEPRI, r4
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 80018fc:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 80018fe:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8001902:	f013 0660 	ands.w	r6, r3, #96	; 0x60
 8001906:	4618      	mov	r0, r3
 8001908:	d11c      	bne.n	8001944 <_usb_ep0setup+0xbc>
           ((uint32_t)usbp->setup[1] << 8U))) {
 800190a:	f894 2081 	ldrb.w	r2, [r4, #129]	; 0x81
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800190e:	f003 057f 	and.w	r5, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8001912:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001916:	f240 3202 	movw	r2, #770	; 0x302
 800191a:	4295      	cmp	r5, r2
 800191c:	f000 8151 	beq.w	8001bc2 <_usb_ep0setup+0x33a>
 8001920:	d840      	bhi.n	80019a4 <_usb_ep0setup+0x11c>
 8001922:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8001926:	f000 8108 	beq.w	8001b3a <_usb_ep0setup+0x2b2>
 800192a:	d91d      	bls.n	8001968 <_usb_ep0setup+0xe0>
 800192c:	f5b5 7f81 	cmp.w	r5, #258	; 0x102
 8001930:	f000 8112 	beq.w	8001b58 <_usb_ep0setup+0x2d0>
 8001934:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 8001938:	d104      	bne.n	8001944 <_usb_ep0setup+0xbc>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800193a:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 800193e:	2b01      	cmp	r3, #1
 8001940:	f000 80d3 	beq.w	8001aea <_usb_ep0setup+0x262>
      usb_lld_stall_in(usbp, 0);
 8001944:	2100      	movs	r1, #0
 8001946:	4620      	mov	r0, r4
 8001948:	f002 fc44 	bl	80041d4 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800194c:	2100      	movs	r1, #0
 800194e:	4620      	mov	r0, r4
 8001950:	f002 fc34 	bl	80041bc <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001954:	6863      	ldr	r3, [r4, #4]
 8001956:	681b      	ldr	r3, [r3, #0]
 8001958:	b113      	cbz	r3, 8001960 <_usb_ep0setup+0xd8>
 800195a:	2106      	movs	r1, #6
 800195c:	4620      	mov	r0, r4
 800195e:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8001960:	2306      	movs	r3, #6
 8001962:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8001966:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001968:	2d01      	cmp	r5, #1
 800196a:	d061      	beq.n	8001a30 <_usb_ep0setup+0x1a8>
 800196c:	2d02      	cmp	r5, #2
 800196e:	d151      	bne.n	8001a14 <_usb_ep0setup+0x18c>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8001970:	f994 3084 	ldrsb.w	r3, [r4, #132]	; 0x84
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8001974:	4620      	mov	r0, r4
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8001976:	f894 1084 	ldrb.w	r1, [r4, #132]	; 0x84
 800197a:	2b00      	cmp	r3, #0
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800197c:	f001 010f 	and.w	r1, r1, #15
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8001980:	f2c0 80ac 	blt.w	8001adc <_usb_ep0setup+0x254>
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8001984:	f002 f878 	bl	8003a78 <usb_lld_get_status_out>
 8001988:	2801      	cmp	r0, #1
 800198a:	f000 80ac 	beq.w	8001ae6 <_usb_ep0setup+0x25e>
 800198e:	2802      	cmp	r0, #2
 8001990:	d1d8      	bne.n	8001944 <_usb_ep0setup+0xbc>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8001992:	499a      	ldr	r1, [pc, #616]	; (8001bfc <_usb_ep0setup+0x374>)
 8001994:	2302      	movs	r3, #2
 8001996:	2200      	movs	r2, #0
 8001998:	e9c4 131d 	strd	r1, r3, [r4, #116]	; 0x74
 800199c:	67e2      	str	r2, [r4, #124]	; 0x7c
        return true;
 800199e:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 80019a2:	e787      	b.n	80018b4 <_usb_ep0setup+0x2c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80019a4:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 80019a8:	f000 8103 	beq.w	8001bb2 <_usb_ep0setup+0x32a>
 80019ac:	d947      	bls.n	8001a3e <_usb_ep0setup+0x1b6>
 80019ae:	f5b5 6f10 	cmp.w	r5, #2304	; 0x900
 80019b2:	d139      	bne.n	8001a28 <_usb_ep0setup+0x1a0>
      if (usbp->state == USB_ACTIVE) {
 80019b4:	7823      	ldrb	r3, [r4, #0]
 80019b6:	2b04      	cmp	r3, #4
 80019b8:	f000 80a1 	beq.w	8001afe <_usb_ep0setup+0x276>
      if (usbp->setup[2] != 0U) {
 80019bc:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 80019c0:	b14b      	cbz	r3, 80019d6 <_usb_ep0setup+0x14e>
        usbp->state = USB_ACTIVE;
 80019c2:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80019c4:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 80019c6:	f884 308b 	strb.w	r3, [r4, #139]	; 0x8b
        usbp->state = USB_ACTIVE;
 80019ca:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80019cc:	6813      	ldr	r3, [r2, #0]
 80019ce:	b113      	cbz	r3, 80019d6 <_usb_ep0setup+0x14e>
 80019d0:	2102      	movs	r1, #2
 80019d2:	4620      	mov	r0, r4
 80019d4:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80019d6:	2300      	movs	r3, #0
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80019d8:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80019dc:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
 80019e0:	67e3      	str	r3, [r4, #124]	; 0x7c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80019e2:	0603      	lsls	r3, r0, #24
 80019e4:	d463      	bmi.n	8001aae <_usb_ep0setup+0x226>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 80019e6:	220b      	movs	r2, #11
 80019e8:	2330      	movs	r3, #48	; 0x30
 80019ea:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 80019ee:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80019f2:	8922      	ldrh	r2, [r4, #8]
  isp->txbuf  = buf;
 80019f4:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
 80019f6:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_in(usbp, ep);
 80019f8:	4620      	mov	r0, r4
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80019fa:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_in(usbp, ep);
 80019fe:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8001a00:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001a02:	8122      	strh	r2, [r4, #8]
  isp->txbuf  = buf;
 8001a04:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8001a06:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8001a0a:	f002 f8eb 	bl	8003be4 <usb_lld_start_in>
 8001a0e:	f385 8811 	msr	BASEPRI, r5
}
 8001a12:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001a14:	2d00      	cmp	r5, #0
 8001a16:	d195      	bne.n	8001944 <_usb_ep0setup+0xbc>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8001a18:	2202      	movs	r2, #2
 8001a1a:	f104 0188 	add.w	r1, r4, #136	; 0x88
 8001a1e:	67e5      	str	r5, [r4, #124]	; 0x7c
 8001a20:	6761      	str	r1, [r4, #116]	; 0x74
 8001a22:	4615      	mov	r5, r2
 8001a24:	67a2      	str	r2, [r4, #120]	; 0x78
    return true;
 8001a26:	e745      	b.n	80018b4 <_usb_ep0setup+0x2c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001a28:	f640 4202 	movw	r2, #3074	; 0xc02
 8001a2c:	4295      	cmp	r5, r2
 8001a2e:	d189      	bne.n	8001944 <_usb_ep0setup+0xbc>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8001a30:	2502      	movs	r5, #2
 8001a32:	4973      	ldr	r1, [pc, #460]	; (8001c00 <_usb_ep0setup+0x378>)
 8001a34:	2200      	movs	r2, #0
 8001a36:	e9c4 151d 	strd	r1, r5, [r4, #116]	; 0x74
 8001a3a:	67e2      	str	r2, [r4, #124]	; 0x7c
    return true;
 8001a3c:	e73a      	b.n	80018b4 <_usb_ep0setup+0x2c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001a3e:	f5b5 6fa0 	cmp.w	r5, #1280	; 0x500
 8001a42:	f000 809f 	beq.w	8001b84 <_usb_ep0setup+0x2fc>
 8001a46:	f5a5 65c0 	sub.w	r5, r5, #1536	; 0x600
 8001a4a:	2d01      	cmp	r5, #1
 8001a4c:	f63f af7a 	bhi.w	8001944 <_usb_ep0setup+0xbc>
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8001a50:	6861      	ldr	r1, [r4, #4]
 8001a52:	4620      	mov	r0, r4
 8001a54:	f8b4 3084 	ldrh.w	r3, [r4, #132]	; 0x84
 8001a58:	684d      	ldr	r5, [r1, #4]
 8001a5a:	f894 2082 	ldrb.w	r2, [r4, #130]	; 0x82
 8001a5e:	f894 1083 	ldrb.w	r1, [r4, #131]	; 0x83
 8001a62:	47a8      	blx	r5
    if (dp == NULL) {
 8001a64:	2800      	cmp	r0, #0
 8001a66:	f43f af6d 	beq.w	8001944 <_usb_ep0setup+0xbc>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8001a6a:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8001a6e:	e9d0 5200 	ldrd	r5, r2, [r0]
 8001a72:	67e6      	str	r6, [r4, #124]	; 0x7c
 8001a74:	e9c4 251d 	strd	r2, r5, [r4, #116]	; 0x74
    return true;
 8001a78:	e71c      	b.n	80018b4 <_usb_ep0setup+0x2c>
    if (usbp->ep0n != 0U) {
 8001a7a:	b1c2      	cbz	r2, 8001aae <_usb_ep0setup+0x226>
      usbp->ep0state = USB_EP0_IN_TX;
 8001a7c:	2209      	movs	r2, #9
 8001a7e:	2330      	movs	r3, #48	; 0x30
 8001a80:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 8001a84:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001a88:	8922      	ldrh	r2, [r4, #8]
  usb_lld_start_in(usbp, ep);
 8001a8a:	4620      	mov	r0, r4
  isp = usbp->epc[ep]->in_state;
 8001a8c:	68e3      	ldr	r3, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001a8e:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
 8001a92:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001a94:	8122      	strh	r2, [r4, #8]
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8001a96:	e9d4 511d 	ldrd	r5, r1, [r4, #116]	; 0x74
  isp->txcnt  = 0;
 8001a9a:	2400      	movs	r4, #0
  isp->txsize = n;
 8001a9c:	6019      	str	r1, [r3, #0]
  isp->txbuf  = buf;
 8001a9e:	609d      	str	r5, [r3, #8]
  usb_lld_start_in(usbp, ep);
 8001aa0:	4621      	mov	r1, r4
  isp->txcnt  = 0;
 8001aa2:	605c      	str	r4, [r3, #4]
  usb_lld_start_in(usbp, ep);
 8001aa4:	f002 f89e 	bl	8003be4 <usb_lld_start_in>
 8001aa8:	f384 8811 	msr	BASEPRI, r4
}
 8001aac:	bd70      	pop	{r4, r5, r6, pc}
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8001aae:	2214      	movs	r2, #20
 8001ab0:	2330      	movs	r3, #48	; 0x30
 8001ab2:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 8001ab6:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001aba:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8001abc:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 8001abe:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
 8001ac0:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001ac2:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
 8001ac6:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
 8001ac8:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001aca:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8001acc:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 8001ace:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 8001ad2:	f001 fff7 	bl	8003ac4 <usb_lld_start_out>
 8001ad6:	f385 8811 	msr	BASEPRI, r5
}
 8001ada:	bd70      	pop	{r4, r5, r6, pc}
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8001adc:	f001 ffda 	bl	8003a94 <usb_lld_get_status_in>
 8001ae0:	2801      	cmp	r0, #1
 8001ae2:	f47f af54 	bne.w	800198e <_usb_ep0setup+0x106>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8001ae6:	4947      	ldr	r1, [pc, #284]	; (8001c04 <_usb_ep0setup+0x37c>)
 8001ae8:	e754      	b.n	8001994 <_usb_ep0setup+0x10c>
      usbp->status |= 2U;
 8001aea:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001aee:	67e6      	str	r6, [r4, #124]	; 0x7c
      usbp->status |= 2U;
 8001af0:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001af4:	e9c4 661d 	strd	r6, r6, [r4, #116]	; 0x74
      usbp->status |= 2U;
 8001af8:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
      return true;
 8001afc:	e771      	b.n	80019e2 <_usb_ep0setup+0x15a>
 8001afe:	2330      	movs	r3, #48	; 0x30
 8001b00:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting &= 1U;
 8001b04:	68a3      	ldr	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8001b06:	2220      	movs	r2, #32
 8001b08:	4631      	mov	r1, r6
 8001b0a:	f104 0010 	add.w	r0, r4, #16
  usbp->transmitting &= 1U;
 8001b0e:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
 8001b12:	60a3      	str	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8001b14:	f00c fe66 	bl	800e7e4 <memset>
  usb_lld_disable_endpoints(usbp);
 8001b18:	4620      	mov	r0, r4
 8001b1a:	f001 ffa5 	bl	8003a68 <usb_lld_disable_endpoints>
 8001b1e:	f386 8811 	msr	BASEPRI, r6
        usbp->state = USB_SELECTED;
 8001b22:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8001b24:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
 8001b26:	f884 608b 	strb.w	r6, [r4, #139]	; 0x8b
        usbp->state = USB_SELECTED;
 8001b2a:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8001b2c:	681b      	ldr	r3, [r3, #0]
 8001b2e:	2b00      	cmp	r3, #0
 8001b30:	f43f af44 	beq.w	80019bc <_usb_ep0setup+0x134>
 8001b34:	4620      	mov	r0, r4
 8001b36:	4798      	blx	r3
 8001b38:	e740      	b.n	80019bc <_usb_ep0setup+0x134>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8001b3a:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8001b3e:	2b01      	cmp	r3, #1
 8001b40:	f47f af00 	bne.w	8001944 <_usb_ep0setup+0xbc>
      usbp->status &= ~2U;
 8001b44:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001b48:	67e6      	str	r6, [r4, #124]	; 0x7c
      usbp->status &= ~2U;
 8001b4a:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001b4e:	e9c4 661d 	strd	r6, r6, [r4, #116]	; 0x74
      usbp->status &= ~2U;
 8001b52:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
      return true;
 8001b56:	e744      	b.n	80019e2 <_usb_ep0setup+0x15a>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8001b58:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8001b5c:	2b00      	cmp	r3, #0
 8001b5e:	f47f aef1 	bne.w	8001944 <_usb_ep0setup+0xbc>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8001b62:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
 8001b66:	f013 010f 	ands.w	r1, r3, #15
 8001b6a:	d006      	beq.n	8001b7a <_usb_ep0setup+0x2f2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8001b6c:	061e      	lsls	r6, r3, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8001b6e:	4620      	mov	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8001b70:	d439      	bmi.n	8001be6 <_usb_ep0setup+0x35e>
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8001b72:	f002 fb3b 	bl	80041ec <usb_lld_clear_out>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001b76:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8001b7a:	2300      	movs	r3, #0
 8001b7c:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
 8001b80:	67e3      	str	r3, [r4, #124]	; 0x7c
    return true;
 8001b82:	e72e      	b.n	80019e2 <_usb_ep0setup+0x15a>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8001b84:	f8b4 3080 	ldrh.w	r3, [r4, #128]	; 0x80
 8001b88:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8001b8c:	d1f5      	bne.n	8001b7a <_usb_ep0setup+0x2f2>
  usbp->address = usbp->setup[2];
 8001b8e:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  usb_lld_set_address(usbp);
 8001b92:	4620      	mov	r0, r4
  usbp->address = usbp->setup[2];
 8001b94:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
  usb_lld_set_address(usbp);
 8001b98:	f001 feb8 	bl	800390c <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8001b9c:	6863      	ldr	r3, [r4, #4]
 8001b9e:	681b      	ldr	r3, [r3, #0]
 8001ba0:	b113      	cbz	r3, 8001ba8 <_usb_ep0setup+0x320>
 8001ba2:	2101      	movs	r1, #1
 8001ba4:	4620      	mov	r0, r4
 8001ba6:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8001ba8:	2303      	movs	r3, #3
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001baa:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
  usbp->state = USB_SELECTED;
 8001bae:	7023      	strb	r3, [r4, #0]
}
 8001bb0:	e7e3      	b.n	8001b7a <_usb_ep0setup+0x2f2>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8001bb2:	2201      	movs	r2, #1
 8001bb4:	f104 018b 	add.w	r1, r4, #139	; 0x8b
 8001bb8:	67e6      	str	r6, [r4, #124]	; 0x7c
 8001bba:	4615      	mov	r5, r2
 8001bbc:	e9c4 121d 	strd	r1, r2, [r4, #116]	; 0x74
    return true;
 8001bc0:	e678      	b.n	80018b4 <_usb_ep0setup+0x2c>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8001bc2:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8001bc6:	2b00      	cmp	r3, #0
 8001bc8:	f47f aebc 	bne.w	8001944 <_usb_ep0setup+0xbc>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8001bcc:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
 8001bd0:	f013 010f 	ands.w	r1, r3, #15
 8001bd4:	d0d1      	beq.n	8001b7a <_usb_ep0setup+0x2f2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8001bd6:	061d      	lsls	r5, r3, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8001bd8:	4620      	mov	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8001bda:	d409      	bmi.n	8001bf0 <_usb_ep0setup+0x368>
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8001bdc:	f002 faee 	bl	80041bc <usb_lld_stall_out>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001be0:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
 8001be4:	e7c9      	b.n	8001b7a <_usb_ep0setup+0x2f2>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8001be6:	f002 fb0d 	bl	8004204 <usb_lld_clear_in>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001bea:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
 8001bee:	e7c4      	b.n	8001b7a <_usb_ep0setup+0x2f2>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8001bf0:	f002 faf0 	bl	80041d4 <usb_lld_stall_in>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001bf4:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
 8001bf8:	e7bf      	b.n	8001b7a <_usb_ep0setup+0x2f2>
 8001bfa:	bf00      	nop
 8001bfc:	08014a88 	.word	0x08014a88
 8001c00:	08014a90 	.word	0x08014a90
 8001c04:	08014a8c 	.word	0x08014a8c

08001c08 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001c08:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8001c0a:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001c0e:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001c10:	2b15      	cmp	r3, #21
 8001c12:	d827      	bhi.n	8001c64 <_usb_ep0in+0x5c>
 8001c14:	e8df f003 	tbb	[pc, r3]
 8001c18:	26262627 	.word	0x26262627
 8001c1c:	26272626 	.word	0x26272626
 8001c20:	38100b26 	.word	0x38100b26
 8001c24:	26262626 	.word	0x26262626
 8001c28:	26262626 	.word	0x26262626
 8001c2c:	2727      	.short	0x2727
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8001c2e:	6f85      	ldr	r5, [r0, #120]	; 0x78
    max = (size_t)get_hword(&usbp->setup[6]);
 8001c30:	f8b0 3086 	ldrh.w	r3, [r0, #134]	; 0x86
    if ((usbp->ep0n < max) &&
 8001c34:	429d      	cmp	r5, r3
 8001c36:	d32e      	bcc.n	8001c96 <_usb_ep0in+0x8e>
      return;
    }
    /* Falls through.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8001c38:	2214      	movs	r2, #20
 8001c3a:	2330      	movs	r3, #48	; 0x30
 8001c3c:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 8001c40:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001c44:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8001c46:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 8001c48:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
 8001c4a:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001c4c:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
 8001c50:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
 8001c52:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001c54:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8001c56:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 8001c58:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 8001c5c:	f001 ff32 	bl	8003ac4 <usb_lld_start_out>
 8001c60:	f385 8811 	msr	BASEPRI, r5
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001c64:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_stall_in(usbp, 0);
 8001c66:	2100      	movs	r1, #0
 8001c68:	f002 fab4 	bl	80041d4 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8001c6c:	2100      	movs	r1, #0
 8001c6e:	4620      	mov	r0, r4
 8001c70:	f002 faa4 	bl	80041bc <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001c74:	6863      	ldr	r3, [r4, #4]
 8001c76:	681b      	ldr	r3, [r3, #0]
 8001c78:	b113      	cbz	r3, 8001c80 <_usb_ep0in+0x78>
 8001c7a:	2106      	movs	r1, #6
 8001c7c:	4620      	mov	r0, r4
 8001c7e:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8001c80:	2306      	movs	r3, #6
 8001c82:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8001c86:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 8001c88:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8001c8a:	b103      	cbz	r3, 8001c8e <_usb_ep0in+0x86>
      usbp->ep0endcb(usbp);
 8001c8c:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001c8e:	2300      	movs	r3, #0
 8001c90:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8001c94:	bd38      	pop	{r3, r4, r5, pc}
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8001c96:	68c3      	ldr	r3, [r0, #12]
 8001c98:	8a1b      	ldrh	r3, [r3, #16]
 8001c9a:	fbb5 f2f3 	udiv	r2, r5, r3
 8001c9e:	fb03 5512 	mls	r5, r3, r2, r5
    if ((usbp->ep0n < max) &&
 8001ca2:	2d00      	cmp	r5, #0
 8001ca4:	d1c8      	bne.n	8001c38 <_usb_ep0in+0x30>
 8001ca6:	2330      	movs	r3, #48	; 0x30
 8001ca8:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001cac:	8902      	ldrh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
 8001cae:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8001cb0:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001cb2:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
 8001cb6:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001cb8:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
 8001cba:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8001cbc:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8001cc0:	f001 ff90 	bl	8003be4 <usb_lld_start_in>
 8001cc4:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 8001cc8:	230a      	movs	r3, #10
 8001cca:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8001cce:	bd38      	pop	{r3, r4, r5, pc}

08001cd0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001cd0:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8001cd2:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001cd6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001cd8:	2b15      	cmp	r3, #21
 8001cda:	d821      	bhi.n	8001d20 <_usb_ep0out+0x50>
 8001cdc:	e8df f003 	tbb	[pc, r3]
 8001ce0:	20202021 	.word	0x20202021
 8001ce4:	20212020 	.word	0x20212020
 8001ce8:	21212120 	.word	0x21212120
 8001cec:	20202020 	.word	0x20202020
 8001cf0:	20202020 	.word	0x20202020
 8001cf4:	0b32      	.short	0x0b32
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8001cf6:	220b      	movs	r2, #11
 8001cf8:	2330      	movs	r3, #48	; 0x30
 8001cfa:	f880 2070 	strb.w	r2, [r0, #112]	; 0x70
 8001cfe:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001d02:	8902      	ldrh	r2, [r0, #8]
  isp->txbuf  = buf;
 8001d04:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
 8001d06:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001d08:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_in(usbp, ep);
 8001d0c:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8001d0e:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001d10:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
 8001d12:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8001d14:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8001d18:	f001 ff64 	bl	8003be4 <usb_lld_start_in>
 8001d1c:	f385 8811 	msr	BASEPRI, r5
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001d20:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_stall_in(usbp, 0);
 8001d22:	2100      	movs	r1, #0
 8001d24:	f002 fa56 	bl	80041d4 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8001d28:	2100      	movs	r1, #0
 8001d2a:	4620      	mov	r0, r4
 8001d2c:	f002 fa46 	bl	80041bc <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001d30:	6863      	ldr	r3, [r4, #4]
 8001d32:	681b      	ldr	r3, [r3, #0]
 8001d34:	b113      	cbz	r3, 8001d3c <_usb_ep0out+0x6c>
 8001d36:	2106      	movs	r1, #6
 8001d38:	4620      	mov	r0, r4
 8001d3a:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8001d3c:	2306      	movs	r3, #6
 8001d3e:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8001d42:	bd38      	pop	{r3, r4, r5, pc}
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8001d44:	68c3      	ldr	r3, [r0, #12]
 8001d46:	699b      	ldr	r3, [r3, #24]
 8001d48:	685b      	ldr	r3, [r3, #4]
 8001d4a:	2b00      	cmp	r3, #0
 8001d4c:	d1e8      	bne.n	8001d20 <_usb_ep0out+0x50>
    if (usbp->ep0endcb != NULL) {
 8001d4e:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8001d50:	b103      	cbz	r3, 8001d54 <_usb_ep0out+0x84>
      usbp->ep0endcb(usbp);
 8001d52:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001d54:	2300      	movs	r3, #0
 8001d56:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8001d5a:	bd38      	pop	{r3, r4, r5, pc}

08001d5c <nvicEnableVector>:
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8001d5c:	4a0a      	ldr	r2, [pc, #40]	; (8001d88 <nvicEnableVector+0x2c>)
 8001d5e:	0109      	lsls	r1, r1, #4
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d60:	ea4f 1c50 	mov.w	ip, r0, lsr #5
 8001d64:	2301      	movs	r3, #1
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8001d66:	b2c9      	uxtb	r1, r1
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001d68:	b500      	push	{lr}
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d6a:	f000 0e1f 	and.w	lr, r0, #31
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8001d6e:	4410      	add	r0, r2
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d70:	fa03 f30e 	lsl.w	r3, r3, lr
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8001d74:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d78:	eb02 018c 	add.w	r1, r2, ip, lsl #2
 8001d7c:	f8c1 3180 	str.w	r3, [r1, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001d80:	f842 302c 	str.w	r3, [r2, ip, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8001d84:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d88:	e000e100 	.word	0xe000e100

08001d8c <nvicDisableVector>:
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8001d8c:	f000 0c1f 	and.w	ip, r0, #31
 8001d90:	2201      	movs	r2, #1
 8001d92:	4b08      	ldr	r3, [pc, #32]	; (8001db4 <nvicDisableVector+0x28>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = 0U;
 8001d94:	2100      	movs	r1, #0
  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8001d96:	fa02 f20c 	lsl.w	r2, r2, ip
 8001d9a:	ea4f 1c50 	mov.w	ip, r0, lsr #5
  NVIC->__IPR[n] = 0U;
 8001d9e:	4418      	add	r0, r3
 8001da0:	eb03 038c 	add.w	r3, r3, ip, lsl #2
  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8001da4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001da8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->__IPR[n] = 0U;
 8001dac:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
#endif
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* Marked as not secure again.*/
  NVIC->__ITNS[n >> 5U] |= 1U << (n & 0x1FU);
#endif
}
 8001db0:	4770      	bx	lr
 8001db2:	bf00      	nop
 8001db4:	e000e100 	.word	0xe000e100

08001db8 <Vector104>:
/**
 * @brief   SDMMC1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
 8001db8:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8001dba:	4c07      	ldr	r4, [pc, #28]	; (8001dd8 <Vector104+0x20>)
 8001dbc:	4620      	mov	r0, r4
 8001dbe:	f003 ffcd 	bl	8005d5c <__trace_isr_enter>

#if HAL_USE_SDC
#if STM32_SDC_USE_SDMMC1
  sdc_lld_serve_interrupt(&SDCD1);
 8001dc2:	4806      	ldr	r0, [pc, #24]	; (8001ddc <Vector104+0x24>)
 8001dc4:	f002 fdcc 	bl	8004960 <sdc_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001dc8:	4620      	mov	r0, r4
 8001dca:	f003 ffdf 	bl	8005d8c <__trace_isr_leave>
}
 8001dce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001dd2:	f004 bf53 	b.w	8006c7c <__port_irq_epilogue>
 8001dd6:	bf00      	nop
 8001dd8:	08014adc 	.word	0x08014adc
 8001ddc:	240009c4 	.word	0x240009c4

08001de0 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8001de0:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8001de2:	4c07      	ldr	r4, [pc, #28]	; (8001e00 <VectorDC+0x20>)
 8001de4:	4620      	mov	r0, r4
 8001de6:	f003 ffb9 	bl	8005d5c <__trace_isr_enter>

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART3
  sd_lld_serve_interrupt(&SD3);
 8001dea:	4806      	ldr	r0, [pc, #24]	; (8001e04 <VectorDC+0x24>)
 8001dec:	f003 fd6c 	bl	80058c8 <sd_lld_serve_interrupt>
#if STM32_UART_USE_USART3
  uart_lld_serve_interrupt(&UARTD3);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001df0:	4620      	mov	r0, r4
 8001df2:	f003 ffcb 	bl	8005d8c <__trace_isr_leave>
}
 8001df6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001dfa:	f004 bf3f 	b.w	8006c7c <__port_irq_epilogue>
 8001dfe:	bf00      	nop
 8001e00:	08014ad0 	.word	0x08014ad0
 8001e04:	24000b9c 	.word	0x24000b9c

08001e08 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8001e08:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e0a:	4806      	ldr	r0, [pc, #24]	; (8001e24 <VectorB0+0x1c>)
 8001e0c:	f003 ffa6 	bl	8005d5c <__trace_isr_enter>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8001e10:	f003 fc4e 	bl	80056b0 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001e14:	4803      	ldr	r0, [pc, #12]	; (8001e24 <VectorB0+0x1c>)
 8001e16:	f003 ffb9 	bl	8005d8c <__trace_isr_leave>
}
 8001e1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001e1e:	f004 bf2d 	b.w	8006c7c <__port_irq_epilogue>
 8001e22:	bf00      	nop
 8001e24:	08014ac4 	.word	0x08014ac4

08001e28 <VectorEC>:
/**
 * @brief   TIM8-BRK, TIM12 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM8_BRK_TIM12_HANDLER) {
 8001e28:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e2a:	4805      	ldr	r0, [pc, #20]	; (8001e40 <VectorEC+0x18>)
 8001e2c:	f003 ff96 	bl	8005d5c <__trace_isr_enter>
#if STM32_ST_USE_TIM12
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001e30:	4803      	ldr	r0, [pc, #12]	; (8001e40 <VectorEC+0x18>)
 8001e32:	f003 ffab 	bl	8005d8c <__trace_isr_leave>
}
 8001e36:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001e3a:	f004 bf1f 	b.w	8006c7c <__port_irq_epilogue>
 8001e3e:	bf00      	nop
 8001e40:	08014ab8 	.word	0x08014ab8

08001e44 <VectorF0>:
/**
 * @brief   TIM8-UP, TIM13 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM8_UP_TIM13_HANDLER) {
 8001e44:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8001e46:	4c07      	ldr	r4, [pc, #28]	; (8001e64 <VectorF0+0x20>)
 8001e48:	4620      	mov	r0, r4
 8001e4a:	f003 ff87 	bl	8005d5c <__trace_isr_enter>
  icu_lld_serve_interrupt(&ICUD13);
#endif
#endif
#if HAL_USE_PWM
#if STM32_PWM_USE_TIM8
  pwm_lld_serve_interrupt(&PWMD8);
 8001e4e:	4806      	ldr	r0, [pc, #24]	; (8001e68 <VectorF0+0x24>)
 8001e50:	f003 fc54 	bl	80056fc <pwm_lld_serve_interrupt>
#if STM32_ST_USE_TIM13
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001e54:	4620      	mov	r0, r4
 8001e56:	f003 ff99 	bl	8005d8c <__trace_isr_leave>
}
 8001e5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001e5e:	f004 bf0d 	b.w	8006c7c <__port_irq_epilogue>
 8001e62:	bf00      	nop
 8001e64:	08014aac 	.word	0x08014aac
 8001e68:	24000b7c 	.word	0x24000b7c

08001e6c <VectorF4>:
/**
 * @brief   TIM8-TRG-COM, TIM14 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM8_TRGCO_TIM14_HANDLER) {
 8001e6c:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e6e:	4805      	ldr	r0, [pc, #20]	; (8001e84 <VectorF4+0x18>)
 8001e70:	f003 ff74 	bl	8005d5c <__trace_isr_enter>
#if STM32_ST_USE_TIM14
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001e74:	4803      	ldr	r0, [pc, #12]	; (8001e84 <VectorF4+0x18>)
 8001e76:	f003 ff89 	bl	8005d8c <__trace_isr_leave>
}
 8001e7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001e7e:	f004 befd 	b.w	8006c7c <__port_irq_epilogue>
 8001e82:	bf00      	nop
 8001e84:	08014aa0 	.word	0x08014aa0

08001e88 <VectorF8>:
/**
 * @brief   TIM8-CC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM8_CC_HANDLER) {
 8001e88:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8001e8a:	4c07      	ldr	r4, [pc, #28]	; (8001ea8 <VectorF8+0x20>)
 8001e8c:	4620      	mov	r0, r4
 8001e8e:	f003 ff65 	bl	8005d5c <__trace_isr_enter>
  icu_lld_serve_interrupt(&ICUD8);
#endif
#endif
#if HAL_USE_PWM
#if STM32_PWM_USE_TIM8
  pwm_lld_serve_interrupt(&PWMD8);
 8001e92:	4806      	ldr	r0, [pc, #24]	; (8001eac <VectorF8+0x24>)
 8001e94:	f003 fc32 	bl	80056fc <pwm_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001e98:	4620      	mov	r0, r4
 8001e9a:	f003 ff77 	bl	8005d8c <__trace_isr_leave>
}
 8001e9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001ea2:	f004 beeb 	b.w	8006c7c <__port_irq_epilogue>
 8001ea6:	bf00      	nop
 8001ea8:	08014a94 	.word	0x08014a94
 8001eac:	24000b7c 	.word	0x24000b7c

08001eb0 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8001eb0:	b508      	push	{r3, lr}

  fdcan1_irq_init();
  fdcan2_irq_init();
  fdcan3_irq_init();

  mdma_irq_init();
 8001eb2:	2109      	movs	r1, #9
 8001eb4:	207a      	movs	r0, #122	; 0x7a
 8001eb6:	f7ff ff51 	bl	8001d5c <nvicEnableVector>
  nvicEnableVector(STM32_SDMMC1_NUMBER, STM32_IRQ_SDMMC1_PRIORITY);
 8001eba:	2109      	movs	r1, #9
 8001ebc:	2031      	movs	r0, #49	; 0x31
 8001ebe:	f7ff ff4d 	bl	8001d5c <nvicEnableVector>
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8001ec2:	2107      	movs	r1, #7
 8001ec4:	201c      	movs	r0, #28
 8001ec6:	f7ff ff49 	bl	8001d5c <nvicEnableVector>
  nvicEnableVector(STM32_TIM8_BRK_TIM12_NUMBER,
 8001eca:	2107      	movs	r1, #7
 8001ecc:	202b      	movs	r0, #43	; 0x2b
 8001ece:	f7ff ff45 	bl	8001d5c <nvicEnableVector>
  nvicEnableVector(STM32_TIM8_UP_TIM13_NUMBER,
 8001ed2:	2107      	movs	r1, #7
 8001ed4:	202c      	movs	r0, #44	; 0x2c
 8001ed6:	f7ff ff41 	bl	8001d5c <nvicEnableVector>
  nvicEnableVector(STM32_TIM8_TRGCO_TIM14_NUMBER,
 8001eda:	2107      	movs	r1, #7
 8001edc:	202d      	movs	r0, #45	; 0x2d
 8001ede:	f7ff ff3d 	bl	8001d5c <nvicEnableVector>
  nvicEnableVector(STM32_TIM8_CC_NUMBER,
 8001ee2:	2107      	movs	r1, #7
 8001ee4:	202e      	movs	r0, #46	; 0x2e
 8001ee6:	f7ff ff39 	bl	8001d5c <nvicEnableVector>
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
 8001eea:	210c      	movs	r1, #12
 8001eec:	2027      	movs	r0, #39	; 0x27
  uart7_irq_init();
  uart8_irq_init();
  uart9_irq_init();
  usart10_irq_init();
  lpuart1_irq_init();
}
 8001eee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001ef2:	f7ff bf33 	b.w	8001d5c <nvicEnableVector>
 8001ef6:	bf00      	nop

08001ef8 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8001ef8:	b538      	push	{r3, r4, r5, lr}
}

__STATIC_INLINE void __rccResetAHB1(uint32_t mask) {

  /* Resetting the peripherals.*/
  RCC->AHB1RSTR |= mask;
 8001efa:	4b36      	ldr	r3, [pc, #216]	; (8001fd4 <hal_lld_init+0xdc>)

__STATIC_INLINE void __rccResetAHB2(uint32_t mask) {

  /* Resetting the peripherals.*/
  RCC->AHB2RSTR |= mask;
  RCC->AHB2RSTR &= ~mask;
 8001efc:	2200      	movs	r2, #0
  RCC->AHB2RSTR |= mask;
 8001efe:	f04f 31ff 	mov.w	r1, #4294967295
}

__STATIC_INLINE void __rccResetAHB3(uint32_t mask) {

  /* Resetting the peripherals.*/
  RCC->AHB3RSTR |= mask;
 8001f02:	4c35      	ldr	r4, [pc, #212]	; (8001fd8 <hal_lld_init+0xe0>)
  RCC->AHB1RSTR |= mask;
 8001f04:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
  RCC->AHB3RSTR &= ~mask;
 8001f08:	4d34      	ldr	r5, [pc, #208]	; (8001fdc <hal_lld_init+0xe4>)
  RCC->AHB1RSTR |= mask;
 8001f0a:	f060 4000 	orn	r0, r0, #2147483648	; 0x80000000
 8001f0e:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
  RCC->AHB1RSTR &= ~mask;
 8001f12:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 8001f16:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8001f1a:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
  (void)RCC->AHB1RSTR;
 8001f1e:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
  RCC->AHB2RSTR |= mask;
 8001f22:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
 8001f26:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
  RCC->AHB2RSTR &= ~mask;
 8001f2a:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
 8001f2e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  (void)RCC->AHB2RSTR;
 8001f32:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
  RCC->AHB3RSTR |= mask;
 8001f36:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
 8001f38:	4320      	orrs	r0, r4
 8001f3a:	67d8      	str	r0, [r3, #124]	; 0x7c
  RCC->AHB3RSTR &= ~mask;
 8001f3c:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
}

__STATIC_INLINE void __rccResetAHB4(uint32_t mask) {

  /* Resetting the peripherals.*/
  RCC->AHB4RSTR |= mask;
 8001f3e:	4828      	ldr	r0, [pc, #160]	; (8001fe0 <hal_lld_init+0xe8>)
  RCC->AHB3RSTR &= ~mask;
 8001f40:	402c      	ands	r4, r5
 8001f42:	67dc      	str	r4, [r3, #124]	; 0x7c
  (void)RCC->AHB3RSTR;
 8001f44:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
  RCC->AHB4RSTR |= mask;
 8001f46:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
 8001f4a:	4320      	orrs	r0, r4
 8001f4c:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 8001f50:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
 8001f54:	f3c0 000a 	ubfx	r0, r0, #0, #11
 8001f58:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 8001f5c:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
  RCC->APB1LRSTR |= mask;
 8001f60:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
 8001f64:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 8001f68:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
 8001f6c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8001f70:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
  RCC->APB1HRSTR |= mask;
 8001f74:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
 8001f78:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
  RCC->APB1HRSTR &= ~mask;
 8001f7c:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
 8001f80:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  (void)RCC->APB1HRSTR;
 8001f84:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
  RCC->APB2RSTR |= mask;
 8001f88:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
 8001f8c:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8001f90:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
 8001f94:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8001f98:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
  RCC->APB3RSTR |= mask;
 8001f9c:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
 8001fa0:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
  RCC->APB3RSTR &= ~mask;
 8001fa4:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
 8001fa8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  (void)RCC->APB3RSTR;
 8001fac:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
  RCC->APB4RSTR |= mask;
 8001fb0:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
 8001fb4:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
  RCC->APB4RSTR &= ~mask;
 8001fb8:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
 8001fbc:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  (void)RCC->APB4RSTR;
 8001fc0:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
  __rccResetAPB4(~0);
#endif /* STM32_NO_INIT == FALSE */

  /* DMA subsystems initialization.*/
#if defined(STM32_BDMA_REQUIRED)
  bdmaInit();
 8001fc4:	f000 fcd6 	bl	8002974 <bdmaInit>
#endif
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8001fc8:	f000 ff4e 	bl	8002e68 <dmaInit>
       immediately.*/
    SCB_CleanInvalidateDCache();
#endif
  }
#endif
}
 8001fcc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  irqInit();
 8001fd0:	f7ff bf6e 	b.w	8001eb0 <irqInit>
 8001fd4:	58024400 	.word	0x58024400
 8001fd8:	7fffefff 	.word	0x7fffefff
 8001fdc:	80001000 	.word	0x80001000
 8001fe0:	fffff800 	.word	0xfffff800

08001fe4 <stm32_clock_init>:
 */
__STATIC_INLINE void rccEnableAPB4(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->APB4ENR |= mask;
 8001fe4:	4b6f      	ldr	r3, [pc, #444]	; (80021a4 <stm32_clock_init+0x1c0>)
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8001fe6:	2002      	movs	r0, #2
 8001fe8:	4a6f      	ldr	r2, [pc, #444]	; (80021a8 <stm32_clock_init+0x1c4>)
 8001fea:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
 8001fee:	4301      	orrs	r1, r0
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8001ff0:	b410      	push	{r4}
 8001ff2:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
  if (lp) {
    RCC_C1->APB4LPENR |= mask;
 8001ff6:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8001ffa:	4301      	orrs	r1, r0
 8001ffc:	f8c3 111c 	str.w	r1, [r3, #284]	; 0x11c
  }
  else {
    RCC_C1->APB4LPENR &= ~mask;
  }
  (void)RCC_C1->APB4LPENR;
 8002000:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8002004:	60d0      	str	r0, [r2, #12]
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0)
 8002006:	6853      	ldr	r3, [r2, #4]
 8002008:	0498      	lsls	r0, r3, #18
 800200a:	d5fc      	bpl.n	8002006 <stm32_clock_init+0x22>
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 800200c:	4867      	ldr	r0, [pc, #412]	; (80021ac <stm32_clock_init+0x1c8>)
  PWR->CPUCR = STM32_PWR_CPUCR;
 800200e:	2300      	movs	r3, #0
  PWR->CR2   = STM32_PWR_CR2;
 8002010:	2101      	movs	r1, #1
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 8002012:	4c67      	ldr	r4, [pc, #412]	; (80021b0 <stm32_clock_init+0x1cc>)
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 8002014:	6010      	str	r0, [r2, #0]
  PWR->D3CR  = STM32_VOS;
 8002016:	f44f 4040 	mov.w	r0, #49152	; 0xc000
  PWR->CR2   = STM32_PWR_CR2;
 800201a:	6091      	str	r1, [r2, #8]
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 800201c:	60d4      	str	r4, [r2, #12]
  SYSCFG->PWRCR = STM32_ODEN;
 800201e:	4965      	ldr	r1, [pc, #404]	; (80021b4 <stm32_clock_init+0x1d0>)
  PWR->CPUCR = STM32_PWR_CPUCR;
 8002020:	6113      	str	r3, [r2, #16]
  PWR->D3CR  = STM32_VOS;
 8002022:	6190      	str	r0, [r2, #24]
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 8002024:	4a60      	ldr	r2, [pc, #384]	; (80021a8 <stm32_clock_init+0x1c4>)
  SYSCFG->PWRCR = STM32_ODEN;
 8002026:	62cb      	str	r3, [r1, #44]	; 0x2c
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 8002028:	6993      	ldr	r3, [r2, #24]
 800202a:	0499      	lsls	r1, r3, #18
 800202c:	d5fc      	bpl.n	8002028 <stm32_clock_init+0x44>
  PWR->CR1 |= PWR_CR1_DBP;
 800202e:	6813      	ldr	r3, [r2, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8002030:	495c      	ldr	r1, [pc, #368]	; (80021a4 <stm32_clock_init+0x1c0>)
  PWR->CR1 |= PWR_CR1_DBP;
 8002032:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002036:	6013      	str	r3, [r2, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8002038:	6f0b      	ldr	r3, [r1, #112]	; 0x70
 800203a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800203e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002042:	d004      	beq.n	800204e <stm32_clock_init+0x6a>
    RCC->BDCR = RCC_BDCR_BDRST;
 8002044:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    RCC->BDCR = 0;
 8002048:	2300      	movs	r3, #0
    RCC->BDCR = RCC_BDCR_BDRST;
 800204a:	670a      	str	r2, [r1, #112]	; 0x70
    RCC->BDCR = 0;
 800204c:	670b      	str	r3, [r1, #112]	; 0x70
  /* Backup domain initialization.*/
  init_bkp_domain();

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800204e:	4955      	ldr	r1, [pc, #340]	; (80021a4 <stm32_clock_init+0x1c0>)
 8002050:	680b      	ldr	r3, [r1, #0]
 8002052:	f043 0301 	orr.w	r3, r3, #1
 8002056:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8002058:	680b      	ldr	r3, [r1, #0]
 800205a:	075b      	lsls	r3, r3, #29
 800205c:	d5fc      	bpl.n	8002058 <stm32_clock_init+0x74>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. This is only required when using a debugger than can cause
     restarts.*/
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 800205e:	2300      	movs	r3, #0
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002060:	4a50      	ldr	r2, [pc, #320]	; (80021a4 <stm32_clock_init+0x1c0>)
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 8002062:	610b      	str	r3, [r1, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002064:	6913      	ldr	r3, [r2, #16]
 8002066:	f013 0338 	ands.w	r3, r3, #56	; 0x38
 800206a:	d1fb      	bne.n	8002064 <stm32_clock_init+0x80>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers cleared to reset values.*/
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 800206c:	2001      	movs	r0, #1
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 800206e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
#if !defined(STM32_ENFORCE_H7_REV_XY)
  RCC->CSICFGR = 0x20000000U;              /* CSICFGR Reset value.         */
 8002072:	f04f 5400 	mov.w	r4, #536870912	; 0x20000000
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 8002076:	6010      	str	r0, [r2, #0]
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 8002078:	6051      	str	r1, [r2, #4]
#endif
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 800207a:	484f      	ldr	r0, [pc, #316]	; (80021b8 <stm32_clock_init+0x1d4>)
  cfgr |= STM32_HRTIMSEL;
#endif
#if STM32_TIMPRE_ENABLE == TRUE
  cfgr |= RCC_CFGR_TIMPRE;
#endif
  RCC->CFGR = cfgr;
 800207c:	494f      	ldr	r1, [pc, #316]	; (80021bc <stm32_clock_init+0x1d8>)
  RCC->CSICFGR = 0x20000000U;              /* CSICFGR Reset value.         */
 800207e:	60d4      	str	r4, [r2, #12]
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
 8002080:	6753      	str	r3, [r2, #116]	; 0x74
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 8002082:	62d0      	str	r0, [r2, #44]	; 0x2c
  RCC->CFGR = cfgr;
 8002084:	6111      	str	r1, [r2, #16]

  /* HSE activation with optional bypass.*/
#if STM32_HSE_ENABLED == TRUE
#if defined(STM32_HSE_BYPASS)
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8002086:	6813      	ldr	r3, [r2, #0]
#else
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8002088:	4846      	ldr	r0, [pc, #280]	; (80021a4 <stm32_clock_init+0x1c0>)
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 800208a:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 800208e:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8002090:	6803      	ldr	r3, [r0, #0]
 8002092:	039c      	lsls	r4, r3, #14
 8002094:	d5fc      	bpl.n	8002090 <stm32_clock_init+0xac>
    ;                           /* Waits until HSE is stable.               */
#endif /* STM32_HSE_ENABLED == TRUE */

  /* HSI48 activation.*/
#if STM32_HSI48_ENABLED == TRUE
  RCC->CR |= RCC_CR_HSI48ON;
 8002096:	6803      	ldr	r3, [r0, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 8002098:	4942      	ldr	r1, [pc, #264]	; (80021a4 <stm32_clock_init+0x1c0>)
  RCC->CR |= RCC_CR_HSI48ON;
 800209a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800209e:	6003      	str	r3, [r0, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 80020a0:	680b      	ldr	r3, [r1, #0]
 80020a2:	0498      	lsls	r0, r3, #18
 80020a4:	d5fc      	bpl.n	80020a0 <stm32_clock_init+0xbc>

#endif /* STM32_HSI48_ENABLED == TRUE */

  /* CSI activation.*/
#if STM32_CSI_ENABLED == TRUE
  RCC->CR |= RCC_CR_CSION;
 80020a6:	680b      	ldr	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_CSIRDY) == 0)
 80020a8:	4a3e      	ldr	r2, [pc, #248]	; (80021a4 <stm32_clock_init+0x1c0>)
  RCC->CR |= RCC_CR_CSION;
 80020aa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80020ae:	600b      	str	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_CSIRDY) == 0)
 80020b0:	6813      	ldr	r3, [r2, #0]
 80020b2:	05d9      	lsls	r1, r3, #23
 80020b4:	d5fc      	bpl.n	80020b0 <stm32_clock_init+0xcc>
    ;                           /* Waits until CSI is stable.               */
#endif /* STM32_CSI_ENABLED == TRUE */

  /* LSI activation.*/
#if STM32_LSI_ENABLED == TRUE
  RCC->CSR |= RCC_CSR_LSION;
 80020b6:	6f51      	ldr	r1, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80020b8:	4b3a      	ldr	r3, [pc, #232]	; (80021a4 <stm32_clock_init+0x1c0>)
  RCC->CSR |= RCC_CSR_LSION;
 80020ba:	f041 0101 	orr.w	r1, r1, #1
 80020be:	6751      	str	r1, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80020c0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80020c2:	0792      	lsls	r2, r2, #30
 80020c4:	d5fc      	bpl.n	80020c0 <stm32_clock_init+0xdc>
    cfgmask = STM32_PLLCFGR_PLL3RGE | STM32_PLLCFGR_PLL3VCOSEL | RCC_PLLCFGR_PLL3FRACEN |
              STM32_PLLCFGR_PLL2RGE | STM32_PLLCFGR_PLL2VCOSEL | RCC_PLLCFGR_PLL2FRACEN |
              STM32_PLLCFGR_PLL1RGE | STM32_PLLCFGR_PLL1VCOSEL | RCC_PLLCFGR_PLL1FRACEN;

#if STM32_PLL1_ENABLED == TRUE
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
 80020c6:	2200      	movs	r2, #0
    RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM3_VALUE(STM32_PLL3_DIVM_VALUE) |
 80020c8:	483d      	ldr	r0, [pc, #244]	; (80021c0 <stm32_clock_init+0x1dc>)
    RCC->PLL1DIVR  = STM32_PLL1_DIVR | STM32_PLL1_DIVQ |
 80020ca:	493e      	ldr	r1, [pc, #248]	; (80021c4 <stm32_clock_init+0x1e0>)
    RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM3_VALUE(STM32_PLL3_DIVM_VALUE) |
 80020cc:	6298      	str	r0, [r3, #40]	; 0x28
    cfgmask |= RCC_PLLCFGR_DIVR2EN;
#endif
#endif /* STM32_PLL2_ENABLED == TRUE */

#if STM32_PLL3_ENABLED == TRUE
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
 80020ce:	f242 60e8 	movw	r0, #9960	; 0x26e8
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
 80020d2:	635a      	str	r2, [r3, #52]	; 0x34
    RCC->PLL1DIVR  = STM32_PLL1_DIVR | STM32_PLL1_DIVQ |
 80020d4:	6319      	str	r1, [r3, #48]	; 0x30
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 80020d6:	f5a1 317f 	sub.w	r1, r1, #261120	; 0x3fc00
    RCC->PLL2FRACR = STM32_PLL2_FRACN;
 80020da:	63da      	str	r2, [r3, #60]	; 0x3c
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 80020dc:	392f      	subs	r1, #47	; 0x2f
    cfgmask |= RCC_PLLCFGR_DIVR3EN;
#endif
#endif /* STM32_PLL3_ENABLED == TRUE */

    /* Activating enabled PLLs and waiting for all of them to become ready.*/
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 80020de:	4a3a      	ldr	r2, [pc, #232]	; (80021c8 <stm32_clock_init+0x1e4>)
    RCC->PLL2DIVR  = STM32_PLL2_DIVR | STM32_PLL2_DIVQ |
 80020e0:	4c3a      	ldr	r4, [pc, #232]	; (80021cc <stm32_clock_init+0x1e8>)
 80020e2:	639c      	str	r4, [r3, #56]	; 0x38
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
 80020e4:	6458      	str	r0, [r3, #68]	; 0x44
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 80020e6:	6419      	str	r1, [r3, #64]	; 0x40
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 80020e8:	62da      	str	r2, [r3, #44]	; 0x2c
    RCC->CR     |= onmask;
 80020ea:	6819      	ldr	r1, [r3, #0]
    while ((RCC->CR & rdymask) != rdymask)
 80020ec:	4a2d      	ldr	r2, [pc, #180]	; (80021a4 <stm32_clock_init+0x1c0>)
    RCC->CR     |= onmask;
 80020ee:	f041 51a8 	orr.w	r1, r1, #352321536	; 0x15000000
 80020f2:	6019      	str	r1, [r3, #0]
    while ((RCC->CR & rdymask) != rdymask)
 80020f4:	6813      	ldr	r3, [r2, #0]
 80020f6:	f003 5328 	and.w	r3, r3, #704643072	; 0x2a000000
 80020fa:	f1b3 5f28 	cmp.w	r3, #704643072	; 0x2a000000
 80020fe:	d1f9      	bne.n	80020f4 <stm32_clock_init+0x110>
#if defined(HAL_LLD_TYPE3_H)
  RCC->CDCFGR1 = STM32_CDCPRE  | STM32_CDPPRE | STM32_CDHPRE;
  RCC->CDCFGR2 = STM32_CDPPRE2 | STM32_CDPPRE1;
  RCC->SRDCFGR = STM32_SRDPPRE;
#else
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 8002100:	2448      	movs	r4, #72	; 0x48
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 8002102:	f44f 6388 	mov.w	r3, #1088	; 0x440
  RCC->D3CFGR = STM32_D3PPRE4;
 8002106:	2040      	movs	r0, #64	; 0x40
#endif

  /* Peripherals clocks.*/
#if defined(HAL_LLD_TYPE1_H)
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_QSPISEL       |
 8002108:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 800210c:	6194      	str	r4, [r2, #24]
                  STM32_FMCSEL;
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 800210e:	2482      	movs	r4, #130	; 0x82
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 8002110:	61d3      	str	r3, [r2, #28]
                  STM32_SPDIFSEL   | STM32_SPDIFSEL    | STM32_SPI45SEL      |
                  STM32_SPI123SEL  | STM32_SAI23SEL    | STM32_SAI1SEL;
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8002112:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  RCC->D3CFGR = STM32_D3PPRE4;
 8002116:	6210      	str	r0, [r2, #32]
                  STM32_I2C123SEL  | STM32_RNGSEL      | STM32_USART16SEL    |
                  STM32_USART234578SEL;
  RCC->D3CCIPR  = STM32_SPI6SEL    | STM32_SAI4BSEL    | STM32_SAI4ASEL      |
 8002118:	f04f 7010 	mov.w	r0, #37748736	; 0x2400000
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_QSPISEL       |
 800211c:	64d1      	str	r1, [r2, #76]	; 0x4c
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 800211e:	6514      	str	r4, [r2, #80]	; 0x50
                  STM32_LPTIM3SEL  | STM32_LPTIM2SEL   | STM32_I2C4SEL       |
                  STM32_LPUART1SEL;
#endif

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8002120:	492b      	ldr	r1, [pc, #172]	; (80021d0 <stm32_clock_init+0x1ec>)
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8002122:	6553      	str	r3, [r2, #84]	; 0x54
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8002124:	2331      	movs	r3, #49	; 0x31
  RCC->D3CCIPR  = STM32_SPI6SEL    | STM32_SAI4BSEL    | STM32_SAI4ASEL      |
 8002126:	6590      	str	r0, [r2, #88]	; 0x58
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8002128:	600b      	str	r3, [r1, #0]
               STM32_FLASHBITS;
  while ((FLASH->ACR & FLASH_ACR_LATENCY) !=
 800212a:	680b      	ldr	r3, [r1, #0]
 800212c:	f003 030f 	and.w	r3, r3, #15
 8002130:	2b01      	cmp	r3, #1
 8002132:	d1fa      	bne.n	800212a <stm32_clock_init+0x146>
  }

  /* Switching to the configured clock source if it is different
     from HSI.*/
#if STM32_SW != STM32_SW_HSI_CK
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8002134:	4a1b      	ldr	r2, [pc, #108]	; (80021a4 <stm32_clock_init+0x1c0>)
 8002136:	6913      	ldr	r3, [r2, #16]
 8002138:	f043 0303 	orr.w	r3, r3, #3
 800213c:	6113      	str	r3, [r2, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != (STM32_SW << RCC_CFGR_SWS_Pos))
 800213e:	6913      	ldr	r3, [r2, #16]
 8002140:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8002144:	2b18      	cmp	r3, #24
 8002146:	d1fa      	bne.n	800213e <stm32_clock_init+0x15a>
 */
__STATIC_INLINE void rccEnableAHB2(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB2ENR |= mask;
 8002148:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
  rccEnableSRAM2(true);
#if !(defined(HAL_LLD_TYPE2_H) || defined(HAL_LLD_TYPE3_H))
  rccEnableSRAM3(true);
#endif
#endif /* STM32_NO_INIT */
}
 800214c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002150:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002154:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
  if (lp) {
    RCC_C1->AHB2LPENR |= mask;
 8002158:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 800215c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002160:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
  }
  else {
    RCC_C1->AHB2LPENR &= ~mask;
  }
  (void)RCC_C1->AHB2LPENR;
 8002164:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
  RCC_C1->AHB2ENR |= mask;
 8002168:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
 800216c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8002170:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
    RCC_C1->AHB2LPENR |= mask;
 8002174:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8002178:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800217c:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
  (void)RCC_C1->AHB2LPENR;
 8002180:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
  RCC_C1->AHB2ENR |= mask;
 8002184:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
 8002188:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800218c:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
    RCC_C1->AHB2LPENR |= mask;
 8002190:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8002194:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002198:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
  (void)RCC_C1->AHB2LPENR;
 800219c:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 80021a0:	4770      	bx	lr
 80021a2:	bf00      	nop
 80021a4:	58024400 	.word	0x58024400
 80021a8:	58024800 	.word	0x58024800
 80021ac:	f000c000 	.word	0xf000c000
 80021b0:	01000002 	.word	0x01000002
 80021b4:	58000400 	.word	0x58000400
 80021b8:	01ff0000 	.word	0x01ff0000
 80021bc:	08108800 	.word	0x08108800
 80021c0:	00202022 	.word	0x00202022
 80021c4:	0307025f 	.word	0x0307025f
 80021c8:	01ff0b9b 	.word	0x01ff0b9b
 80021cc:	03031e8f 	.word	0x03031e8f
 80021d0:	52002000 	.word	0x52002000

080021d4 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 80021d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#if STM32_ADC_USE_ADC12 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80021d6:	4c3c      	ldr	r4, [pc, #240]	; (80022c8 <adc_lld_init+0xf4>)
  ADCD1.adcc        = ADC12_COMMON;
  ADCD1.adcm        = ADC1;
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs        = ADC2;
#endif
  ADCD1.data.dma    = NULL;
 80021d8:	2500      	movs	r5, #0
  ADCD1.adcc        = ADC12_COMMON;
 80021da:	4e3c      	ldr	r6, [pc, #240]	; (80022cc <adc_lld_init+0xf8>)
  adcObjectInit(&ADCD1);
 80021dc:	4620      	mov	r0, r4
  ADCD1.dmamode     = ADC12_DMA_SIZE |
 80021de:	4f3c      	ldr	r7, [pc, #240]	; (80022d0 <adc_lld_init+0xfc>)
  adcObjectInit(&ADCD1);
 80021e0:	f7fe fefe 	bl	8000fe0 <adcObjectInit>
  ADCD1.adcm        = ADC1;
 80021e4:	4b3b      	ldr	r3, [pc, #236]	; (80022d4 <adc_lld_init+0x100>)
  ADCD1.dmamode     = ADC12_DMA_SIZE |
 80021e6:	6367      	str	r7, [r4, #52]	; 0x34
                      STM32_DMA_CR_PL(STM32_ADC_ADC12_DMA_PRIORITY) |
                      STM32_DMA_CR_DIR_P2M  |
                      STM32_DMA_CR_MINC     | STM32_DMA_CR_TCIE     |
                      STM32_DMA_CR_DMEIE    | STM32_DMA_CR_TEIE;
  nvicEnableVector(STM32_ADC12_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 80021e8:	2105      	movs	r1, #5
  ADCD1.adcm        = ADC1;
 80021ea:	62a3      	str	r3, [r4, #40]	; 0x28
  nvicEnableVector(STM32_ADC12_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 80021ec:	2012      	movs	r0, #18
  ADCD1.data.dma    = NULL;
 80021ee:	e9c4 650b 	strd	r6, r5, [r4, #44]	; 0x2c
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
 80021f2:	4c39      	ldr	r4, [pc, #228]	; (80022d8 <adc_lld_init+0x104>)
  nvicEnableVector(STM32_ADC12_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 80021f4:	f7ff fdb2 	bl	8001d5c <nvicEnableVector>
  adcObjectInit(&ADCD3);
 80021f8:	4620      	mov	r0, r4
 80021fa:	f7fe fef1 	bl	8000fe0 <adcObjectInit>
  ADCD3.adcc        = ADC3_COMMON;
  ADCD3.adcm        = ADC3;
 80021fe:	4b37      	ldr	r3, [pc, #220]	; (80022dc <adc_lld_init+0x108>)
                      STM32_BDMA_CR_DIR_P2M  |
                      STM32_BDMA_CR_MINC     | STM32_BDMA_CR_TCIE     |
                                               STM32_BDMA_CR_TEIE;
  nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
#else
  ADCD3.data.dma    = NULL;
 8002200:	6325      	str	r5, [r4, #48]	; 0x30
  ADCD3.dmamode     = ADC3_DMA_SIZE |
                      STM32_DMA_CR_PL(STM32_ADC_ADC3_DMA_PRIORITY) |
                      STM32_DMA_CR_DIR_P2M  |
                      STM32_DMA_CR_MINC     | STM32_DMA_CR_TCIE     |
                      STM32_DMA_CR_DMEIE    | STM32_DMA_CR_TEIE;
  nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
 8002202:	2105      	movs	r1, #5
  ADCD3.adcc        = ADC3_COMMON;
 8002204:	4d36      	ldr	r5, [pc, #216]	; (80022e0 <adc_lld_init+0x10c>)
  nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
 8002206:	207f      	movs	r0, #127	; 0x7f
  ADCD3.dmamode     = ADC3_DMA_SIZE |
 8002208:	6367      	str	r7, [r4, #52]	; 0x34
  ADCD3.adcm        = ADC3;
 800220a:	e9c4 350a 	strd	r3, r5, [r4, #40]	; 0x28
  nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
 800220e:	f7ff fda5 	bl	8001d5c <nvicEnableVector>
  RCC_C1->AHB1ENR |= mask;
 8002212:	4b34      	ldr	r3, [pc, #208]	; (80022e4 <adc_lld_init+0x110>)
  /* ADC units pre-initializations.*/
#if (STM32_HAS_ADC1 == TRUE) && (STM32_HAS_ADC2 == TRUE)
#if STM32_ADC_USE_ADC12 == TRUE
  rccEnableADC12(true);
  rccResetADC12();
  ADC12_COMMON->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_DAMDF;
 8002214:	f44f 3140 	mov.w	r1, #196608	; 0x30000
 8002218:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 800221c:	f042 0220 	orr.w	r2, r2, #32
 8002220:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 8002224:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 8002228:	f042 0220 	orr.w	r2, r2, #32
 800222c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8002230:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  RCC->AHB1RSTR |= mask;
 8002234:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8002238:	f042 0220 	orr.w	r2, r2, #32
 800223c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  RCC->AHB1RSTR &= ~mask;
 8002240:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8002244:	f022 0220 	bic.w	r2, r2, #32
 8002248:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  (void)RCC->AHB1RSTR;
 800224c:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8002250:	60b1      	str	r1, [r6, #8]
  RCC_C1->AHB1ENR &= ~mask;
 8002252:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 8002256:	f022 0220 	bic.w	r2, r2, #32
 800225a:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 800225e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 8002262:	f022 0220 	bic.w	r2, r2, #32
 8002266:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 800226a:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 */
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB4ENR |= mask;
 800226e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8002272:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002276:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  if (lp) {
    RCC_C1->AHB4LPENR |= mask;
 800227a:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 800227e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002282:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
  else {
    RCC_C1->AHB4LPENR &= ~mask;
  }
  (void)RCC_C1->AHB4LPENR;
 8002286:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  RCC->AHB4RSTR |= mask;
 800228a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800228e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002292:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 8002296:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800229a:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800229e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 80022a2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  rccDisableADC12();
#endif
#if STM32_ADC_USE_ADC3 == TRUE
  rccEnableADC3(true);
  rccResetADC3();
  ADC3_COMMON->CCR = STM32_ADC_ADC3_CLOCK_MODE;
 80022a6:	60a9      	str	r1, [r5, #8]
     allocation.*/
  osalDbgAssert((RCC_C1->AHB4ENR & mask) == mask, "peripherals not allocated");
#endif

  /* Disabling the peripherals.*/
  RCC_C1->AHB4ENR &= ~mask;
 80022a8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80022ac:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80022b0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  RCC_C1->AHB4LPENR &= ~mask;
 80022b4:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 80022b8:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80022bc:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 80022c0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  rccDisableADC3();
#endif
#endif
}
 80022c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80022c6:	bf00      	nop
 80022c8:	24000700 	.word	0x24000700
 80022cc:	40022300 	.word	0x40022300
 80022d0:	00022c16 	.word	0x00022c16
 80022d4:	40022000 	.word	0x40022000
 80022d8:	24000738 	.word	0x24000738
 80022dc:	58026000 	.word	0x58026000
 80022e0:	58026300 	.word	0x58026300
 80022e4:	58024400 	.word	0x58024400

080022e8 <adc_lld_start>:
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @return              The operation status.
 *
 * @notapi
 */
msg_t adc_lld_start(ADCDriver *adcp) {
 80022e8:	b538      	push	{r3, r4, r5, lr}

  /* Handling the default configuration.*/
  if (adcp->config == NULL) {
 80022ea:	6843      	ldr	r3, [r0, #4]
msg_t adc_lld_start(ADCDriver *adcp) {
 80022ec:	4604      	mov	r4, r0
  if (adcp->config == NULL) {
 80022ee:	2b00      	cmp	r3, #0
 80022f0:	d038      	beq.n	8002364 <adc_lld_start+0x7c>
    adcp->config = &default_config;
  }

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 80022f2:	7823      	ldrb	r3, [r4, #0]
 80022f4:	2b01      	cmp	r3, #1
 80022f6:	d001      	beq.n	80022fc <adc_lld_start+0x14>

    /* Master ADC enabled here in order to reduce conversions latencies.*/
    adc_lld_analog_on(adcp);
  }

  return HAL_RET_SUCCESS;
 80022f8:	2000      	movs	r0, #0
}
 80022fa:	bd38      	pop	{r3, r4, r5, pc}
    if (&ADCD1 == adcp) {
 80022fc:	4d43      	ldr	r5, [pc, #268]	; (800240c <adc_lld_start+0x124>)
 80022fe:	42ac      	cmp	r4, r5
 8002300:	d067      	beq.n	80023d2 <adc_lld_start+0xea>
    if (&ADCD3 == adcp) {
 8002302:	4b43      	ldr	r3, [pc, #268]	; (8002410 <adc_lld_start+0x128>)
 8002304:	429c      	cmp	r4, r3
 8002306:	d030      	beq.n	800236a <adc_lld_start+0x82>
  adcp->adcm->CR = ADC_CR_ADVREGEN;
 8002308:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800230a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  chSysPolledDelayX(cycles);
 800230e:	f44f 60f0 	mov.w	r0, #1920	; 0x780
 8002312:	609a      	str	r2, [r3, #8]
 8002314:	f003 fcb2 	bl	8005c7c <chSysPolledDelayX>
    adc_lld_calibrate(adcp);
 8002318:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  adcp->adcm->CR &= ~(ADC_CR_ADCALDIF | ADC_CR_ADCALLIN);
 800231a:	6863      	ldr	r3, [r4, #4]
 800231c:	6891      	ldr	r1, [r2, #8]
  adcp->adcm->CR |= adcp->config->calibration & (ADC_CR_ADCALDIF |
 800231e:	6858      	ldr	r0, [r3, #4]
  adcp->adcm->CR &= ~(ADC_CR_ADCALDIF | ADC_CR_ADCALLIN);
 8002320:	4b3c      	ldr	r3, [pc, #240]	; (8002414 <adc_lld_start+0x12c>)
 8002322:	400b      	ands	r3, r1
 8002324:	6093      	str	r3, [r2, #8]
  adcp->adcm->CR |= adcp->config->calibration & (ADC_CR_ADCALDIF |
 8002326:	4b3c      	ldr	r3, [pc, #240]	; (8002418 <adc_lld_start+0x130>)
 8002328:	6891      	ldr	r1, [r2, #8]
 800232a:	4003      	ands	r3, r0
 800232c:	430b      	orrs	r3, r1
 800232e:	6093      	str	r3, [r2, #8]
  adcp->adcm->CR |= ADC_CR_ADCAL;
 8002330:	6893      	ldr	r3, [r2, #8]
 8002332:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002336:	6093      	str	r3, [r2, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0U)
 8002338:	6893      	ldr	r3, [r2, #8]
 800233a:	2b00      	cmp	r3, #0
 800233c:	dbfc      	blt.n	8002338 <adc_lld_start+0x50>
    if (&ADCD1 == adcp) {
 800233e:	42ac      	cmp	r4, r5
 8002340:	d00c      	beq.n	800235c <adc_lld_start+0x74>
    if (&ADCD3 == adcp) {
 8002342:	4b33      	ldr	r3, [pc, #204]	; (8002410 <adc_lld_start+0x128>)
 8002344:	429c      	cmp	r4, r3
 8002346:	d009      	beq.n	800235c <adc_lld_start+0x74>
  adcp->adcm->ISR = ADC_ISR_ADRDY;
 8002348:	2301      	movs	r3, #1
 800234a:	6013      	str	r3, [r2, #0]
  adcp->adcm->CR |= ADC_CR_ADEN;
 800234c:	6893      	ldr	r3, [r2, #8]
 800234e:	f043 0301 	orr.w	r3, r3, #1
 8002352:	6093      	str	r3, [r2, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRDY) == 0U)
 8002354:	6813      	ldr	r3, [r2, #0]
 8002356:	07db      	lsls	r3, r3, #31
 8002358:	d5fc      	bpl.n	8002354 <adc_lld_start+0x6c>
 800235a:	e7cd      	b.n	80022f8 <adc_lld_start+0x10>
      adcp->adcm->CR |= STM32_ADC3_BOOST;
 800235c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800235e:	6899      	ldr	r1, [r3, #8]
 8002360:	6099      	str	r1, [r3, #8]
 8002362:	e7f1      	b.n	8002348 <adc_lld_start+0x60>
    adcp->config = &default_config;
 8002364:	4b2d      	ldr	r3, [pc, #180]	; (800241c <adc_lld_start+0x134>)
 8002366:	6043      	str	r3, [r0, #4]
 8002368:	e7c3      	b.n	80022f2 <adc_lld_start+0xa>
      adcp->data.dma = dmaStreamAllocI(STM32_ADC_ADC3_DMA_STREAM,
 800236a:	4623      	mov	r3, r4
 800236c:	4a2c      	ldr	r2, [pc, #176]	; (8002420 <adc_lld_start+0x138>)
 800236e:	2105      	movs	r1, #5
 8002370:	2010      	movs	r0, #16
 8002372:	f000 fd9f 	bl	8002eb4 <dmaStreamAllocI>
 8002376:	6320      	str	r0, [r4, #48]	; 0x30
      if (adcp->data.dma == NULL) {
 8002378:	2800      	cmp	r0, #0
 800237a:	d043      	beq.n	8002404 <adc_lld_start+0x11c>
  RCC_C1->AHB4ENR |= mask;
 800237c:	4b29      	ldr	r3, [pc, #164]	; (8002424 <adc_lld_start+0x13c>)
      dmaSetRequestSource(adcp->data.dma, STM32_DMAMUX1_ADC3);
 800237e:	2173      	movs	r1, #115	; 0x73
 8002380:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8002384:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002388:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    RCC_C1->AHB4LPENR |= mask;
 800238c:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 8002390:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002394:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 8002398:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  RCC->AHB4RSTR |= mask;
 800239c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80023a0:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80023a4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 80023a8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80023ac:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80023b0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 80023b4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80023b8:	f000 fe48 	bl	800304c <dmaSetRequestSource>
      dmaStreamSetPeripheral(adcp->data.dma, &adcp->adcm->DR);
 80023bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80023be:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80023c0:	f103 0140 	add.w	r1, r3, #64	; 0x40
 80023c4:	6812      	ldr	r2, [r2, #0]
 80023c6:	6091      	str	r1, [r2, #8]
      adcp->adcm->DIFSEL = adcp->config->difsel;
 80023c8:	6862      	ldr	r2, [r4, #4]
 80023ca:	6812      	ldr	r2, [r2, #0]
 80023cc:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 80023d0:	e79a      	b.n	8002308 <adc_lld_start+0x20>
      adcp->data.dma = dmaStreamAllocI(STM32_ADC_ADC12_DMA_STREAM,
 80023d2:	4623      	mov	r3, r4
 80023d4:	4a12      	ldr	r2, [pc, #72]	; (8002420 <adc_lld_start+0x138>)
 80023d6:	2105      	movs	r1, #5
 80023d8:	2010      	movs	r0, #16
 80023da:	f000 fd6b 	bl	8002eb4 <dmaStreamAllocI>
 80023de:	6320      	str	r0, [r4, #48]	; 0x30
      if (adcp->data.dma == NULL) {
 80023e0:	b180      	cbz	r0, 8002404 <adc_lld_start+0x11c>
  RCC_C1->AHB1ENR |= mask;
 80023e2:	4b10      	ldr	r3, [pc, #64]	; (8002424 <adc_lld_start+0x13c>)
      dmaSetRequestSource(adcp->data.dma, STM32_DMAMUX1_ADC1);
 80023e4:	2109      	movs	r1, #9
 80023e6:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 80023ea:	f042 0220 	orr.w	r2, r2, #32
 80023ee:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 80023f2:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 80023f6:	f042 0220 	orr.w	r2, r2, #32
 80023fa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 80023fe:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8002402:	e7d9      	b.n	80023b8 <adc_lld_start+0xd0>
        return HAL_RET_NO_RESOURCE;
 8002404:	f06f 0010 	mvn.w	r0, #16
}
 8002408:	bd38      	pop	{r3, r4, r5, pc}
 800240a:	bf00      	nop
 800240c:	24000700 	.word	0x24000700
 8002410:	24000738 	.word	0x24000738
 8002414:	bffeffff 	.word	0xbffeffff
 8002418:	40010000 	.word	0x40010000
 800241c:	08014b00 	.word	0x08014b00
 8002420:	080026e9 	.word	0x080026e9
 8002424:	58024400 	.word	0x58024400

08002428 <adc_lld_stop>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop(ADCDriver *adcp) {
 8002428:	b538      	push	{r3, r4, r5, lr}

  /* If in ready state then disables the ADC clock and analog part.*/
  if (adcp->state == ADC_READY) {
 800242a:	7803      	ldrb	r3, [r0, #0]
 800242c:	2b02      	cmp	r3, #2
 800242e:	d000      	beq.n	8002432 <adc_lld_stop+0xa>
    rccDisableADC3();
  }
#endif /* STM32_ADC_ADC3_USE_BDMA */
#endif
  }
}
 8002430:	bd38      	pop	{r3, r4, r5, pc}
    adc_lld_stop_adc(adcp);
 8002432:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8002434:	4605      	mov	r5, r0
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8002436:	6893      	ldr	r3, [r2, #8]
 8002438:	0759      	lsls	r1, r3, #29
 800243a:	d506      	bpl.n	800244a <adc_lld_stop+0x22>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 800243c:	6893      	ldr	r3, [r2, #8]
 800243e:	f043 0310 	orr.w	r3, r3, #16
 8002442:	6093      	str	r3, [r2, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8002444:	6893      	ldr	r3, [r2, #8]
 8002446:	06db      	lsls	r3, r3, #27
 8002448:	d4fc      	bmi.n	8002444 <adc_lld_stop+0x1c>
  adcp->adcm->PCSEL = 0U;
 800244a:	2300      	movs	r3, #0
 800244c:	61d3      	str	r3, [r2, #28]
  adcp->adcm->CR |= ADC_CR_ADDIS;
 800244e:	6893      	ldr	r3, [r2, #8]
 8002450:	f043 0302 	orr.w	r3, r3, #2
 8002454:	6093      	str	r3, [r2, #8]
  while ((adcp->adcm->CR & ADC_CR_ADDIS) != 0U)
 8002456:	6894      	ldr	r4, [r2, #8]
 8002458:	f014 0402 	ands.w	r4, r4, #2
 800245c:	d1fb      	bne.n	8002456 <adc_lld_stop+0x2e>
    if (&ADCD1 == adcp) {
 800245e:	4b1c      	ldr	r3, [pc, #112]	; (80024d0 <adc_lld_stop+0xa8>)
  adcp->adcm->CR = ADC_CR_DEEPPWD;
 8002460:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    if (&ADCD1 == adcp) {
 8002464:	429d      	cmp	r5, r3
  adcp->adcm->CR = ADC_CR_DEEPPWD;
 8002466:	6091      	str	r1, [r2, #8]
    if (&ADCD1 == adcp) {
 8002468:	d01a      	beq.n	80024a0 <adc_lld_stop+0x78>
    if (&ADCD3 == adcp) {
 800246a:	4b1a      	ldr	r3, [pc, #104]	; (80024d4 <adc_lld_stop+0xac>)
 800246c:	429d      	cmp	r5, r3
 800246e:	d1df      	bne.n	8002430 <adc_lld_stop+0x8>
    dmaStreamFreeI(adcp->data.dma);
 8002470:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8002472:	f000 fdb5 	bl	8002fe0 <dmaStreamFreeI>
  RCC_C1->AHB4ENR &= ~mask;
 8002476:	4b18      	ldr	r3, [pc, #96]	; (80024d8 <adc_lld_stop+0xb0>)
    adcp->adcc->CCR = STM32_ADC_ADC3_CLOCK_MODE;
 8002478:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800247a:	f44f 3140 	mov.w	r1, #196608	; 0x30000
    adcp->data.dma = NULL;
 800247e:	632c      	str	r4, [r5, #48]	; 0x30
    adcp->adcc->CCR = STM32_ADC_ADC3_CLOCK_MODE;
 8002480:	6091      	str	r1, [r2, #8]
 8002482:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8002486:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800248a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  RCC_C1->AHB4LPENR &= ~mask;
 800248e:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 8002492:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8002496:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 800249a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
}
 800249e:	bd38      	pop	{r3, r4, r5, pc}
      dmaStreamFreeI(adcp->data.dma);
 80024a0:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80024a2:	f000 fd9d 	bl	8002fe0 <dmaStreamFreeI>
  RCC_C1->AHB1ENR &= ~mask;
 80024a6:	4b0c      	ldr	r3, [pc, #48]	; (80024d8 <adc_lld_stop+0xb0>)
      adcp->adcc->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_DAMDF;
 80024a8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80024aa:	f44f 3140 	mov.w	r1, #196608	; 0x30000
      adcp->data.dma = NULL;
 80024ae:	632c      	str	r4, [r5, #48]	; 0x30
      adcp->adcc->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_DAMDF;
 80024b0:	6091      	str	r1, [r2, #8]
 80024b2:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 80024b6:	f022 0220 	bic.w	r2, r2, #32
 80024ba:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 80024be:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 80024c2:	f022 0220 	bic.w	r2, r2, #32
 80024c6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 80024ca:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
}
 80024ce:	bd38      	pop	{r3, r4, r5, pc}
 80024d0:	24000700 	.word	0x24000700
 80024d4:	24000738 	.word	0x24000738
 80024d8:	58024400 	.word	0x58024400

080024dc <adc_lld_start_conversion>:

#if STM32_ADC_USE_ADC12 == TRUE
#if STM32_ADC_DUAL_MODE
  uint32_t ccr;
#endif
  if (&ADCD1 == adcp) {
 80024dc:	4b2f      	ldr	r3, [pc, #188]	; (800259c <adc_lld_start_conversion+0xc0>)
  const ADCConversionGroup *grpp = adcp->grpp;
 80024de:	6902      	ldr	r2, [r0, #16]
  if (&ADCD1 == adcp) {
 80024e0:	4298      	cmp	r0, r3
void adc_lld_start_conversion(ADCDriver *adcp) {
 80024e2:	b4f0      	push	{r4, r5, r6, r7}
  if (&ADCD1 == adcp) {
 80024e4:	d03b      	beq.n	800255e <adc_lld_start_conversion+0x82>
    dmaStreamEnable(adcp->data.dma);
  }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
  if (&ADCD3 == adcp) {
 80024e6:	4b2e      	ldr	r3, [pc, #184]	; (80025a0 <adc_lld_start_conversion+0xc4>)
 80024e8:	4298      	cmp	r0, r3
 80024ea:	d038      	beq.n	800255e <adc_lld_start_conversion+0x82>
    dmaStreamSetTransactionSize(adcp->data.dma, (uint32_t)grpp->num_channels *
 80024ec:	6851      	ldr	r1, [r2, #4]
  uint32_t dmamode, cfgr = 0U;
 80024ee:	2400      	movs	r4, #0
#endif /* STM32_ADC_USE_ADC3 == TRUE */

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  /* clear AWD1..3 flags */
  adcp->adcm->ISR   = adcp->adcm->ISR;
 80024f0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80024f2:	6818      	ldr	r0, [r3, #0]
 80024f4:	6018      	str	r0, [r3, #0]
  /* If a callback is set enable the overflow and analog watch dog interrupts. */
  if (grpp->error_cb != NULL) {
 80024f6:	68d0      	ldr	r0, [r2, #12]
 80024f8:	b110      	cbz	r0, 8002500 <adc_lld_start_conversion+0x24>
    adcp->adcm->IER   = ADC_IER_OVRIE | ADC_IER_AWD1IE |
 80024fa:	f44f 7064 	mov.w	r0, #912	; 0x390
 80024fe:	6058      	str	r0, [r3, #4]
#endif /* STM32_ADC_DUAL_MODE == TRUE && STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_DUAL_MODE == FALSE || STM32_ADC_USE_ADC3 == TRUE
  /* Configuration for ADC3 and single mode ADC1 */

    adcp->adcm->CFGR2   = grpp->cfgr2;
 8002500:	6950      	ldr	r0, [r2, #20]
    adcp->adcm->HTR3    = grpp->htr3;
    adcp->adcm->AWD2CR  = grpp->awd2cr;
    adcp->adcm->AWD3CR  = grpp->awd3cr;
    adcp->adcm->SMPR1   = grpp->smpr[0];
    adcp->adcm->SMPR2   = grpp->smpr[1];
    adcp->adcm->SQR1    = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002502:	3901      	subs	r1, #1
    adcp->adcm->CFGR2   = grpp->cfgr2;
 8002504:	6118      	str	r0, [r3, #16]
    adcp->adcm->PCSEL   = grpp->pcsel;
 8002506:	69d0      	ldr	r0, [r2, #28]
 8002508:	61d8      	str	r0, [r3, #28]
    adcp->adcm->LTR1    = grpp->ltr1;
 800250a:	6a10      	ldr	r0, [r2, #32]
 800250c:	6218      	str	r0, [r3, #32]
    adcp->adcm->HTR1    = grpp->htr1;
 800250e:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8002510:	6258      	str	r0, [r3, #36]	; 0x24
    adcp->adcm->LTR2    = grpp->ltr2;
 8002512:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8002514:	f8c3 00b0 	str.w	r0, [r3, #176]	; 0xb0
    adcp->adcm->HTR2    = grpp->htr2;
 8002518:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 800251a:	f8c3 00b4 	str.w	r0, [r3, #180]	; 0xb4
    adcp->adcm->LTR3    = grpp->ltr3;
 800251e:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8002520:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
    adcp->adcm->HTR3    = grpp->htr3;
 8002524:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8002526:	f8c3 00bc 	str.w	r0, [r3, #188]	; 0xbc
    adcp->adcm->AWD2CR  = grpp->awd2cr;
 800252a:	6b90      	ldr	r0, [r2, #56]	; 0x38
 800252c:	f8c3 00a0 	str.w	r0, [r3, #160]	; 0xa0
    adcp->adcm->AWD3CR  = grpp->awd3cr;
 8002530:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8002532:	f8c3 00a4 	str.w	r0, [r3, #164]	; 0xa4
    adcp->adcm->SMPR1   = grpp->smpr[0];
 8002536:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8002538:	6158      	str	r0, [r3, #20]
    adcp->adcm->SMPR2   = grpp->smpr[1];
 800253a:	6c50      	ldr	r0, [r2, #68]	; 0x44
 800253c:	6198      	str	r0, [r3, #24]
    adcp->adcm->SQR1    = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 800253e:	6c90      	ldr	r0, [r2, #72]	; 0x48
 8002540:	4301      	orrs	r1, r0
    adcp->adcm->SQR2    = grpp->sqr[1];
 8002542:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
    adcp->adcm->SQR1    = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002544:	6319      	str	r1, [r3, #48]	; 0x30
    adcp->adcm->SQR2    = grpp->sqr[1];
 8002546:	6358      	str	r0, [r3, #52]	; 0x34
    adcp->adcm->SQR3    = grpp->sqr[2];
    adcp->adcm->SQR4    = grpp->sqr[3];
 8002548:	e9d2 1214 	ldrd	r1, r2, [r2, #80]	; 0x50
    adcp->adcm->SQR3    = grpp->sqr[2];
 800254c:	6399      	str	r1, [r3, #56]	; 0x38
    adcp->adcm->SQR4    = grpp->sqr[3];
 800254e:	63da      	str	r2, [r3, #60]	; 0x3c

    /* ADC configuration.*/
    adcp->adcm->CFGR  = cfgr;
 8002550:	60dc      	str	r4, [r3, #12]
#endif

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 8002552:	689a      	ldr	r2, [r3, #8]
 8002554:	f042 0204 	orr.w	r2, r2, #4
}
 8002558:	bcf0      	pop	{r4, r5, r6, r7}
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 800255a:	609a      	str	r2, [r3, #8]
}
 800255c:	4770      	bx	lr
    if (grpp->circular) {
 800255e:	7811      	ldrb	r1, [r2, #0]
    dmamode = adcp->dmamode;
 8002560:	6b46      	ldr	r6, [r0, #52]	; 0x34
      cfgr = grpp->cfgr | ADC_CFGR_DMNGT_CIRCULAR;
 8002562:	6914      	ldr	r4, [r2, #16]
    if (grpp->circular) {
 8002564:	b981      	cbnz	r1, 8002588 <adc_lld_start_conversion+0xac>
      cfgr = grpp->cfgr | ADC_CFGR_DMNGT_ONESHOT;
 8002566:	f044 0401 	orr.w	r4, r4, #1
      if (adcp->depth > 1) {
 800256a:	68c5      	ldr	r5, [r0, #12]
    dmaStreamSetMemory0(adcp->data.dma, adcp->samples);
 800256c:	6b1f      	ldr	r7, [r3, #48]	; 0x30
 800256e:	6899      	ldr	r1, [r3, #8]
 8002570:	683b      	ldr	r3, [r7, #0]
 8002572:	60d9      	str	r1, [r3, #12]
    dmaStreamSetTransactionSize(adcp->data.dma, (uint32_t)grpp->num_channels *
 8002574:	6851      	ldr	r1, [r2, #4]
 8002576:	fb01 f505 	mul.w	r5, r1, r5
 800257a:	605d      	str	r5, [r3, #4]
    dmaStreamSetMode(adcp->data.dma, dmamode);
 800257c:	601e      	str	r6, [r3, #0]
    dmaStreamEnable(adcp->data.dma);
 800257e:	681d      	ldr	r5, [r3, #0]
 8002580:	f045 0501 	orr.w	r5, r5, #1
 8002584:	601d      	str	r5, [r3, #0]
 8002586:	e7b3      	b.n	80024f0 <adc_lld_start_conversion+0x14>
      if (adcp->depth > 1) {
 8002588:	68c5      	ldr	r5, [r0, #12]
      cfgr = grpp->cfgr | ADC_CFGR_DMNGT_CIRCULAR;
 800258a:	f044 0403 	orr.w	r4, r4, #3
      if (adcp->depth > 1) {
 800258e:	2d01      	cmp	r5, #1
      dmamode |= STM32_DMA_CR_CIRC;
 8002590:	bf94      	ite	ls
 8002592:	f446 7680 	orrls.w	r6, r6, #256	; 0x100
        dmamode |= STM32_DMA_CR_HTIE;
 8002596:	f446 7684 	orrhi.w	r6, r6, #264	; 0x108
 800259a:	e7e7      	b.n	800256c <adc_lld_start_conversion+0x90>
 800259c:	24000700 	.word	0x24000700
 80025a0:	24000738 	.word	0x24000738

080025a4 <adc_lld_stop_conversion>:
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

#if STM32_ADC_USE_ADC12 == TRUE
  if (&ADCD1 == adcp) {
 80025a4:	4b17      	ldr	r3, [pc, #92]	; (8002604 <adc_lld_stop_conversion+0x60>)
 80025a6:	4298      	cmp	r0, r3
 80025a8:	d021      	beq.n	80025ee <adc_lld_stop_conversion+0x4a>
    dmaStreamDisable(adcp->data.dma);
  }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
  if (&ADCD3 == adcp) {
 80025aa:	4b17      	ldr	r3, [pc, #92]	; (8002608 <adc_lld_stop_conversion+0x64>)
 80025ac:	4298      	cmp	r0, r3
 80025ae:	d00d      	beq.n	80025cc <adc_lld_stop_conversion+0x28>
    dmaStreamDisable(adcp->data.dma);
#endif
  }
#endif /* STM32_ADC_USE_ADC3 == TRUE */

  adc_lld_stop_adc(adcp);
 80025b0:	6a82      	ldr	r2, [r0, #40]	; 0x28
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 80025b2:	6893      	ldr	r3, [r2, #8]
 80025b4:	0759      	lsls	r1, r3, #29
 80025b6:	d506      	bpl.n	80025c6 <adc_lld_stop_conversion+0x22>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 80025b8:	6893      	ldr	r3, [r2, #8]
 80025ba:	f043 0310 	orr.w	r3, r3, #16
 80025be:	6093      	str	r3, [r2, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 80025c0:	6893      	ldr	r3, [r2, #8]
 80025c2:	06db      	lsls	r3, r3, #27
 80025c4:	d4fc      	bmi.n	80025c0 <adc_lld_stop_conversion+0x1c>
  adcp->adcm->PCSEL = 0U;
 80025c6:	2300      	movs	r3, #0
 80025c8:	61d3      	str	r3, [r2, #28]
}
 80025ca:	4770      	bx	lr
    dmaStreamDisable(adcp->data.dma);
 80025cc:	6b01      	ldr	r1, [r0, #48]	; 0x30
 80025ce:	680a      	ldr	r2, [r1, #0]
 80025d0:	6813      	ldr	r3, [r2, #0]
 80025d2:	f023 031f 	bic.w	r3, r3, #31
 80025d6:	6013      	str	r3, [r2, #0]
 80025d8:	6813      	ldr	r3, [r2, #0]
 80025da:	07db      	lsls	r3, r3, #31
 80025dc:	d4fc      	bmi.n	80025d8 <adc_lld_stop_conversion+0x34>
 80025de:	f891 c00c 	ldrb.w	ip, [r1, #12]
 80025e2:	233d      	movs	r3, #61	; 0x3d
 80025e4:	684a      	ldr	r2, [r1, #4]
 80025e6:	fa03 f30c 	lsl.w	r3, r3, ip
 80025ea:	6013      	str	r3, [r2, #0]
 80025ec:	e7e0      	b.n	80025b0 <adc_lld_stop_conversion+0xc>
    dmaStreamDisable(adcp->data.dma);
 80025ee:	6b01      	ldr	r1, [r0, #48]	; 0x30
 80025f0:	680a      	ldr	r2, [r1, #0]
 80025f2:	6813      	ldr	r3, [r2, #0]
 80025f4:	f023 031f 	bic.w	r3, r3, #31
 80025f8:	6013      	str	r3, [r2, #0]
 80025fa:	6813      	ldr	r3, [r2, #0]
 80025fc:	07db      	lsls	r3, r3, #31
 80025fe:	d4fc      	bmi.n	80025fa <adc_lld_stop_conversion+0x56>
 8002600:	e7ed      	b.n	80025de <adc_lld_stop_conversion+0x3a>
 8002602:	bf00      	nop
 8002604:	24000700 	.word	0x24000700
 8002608:	24000738 	.word	0x24000738

0800260c <adc_lld_serve_interrupt>:
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 800260c:	b570      	push	{r4, r5, r6, lr}
  if (adcp->grpp != NULL) {
 800260e:	6906      	ldr	r6, [r0, #16]
 8002610:	b376      	cbz	r6, 8002670 <adc_lld_serve_interrupt+0x64>
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8002612:	f011 0510 	ands.w	r5, r1, #16
 8002616:	4604      	mov	r4, r0
 8002618:	d006      	beq.n	8002628 <adc_lld_serve_interrupt+0x1c>
 800261a:	7805      	ldrb	r5, [r0, #0]
 800261c:	f1a5 0503 	sub.w	r5, r5, #3
 8002620:	fab5 f585 	clz	r5, r5
 8002624:	096d      	lsrs	r5, r5, #5
 8002626:	006d      	lsls	r5, r5, #1
    if (isr & ADC_ISR_AWD1) {
 8002628:	060b      	lsls	r3, r1, #24
      emask |= ADC_ERR_AWD1;
 800262a:	bf48      	it	mi
 800262c:	f045 0504 	orrmi.w	r5, r5, #4
    if (isr & ADC_ISR_AWD2) {
 8002630:	05c8      	lsls	r0, r1, #23
 8002632:	d51e      	bpl.n	8002672 <adc_lld_serve_interrupt+0x66>
    if (isr & ADC_ISR_AWD3) {
 8002634:	058a      	lsls	r2, r1, #22
      emask |= ADC_ERR_AWD2;
 8002636:	f045 0508 	orr.w	r5, r5, #8
    if (isr & ADC_ISR_AWD3) {
 800263a:	d501      	bpl.n	8002640 <adc_lld_serve_interrupt+0x34>
      emask |= ADC_ERR_AWD3;
 800263c:	f045 0510 	orr.w	r5, r5, #16
      _adc_isr_error_code(adcp, emask);
 8002640:	4620      	mov	r0, r4
 8002642:	f7ff ffaf 	bl	80025a4 <adc_lld_stop_conversion>
 8002646:	68f3      	ldr	r3, [r6, #12]
 8002648:	b1c3      	cbz	r3, 800267c <adc_lld_serve_interrupt+0x70>
 800264a:	2205      	movs	r2, #5
 800264c:	4629      	mov	r1, r5
 800264e:	7022      	strb	r2, [r4, #0]
 8002650:	4798      	blx	r3
 8002652:	7823      	ldrb	r3, [r4, #0]
 8002654:	2b05      	cmp	r3, #5
 8002656:	d011      	beq.n	800267c <adc_lld_serve_interrupt+0x70>
 8002658:	2330      	movs	r3, #48	; 0x30
 800265a:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 800265e:	f04f 31ff 	mov.w	r1, #4294967295
 8002662:	f104 0014 	add.w	r0, r4, #20
 8002666:	f003 fff1 	bl	800664c <chThdResumeI>
 800266a:	2300      	movs	r3, #0
 800266c:	f383 8811 	msr	BASEPRI, r3
}
 8002670:	bd70      	pop	{r4, r5, r6, pc}
    if (isr & ADC_ISR_AWD3) {
 8002672:	058b      	lsls	r3, r1, #22
 8002674:	d4e2      	bmi.n	800263c <adc_lld_serve_interrupt+0x30>
    if (emask != 0U) {
 8002676:	2d00      	cmp	r5, #0
 8002678:	d1e2      	bne.n	8002640 <adc_lld_serve_interrupt+0x34>
}
 800267a:	bd70      	pop	{r4, r5, r6, pc}
      _adc_isr_error_code(adcp, emask);
 800267c:	2202      	movs	r2, #2
 800267e:	2300      	movs	r3, #0
 8002680:	7022      	strb	r2, [r4, #0]
 8002682:	6123      	str	r3, [r4, #16]
 8002684:	e7e8      	b.n	8002658 <adc_lld_serve_interrupt+0x4c>
 8002686:	bf00      	nop

08002688 <Vector88>:
OSAL_IRQ_HANDLER(STM32_ADC12_HANDLER) {
 8002688:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 800268a:	4c08      	ldr	r4, [pc, #32]	; (80026ac <Vector88+0x24>)
 800268c:	4620      	mov	r0, r4
 800268e:	f003 fb65 	bl	8005d5c <__trace_isr_enter>
  isr  = ADC1->ISR;
 8002692:	4b07      	ldr	r3, [pc, #28]	; (80026b0 <Vector88+0x28>)
  adc_lld_serve_interrupt(&ADCD1, isr);
 8002694:	4807      	ldr	r0, [pc, #28]	; (80026b4 <Vector88+0x2c>)
  isr  = ADC1->ISR;
 8002696:	6819      	ldr	r1, [r3, #0]
  ADC1->ISR = isr;
 8002698:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD1, isr);
 800269a:	f7ff ffb7 	bl	800260c <adc_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 800269e:	4620      	mov	r0, r4
 80026a0:	f003 fb74 	bl	8005d8c <__trace_isr_leave>
}
 80026a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80026a8:	f004 bae8 	b.w	8006c7c <__port_irq_epilogue>
 80026ac:	08014af4 	.word	0x08014af4
 80026b0:	40022000 	.word	0x40022000
 80026b4:	24000700 	.word	0x24000700

080026b8 <Vector23C>:
OSAL_IRQ_HANDLER(STM32_ADC3_HANDLER) {
 80026b8:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80026ba:	4c08      	ldr	r4, [pc, #32]	; (80026dc <Vector23C+0x24>)
 80026bc:	4620      	mov	r0, r4
 80026be:	f003 fb4d 	bl	8005d5c <__trace_isr_enter>
  isr  = ADC3->ISR;
 80026c2:	4b07      	ldr	r3, [pc, #28]	; (80026e0 <Vector23C+0x28>)
  adc_lld_serve_interrupt(&ADCD3, isr);
 80026c4:	4807      	ldr	r0, [pc, #28]	; (80026e4 <Vector23C+0x2c>)
  isr  = ADC3->ISR;
 80026c6:	6819      	ldr	r1, [r3, #0]
  ADC3->ISR = isr;
 80026c8:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD3, isr);
 80026ca:	f7ff ff9f 	bl	800260c <adc_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 80026ce:	4620      	mov	r0, r4
 80026d0:	f003 fb5c 	bl	8005d8c <__trace_isr_leave>
}
 80026d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80026d8:	f004 bad0 	b.w	8006c7c <__port_irq_epilogue>
 80026dc:	08014ae8 	.word	0x08014ae8
 80026e0:	58026000 	.word	0x58026000
 80026e4:	24000738 	.word	0x24000738

080026e8 <adc_lld_serve_dma_interrupt>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80026e8:	f011 0f0c 	tst.w	r1, #12
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 80026ec:	b570      	push	{r4, r5, r6, lr}
 80026ee:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80026f0:	d10e      	bne.n	8002710 <adc_lld_serve_dma_interrupt+0x28>
    if (adcp->grpp != NULL) {
 80026f2:	6905      	ldr	r5, [r0, #16]
 80026f4:	b15d      	cbz	r5, 800270e <adc_lld_serve_dma_interrupt+0x26>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80026f6:	068a      	lsls	r2, r1, #26
 80026f8:	d523      	bpl.n	8002742 <adc_lld_serve_dma_interrupt+0x5a>
        _adc_isr_full_code(adcp);
 80026fa:	782b      	ldrb	r3, [r5, #0]
 80026fc:	b373      	cbz	r3, 800275c <adc_lld_serve_dma_interrupt+0x74>
 80026fe:	68ab      	ldr	r3, [r5, #8]
 8002700:	b12b      	cbz	r3, 800270e <adc_lld_serve_dma_interrupt+0x26>
 8002702:	2204      	movs	r2, #4
 8002704:	7002      	strb	r2, [r0, #0]
 8002706:	4798      	blx	r3
 8002708:	7823      	ldrb	r3, [r4, #0]
 800270a:	2b04      	cmp	r3, #4
 800270c:	d03c      	beq.n	8002788 <adc_lld_serve_dma_interrupt+0xa0>
}
 800270e:	bd70      	pop	{r4, r5, r6, pc}
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8002710:	f7ff ff48 	bl	80025a4 <adc_lld_stop_conversion>
 8002714:	6903      	ldr	r3, [r0, #16]
 8002716:	68db      	ldr	r3, [r3, #12]
 8002718:	b1db      	cbz	r3, 8002752 <adc_lld_serve_dma_interrupt+0x6a>
 800271a:	2205      	movs	r2, #5
 800271c:	2101      	movs	r1, #1
 800271e:	7002      	strb	r2, [r0, #0]
 8002720:	4798      	blx	r3
 8002722:	7823      	ldrb	r3, [r4, #0]
 8002724:	2b05      	cmp	r3, #5
 8002726:	d014      	beq.n	8002752 <adc_lld_serve_dma_interrupt+0x6a>
 8002728:	2330      	movs	r3, #48	; 0x30
 800272a:	f383 8811 	msr	BASEPRI, r3
 800272e:	f04f 31ff 	mov.w	r1, #4294967295
 8002732:	f104 0014 	add.w	r0, r4, #20
 8002736:	f003 ff89 	bl	800664c <chThdResumeI>
 800273a:	2300      	movs	r3, #0
 800273c:	f383 8811 	msr	BASEPRI, r3
}
 8002740:	bd70      	pop	{r4, r5, r6, pc}
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8002742:	06cb      	lsls	r3, r1, #27
 8002744:	d5e3      	bpl.n	800270e <adc_lld_serve_dma_interrupt+0x26>
        _adc_isr_half_code(adcp);
 8002746:	68ab      	ldr	r3, [r5, #8]
 8002748:	2b00      	cmp	r3, #0
 800274a:	d0e0      	beq.n	800270e <adc_lld_serve_dma_interrupt+0x26>
}
 800274c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_half_code(adcp);
 8002750:	4718      	bx	r3
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8002752:	2202      	movs	r2, #2
 8002754:	2300      	movs	r3, #0
 8002756:	7022      	strb	r2, [r4, #0]
 8002758:	6123      	str	r3, [r4, #16]
 800275a:	e7e5      	b.n	8002728 <adc_lld_serve_dma_interrupt+0x40>
        _adc_isr_full_code(adcp);
 800275c:	f7ff ff22 	bl	80025a4 <adc_lld_stop_conversion>
 8002760:	68ab      	ldr	r3, [r5, #8]
 8002762:	b1a3      	cbz	r3, 800278e <adc_lld_serve_dma_interrupt+0xa6>
 8002764:	2204      	movs	r2, #4
 8002766:	7002      	strb	r2, [r0, #0]
 8002768:	4798      	blx	r3
 800276a:	7823      	ldrb	r3, [r4, #0]
 800276c:	2b04      	cmp	r3, #4
 800276e:	d00e      	beq.n	800278e <adc_lld_serve_dma_interrupt+0xa6>
 8002770:	2330      	movs	r3, #48	; 0x30
 8002772:	f383 8811 	msr	BASEPRI, r3
 8002776:	2100      	movs	r1, #0
 8002778:	f104 0014 	add.w	r0, r4, #20
 800277c:	f003 ff66 	bl	800664c <chThdResumeI>
 8002780:	2300      	movs	r3, #0
 8002782:	f383 8811 	msr	BASEPRI, r3
}
 8002786:	bd70      	pop	{r4, r5, r6, pc}
        _adc_isr_full_code(adcp);
 8002788:	2303      	movs	r3, #3
 800278a:	7023      	strb	r3, [r4, #0]
}
 800278c:	bd70      	pop	{r4, r5, r6, pc}
        _adc_isr_full_code(adcp);
 800278e:	2202      	movs	r2, #2
 8002790:	2300      	movs	r3, #0
 8002792:	7022      	strb	r2, [r4, #0]
 8002794:	6123      	str	r3, [r4, #16]
 8002796:	e7eb      	b.n	8002770 <adc_lld_serve_dma_interrupt+0x88>

08002798 <Vector244>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002798:	480a      	ldr	r0, [pc, #40]	; (80027c4 <Vector244+0x2c>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH0_HANDLER) {
 800279a:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 800279c:	f003 fade 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 80027a0:	4b09      	ldr	r3, [pc, #36]	; (80027c8 <Vector244+0x30>)
  BDMA->IFCR = flags << 0U;
  if (bdma.streams[0].func)
 80027a2:	480a      	ldr	r0, [pc, #40]	; (80027cc <Vector244+0x34>)
  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 80027a4:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[0].func)
 80027a6:	6842      	ldr	r2, [r0, #4]
  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 80027a8:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 0U;
 80027ac:	6059      	str	r1, [r3, #4]
  if (bdma.streams[0].func)
 80027ae:	b10a      	cbz	r2, 80027b4 <Vector244+0x1c>
    bdma.streams[0].func(bdma.streams[0].param, flags);
 80027b0:	6880      	ldr	r0, [r0, #8]
 80027b2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80027b4:	4803      	ldr	r0, [pc, #12]	; (80027c4 <Vector244+0x2c>)
 80027b6:	f003 fae9 	bl	8005d8c <__trace_isr_leave>
}
 80027ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 80027be:	f004 ba5d 	b.w	8006c7c <__port_irq_epilogue>
 80027c2:	bf00      	nop
 80027c4:	08014b5c 	.word	0x08014b5c
 80027c8:	58025400 	.word	0x58025400
 80027cc:	24000770 	.word	0x24000770

080027d0 <Vector248>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80027d0:	480b      	ldr	r0, [pc, #44]	; (8002800 <Vector248+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH1_HANDLER) {
 80027d2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80027d4:	f003 fac2 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 80027d8:	4b0a      	ldr	r3, [pc, #40]	; (8002804 <Vector248+0x34>)
  BDMA->IFCR = flags << 4U;
  if (bdma.streams[1].func)
 80027da:	480b      	ldr	r0, [pc, #44]	; (8002808 <Vector248+0x38>)
  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 80027dc:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[1].func)
 80027de:	68c2      	ldr	r2, [r0, #12]
  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 80027e0:	0909      	lsrs	r1, r1, #4
 80027e2:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 4U;
 80027e6:	010c      	lsls	r4, r1, #4
 80027e8:	605c      	str	r4, [r3, #4]
  if (bdma.streams[1].func)
 80027ea:	b10a      	cbz	r2, 80027f0 <Vector248+0x20>
    bdma.streams[1].func(bdma.streams[1].param, flags);
 80027ec:	6900      	ldr	r0, [r0, #16]
 80027ee:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80027f0:	4803      	ldr	r0, [pc, #12]	; (8002800 <Vector248+0x30>)
 80027f2:	f003 facb 	bl	8005d8c <__trace_isr_leave>
}
 80027f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80027fa:	f004 ba3f 	b.w	8006c7c <__port_irq_epilogue>
 80027fe:	bf00      	nop
 8002800:	08014b50 	.word	0x08014b50
 8002804:	58025400 	.word	0x58025400
 8002808:	24000770 	.word	0x24000770

0800280c <Vector24C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800280c:	480b      	ldr	r0, [pc, #44]	; (800283c <Vector24C+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH2_HANDLER) {
 800280e:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002810:	f003 faa4 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 8002814:	4b0a      	ldr	r3, [pc, #40]	; (8002840 <Vector24C+0x34>)
  BDMA->IFCR = flags << 8U;
  if (bdma.streams[2].func)
 8002816:	480b      	ldr	r0, [pc, #44]	; (8002844 <Vector24C+0x38>)
  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 8002818:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[2].func)
 800281a:	6942      	ldr	r2, [r0, #20]
  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 800281c:	0a09      	lsrs	r1, r1, #8
 800281e:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 8U;
 8002822:	020c      	lsls	r4, r1, #8
 8002824:	605c      	str	r4, [r3, #4]
  if (bdma.streams[2].func)
 8002826:	b10a      	cbz	r2, 800282c <Vector24C+0x20>
    bdma.streams[2].func(bdma.streams[2].param, flags);
 8002828:	6980      	ldr	r0, [r0, #24]
 800282a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800282c:	4803      	ldr	r0, [pc, #12]	; (800283c <Vector24C+0x30>)
 800282e:	f003 faad 	bl	8005d8c <__trace_isr_leave>
}
 8002832:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002836:	f004 ba21 	b.w	8006c7c <__port_irq_epilogue>
 800283a:	bf00      	nop
 800283c:	08014b44 	.word	0x08014b44
 8002840:	58025400 	.word	0x58025400
 8002844:	24000770 	.word	0x24000770

08002848 <Vector250>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002848:	480b      	ldr	r0, [pc, #44]	; (8002878 <Vector250+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH3_HANDLER) {
 800284a:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 800284c:	f003 fa86 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 8002850:	4b0a      	ldr	r3, [pc, #40]	; (800287c <Vector250+0x34>)
  BDMA->IFCR = flags << 12U;
  if (bdma.streams[3].func)
 8002852:	480b      	ldr	r0, [pc, #44]	; (8002880 <Vector250+0x38>)
  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 8002854:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[3].func)
 8002856:	69c2      	ldr	r2, [r0, #28]
  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 8002858:	0b09      	lsrs	r1, r1, #12
 800285a:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 12U;
 800285e:	030c      	lsls	r4, r1, #12
 8002860:	605c      	str	r4, [r3, #4]
  if (bdma.streams[3].func)
 8002862:	b10a      	cbz	r2, 8002868 <Vector250+0x20>
    bdma.streams[3].func(bdma.streams[3].param, flags);
 8002864:	6a00      	ldr	r0, [r0, #32]
 8002866:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002868:	4803      	ldr	r0, [pc, #12]	; (8002878 <Vector250+0x30>)
 800286a:	f003 fa8f 	bl	8005d8c <__trace_isr_leave>
}
 800286e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002872:	f004 ba03 	b.w	8006c7c <__port_irq_epilogue>
 8002876:	bf00      	nop
 8002878:	08014b38 	.word	0x08014b38
 800287c:	58025400 	.word	0x58025400
 8002880:	24000770 	.word	0x24000770

08002884 <Vector254>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002884:	480b      	ldr	r0, [pc, #44]	; (80028b4 <Vector254+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH4_HANDLER) {
 8002886:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002888:	f003 fa68 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 800288c:	4b0a      	ldr	r3, [pc, #40]	; (80028b8 <Vector254+0x34>)
  BDMA->IFCR = flags << 16U;
  if (bdma.streams[4].func)
 800288e:	480b      	ldr	r0, [pc, #44]	; (80028bc <Vector254+0x38>)
  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 8002890:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[4].func)
 8002892:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 8002894:	0c09      	lsrs	r1, r1, #16
 8002896:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 16U;
 800289a:	040c      	lsls	r4, r1, #16
 800289c:	605c      	str	r4, [r3, #4]
  if (bdma.streams[4].func)
 800289e:	b10a      	cbz	r2, 80028a4 <Vector254+0x20>
    bdma.streams[4].func(bdma.streams[4].param, flags);
 80028a0:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80028a2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80028a4:	4803      	ldr	r0, [pc, #12]	; (80028b4 <Vector254+0x30>)
 80028a6:	f003 fa71 	bl	8005d8c <__trace_isr_leave>
}
 80028aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80028ae:	f004 b9e5 	b.w	8006c7c <__port_irq_epilogue>
 80028b2:	bf00      	nop
 80028b4:	08014b2c 	.word	0x08014b2c
 80028b8:	58025400 	.word	0x58025400
 80028bc:	24000770 	.word	0x24000770

080028c0 <Vector258>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80028c0:	480b      	ldr	r0, [pc, #44]	; (80028f0 <Vector258+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH5_HANDLER) {
 80028c2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80028c4:	f003 fa4a 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 80028c8:	4b0a      	ldr	r3, [pc, #40]	; (80028f4 <Vector258+0x34>)
  BDMA->IFCR = flags << 20U;
  if (bdma.streams[5].func)
 80028ca:	480b      	ldr	r0, [pc, #44]	; (80028f8 <Vector258+0x38>)
  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 80028cc:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[5].func)
 80028ce:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 80028d0:	0d09      	lsrs	r1, r1, #20
 80028d2:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 20U;
 80028d6:	050c      	lsls	r4, r1, #20
 80028d8:	605c      	str	r4, [r3, #4]
  if (bdma.streams[5].func)
 80028da:	b10a      	cbz	r2, 80028e0 <Vector258+0x20>
    bdma.streams[5].func(bdma.streams[5].param, flags);
 80028dc:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80028de:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80028e0:	4803      	ldr	r0, [pc, #12]	; (80028f0 <Vector258+0x30>)
 80028e2:	f003 fa53 	bl	8005d8c <__trace_isr_leave>
}
 80028e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80028ea:	f004 b9c7 	b.w	8006c7c <__port_irq_epilogue>
 80028ee:	bf00      	nop
 80028f0:	08014b20 	.word	0x08014b20
 80028f4:	58025400 	.word	0x58025400
 80028f8:	24000770 	.word	0x24000770

080028fc <Vector25C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80028fc:	480b      	ldr	r0, [pc, #44]	; (800292c <Vector25C+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH6_HANDLER) {
 80028fe:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002900:	f003 fa2c 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 8002904:	4b0a      	ldr	r3, [pc, #40]	; (8002930 <Vector25C+0x34>)
  BDMA->IFCR = flags << 24U;
  if (bdma.streams[6].func)
 8002906:	480b      	ldr	r0, [pc, #44]	; (8002934 <Vector25C+0x38>)
  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 8002908:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[6].func)
 800290a:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 800290c:	0e09      	lsrs	r1, r1, #24
 800290e:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 24U;
 8002912:	060c      	lsls	r4, r1, #24
 8002914:	605c      	str	r4, [r3, #4]
  if (bdma.streams[6].func)
 8002916:	b10a      	cbz	r2, 800291c <Vector25C+0x20>
    bdma.streams[6].func(bdma.streams[6].param, flags);
 8002918:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800291a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800291c:	4803      	ldr	r0, [pc, #12]	; (800292c <Vector25C+0x30>)
 800291e:	f003 fa35 	bl	8005d8c <__trace_isr_leave>
}
 8002922:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002926:	f004 b9a9 	b.w	8006c7c <__port_irq_epilogue>
 800292a:	bf00      	nop
 800292c:	08014b14 	.word	0x08014b14
 8002930:	58025400 	.word	0x58025400
 8002934:	24000770 	.word	0x24000770

08002938 <Vector260>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002938:	480b      	ldr	r0, [pc, #44]	; (8002968 <Vector260+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH7_HANDLER) {
 800293a:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 800293c:	f003 fa0e 	bl	8005d5c <__trace_isr_enter>

  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 8002940:	4b0a      	ldr	r3, [pc, #40]	; (800296c <Vector260+0x34>)
  BDMA->IFCR = flags << 28U;
  if (bdma.streams[7].func)
 8002942:	480b      	ldr	r0, [pc, #44]	; (8002970 <Vector260+0x38>)
  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 8002944:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[7].func)
 8002946:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 8002948:	0f09      	lsrs	r1, r1, #28
 800294a:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 28U;
 800294e:	070c      	lsls	r4, r1, #28
 8002950:	605c      	str	r4, [r3, #4]
  if (bdma.streams[7].func)
 8002952:	b10a      	cbz	r2, 8002958 <Vector260+0x20>
    bdma.streams[7].func(bdma.streams[7].param, flags);
 8002954:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8002956:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002958:	4803      	ldr	r0, [pc, #12]	; (8002968 <Vector260+0x30>)
 800295a:	f003 fa17 	bl	8005d8c <__trace_isr_leave>
}
 800295e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002962:	f004 b98b 	b.w	8006c7c <__port_irq_epilogue>
 8002966:	bf00      	nop
 8002968:	08014b08 	.word	0x08014b08
 800296c:	58025400 	.word	0x58025400
 8002970:	24000770 	.word	0x24000770

08002974 <bdmaInit>:
 * @init
 */
void bdmaInit(void) {
  unsigned i;

  bdma.allocated_mask = 0U;
 8002974:	480b      	ldr	r0, [pc, #44]	; (80029a4 <bdmaInit+0x30>)
 8002976:	2200      	movs	r2, #0
 8002978:	4b0b      	ldr	r3, [pc, #44]	; (80029a8 <bdmaInit+0x34>)
 800297a:	4601      	mov	r1, r0
 800297c:	6002      	str	r2, [r0, #0]
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 800297e:	f103 0ca0 	add.w	ip, r3, #160	; 0xa0
  bdma.allocated_mask = 0U;
 8002982:	480a      	ldr	r0, [pc, #40]	; (80029ac <bdmaInit+0x38>)
 8002984:	e001      	b.n	800298a <bdmaInit+0x16>
    _stm32_bdma_streams[i].channel->CCR = 0U;
 8002986:	f853 0c14 	ldr.w	r0, [r3, #-20]
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 800298a:	3314      	adds	r3, #20
    _stm32_bdma_streams[i].channel->CCR = 0U;
 800298c:	6002      	str	r2, [r0, #0]
    bdma.streams[i].func  = NULL;
 800298e:	604a      	str	r2, [r1, #4]
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 8002990:	4563      	cmp	r3, ip
    bdma.streams[i].param = NULL;
 8002992:	f841 2f08 	str.w	r2, [r1, #8]!
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 8002996:	d1f6      	bne.n	8002986 <bdmaInit+0x12>
  }
  BDMA->IFCR = 0xFFFFFFFFU;
 8002998:	4b05      	ldr	r3, [pc, #20]	; (80029b0 <bdmaInit+0x3c>)
 800299a:	f04f 32ff 	mov.w	r2, #4294967295
 800299e:	605a      	str	r2, [r3, #4]
}
 80029a0:	4770      	bx	lr
 80029a2:	bf00      	nop
 80029a4:	24000770 	.word	0x24000770
 80029a8:	08014b80 	.word	0x08014b80
 80029ac:	58025408 	.word	0x58025408
 80029b0:	58025400 	.word	0x58025400

080029b4 <bdmaStreamAllocI>:
                                            void *param) {
  uint32_t i, startid, endid;

  osalDbgCheckClassI();

  if (id < STM32_BDMA_STREAMS) {
 80029b4:	2807      	cmp	r0, #7
                                            void *param) {
 80029b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80029b8:	4604      	mov	r4, r0
  if (id < STM32_BDMA_STREAMS) {
 80029ba:	d906      	bls.n	80029ca <bdmaStreamAllocI+0x16>
    startid = id;
    endid   = id;
  }
  else if (id == STM32_BDMA_STREAM_ID_ANY) {
 80029bc:	2808      	cmp	r0, #8
 80029be:	d115      	bne.n	80029ec <bdmaStreamAllocI+0x38>
 80029c0:	2001      	movs	r0, #1
    startid = 0U;
    endid   = STM32_BDMA_STREAMS - 1U;
 80029c2:	f04f 0c07 	mov.w	ip, #7
    startid = 0U;
 80029c6:	2400      	movs	r4, #0
 80029c8:	e002      	b.n	80029d0 <bdmaStreamAllocI+0x1c>
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
 80029ca:	2001      	movs	r0, #1
 80029cc:	46a4      	mov	ip, r4
 80029ce:	40a0      	lsls	r0, r4
    if ((bdma.allocated_mask & mask) == 0U) {
 80029d0:	4e20      	ldr	r6, [pc, #128]	; (8002a54 <bdmaStreamAllocI+0xa0>)
 80029d2:	6835      	ldr	r5, [r6, #0]
 80029d4:	4205      	tst	r5, r0
 80029d6:	d00c      	beq.n	80029f2 <bdmaStreamAllocI+0x3e>
    uint32_t mask = (1U << i);
 80029d8:	f04f 0e01 	mov.w	lr, #1
 80029dc:	e001      	b.n	80029e2 <bdmaStreamAllocI+0x2e>
    if ((bdma.allocated_mask & mask) == 0U) {
 80029de:	4205      	tst	r5, r0
 80029e0:	d007      	beq.n	80029f2 <bdmaStreamAllocI+0x3e>
  for (i = startid; i <= endid; i++) {
 80029e2:	3401      	adds	r4, #1
 80029e4:	45a4      	cmp	ip, r4
    uint32_t mask = (1U << i);
 80029e6:	fa0e f004 	lsl.w	r0, lr, r4
  for (i = startid; i <= endid; i++) {
 80029ea:	d2f8      	bcs.n	80029de <bdmaStreamAllocI+0x2a>
    return NULL;
 80029ec:	2500      	movs	r5, #0
      return stp;
    }
  }

  return NULL;
}
 80029ee:	4628      	mov	r0, r5
 80029f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      bdma.allocated_mask  |= mask;
 80029f2:	4305      	orrs	r5, r0
      const stm32_bdma_stream_t *stp = STM32_BDMA_STREAM(i);
 80029f4:	4f18      	ldr	r7, [pc, #96]	; (8002a58 <bdmaStreamAllocI+0xa4>)
      bdma.allocated_mask  |= mask;
 80029f6:	6035      	str	r5, [r6, #0]
      bdma.streams[i].func  = func;
 80029f8:	eb06 06c4 	add.w	r6, r6, r4, lsl #3
      const stm32_bdma_stream_t *stp = STM32_BDMA_STREAM(i);
 80029fc:	eb04 0584 	add.w	r5, r4, r4, lsl #2
      bdma.streams[i].func  = func;
 8002a00:	e9c6 2301 	strd	r2, r3, [r6, #4]
  RCC_C1->AHB4ENR |= mask;
 8002a04:	4b15      	ldr	r3, [pc, #84]	; (8002a5c <bdmaStreamAllocI+0xa8>)
      const stm32_bdma_stream_t *stp = STM32_BDMA_STREAM(i);
 8002a06:	00a6      	lsls	r6, r4, #2
 8002a08:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8002a0c:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
 8002a10:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 8002a14:	f8c3 00e0 	str.w	r0, [r3, #224]	; 0xe0
    RCC_C1->AHB4LPENR |= mask;
 8002a18:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
 8002a1c:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 8002a20:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 8002a24:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
      if (func != NULL) {
 8002a28:	b112      	cbz	r2, 8002a30 <bdmaStreamAllocI+0x7c>
        nvicEnableVector(stp->vector, priority);
 8002a2a:	7c68      	ldrb	r0, [r5, #17]
 8002a2c:	f7ff f996 	bl	8001d5c <nvicEnableVector>
      bdmaStreamDisable(stp);
 8002a30:	1933      	adds	r3, r6, r4
 8002a32:	220e      	movs	r2, #14
      stp->channel->CCR = STM32_BDMA_CR_RESET_VALUE;
 8002a34:	2000      	movs	r0, #0
      bdmaStreamDisable(stp);
 8002a36:	eb07 0183 	add.w	r1, r7, r3, lsl #2
 8002a3a:	f857 4023 	ldr.w	r4, [r7, r3, lsl #2]
 8002a3e:	684b      	ldr	r3, [r1, #4]
 8002a40:	7a09      	ldrb	r1, [r1, #8]
 8002a42:	408a      	lsls	r2, r1
 8002a44:	6819      	ldr	r1, [r3, #0]
 8002a46:	f021 010f 	bic.w	r1, r1, #15
 8002a4a:	6019      	str	r1, [r3, #0]
 8002a4c:	6062      	str	r2, [r4, #4]
      stp->channel->CCR = STM32_BDMA_CR_RESET_VALUE;
 8002a4e:	6018      	str	r0, [r3, #0]
}
 8002a50:	4628      	mov	r0, r5
 8002a52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002a54:	24000770 	.word	0x24000770
 8002a58:	08014b68 	.word	0x08014b68
 8002a5c:	58024400 	.word	0x58024400

08002a60 <bdmaStreamFreeI>:
 *
 * @param[in] stp       pointer to an @p stm32_bdma_stream_t structure
 *
 * @iclass
 */
void bdmaStreamFreeI(const stm32_bdma_stream_t *stp) {
 8002a60:	b510      	push	{r4, lr}
 8002a62:	4604      	mov	r4, r0
  /* Check if the streams is not taken.*/
  osalDbgAssert((bdma.allocated_mask & (1U << stp->selfindex)) != 0U,
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(stp->vector);
 8002a64:	7c40      	ldrb	r0, [r0, #17]
 8002a66:	f7ff f991 	bl	8001d8c <nvicDisableVector>

  /* Marks the stream as not allocated.*/
  bdma.allocated_mask &= ~(1U << stp->selfindex);
 8002a6a:	490f      	ldr	r1, [pc, #60]	; (8002aa8 <bdmaStreamFreeI+0x48>)
 8002a6c:	7c23      	ldrb	r3, [r4, #16]
 8002a6e:	2001      	movs	r0, #1
 8002a70:	680a      	ldr	r2, [r1, #0]

  /* Clearing associated handler and parameter.*/
  bdma.streams[stp->selfindex].func  = NULL;
 8002a72:	2400      	movs	r4, #0
  bdma.allocated_mask &= ~(1U << stp->selfindex);
 8002a74:	4098      	lsls	r0, r3
  bdma.streams[stp->selfindex].func  = NULL;
 8002a76:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
  bdma.allocated_mask &= ~(1U << stp->selfindex);
 8002a7a:	ea22 0200 	bic.w	r2, r2, r0
  bdma.streams[stp->selfindex].param = NULL;
 8002a7e:	e9c3 4401 	strd	r4, r4, [r3, #4]

  /* Shutting down clocks that are no more required, if any.*/
  if ((bdma.allocated_mask & STM32_BDMA_STREAMS_MASK) == 0U) {
 8002a82:	b2d3      	uxtb	r3, r2
  bdma.allocated_mask &= ~(1U << stp->selfindex);
 8002a84:	600a      	str	r2, [r1, #0]
  if ((bdma.allocated_mask & STM32_BDMA_STREAMS_MASK) == 0U) {
 8002a86:	b973      	cbnz	r3, 8002aa6 <bdmaStreamFreeI+0x46>
  RCC_C1->AHB4ENR &= ~mask;
 8002a88:	4b08      	ldr	r3, [pc, #32]	; (8002aac <bdmaStreamFreeI+0x4c>)
 8002a8a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8002a8e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002a92:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  RCC_C1->AHB4LPENR &= ~mask;
 8002a96:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 8002a9a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002a9e:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 8002aa2:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    rccDisableBDMA1();
  }
}
 8002aa6:	bd10      	pop	{r4, pc}
 8002aa8:	24000770 	.word	0x24000770
 8002aac:	58024400 	.word	0x58024400

08002ab0 <bdmaSetRequestSource>:
 */
void bdmaSetRequestSource(const stm32_bdma_stream_t *stp, uint32_t per) {

  osalDbgCheck(per < 256U);

  stp->mux->CCR = per;
 8002ab0:	68c3      	ldr	r3, [r0, #12]
 8002ab2:	6019      	str	r1, [r3, #0]
}
 8002ab4:	4770      	bx	lr
 8002ab6:	bf00      	nop

08002ab8 <Vector6C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ab8:	480a      	ldr	r0, [pc, #40]	; (8002ae4 <Vector6C+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8002aba:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8002abc:	f003 f94e 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002ac0:	4b09      	ldr	r3, [pc, #36]	; (8002ae8 <Vector6C+0x30>)
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
 8002ac2:	480a      	ldr	r0, [pc, #40]	; (8002aec <Vector6C+0x34>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002ac4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 8002ac6:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002ac8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8002acc:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8002ace:	b10a      	cbz	r2, 8002ad4 <Vector6C+0x1c>
    dma.streams[0].func(dma.streams[0].param, flags);
 8002ad0:	6880      	ldr	r0, [r0, #8]
 8002ad2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002ad4:	4803      	ldr	r0, [pc, #12]	; (8002ae4 <Vector6C+0x2c>)
 8002ad6:	f003 f959 	bl	8005d8c <__trace_isr_leave>
}
 8002ada:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8002ade:	f004 b8cd 	b.w	8006c7c <__port_irq_epilogue>
 8002ae2:	bf00      	nop
 8002ae4:	08014c5c 	.word	0x08014c5c
 8002ae8:	40020000 	.word	0x40020000
 8002aec:	240007b4 	.word	0x240007b4

08002af0 <Vector70>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002af0:	480b      	ldr	r0, [pc, #44]	; (8002b20 <Vector70+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002af2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002af4:	f003 f932 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002af8:	4b0a      	ldr	r3, [pc, #40]	; (8002b24 <Vector70+0x34>)
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
 8002afa:	480b      	ldr	r0, [pc, #44]	; (8002b28 <Vector70+0x38>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002afc:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[1].func)
 8002afe:	68c2      	ldr	r2, [r0, #12]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002b00:	0989      	lsrs	r1, r1, #6
 8002b02:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 8002b06:	018c      	lsls	r4, r1, #6
 8002b08:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
 8002b0a:	b10a      	cbz	r2, 8002b10 <Vector70+0x20>
    dma.streams[1].func(dma.streams[1].param, flags);
 8002b0c:	6900      	ldr	r0, [r0, #16]
 8002b0e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002b10:	4803      	ldr	r0, [pc, #12]	; (8002b20 <Vector70+0x30>)
 8002b12:	f003 f93b 	bl	8005d8c <__trace_isr_leave>
}
 8002b16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002b1a:	f004 b8af 	b.w	8006c7c <__port_irq_epilogue>
 8002b1e:	bf00      	nop
 8002b20:	08014c50 	.word	0x08014c50
 8002b24:	40020000 	.word	0x40020000
 8002b28:	240007b4 	.word	0x240007b4

08002b2c <Vector74>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002b2c:	480b      	ldr	r0, [pc, #44]	; (8002b5c <Vector74+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8002b2e:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002b30:	f003 f914 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002b34:	4b0a      	ldr	r3, [pc, #40]	; (8002b60 <Vector74+0x34>)
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
 8002b36:	480b      	ldr	r0, [pc, #44]	; (8002b64 <Vector74+0x38>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002b38:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[2].func)
 8002b3a:	6942      	ldr	r2, [r0, #20]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002b3c:	0c09      	lsrs	r1, r1, #16
 8002b3e:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 8002b42:	040c      	lsls	r4, r1, #16
 8002b44:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
 8002b46:	b10a      	cbz	r2, 8002b4c <Vector74+0x20>
    dma.streams[2].func(dma.streams[2].param, flags);
 8002b48:	6980      	ldr	r0, [r0, #24]
 8002b4a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002b4c:	4803      	ldr	r0, [pc, #12]	; (8002b5c <Vector74+0x30>)
 8002b4e:	f003 f91d 	bl	8005d8c <__trace_isr_leave>
}
 8002b52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002b56:	f004 b891 	b.w	8006c7c <__port_irq_epilogue>
 8002b5a:	bf00      	nop
 8002b5c:	08014c44 	.word	0x08014c44
 8002b60:	40020000 	.word	0x40020000
 8002b64:	240007b4 	.word	0x240007b4

08002b68 <Vector78>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002b68:	480b      	ldr	r0, [pc, #44]	; (8002b98 <Vector78+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8002b6a:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002b6c:	f003 f8f6 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002b70:	4b0a      	ldr	r3, [pc, #40]	; (8002b9c <Vector78+0x34>)
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
 8002b72:	480b      	ldr	r0, [pc, #44]	; (8002ba0 <Vector78+0x38>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002b74:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[3].func)
 8002b76:	69c2      	ldr	r2, [r0, #28]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002b78:	0d89      	lsrs	r1, r1, #22
 8002b7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 8002b7e:	058c      	lsls	r4, r1, #22
 8002b80:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
 8002b82:	b10a      	cbz	r2, 8002b88 <Vector78+0x20>
    dma.streams[3].func(dma.streams[3].param, flags);
 8002b84:	6a00      	ldr	r0, [r0, #32]
 8002b86:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002b88:	4803      	ldr	r0, [pc, #12]	; (8002b98 <Vector78+0x30>)
 8002b8a:	f003 f8ff 	bl	8005d8c <__trace_isr_leave>
}
 8002b8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002b92:	f004 b873 	b.w	8006c7c <__port_irq_epilogue>
 8002b96:	bf00      	nop
 8002b98:	08014c38 	.word	0x08014c38
 8002b9c:	40020000 	.word	0x40020000
 8002ba0:	240007b4 	.word	0x240007b4

08002ba4 <Vector7C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002ba4:	480a      	ldr	r0, [pc, #40]	; (8002bd0 <Vector7C+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002ba6:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8002ba8:	f003 f8d8 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002bac:	4b09      	ldr	r3, [pc, #36]	; (8002bd4 <Vector7C+0x30>)
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
 8002bae:	480a      	ldr	r0, [pc, #40]	; (8002bd8 <Vector7C+0x34>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002bb0:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 8002bb2:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002bb4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8002bb8:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 8002bba:	b10a      	cbz	r2, 8002bc0 <Vector7C+0x1c>
    dma.streams[4].func(dma.streams[4].param, flags);
 8002bbc:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8002bbe:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002bc0:	4803      	ldr	r0, [pc, #12]	; (8002bd0 <Vector7C+0x2c>)
 8002bc2:	f003 f8e3 	bl	8005d8c <__trace_isr_leave>
}
 8002bc6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8002bca:	f004 b857 	b.w	8006c7c <__port_irq_epilogue>
 8002bce:	bf00      	nop
 8002bd0:	08014c2c 	.word	0x08014c2c
 8002bd4:	40020000 	.word	0x40020000
 8002bd8:	240007b4 	.word	0x240007b4

08002bdc <Vector80>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002bdc:	480b      	ldr	r0, [pc, #44]	; (8002c0c <Vector80+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002bde:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002be0:	f003 f8bc 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002be4:	4b0a      	ldr	r3, [pc, #40]	; (8002c10 <Vector80+0x34>)
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
 8002be6:	480b      	ldr	r0, [pc, #44]	; (8002c14 <Vector80+0x38>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002be8:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[5].func)
 8002bea:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002bec:	0989      	lsrs	r1, r1, #6
 8002bee:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 8002bf2:	018c      	lsls	r4, r1, #6
 8002bf4:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
 8002bf6:	b10a      	cbz	r2, 8002bfc <Vector80+0x20>
    dma.streams[5].func(dma.streams[5].param, flags);
 8002bf8:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8002bfa:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002bfc:	4803      	ldr	r0, [pc, #12]	; (8002c0c <Vector80+0x30>)
 8002bfe:	f003 f8c5 	bl	8005d8c <__trace_isr_leave>
}
 8002c02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002c06:	f004 b839 	b.w	8006c7c <__port_irq_epilogue>
 8002c0a:	bf00      	nop
 8002c0c:	08014c20 	.word	0x08014c20
 8002c10:	40020000 	.word	0x40020000
 8002c14:	240007b4 	.word	0x240007b4

08002c18 <Vector84>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c18:	480b      	ldr	r0, [pc, #44]	; (8002c48 <Vector84+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8002c1a:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002c1c:	f003 f89e 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002c20:	4b0a      	ldr	r3, [pc, #40]	; (8002c4c <Vector84+0x34>)
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
 8002c22:	480b      	ldr	r0, [pc, #44]	; (8002c50 <Vector84+0x38>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002c24:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[6].func)
 8002c26:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002c28:	0c09      	lsrs	r1, r1, #16
 8002c2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 8002c2e:	040c      	lsls	r4, r1, #16
 8002c30:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
 8002c32:	b10a      	cbz	r2, 8002c38 <Vector84+0x20>
    dma.streams[6].func(dma.streams[6].param, flags);
 8002c34:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002c36:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002c38:	4803      	ldr	r0, [pc, #12]	; (8002c48 <Vector84+0x30>)
 8002c3a:	f003 f8a7 	bl	8005d8c <__trace_isr_leave>
}
 8002c3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002c42:	f004 b81b 	b.w	8006c7c <__port_irq_epilogue>
 8002c46:	bf00      	nop
 8002c48:	08014cbc 	.word	0x08014cbc
 8002c4c:	40020000 	.word	0x40020000
 8002c50:	240007b4 	.word	0x240007b4

08002c54 <VectorFC>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c54:	480b      	ldr	r0, [pc, #44]	; (8002c84 <VectorFC+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002c56:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002c58:	f003 f880 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002c5c:	4b0a      	ldr	r3, [pc, #40]	; (8002c88 <VectorFC+0x34>)
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
 8002c5e:	480b      	ldr	r0, [pc, #44]	; (8002c8c <VectorFC+0x38>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002c60:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[7].func)
 8002c62:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002c64:	0d89      	lsrs	r1, r1, #22
 8002c66:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 8002c6a:	058c      	lsls	r4, r1, #22
 8002c6c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
 8002c6e:	b10a      	cbz	r2, 8002c74 <VectorFC+0x20>
    dma.streams[7].func(dma.streams[7].param, flags);
 8002c70:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8002c72:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002c74:	4803      	ldr	r0, [pc, #12]	; (8002c84 <VectorFC+0x30>)
 8002c76:	f003 f889 	bl	8005d8c <__trace_isr_leave>
}
 8002c7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002c7e:	f003 bffd 	b.w	8006c7c <__port_irq_epilogue>
 8002c82:	bf00      	nop
 8002c84:	08014cb0 	.word	0x08014cb0
 8002c88:	40020000 	.word	0x40020000
 8002c8c:	240007b4 	.word	0x240007b4

08002c90 <Vector120>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002c90:	480a      	ldr	r0, [pc, #40]	; (8002cbc <Vector120+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8002c92:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8002c94:	f003 f862 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002c98:	4b09      	ldr	r3, [pc, #36]	; (8002cc0 <Vector120+0x30>)
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
 8002c9a:	480a      	ldr	r0, [pc, #40]	; (8002cc4 <Vector120+0x34>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002c9c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 8002c9e:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002ca0:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8002ca4:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 8002ca6:	b10a      	cbz	r2, 8002cac <Vector120+0x1c>
    dma.streams[8].func(dma.streams[8].param, flags);
 8002ca8:	6c80      	ldr	r0, [r0, #72]	; 0x48
 8002caa:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002cac:	4803      	ldr	r0, [pc, #12]	; (8002cbc <Vector120+0x2c>)
 8002cae:	f003 f86d 	bl	8005d8c <__trace_isr_leave>
}
 8002cb2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8002cb6:	f003 bfe1 	b.w	8006c7c <__port_irq_epilogue>
 8002cba:	bf00      	nop
 8002cbc:	08014ca4 	.word	0x08014ca4
 8002cc0:	40020400 	.word	0x40020400
 8002cc4:	240007b4 	.word	0x240007b4

08002cc8 <Vector124>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002cc8:	480b      	ldr	r0, [pc, #44]	; (8002cf8 <Vector124+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8002cca:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002ccc:	f003 f846 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002cd0:	4b0a      	ldr	r3, [pc, #40]	; (8002cfc <Vector124+0x34>)
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
 8002cd2:	480b      	ldr	r0, [pc, #44]	; (8002d00 <Vector124+0x38>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002cd4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[9].func)
 8002cd6:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002cd8:	0989      	lsrs	r1, r1, #6
 8002cda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 8002cde:	018c      	lsls	r4, r1, #6
 8002ce0:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
 8002ce2:	b10a      	cbz	r2, 8002ce8 <Vector124+0x20>
    dma.streams[9].func(dma.streams[9].param, flags);
 8002ce4:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8002ce6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002ce8:	4803      	ldr	r0, [pc, #12]	; (8002cf8 <Vector124+0x30>)
 8002cea:	f003 f84f 	bl	8005d8c <__trace_isr_leave>
}
 8002cee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002cf2:	f003 bfc3 	b.w	8006c7c <__port_irq_epilogue>
 8002cf6:	bf00      	nop
 8002cf8:	08014c98 	.word	0x08014c98
 8002cfc:	40020400 	.word	0x40020400
 8002d00:	240007b4 	.word	0x240007b4

08002d04 <Vector128>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d04:	480b      	ldr	r0, [pc, #44]	; (8002d34 <Vector128+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8002d06:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002d08:	f003 f828 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002d0c:	4b0a      	ldr	r3, [pc, #40]	; (8002d38 <Vector128+0x34>)
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
 8002d0e:	480b      	ldr	r0, [pc, #44]	; (8002d3c <Vector128+0x38>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002d10:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[10].func)
 8002d12:	6d42      	ldr	r2, [r0, #84]	; 0x54
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002d14:	0c09      	lsrs	r1, r1, #16
 8002d16:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 8002d1a:	040c      	lsls	r4, r1, #16
 8002d1c:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
 8002d1e:	b10a      	cbz	r2, 8002d24 <Vector128+0x20>
    dma.streams[10].func(dma.streams[10].param, flags);
 8002d20:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8002d22:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002d24:	4803      	ldr	r0, [pc, #12]	; (8002d34 <Vector128+0x30>)
 8002d26:	f003 f831 	bl	8005d8c <__trace_isr_leave>
}
 8002d2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002d2e:	f003 bfa5 	b.w	8006c7c <__port_irq_epilogue>
 8002d32:	bf00      	nop
 8002d34:	08014c8c 	.word	0x08014c8c
 8002d38:	40020400 	.word	0x40020400
 8002d3c:	240007b4 	.word	0x240007b4

08002d40 <Vector12C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d40:	480b      	ldr	r0, [pc, #44]	; (8002d70 <Vector12C+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8002d42:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002d44:	f003 f80a 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002d48:	4b0a      	ldr	r3, [pc, #40]	; (8002d74 <Vector12C+0x34>)
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
 8002d4a:	480b      	ldr	r0, [pc, #44]	; (8002d78 <Vector12C+0x38>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002d4c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[11].func)
 8002d4e:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002d50:	0d89      	lsrs	r1, r1, #22
 8002d52:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 8002d56:	058c      	lsls	r4, r1, #22
 8002d58:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
 8002d5a:	b10a      	cbz	r2, 8002d60 <Vector12C+0x20>
    dma.streams[11].func(dma.streams[11].param, flags);
 8002d5c:	6e00      	ldr	r0, [r0, #96]	; 0x60
 8002d5e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002d60:	4803      	ldr	r0, [pc, #12]	; (8002d70 <Vector12C+0x30>)
 8002d62:	f003 f813 	bl	8005d8c <__trace_isr_leave>
}
 8002d66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002d6a:	f003 bf87 	b.w	8006c7c <__port_irq_epilogue>
 8002d6e:	bf00      	nop
 8002d70:	08014c80 	.word	0x08014c80
 8002d74:	40020400 	.word	0x40020400
 8002d78:	240007b4 	.word	0x240007b4

08002d7c <Vector130>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002d7c:	480a      	ldr	r0, [pc, #40]	; (8002da8 <Vector130+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8002d7e:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8002d80:	f002 ffec 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002d84:	4b09      	ldr	r3, [pc, #36]	; (8002dac <Vector130+0x30>)
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
 8002d86:	480a      	ldr	r0, [pc, #40]	; (8002db0 <Vector130+0x34>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002d88:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 8002d8a:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002d8c:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8002d90:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 8002d92:	b10a      	cbz	r2, 8002d98 <Vector130+0x1c>
    dma.streams[12].func(dma.streams[12].param, flags);
 8002d94:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8002d96:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002d98:	4803      	ldr	r0, [pc, #12]	; (8002da8 <Vector130+0x2c>)
 8002d9a:	f002 fff7 	bl	8005d8c <__trace_isr_leave>
}
 8002d9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8002da2:	f003 bf6b 	b.w	8006c7c <__port_irq_epilogue>
 8002da6:	bf00      	nop
 8002da8:	08014c74 	.word	0x08014c74
 8002dac:	40020400 	.word	0x40020400
 8002db0:	240007b4 	.word	0x240007b4

08002db4 <Vector150>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002db4:	480b      	ldr	r0, [pc, #44]	; (8002de4 <Vector150+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8002db6:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002db8:	f002 ffd0 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002dbc:	4b0a      	ldr	r3, [pc, #40]	; (8002de8 <Vector150+0x34>)
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
 8002dbe:	480b      	ldr	r0, [pc, #44]	; (8002dec <Vector150+0x38>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002dc0:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[13].func)
 8002dc2:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002dc4:	0989      	lsrs	r1, r1, #6
 8002dc6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 8002dca:	018c      	lsls	r4, r1, #6
 8002dcc:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
 8002dce:	b10a      	cbz	r2, 8002dd4 <Vector150+0x20>
    dma.streams[13].func(dma.streams[13].param, flags);
 8002dd0:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8002dd2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002dd4:	4803      	ldr	r0, [pc, #12]	; (8002de4 <Vector150+0x30>)
 8002dd6:	f002 ffd9 	bl	8005d8c <__trace_isr_leave>
}
 8002dda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002dde:	f003 bf4d 	b.w	8006c7c <__port_irq_epilogue>
 8002de2:	bf00      	nop
 8002de4:	08014c68 	.word	0x08014c68
 8002de8:	40020400 	.word	0x40020400
 8002dec:	240007b4 	.word	0x240007b4

08002df0 <Vector154>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002df0:	480b      	ldr	r0, [pc, #44]	; (8002e20 <Vector154+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8002df2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002df4:	f002 ffb2 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002df8:	4b0a      	ldr	r3, [pc, #40]	; (8002e24 <Vector154+0x34>)
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
 8002dfa:	480b      	ldr	r0, [pc, #44]	; (8002e28 <Vector154+0x38>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002dfc:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[14].func)
 8002dfe:	6f42      	ldr	r2, [r0, #116]	; 0x74
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002e00:	0c09      	lsrs	r1, r1, #16
 8002e02:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 8002e06:	040c      	lsls	r4, r1, #16
 8002e08:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
 8002e0a:	b10a      	cbz	r2, 8002e10 <Vector154+0x20>
    dma.streams[14].func(dma.streams[14].param, flags);
 8002e0c:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8002e0e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002e10:	4803      	ldr	r0, [pc, #12]	; (8002e20 <Vector154+0x30>)
 8002e12:	f002 ffbb 	bl	8005d8c <__trace_isr_leave>
}
 8002e16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002e1a:	f003 bf2f 	b.w	8006c7c <__port_irq_epilogue>
 8002e1e:	bf00      	nop
 8002e20:	08014c14 	.word	0x08014c14
 8002e24:	40020400 	.word	0x40020400
 8002e28:	240007b4 	.word	0x240007b4

08002e2c <Vector158>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002e2c:	480b      	ldr	r0, [pc, #44]	; (8002e5c <Vector158+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8002e2e:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8002e30:	f002 ff94 	bl	8005d5c <__trace_isr_enter>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002e34:	4b0a      	ldr	r3, [pc, #40]	; (8002e60 <Vector158+0x34>)
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
 8002e36:	480b      	ldr	r0, [pc, #44]	; (8002e64 <Vector158+0x38>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002e38:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[15].func)
 8002e3a:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002e3c:	0d89      	lsrs	r1, r1, #22
 8002e3e:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 8002e42:	058c      	lsls	r4, r1, #22
 8002e44:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
 8002e46:	b112      	cbz	r2, 8002e4e <Vector158+0x22>
    dma.streams[15].func(dma.streams[15].param, flags);
 8002e48:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8002e4c:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002e4e:	4803      	ldr	r0, [pc, #12]	; (8002e5c <Vector158+0x30>)
 8002e50:	f002 ff9c 	bl	8005d8c <__trace_isr_leave>
}
 8002e54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002e58:	f003 bf10 	b.w	8006c7c <__port_irq_epilogue>
 8002e5c:	08014c08 	.word	0x08014c08
 8002e60:	40020400 	.word	0x40020400
 8002e64:	240007b4 	.word	0x240007b4

08002e68 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 8002e68:	2200      	movs	r2, #0
 8002e6a:	480d      	ldr	r0, [pc, #52]	; (8002ea0 <dmaInit+0x38>)
void dmaInit(void) {
 8002e6c:	b430      	push	{r4, r5}
  dma.allocated_mask = 0U;
 8002e6e:	4c0d      	ldr	r4, [pc, #52]	; (8002ea4 <dmaInit+0x3c>)
 8002e70:	4613      	mov	r3, r2
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002e72:	4d0d      	ldr	r5, [pc, #52]	; (8002ea8 <dmaInit+0x40>)
  dma.allocated_mask = 0U;
 8002e74:	6022      	str	r2, [r4, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002e76:	e001      	b.n	8002e7c <dmaInit+0x14>
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002e78:	f855 0033 	ldr.w	r0, [r5, r3, lsl #3]
    dma.streams[i].func = NULL;
 8002e7c:	eb04 0183 	add.w	r1, r4, r3, lsl #2
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002e80:	3302      	adds	r3, #2
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002e82:	6002      	str	r2, [r0, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002e84:	2b20      	cmp	r3, #32
    dma.streams[i].func = NULL;
 8002e86:	604a      	str	r2, [r1, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002e88:	d1f6      	bne.n	8002e78 <dmaInit+0x10>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8002e8a:	f04f 33ff 	mov.w	r3, #4294967295
 8002e8e:	4907      	ldr	r1, [pc, #28]	; (8002eac <dmaInit+0x44>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8002e90:	4a07      	ldr	r2, [pc, #28]	; (8002eb0 <dmaInit+0x48>)
  DMA1->LIFCR = 0xFFFFFFFFU;
 8002e92:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8002e94:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8002e96:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8002e98:	60d3      	str	r3, [r2, #12]
}
 8002e9a:	bc30      	pop	{r4, r5}
 8002e9c:	4770      	bx	lr
 8002e9e:	bf00      	nop
 8002ea0:	40020010 	.word	0x40020010
 8002ea4:	240007b4 	.word	0x240007b4
 8002ea8:	08014cc8 	.word	0x08014cc8
 8002eac:	40020000 	.word	0x40020000
 8002eb0:	40020400 	.word	0x40020400

08002eb4 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8002eb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002eb6:	2812      	cmp	r0, #18
 8002eb8:	d820      	bhi.n	8002efc <dmaStreamAllocI+0x48>
 8002eba:	e8df f000 	tbb	[pc, r0]
 8002ebe:	0a0a      	.short	0x0a0a
 8002ec0:	0a0a0a0a 	.word	0x0a0a0a0a
 8002ec4:	0a0a0a0a 	.word	0x0a0a0a0a
 8002ec8:	0a0a0a0a 	.word	0x0a0a0a0a
 8002ecc:	746f0a0a 	.word	0x746f0a0a
 8002ed0:	79          	.byte	0x79
 8002ed1:	00          	.byte	0x00
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
 8002ed2:	f04f 0c01 	mov.w	ip, #1
 8002ed6:	4605      	mov	r5, r0
 8002ed8:	fa0c fc00 	lsl.w	ip, ip, r0
    if ((dma.allocated_mask & mask) == 0U) {
 8002edc:	4e37      	ldr	r6, [pc, #220]	; (8002fbc <dmaStreamAllocI+0x108>)
 8002ede:	6834      	ldr	r4, [r6, #0]
 8002ee0:	ea14 0f0c 	tst.w	r4, ip
 8002ee4:	d00d      	beq.n	8002f02 <dmaStreamAllocI+0x4e>
    uint32_t mask = (1U << i);
 8002ee6:	f04f 0e01 	mov.w	lr, #1
 8002eea:	e002      	b.n	8002ef2 <dmaStreamAllocI+0x3e>
    if ((dma.allocated_mask & mask) == 0U) {
 8002eec:	ea14 0f0c 	tst.w	r4, ip
 8002ef0:	d007      	beq.n	8002f02 <dmaStreamAllocI+0x4e>
  for (i = startid; i <= endid; i++) {
 8002ef2:	3001      	adds	r0, #1
 8002ef4:	42a8      	cmp	r0, r5
    uint32_t mask = (1U << i);
 8002ef6:	fa0e fc00 	lsl.w	ip, lr, r0
  for (i = startid; i <= endid; i++) {
 8002efa:	d9f7      	bls.n	8002eec <dmaStreamAllocI+0x38>
                                          void *param) {
 8002efc:	2500      	movs	r5, #0
      return dmastp;
    }
  }

  return NULL;
}
 8002efe:	4628      	mov	r0, r5
 8002f00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      dma.allocated_mask  |= mask;
 8002f02:	ea44 040c 	orr.w	r4, r4, ip
 8002f06:	6034      	str	r4, [r6, #0]
      dma.streams[i].func  = func;
 8002f08:	eb06 06c0 	add.w	r6, r6, r0, lsl #3
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8002f0c:	4c2c      	ldr	r4, [pc, #176]	; (8002fc0 <dmaStreamAllocI+0x10c>)
      dma.streams[i].func  = func;
 8002f0e:	e9c6 2301 	strd	r2, r3, [r6, #4]
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8002f12:	fa5f f38c 	uxtb.w	r3, ip
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8002f16:	0106      	lsls	r6, r0, #4
 8002f18:	eb04 1500 	add.w	r5, r4, r0, lsl #4
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8002f1c:	b173      	cbz	r3, 8002f3c <dmaStreamAllocI+0x88>
  RCC_C1->AHB1ENR |= mask;
 8002f1e:	4b29      	ldr	r3, [pc, #164]	; (8002fc4 <dmaStreamAllocI+0x110>)
 8002f20:	f8d3 00d8 	ldr.w	r0, [r3, #216]	; 0xd8
 8002f24:	f040 0001 	orr.w	r0, r0, #1
 8002f28:	f8c3 00d8 	str.w	r0, [r3, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 8002f2c:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
 8002f30:	f040 0001 	orr.w	r0, r0, #1
 8002f34:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8002f38:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 8002f3c:	f41c 4f7f 	tst.w	ip, #65280	; 0xff00
 8002f40:	d11c      	bne.n	8002f7c <dmaStreamAllocI+0xc8>
      dmaStreamDisable(dmastp);
 8002f42:	59a0      	ldr	r0, [r4, r6]
 8002f44:	6803      	ldr	r3, [r0, #0]
 8002f46:	f023 031f 	bic.w	r3, r3, #31
 8002f4a:	6003      	str	r3, [r0, #0]
 8002f4c:	6803      	ldr	r3, [r0, #0]
 8002f4e:	f013 0301 	ands.w	r3, r3, #1
 8002f52:	d1fb      	bne.n	8002f4c <dmaStreamAllocI+0x98>
 8002f54:	4434      	add	r4, r6
 8002f56:	263d      	movs	r6, #61	; 0x3d
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8002f58:	f04f 0e21 	mov.w	lr, #33	; 0x21
      dmaStreamDisable(dmastp);
 8002f5c:	f894 c00c 	ldrb.w	ip, [r4, #12]
 8002f60:	6867      	ldr	r7, [r4, #4]
 8002f62:	fa06 f60c 	lsl.w	r6, r6, ip
 8002f66:	603e      	str	r6, [r7, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002f68:	6003      	str	r3, [r0, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8002f6a:	f8c0 e014 	str.w	lr, [r0, #20]
      if (func != NULL) {
 8002f6e:	2a00      	cmp	r2, #0
 8002f70:	d0c5      	beq.n	8002efe <dmaStreamAllocI+0x4a>
        nvicEnableVector(dmastp->vector, priority);
 8002f72:	7ba0      	ldrb	r0, [r4, #14]
 8002f74:	f7fe fef2 	bl	8001d5c <nvicEnableVector>
}
 8002f78:	4628      	mov	r0, r5
 8002f7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  RCC_C1->AHB1ENR |= mask;
 8002f7c:	4b11      	ldr	r3, [pc, #68]	; (8002fc4 <dmaStreamAllocI+0x110>)
 8002f7e:	f8d3 00d8 	ldr.w	r0, [r3, #216]	; 0xd8
 8002f82:	f040 0002 	orr.w	r0, r0, #2
 8002f86:	f8c3 00d8 	str.w	r0, [r3, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 8002f8a:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
 8002f8e:	f040 0002 	orr.w	r0, r0, #2
 8002f92:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8002f96:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
}
 8002f9a:	e7d2      	b.n	8002f42 <dmaStreamAllocI+0x8e>
                                          void *param) {
 8002f9c:	f04f 0c01 	mov.w	ip, #1
 8002fa0:	250f      	movs	r5, #15
 8002fa2:	2000      	movs	r0, #0
 8002fa4:	e79a      	b.n	8002edc <dmaStreamAllocI+0x28>
  return NULL;
 8002fa6:	f04f 0c01 	mov.w	ip, #1
 8002faa:	2507      	movs	r5, #7
 8002fac:	2000      	movs	r0, #0
  for (i = startid; i <= endid; i++) {
 8002fae:	e795      	b.n	8002edc <dmaStreamAllocI+0x28>
  return NULL;
 8002fb0:	f04f 0c80 	mov.w	ip, #128	; 0x80
 8002fb4:	250f      	movs	r5, #15
 8002fb6:	2007      	movs	r0, #7
 8002fb8:	e790      	b.n	8002edc <dmaStreamAllocI+0x28>
 8002fba:	bf00      	nop
 8002fbc:	240007b4 	.word	0x240007b4
 8002fc0:	08014cc8 	.word	0x08014cc8
 8002fc4:	58024400 	.word	0x58024400

08002fc8 <dmaStreamAlloc>:
 * @api
 */
const stm32_dma_stream_t *dmaStreamAlloc(uint32_t id,
                                         uint32_t priority,
                                         stm32_dmaisr_t func,
                                         void *param) {
 8002fc8:	b508      	push	{r3, lr}
 8002fca:	f04f 0c30 	mov.w	ip, #48	; 0x30
 8002fce:	f38c 8811 	msr	BASEPRI, ip
  const stm32_dma_stream_t *dmastp;

  osalSysLock();
  dmastp = dmaStreamAllocI(id, priority, func, param);
 8002fd2:	f7ff ff6f 	bl	8002eb4 <dmaStreamAllocI>
 8002fd6:	2300      	movs	r3, #0
 8002fd8:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();

  return dmastp;
}
 8002fdc:	bd08      	pop	{r3, pc}
 8002fde:	bf00      	nop

08002fe0 <dmaStreamFreeI>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @iclass
 */
void dmaStreamFreeI(const stm32_dma_stream_t *dmastp) {
 8002fe0:	b510      	push	{r4, lr}
 8002fe2:	4604      	mov	r4, r0
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma.allocated_mask & (1U << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 8002fe4:	7b80      	ldrb	r0, [r0, #14]
 8002fe6:	f7fe fed1 	bl	8001d8c <nvicDisableVector>

  /* Marks the stream as not allocated.*/
  dma.allocated_mask &= ~(1U << dmastp->selfindex);
 8002fea:	4916      	ldr	r1, [pc, #88]	; (8003044 <dmaStreamFreeI+0x64>)
 8002fec:	7b60      	ldrb	r0, [r4, #13]
 8002fee:	2201      	movs	r2, #1
 8002ff0:	680b      	ldr	r3, [r1, #0]
 8002ff2:	4082      	lsls	r2, r0
 8002ff4:	ea23 0302 	bic.w	r3, r3, r2

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma.allocated_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8002ff8:	b2da      	uxtb	r2, r3
  dma.allocated_mask &= ~(1U << dmastp->selfindex);
 8002ffa:	600b      	str	r3, [r1, #0]
  if ((dma.allocated_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8002ffc:	b972      	cbnz	r2, 800301c <dmaStreamFreeI+0x3c>
  RCC_C1->AHB1ENR &= ~mask;
 8002ffe:	4a12      	ldr	r2, [pc, #72]	; (8003048 <dmaStreamFreeI+0x68>)
 8003000:	f8d2 10d8 	ldr.w	r1, [r2, #216]	; 0xd8
 8003004:	f021 0101 	bic.w	r1, r1, #1
 8003008:	f8c2 10d8 	str.w	r1, [r2, #216]	; 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 800300c:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
 8003010:	f021 0101 	bic.w	r1, r1, #1
 8003014:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8003018:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    rccDisableDMA1();
  }
  if ((dma.allocated_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 800301c:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 8003020:	d10e      	bne.n	8003040 <dmaStreamFreeI+0x60>
  RCC_C1->AHB1ENR &= ~mask;
 8003022:	4b09      	ldr	r3, [pc, #36]	; (8003048 <dmaStreamFreeI+0x68>)
 8003024:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 8003028:	f022 0202 	bic.w	r2, r2, #2
 800302c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 8003030:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 8003034:	f022 0202 	bic.w	r2, r2, #2
 8003038:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 800303c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
  /* Shutting down DMAMUX if present.*/
  if (dma.allocated_mask == 0U) {
    rccDisableDMAMUX();
  }
#endif
}
 8003040:	bd10      	pop	{r4, pc}
 8003042:	bf00      	nop
 8003044:	240007b4 	.word	0x240007b4
 8003048:	58024400 	.word	0x58024400

0800304c <dmaSetRequestSource>:
 */
void dmaSetRequestSource(const stm32_dma_stream_t *dmastp, uint32_t per) {

  osalDbgCheck(per < 256U);

  dmastp->mux->CCR = per;
 800304c:	6883      	ldr	r3, [r0, #8]
 800304e:	6019      	str	r1, [r3, #0]
}
 8003050:	4770      	bx	lr
 8003052:	bf00      	nop

08003054 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8003054:	4770      	bx	lr
 8003056:	bf00      	nop

08003058 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8003058:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800305c:	f002 0903 	and.w	r9, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8003060:	f3c2 1441 	ubfx	r4, r2, #5, #2
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8003064:	f3c2 0680 	ubfx	r6, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8003068:	f3c2 05c1 	ubfx	r5, r2, #3, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800306c:	f3c2 17c3 	ubfx	r7, r2, #7, #4
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8003070:	46ce      	mov	lr, r9
  uint32_t bit     = 0;
 8003072:	2200      	movs	r2, #0
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8003074:	f04f 0b0f 	mov.w	fp, #15
      m2 = 3 << (bit * 2);
 8003078:	46a0      	mov	r8, r4
 800307a:	e016      	b.n	80030aa <_pal_lld_setgroupmode+0x52>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800307c:	6803      	ldr	r3, [r0, #0]
        if (bit < 8)
 800307e:	2a07      	cmp	r2, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 8003080:	ea0a 0303 	and.w	r3, sl, r3
 8003084:	ea43 030e 	orr.w	r3, r3, lr
 8003088:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 800308a:	d84a      	bhi.n	8003122 <_pal_lld_setgroupmode+0xca>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800308c:	6a03      	ldr	r3, [r0, #32]
 800308e:	ea23 0304 	bic.w	r3, r3, r4
 8003092:	ea43 030c 	orr.w	r3, r3, ip
 8003096:	6203      	str	r3, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8003098:	0849      	lsrs	r1, r1, #1
 800309a:	d040      	beq.n	800311e <_pal_lld_setgroupmode+0xc6>
      return;
    otyper <<= 1;
 800309c:	0076      	lsls	r6, r6, #1
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
 800309e:	3201      	adds	r2, #1
    ospeedr <<= 2;
 80030a0:	00ad      	lsls	r5, r5, #2
    pupdr <<= 2;
 80030a2:	ea4f 0888 	mov.w	r8, r8, lsl #2
    moder <<= 2;
 80030a6:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    if ((mask & 1) != 0) {
 80030aa:	07cb      	lsls	r3, r1, #31
 80030ac:	d5f4      	bpl.n	8003098 <_pal_lld_setgroupmode+0x40>
      m1 = 1 << bit;
 80030ae:	2401      	movs	r4, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80030b0:	6843      	ldr	r3, [r0, #4]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80030b2:	f1b9 0f02 	cmp.w	r9, #2
      m1 = 1 << bit;
 80030b6:	fa04 f402 	lsl.w	r4, r4, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80030ba:	ea23 0304 	bic.w	r3, r3, r4
      m2 = 3 << (bit * 2);
 80030be:	f04f 0403 	mov.w	r4, #3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80030c2:	ea43 0306 	orr.w	r3, r3, r6
 80030c6:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
 80030c8:	ea4f 0342 	mov.w	r3, r2, lsl #1
 80030cc:	fa04 f303 	lsl.w	r3, r4, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80030d0:	6884      	ldr	r4, [r0, #8]
 80030d2:	ea24 0403 	bic.w	r4, r4, r3
 80030d6:	ea6f 0a03 	mvn.w	sl, r3
 80030da:	ea44 0405 	orr.w	r4, r4, r5
 80030de:	6084      	str	r4, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80030e0:	68c4      	ldr	r4, [r0, #12]
 80030e2:	ea24 0c03 	bic.w	ip, r4, r3
      altrmask = altr << ((bit & 7) * 4);
 80030e6:	f002 0407 	and.w	r4, r2, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80030ea:	ea4c 0308 	orr.w	r3, ip, r8
      altrmask = altr << ((bit & 7) * 4);
 80030ee:	ea4f 0484 	mov.w	r4, r4, lsl #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80030f2:	60c3      	str	r3, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 80030f4:	fa07 fc04 	lsl.w	ip, r7, r4
      m4 = 15 << ((bit & 7) * 4);
 80030f8:	fa0b f404 	lsl.w	r4, fp, r4
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80030fc:	d1be      	bne.n	800307c <_pal_lld_setgroupmode+0x24>
        if (bit < 8)
 80030fe:	2a07      	cmp	r2, #7
 8003100:	d816      	bhi.n	8003130 <_pal_lld_setgroupmode+0xd8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003102:	6a03      	ldr	r3, [r0, #32]
 8003104:	ea23 0304 	bic.w	r3, r3, r4
 8003108:	ea43 030c 	orr.w	r3, r3, ip
 800310c:	6203      	str	r3, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 800310e:	6803      	ldr	r3, [r0, #0]
    if (!mask)
 8003110:	0849      	lsrs	r1, r1, #1
        port->MODER   = (port->MODER & ~m2) | moder;
 8003112:	ea0a 0303 	and.w	r3, sl, r3
 8003116:	ea43 030e 	orr.w	r3, r3, lr
 800311a:	6003      	str	r3, [r0, #0]
    if (!mask)
 800311c:	d1be      	bne.n	800309c <_pal_lld_setgroupmode+0x44>
  }
}
 800311e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003122:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003124:	ea23 0304 	bic.w	r3, r3, r4
 8003128:	ea43 030c 	orr.w	r3, r3, ip
 800312c:	6243      	str	r3, [r0, #36]	; 0x24
 800312e:	e7b3      	b.n	8003098 <_pal_lld_setgroupmode+0x40>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003130:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003132:	ea23 0304 	bic.w	r3, r3, r4
 8003136:	ea43 030c 	orr.w	r3, r3, ip
 800313a:	6243      	str	r3, [r0, #36]	; 0x24
 800313c:	e7e7      	b.n	800310e <_pal_lld_setgroupmode+0xb6>
 800313e:	bf00      	nop

08003140 <Vector160>:

  OSAL_IRQ_EPILOGUE();
}

#elif defined(STM32_I2C3_EVENT_HANDLER) && defined(STM32_I2C3_ERROR_HANDLER)
OSAL_IRQ_HANDLER(STM32_I2C3_EVENT_HANDLER) {
 8003140:	b570      	push	{r4, r5, r6, lr}
  uint32_t isr = I2CD3.i2c->ISR;
 8003142:	4d70      	ldr	r5, [pc, #448]	; (8003304 <Vector160+0x1c4>)

  OSAL_IRQ_PROLOGUE();
 8003144:	4870      	ldr	r0, [pc, #448]	; (8003308 <Vector160+0x1c8>)
  uint32_t isr = I2CD3.i2c->ISR;
 8003146:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8003148:	699c      	ldr	r4, [r3, #24]
  OSAL_IRQ_PROLOGUE();
 800314a:	f002 fe07 	bl	8005d5c <__trace_isr_enter>

  /* Clearing IRQ bits.*/
  I2CD3.i2c->ICR = isr & I2C_INT_MASK;
 800314e:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8003150:	f004 03fe 	and.w	r3, r4, #254	; 0xfe
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8003154:	f014 0110 	ands.w	r1, r4, #16
  I2CD3.i2c->ICR = isr & I2C_INT_MASK;
 8003158:	61d3      	str	r3, [r2, #28]
  if ((isr & I2C_ISR_NACKF) != 0U) {
 800315a:	d14a      	bne.n	80031f2 <Vector160+0xb2>
  if ((isr & I2C_ISR_TCR) != 0U) {
 800315c:	0620      	lsls	r0, r4, #24
 800315e:	d42c      	bmi.n	80031ba <Vector160+0x7a>
  if ((isr & I2C_ISR_TC) != 0U) {
 8003160:	0661      	lsls	r1, r4, #25
 8003162:	d523      	bpl.n	80031ac <Vector160+0x6c>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8003164:	782b      	ldrb	r3, [r5, #0]
 8003166:	2b03      	cmp	r3, #3
 8003168:	f000 808d 	beq.w	8003286 <Vector160+0x146>
      i2c_lld_stop_rx_dma(i2cp);
 800316c:	6b28      	ldr	r0, [r5, #48]	; 0x30
    dmaStreamDisable(i2cp->rx.dma);
 800316e:	6801      	ldr	r1, [r0, #0]
 8003170:	680b      	ldr	r3, [r1, #0]
 8003172:	f023 031f 	bic.w	r3, r3, #31
 8003176:	600b      	str	r3, [r1, #0]
 8003178:	680b      	ldr	r3, [r1, #0]
 800317a:	07db      	lsls	r3, r3, #31
 800317c:	d4fc      	bmi.n	8003178 <Vector160+0x38>
 800317e:	7b04      	ldrb	r4, [r0, #12]
 8003180:	233d      	movs	r3, #61	; 0x3d
 8003182:	6841      	ldr	r1, [r0, #4]
 8003184:	40a3      	lsls	r3, r4
 8003186:	600b      	str	r3, [r1, #0]
    dp->CR2 |= I2C_CR2_STOP;
 8003188:	6853      	ldr	r3, [r2, #4]
 800318a:	2130      	movs	r1, #48	; 0x30
 800318c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003190:	6053      	str	r3, [r2, #4]
    dp->CR1 &= ~I2C_CR1_TCIE;
 8003192:	6813      	ldr	r3, [r2, #0]
 8003194:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003198:	6013      	str	r3, [r2, #0]
 800319a:	f381 8811 	msr	BASEPRI, r1
 800319e:	2100      	movs	r1, #0
 80031a0:	485a      	ldr	r0, [pc, #360]	; (800330c <Vector160+0x1cc>)
 80031a2:	f003 fa53 	bl	800664c <chThdResumeI>
 80031a6:	2300      	movs	r3, #0
 80031a8:	f383 8811 	msr	BASEPRI, r3

  i2c_lld_serve_interrupt(&I2CD3, isr);

  OSAL_IRQ_EPILOGUE();
 80031ac:	4856      	ldr	r0, [pc, #344]	; (8003308 <Vector160+0x1c8>)
 80031ae:	f002 fded 	bl	8005d8c <__trace_isr_leave>
}
 80031b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 80031b6:	f003 bd61 	b.w	8006c7c <__port_irq_epilogue>
    if (i2cp->state == I2C_ACTIVE_TX) {
 80031ba:	782b      	ldrb	r3, [r5, #0]
 80031bc:	2b03      	cmp	r3, #3
 80031be:	d052      	beq.n	8003266 <Vector160+0x126>
    return dmaStreamGetTransactionSize((i2cp)->rx.dma);
 80031c0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80031c2:	681b      	ldr	r3, [r3, #0]
 80031c4:	685b      	ldr	r3, [r3, #4]
  if (n > 255U) {
 80031c6:	2bff      	cmp	r3, #255	; 0xff
 80031c8:	f200 808c 	bhi.w	80032e4 <Vector160+0x1a4>
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80031cc:	041b      	lsls	r3, r3, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80031ce:	6868      	ldr	r0, [r5, #4]
 80031d0:	6854      	ldr	r4, [r2, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80031d2:	6880      	ldr	r0, [r0, #8]
 80031d4:	4303      	orrs	r3, r0
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80031d6:	484e      	ldr	r0, [pc, #312]	; (8003310 <Vector160+0x1d0>)
 80031d8:	4020      	ands	r0, r4
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80031da:	4303      	orrs	r3, r0
  OSAL_IRQ_EPILOGUE();
 80031dc:	484a      	ldr	r0, [pc, #296]	; (8003308 <Vector160+0x1c8>)
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80031de:	430b      	orrs	r3, r1
 80031e0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80031e4:	6053      	str	r3, [r2, #4]
  OSAL_IRQ_EPILOGUE();
 80031e6:	f002 fdd1 	bl	8005d8c <__trace_isr_leave>
}
 80031ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 80031ee:	f003 bd45 	b.w	8006c7c <__port_irq_epilogue>
    i2c_lld_stop_rx_dma(i2cp);
 80031f2:	6b28      	ldr	r0, [r5, #48]	; 0x30
    dmaStreamDisable(i2cp->rx.dma);
 80031f4:	6801      	ldr	r1, [r0, #0]
 80031f6:	680b      	ldr	r3, [r1, #0]
 80031f8:	f023 031f 	bic.w	r3, r3, #31
 80031fc:	600b      	str	r3, [r1, #0]
 80031fe:	680b      	ldr	r3, [r1, #0]
 8003200:	07dc      	lsls	r4, r3, #31
 8003202:	d4fc      	bmi.n	80031fe <Vector160+0xbe>
 8003204:	7b04      	ldrb	r4, [r0, #12]
 8003206:	233d      	movs	r3, #61	; 0x3d
 8003208:	6841      	ldr	r1, [r0, #4]
 800320a:	40a3      	lsls	r3, r4
 800320c:	6b68      	ldr	r0, [r5, #52]	; 0x34
 800320e:	600b      	str	r3, [r1, #0]
    dmaStreamDisable(i2cp->tx.dma);
 8003210:	6801      	ldr	r1, [r0, #0]
 8003212:	680b      	ldr	r3, [r1, #0]
 8003214:	f023 031f 	bic.w	r3, r3, #31
 8003218:	600b      	str	r3, [r1, #0]
 800321a:	680c      	ldr	r4, [r1, #0]
 800321c:	f014 0401 	ands.w	r4, r4, #1
 8003220:	d1fb      	bne.n	800321a <Vector160+0xda>
 8003222:	6841      	ldr	r1, [r0, #4]
 8003224:	233d      	movs	r3, #61	; 0x3d
 8003226:	7b00      	ldrb	r0, [r0, #12]
 8003228:	4083      	lsls	r3, r0
 800322a:	600b      	str	r3, [r1, #0]
    dp->CR2 |= I2C_CR2_STOP;
 800322c:	6853      	ldr	r3, [r2, #4]
    i2cp->errors |= I2C_ACK_FAILURE;
 800322e:	68a9      	ldr	r1, [r5, #8]
    dp->CR2 |= I2C_CR2_STOP;
 8003230:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    i2cp->errors |= I2C_ACK_FAILURE;
 8003234:	f041 0104 	orr.w	r1, r1, #4
 8003238:	60a9      	str	r1, [r5, #8]
 800323a:	2130      	movs	r1, #48	; 0x30
    dp->CR2 |= I2C_CR2_STOP;
 800323c:	6053      	str	r3, [r2, #4]
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 800323e:	6813      	ldr	r3, [r2, #0]
 8003240:	f023 0346 	bic.w	r3, r3, #70	; 0x46
 8003244:	6013      	str	r3, [r2, #0]
 8003246:	f381 8811 	msr	BASEPRI, r1
 800324a:	f06f 0101 	mvn.w	r1, #1
 800324e:	482f      	ldr	r0, [pc, #188]	; (800330c <Vector160+0x1cc>)
 8003250:	f003 f9fc 	bl	800664c <chThdResumeI>
 8003254:	f384 8811 	msr	BASEPRI, r4
  OSAL_IRQ_EPILOGUE();
 8003258:	482b      	ldr	r0, [pc, #172]	; (8003308 <Vector160+0x1c8>)
 800325a:	f002 fd97 	bl	8005d8c <__trace_isr_leave>
}
 800325e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8003262:	f003 bd0b 	b.w	8006c7c <__port_irq_epilogue>
    return dmaStreamGetTransactionSize((i2cp)->tx.dma);
 8003266:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8003268:	681b      	ldr	r3, [r3, #0]
 800326a:	6858      	ldr	r0, [r3, #4]
  if (n > 255U) {
 800326c:	28ff      	cmp	r0, #255	; 0xff
 800326e:	d83e      	bhi.n	80032ee <Vector160+0x1ae>
            (n << 16U) | reload;
 8003270:	0400      	lsls	r0, r0, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003272:	686b      	ldr	r3, [r5, #4]
 8003274:	6856      	ldr	r6, [r2, #4]
 8003276:	689c      	ldr	r4, [r3, #8]
 8003278:	4b25      	ldr	r3, [pc, #148]	; (8003310 <Vector160+0x1d0>)
 800327a:	4033      	ands	r3, r6
 800327c:	4323      	orrs	r3, r4
            (n << 16U) | reload;
 800327e:	4303      	orrs	r3, r0
 8003280:	430b      	orrs	r3, r1
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003282:	6053      	str	r3, [r2, #4]
}
 8003284:	e792      	b.n	80031ac <Vector160+0x6c>
      i2c_lld_stop_tx_dma(i2cp);
 8003286:	6b68      	ldr	r0, [r5, #52]	; 0x34
    dmaStreamDisable(i2cp->tx.dma);
 8003288:	6801      	ldr	r1, [r0, #0]
 800328a:	680b      	ldr	r3, [r1, #0]
 800328c:	f023 031f 	bic.w	r3, r3, #31
 8003290:	600b      	str	r3, [r1, #0]
 8003292:	680b      	ldr	r3, [r1, #0]
 8003294:	f013 0301 	ands.w	r3, r3, #1
 8003298:	d1fb      	bne.n	8003292 <Vector160+0x152>
 800329a:	6844      	ldr	r4, [r0, #4]
 800329c:	213d      	movs	r1, #61	; 0x3d
 800329e:	7b00      	ldrb	r0, [r0, #12]
 80032a0:	4081      	lsls	r1, r0
 80032a2:	6021      	str	r1, [r4, #0]
    return dmaStreamGetTransactionSize((i2cp)->rx.dma);
 80032a4:	6b29      	ldr	r1, [r5, #48]	; 0x30
 80032a6:	6809      	ldr	r1, [r1, #0]
 80032a8:	6848      	ldr	r0, [r1, #4]
      if ((i2c_lld_get_rxbytes(i2cp)) > 0U) {
 80032aa:	2800      	cmp	r0, #0
 80032ac:	f43f af6c 	beq.w	8003188 <Vector160+0x48>
    return dmaStreamGetTransactionSize((i2cp)->rx.dma);
 80032b0:	6848      	ldr	r0, [r1, #4]
  if (n > 255U) {
 80032b2:	28ff      	cmp	r0, #255	; 0xff
 80032b4:	d820      	bhi.n	80032f8 <Vector160+0x1b8>
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80032b6:	0400      	lsls	r0, r0, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80032b8:	686c      	ldr	r4, [r5, #4]
 80032ba:	6856      	ldr	r6, [r2, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80032bc:	68a4      	ldr	r4, [r4, #8]
 80032be:	4320      	orrs	r0, r4
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80032c0:	4c13      	ldr	r4, [pc, #76]	; (8003310 <Vector160+0x1d0>)
 80032c2:	4034      	ands	r4, r6
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80032c4:	4320      	orrs	r0, r4
 80032c6:	4303      	orrs	r3, r0
        i2cp->state = I2C_ACTIVE_RX;
 80032c8:	2004      	movs	r0, #4
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80032ca:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80032ce:	6053      	str	r3, [r2, #4]
    dmaStreamEnable(i2cp->rx.dma);
 80032d0:	680b      	ldr	r3, [r1, #0]
 80032d2:	f043 0301 	orr.w	r3, r3, #1
 80032d6:	600b      	str	r3, [r1, #0]
        dp->CR2 |= I2C_CR2_START;
 80032d8:	6853      	ldr	r3, [r2, #4]
        i2cp->state = I2C_ACTIVE_RX;
 80032da:	7028      	strb	r0, [r5, #0]
        dp->CR2 |= I2C_CR2_START;
 80032dc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80032e0:	6053      	str	r3, [r2, #4]
        return;
 80032e2:	e763      	b.n	80031ac <Vector160+0x6c>
 80032e4:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    reload = I2C_CR2_RELOAD;
 80032e8:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 80032ec:	e76f      	b.n	80031ce <Vector160+0x8e>
 80032ee:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
    reload = I2C_CR2_RELOAD;
 80032f2:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 80032f6:	e7bc      	b.n	8003272 <Vector160+0x132>
 80032f8:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
    reload = I2C_CR2_RELOAD;
 80032fc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003300:	e7da      	b.n	80032b8 <Vector160+0x178>
 8003302:	bf00      	nop
 8003304:	24000838 	.word	0x24000838
 8003308:	08014dd4 	.word	0x08014dd4
 800330c:	24000854 	.word	0x24000854
 8003310:	fe00ffff 	.word	0xfe00ffff

08003314 <Vector164>:

OSAL_IRQ_HANDLER(STM32_I2C3_ERROR_HANDLER) {
 8003314:	b538      	push	{r3, r4, r5, lr}
  uint32_t isr = I2CD3.i2c->ISR;
 8003316:	4c2c      	ldr	r4, [pc, #176]	; (80033c8 <Vector164+0xb4>)

  OSAL_IRQ_PROLOGUE();
 8003318:	482c      	ldr	r0, [pc, #176]	; (80033cc <Vector164+0xb8>)
  uint32_t isr = I2CD3.i2c->ISR;
 800331a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800331c:	699d      	ldr	r5, [r3, #24]
  OSAL_IRQ_PROLOGUE();
 800331e:	f002 fd1d 	bl	8005d5c <__trace_isr_enter>

  /* Clearing IRQ bits.*/
  I2CD3.i2c->ICR = isr & I2C_ERROR_MASK;
 8003322:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003324:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003326:	f405 527c 	and.w	r2, r5, #16128	; 0x3f00
 800332a:	61da      	str	r2, [r3, #28]
    dmaStreamDisable(i2cp->rx.dma);
 800332c:	680a      	ldr	r2, [r1, #0]
 800332e:	6813      	ldr	r3, [r2, #0]
 8003330:	f023 031f 	bic.w	r3, r3, #31
 8003334:	6013      	str	r3, [r2, #0]
 8003336:	6813      	ldr	r3, [r2, #0]
 8003338:	07db      	lsls	r3, r3, #31
 800333a:	d4fc      	bmi.n	8003336 <Vector164+0x22>
 800333c:	7b08      	ldrb	r0, [r1, #12]
 800333e:	233d      	movs	r3, #61	; 0x3d
 8003340:	684a      	ldr	r2, [r1, #4]
 8003342:	4083      	lsls	r3, r0
 8003344:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003346:	6013      	str	r3, [r2, #0]
    dmaStreamDisable(i2cp->tx.dma);
 8003348:	680a      	ldr	r2, [r1, #0]
 800334a:	6813      	ldr	r3, [r2, #0]
 800334c:	f023 031f 	bic.w	r3, r3, #31
 8003350:	6013      	str	r3, [r2, #0]
 8003352:	6813      	ldr	r3, [r2, #0]
 8003354:	07d8      	lsls	r0, r3, #31
 8003356:	d4fc      	bmi.n	8003352 <Vector164+0x3e>
 8003358:	7b08      	ldrb	r0, [r1, #12]
 800335a:	233d      	movs	r3, #61	; 0x3d
 800335c:	684a      	ldr	r2, [r1, #4]
  if (isr & I2C_ISR_BERR)
 800335e:	05e9      	lsls	r1, r5, #23
    dmaStreamDisable(i2cp->tx.dma);
 8003360:	fa03 f300 	lsl.w	r3, r3, r0
 8003364:	6013      	str	r3, [r2, #0]
    i2cp->errors |= I2C_BUS_ERROR;
 8003366:	68a3      	ldr	r3, [r4, #8]
 8003368:	bf44      	itt	mi
 800336a:	f043 0301 	orrmi.w	r3, r3, #1
 800336e:	60a3      	strmi	r3, [r4, #8]
  if (isr & I2C_ISR_ARLO)
 8003370:	05aa      	lsls	r2, r5, #22
 8003372:	d502      	bpl.n	800337a <Vector164+0x66>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8003374:	f043 0302 	orr.w	r3, r3, #2
 8003378:	60a3      	str	r3, [r4, #8]
  if (isr & I2C_ISR_OVR)
 800337a:	0568      	lsls	r0, r5, #21
 800337c:	d519      	bpl.n	80033b2 <Vector164+0x9e>
    i2cp->errors |= I2C_OVERRUN;
 800337e:	f043 0308 	orr.w	r3, r3, #8
  if (isr & I2C_ISR_TIMEOUT)
 8003382:	04e9      	lsls	r1, r5, #19
    i2cp->errors |= I2C_OVERRUN;
 8003384:	60a3      	str	r3, [r4, #8]
  if (isr & I2C_ISR_TIMEOUT)
 8003386:	d502      	bpl.n	800338e <Vector164+0x7a>
    i2cp->errors |= I2C_TIMEOUT;
 8003388:	f043 0320 	orr.w	r3, r3, #32
 800338c:	60a3      	str	r3, [r4, #8]
 800338e:	2330      	movs	r3, #48	; 0x30
 8003390:	f383 8811 	msr	BASEPRI, r3
 8003394:	f06f 0101 	mvn.w	r1, #1
 8003398:	480d      	ldr	r0, [pc, #52]	; (80033d0 <Vector164+0xbc>)
 800339a:	f003 f957 	bl	800664c <chThdResumeI>
 800339e:	2300      	movs	r3, #0
 80033a0:	f383 8811 	msr	BASEPRI, r3

  i2c_lld_serve_error_interrupt(&I2CD3, isr);

  OSAL_IRQ_EPILOGUE();
 80033a4:	4809      	ldr	r0, [pc, #36]	; (80033cc <Vector164+0xb8>)
 80033a6:	f002 fcf1 	bl	8005d8c <__trace_isr_leave>
}
 80033aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80033ae:	f003 bc65 	b.w	8006c7c <__port_irq_epilogue>
  if (isr & I2C_ISR_TIMEOUT)
 80033b2:	04ea      	lsls	r2, r5, #19
 80033b4:	d4e8      	bmi.n	8003388 <Vector164+0x74>
  if (i2cp->errors != I2C_NO_ERROR)
 80033b6:	2b00      	cmp	r3, #0
 80033b8:	d1e9      	bne.n	800338e <Vector164+0x7a>
  OSAL_IRQ_EPILOGUE();
 80033ba:	4804      	ldr	r0, [pc, #16]	; (80033cc <Vector164+0xb8>)
 80033bc:	f002 fce6 	bl	8005d8c <__trace_isr_leave>
}
 80033c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80033c4:	f003 bc5a 	b.w	8006c7c <__port_irq_epilogue>
 80033c8:	24000838 	.word	0x24000838
 80033cc:	08014dc8 	.word	0x08014dc8
 80033d0:	24000854 	.word	0x24000854

080033d4 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 80033d4:	b510      	push	{r4, lr}
#error "I2C2 interrupt numbers not defined"
#endif
#endif /* STM32_I2C_USE_I2C2 */

#if STM32_I2C_USE_I2C3
  i2cObjectInit(&I2CD3);
 80033d6:	4c0a      	ldr	r4, [pc, #40]	; (8003400 <i2c_lld_init+0x2c>)
 80033d8:	4620      	mov	r0, r4
 80033da:	f7fd fe45 	bl	8001068 <i2cObjectInit>
  I2CD3.thread  = NULL;
 80033de:	2300      	movs	r3, #0
  I2CD3.i2c     = I2C3;
 80033e0:	4a08      	ldr	r2, [pc, #32]	; (8003404 <i2c_lld_init+0x30>)
  I2CD3.tx.dma  = NULL;
#endif
#if defined(STM32_I2C3_GLOBAL_NUMBER) || defined(__DOXYGEN__)
      nvicEnableVector(STM32_I2C3_GLOBAL_NUMBER, STM32_I2C_I2C3_IRQ_PRIORITY);
#elif defined(STM32_I2C3_EVENT_NUMBER) && defined(STM32_I2C3_ERROR_NUMBER)
      nvicEnableVector(STM32_I2C3_EVENT_NUMBER, STM32_I2C_I2C3_IRQ_PRIORITY);
 80033e2:	2105      	movs	r1, #5
 80033e4:	2048      	movs	r0, #72	; 0x48
  I2CD3.thread  = NULL;
 80033e6:	61e3      	str	r3, [r4, #28]
  I2CD3.i2c     = I2C3;
 80033e8:	63a2      	str	r2, [r4, #56]	; 0x38
  I2CD3.tx.dma  = NULL;
 80033ea:	e9c4 330c 	strd	r3, r3, [r4, #48]	; 0x30
      nvicEnableVector(STM32_I2C3_EVENT_NUMBER, STM32_I2C_I2C3_IRQ_PRIORITY);
 80033ee:	f7fe fcb5 	bl	8001d5c <nvicEnableVector>
      nvicEnableVector(STM32_I2C3_ERROR_NUMBER, STM32_I2C_I2C3_IRQ_PRIORITY);
 80033f2:	2105      	movs	r1, #5
 80033f4:	2049      	movs	r0, #73	; 0x49
      nvicEnableVector(STM32_I2C5_ERROR_NUMBER, STM32_I2C_I2C5_IRQ_PRIORITY);
#else
#error "I2C5 interrupt numbers not defined"
#endif
#endif /* STM32_I2C_USE_I2C5 */
}
 80033f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      nvicEnableVector(STM32_I2C3_ERROR_NUMBER, STM32_I2C_I2C3_IRQ_PRIORITY);
 80033fa:	f7fe bcaf 	b.w	8001d5c <nvicEnableVector>
 80033fe:	bf00      	nop
 8003400:	24000838 	.word	0x24000838
 8003404:	40005c00 	.word	0x40005c00

08003408 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 8003408:	b538      	push	{r3, r4, r5, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800340a:	6b85      	ldr	r5, [r0, #56]	; 0x38
void i2c_lld_start(I2CDriver *i2cp) {
 800340c:	4604      	mov	r4, r0

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 800340e:	682b      	ldr	r3, [r5, #0]
 8003410:	f023 0301 	bic.w	r3, r3, #1
 8003414:	602b      	str	r3, [r5, #0]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8003416:	7803      	ldrb	r3, [r0, #0]
 8003418:	2b01      	cmp	r3, #1
 800341a:	d016      	beq.n	800344a <i2c_lld_start+0x42>
  }
#endif
#endif /* STM32_I2C_USE_DMA == TRUE */

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 800341c:	6862      	ldr	r2, [r4, #4]
    dmaStreamSetPeripheral(i2cp->rx.dma, &dp->RXDR);
 800341e:	f105 0024 	add.w	r0, r5, #36	; 0x24
    dmaStreamSetPeripheral(i2cp->tx.dma, &dp->TXDR);
 8003422:	e9d4 310c 	ldrd	r3, r1, [r4, #48]	; 0x30
#if STM32_I2C_USE_DMA == TRUE
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 8003426:	6854      	ldr	r4, [r2, #4]
    dmaStreamSetPeripheral(i2cp->rx.dma, &dp->RXDR);
 8003428:	681b      	ldr	r3, [r3, #0]
    dmaStreamSetPeripheral(i2cp->tx.dma, &dp->TXDR);
 800342a:	6809      	ldr	r1, [r1, #0]
    dmaStreamSetPeripheral(i2cp->rx.dma, &dp->RXDR);
 800342c:	6098      	str	r0, [r3, #8]
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 800342e:	f24c 0390 	movw	r3, #49296	; 0xc090

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 8003432:	6812      	ldr	r2, [r2, #0]
    dmaStreamSetPeripheral(i2cp->tx.dma, &dp->TXDR);
 8003434:	f105 0028 	add.w	r0, r5, #40	; 0x28
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 8003438:	4323      	orrs	r3, r4
    dmaStreamSetPeripheral(i2cp->tx.dma, &dp->TXDR);
 800343a:	6088      	str	r0, [r1, #8]
  dp->CR1 = i2cp->config->cr1 |
 800343c:	602b      	str	r3, [r5, #0]
  dp->TIMINGR = i2cp->config->timingr;
 800343e:	612a      	str	r2, [r5, #16]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8003440:	682b      	ldr	r3, [r5, #0]
 8003442:	f043 0301 	orr.w	r3, r3, #1
 8003446:	602b      	str	r3, [r5, #0]
}
 8003448:	bd38      	pop	{r3, r4, r5, pc}
    if (&I2CD3 == i2cp) {
 800344a:	4b22      	ldr	r3, [pc, #136]	; (80034d4 <i2c_lld_start+0xcc>)
    i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
 800344c:	f240 4156 	movw	r1, #1110	; 0x456
    i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 8003450:	f240 4216 	movw	r2, #1046	; 0x416
    if (&I2CD3 == i2cp) {
 8003454:	4298      	cmp	r0, r3
    i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 8003456:	e9c0 210a 	strd	r2, r1, [r0, #40]	; 0x28
    if (&I2CD3 == i2cp) {
 800345a:	d1df      	bne.n	800341c <i2c_lld_start+0x14>
  RCC->APB1LRSTR |= mask;
 800345c:	491e      	ldr	r1, [pc, #120]	; (80034d8 <i2c_lld_start+0xd0>)
        i2cp->rx.dma = dmaStreamAllocI(STM32_I2C_I2C3_RX_DMA_STREAM,
 800345e:	2300      	movs	r3, #0
 8003460:	2010      	movs	r0, #16
 8003462:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8003466:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800346a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 800346e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8003472:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8003476:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 800347a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  RCC_C1->APB1LENR |= mask;
 800347e:	f8d1 20e8 	ldr.w	r2, [r1, #232]	; 0xe8
 8003482:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8003486:	f8c1 20e8 	str.w	r2, [r1, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 800348a:	f8d1 2110 	ldr.w	r2, [r1, #272]	; 0x110
 800348e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8003492:	f8c1 2110 	str.w	r2, [r1, #272]	; 0x110
 8003496:	461a      	mov	r2, r3
  (void)RCC_C1->APB1LLPENR;
 8003498:	f8d1 1110 	ldr.w	r1, [r1, #272]	; 0x110
 800349c:	2105      	movs	r1, #5
 800349e:	f7ff fd09 	bl	8002eb4 <dmaStreamAllocI>
        i2cp->tx.dma = dmaStreamAllocI(STM32_I2C_I2C3_TX_DMA_STREAM,
 80034a2:	2300      	movs	r3, #0
        i2cp->rx.dma = dmaStreamAllocI(STM32_I2C_I2C3_RX_DMA_STREAM,
 80034a4:	6320      	str	r0, [r4, #48]	; 0x30
        i2cp->tx.dma = dmaStreamAllocI(STM32_I2C_I2C3_TX_DMA_STREAM,
 80034a6:	2105      	movs	r1, #5
 80034a8:	461a      	mov	r2, r3
 80034aa:	2010      	movs	r0, #16
 80034ac:	f7ff fd02 	bl	8002eb4 <dmaStreamAllocI>
        dmaSetRequestSource(i2cp->rx.dma, STM32_DMAMUX1_I2C3_RX);
 80034b0:	2149      	movs	r1, #73	; 0x49
        i2cp->tx.dma = dmaStreamAllocI(STM32_I2C_I2C3_TX_DMA_STREAM,
 80034b2:	6360      	str	r0, [r4, #52]	; 0x34
        dmaSetRequestSource(i2cp->rx.dma, STM32_DMAMUX1_I2C3_RX);
 80034b4:	6b20      	ldr	r0, [r4, #48]	; 0x30
        i2cp->txdmamode |= STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
 80034b6:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
        i2cp->rxdmamode |= STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
 80034ba:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
        i2cp->txdmamode |= STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
 80034be:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
        i2cp->rxdmamode |= STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
 80034c2:	62a2      	str	r2, [r4, #40]	; 0x28
        i2cp->txdmamode |= STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
 80034c4:	62e3      	str	r3, [r4, #44]	; 0x2c
        dmaSetRequestSource(i2cp->rx.dma, STM32_DMAMUX1_I2C3_RX);
 80034c6:	f7ff fdc1 	bl	800304c <dmaSetRequestSource>
        dmaSetRequestSource(i2cp->tx.dma, STM32_DMAMUX1_I2C3_TX);
 80034ca:	214a      	movs	r1, #74	; 0x4a
 80034cc:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80034ce:	f7ff fdbd 	bl	800304c <dmaSetRequestSource>
 80034d2:	e7a3      	b.n	800341c <i2c_lld_start+0x14>
 80034d4:	24000838 	.word	0x24000838
 80034d8:	58024400 	.word	0x58024400

080034dc <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      sysinterval_t timeout) {
 80034dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if (I2C_ENABLE_SLAVE_MODE == TRUE)
  i2cp->isMaster = true;
#endif /* I2C_ENABLE_SLAVE_MODE == TRUE */

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 80034e0:	2400      	movs	r4, #0
                                      sysinterval_t timeout) {
 80034e2:	4680      	mov	r8, r0
 80034e4:	4689      	mov	r9, r1
 80034e6:	9f08      	ldr	r7, [sp, #32]
  I2C_TypeDef *dp = i2cp->i2c;
 80034e8:	6b85      	ldr	r5, [r0, #56]	; 0x38
  i2cp->errors = I2C_NO_ERROR;
 80034ea:	6084      	str	r4, [r0, #8]
 80034ec:	f384 8811 	msr	BASEPRI, r4
#if defined(STM32_I2C_DMA_REQUIRED) && defined(STM32_I2C_BDMA_REQUIRED)
  else
#endif
#if defined(STM32_I2C_DMA_REQUIRED)
  {
    dmaStreamSetMode(i2cp->tx.dma, i2cp->txdmamode);
 80034f0:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80034f2:	f8d8 602c 	ldr.w	r6, [r8, #44]	; 0x2c
 80034f6:	6808      	ldr	r0, [r1, #0]
    dmaStreamSetMemory0(i2cp->tx.dma, txbuf);
    dmaStreamSetTransactionSize(i2cp->tx.dma, txbytes);

    dmaStreamSetMode(i2cp->rx.dma, i2cp->rxdmamode);
 80034f8:	f8d8 1030 	ldr.w	r1, [r8, #48]	; 0x30
 80034fc:	6809      	ldr	r1, [r1, #0]
    dmaStreamSetMode(i2cp->tx.dma, i2cp->txdmamode);
 80034fe:	6006      	str	r6, [r0, #0]
 8003500:	2630      	movs	r6, #48	; 0x30
    dmaStreamSetMemory0(i2cp->tx.dma, txbuf);
 8003502:	60c2      	str	r2, [r0, #12]
    dmaStreamSetTransactionSize(i2cp->tx.dma, txbytes);
 8003504:	6043      	str	r3, [r0, #4]
    dmaStreamSetMode(i2cp->rx.dma, i2cp->rxdmamode);
 8003506:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
 800350a:	600b      	str	r3, [r1, #0]
    dmaStreamSetMemory0(i2cp->rx.dma, rxbuf);
    dmaStreamSetTransactionSize(i2cp->rx.dma, rxbytes);
 800350c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dmaStreamSetMemory0(i2cp->rx.dma, rxbuf);
 800350e:	60cf      	str	r7, [r1, #12]
    dmaStreamSetTransactionSize(i2cp->rx.dma, rxbytes);
 8003510:	604b      	str	r3, [r1, #4]
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
 8003512:	f7fd fb73 	bl	8000bfc <stGetCounter>
 8003516:	f386 8811 	msr	BASEPRI, r6
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 800351a:	69ab      	ldr	r3, [r5, #24]
 800351c:	0419      	lsls	r1, r3, #16
 800351e:	d512      	bpl.n	8003546 <i2c_lld_master_transmit_timeout+0x6a>
 8003520:	4607      	mov	r7, r0
 8003522:	e006      	b.n	8003532 <i2c_lld_master_transmit_timeout+0x56>
 8003524:	f384 8811 	msr	BASEPRI, r4
 8003528:	f386 8811 	msr	BASEPRI, r6
 800352c:	69ab      	ldr	r3, [r5, #24]
 800352e:	041b      	lsls	r3, r3, #16
 8003530:	d509      	bpl.n	8003546 <i2c_lld_master_transmit_timeout+0x6a>
 8003532:	f7fd fb63 	bl	8000bfc <stGetCounter>
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 8003536:	1bc3      	subs	r3, r0, r7
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 8003538:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 800353c:	d3f2      	bcc.n	8003524 <i2c_lld_master_transmit_timeout+0x48>
      return MSG_TIMEOUT;
 800353e:	f04f 30ff 	mov.w	r0, #4294967295
    i2c_lld_stop_tx_dma(i2cp);
#endif
  }

  return msg;
}
 8003542:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 8003546:	f8d8 3004 	ldr.w	r3, [r8, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 800354a:	f8d8 4038 	ldr.w	r4, [r8, #56]	; 0x38
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 800354e:	6899      	ldr	r1, [r3, #8]
 8003550:	050a      	lsls	r2, r1, #20
 8003552:	d547      	bpl.n	80035e4 <i2c_lld_master_transmit_timeout+0x108>
    return dmaStreamGetTransactionSize((i2cp)->tx.dma);
 8003554:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
    dp->CR2 = (uint32_t)addr;
 8003558:	f8c4 9004 	str.w	r9, [r4, #4]
    return dmaStreamGetTransactionSize((i2cp)->tx.dma);
 800355c:	6818      	ldr	r0, [r3, #0]
 800355e:	6842      	ldr	r2, [r0, #4]
  if (n > 255U) {
 8003560:	2aff      	cmp	r2, #255	; 0xff
 8003562:	d848      	bhi.n	80035f6 <i2c_lld_master_transmit_timeout+0x11a>
            (n << 16U) | reload;
 8003564:	0412      	lsls	r2, r2, #16
    reload = 0U;
 8003566:	2700      	movs	r7, #0
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003568:	6866      	ldr	r6, [r4, #4]
 800356a:	4b25      	ldr	r3, [pc, #148]	; (8003600 <i2c_lld_master_transmit_timeout+0x124>)
 800356c:	4033      	ands	r3, r6
            (n << 16U) | reload;
 800356e:	430b      	orrs	r3, r1
  return chThdSuspendTimeoutS(trp, timeout);
 8003570:	990a      	ldr	r1, [sp, #40]	; 0x28
 8003572:	433b      	orrs	r3, r7
 8003574:	4313      	orrs	r3, r2
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003576:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->tx.dma);
 8003578:	6803      	ldr	r3, [r0, #0]
 800357a:	f043 0301 	orr.w	r3, r3, #1
 800357e:	6003      	str	r3, [r0, #0]
 8003580:	f108 001c 	add.w	r0, r8, #28
  dp->CR1 |= I2C_CR1_TCIE;
 8003584:	682b      	ldr	r3, [r5, #0]
 8003586:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800358a:	602b      	str	r3, [r5, #0]
  dp->CR2 |= I2C_CR2_START;
 800358c:	686b      	ldr	r3, [r5, #4]
 800358e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003592:	606b      	str	r3, [r5, #4]
 8003594:	f003 f84c 	bl	8006630 <chThdSuspendTimeoutS>
  if (msg == MSG_TIMEOUT) {
 8003598:	1c44      	adds	r4, r0, #1
 800359a:	d1d2      	bne.n	8003542 <i2c_lld_master_transmit_timeout+0x66>
    dp->CR2 |= I2C_CR2_STOP;
 800359c:	686b      	ldr	r3, [r5, #4]
 800359e:	f8d8 4030 	ldr.w	r4, [r8, #48]	; 0x30
 80035a2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    dmaStreamDisable(i2cp->rx.dma);
 80035a6:	6822      	ldr	r2, [r4, #0]
    dp->CR2 |= I2C_CR2_STOP;
 80035a8:	606b      	str	r3, [r5, #4]
    dmaStreamDisable(i2cp->rx.dma);
 80035aa:	6813      	ldr	r3, [r2, #0]
 80035ac:	f023 031f 	bic.w	r3, r3, #31
 80035b0:	6013      	str	r3, [r2, #0]
 80035b2:	6813      	ldr	r3, [r2, #0]
 80035b4:	07d9      	lsls	r1, r3, #31
 80035b6:	d4fc      	bmi.n	80035b2 <i2c_lld_master_transmit_timeout+0xd6>
 80035b8:	7b22      	ldrb	r2, [r4, #12]
 80035ba:	233d      	movs	r3, #61	; 0x3d
 80035bc:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
 80035c0:	4093      	lsls	r3, r2
 80035c2:	6864      	ldr	r4, [r4, #4]
    dmaStreamDisable(i2cp->tx.dma);
 80035c4:	680a      	ldr	r2, [r1, #0]
    dmaStreamDisable(i2cp->rx.dma);
 80035c6:	6023      	str	r3, [r4, #0]
    dmaStreamDisable(i2cp->tx.dma);
 80035c8:	6813      	ldr	r3, [r2, #0]
 80035ca:	f023 031f 	bic.w	r3, r3, #31
 80035ce:	6013      	str	r3, [r2, #0]
 80035d0:	6813      	ldr	r3, [r2, #0]
 80035d2:	07db      	lsls	r3, r3, #31
 80035d4:	d4fc      	bmi.n	80035d0 <i2c_lld_master_transmit_timeout+0xf4>
 80035d6:	7b0c      	ldrb	r4, [r1, #12]
 80035d8:	233d      	movs	r3, #61	; 0x3d
 80035da:	684a      	ldr	r2, [r1, #4]
 80035dc:	40a3      	lsls	r3, r4
 80035de:	6013      	str	r3, [r2, #0]
}
 80035e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    dp->CR2 = (uint32_t)addr << 1U;
 80035e4:	ea4f 0349 	mov.w	r3, r9, lsl #1
 80035e8:	6063      	str	r3, [r4, #4]
    return dmaStreamGetTransactionSize((i2cp)->tx.dma);
 80035ea:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
 80035ee:	6818      	ldr	r0, [r3, #0]
 80035f0:	6842      	ldr	r2, [r0, #4]
  if (n > 255U) {
 80035f2:	2aff      	cmp	r2, #255	; 0xff
 80035f4:	d9b6      	bls.n	8003564 <i2c_lld_master_transmit_timeout+0x88>
 80035f6:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
    reload = I2C_CR2_RELOAD;
 80035fa:	f04f 7780 	mov.w	r7, #16777216	; 0x1000000
 80035fe:	e7b3      	b.n	8003568 <i2c_lld_master_transmit_timeout+0x8c>
 8003600:	fe00ffff 	.word	0xfe00ffff

08003604 <otg_enable_ep>:

static void otg_enable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003604:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
 8003608:	f100 0108 	add.w	r1, r0, #8
 800360c:	2200      	movs	r2, #0
    if (usbp->epc[i]->out_state != NULL) {
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 800360e:	f04f 0c01 	mov.w	ip, #1
 8003612:	689b      	ldr	r3, [r3, #8]
static void otg_enable_ep(USBDriver *usbp) {
 8003614:	b570      	push	{r4, r5, r6, lr}
 8003616:	f100 0e0c 	add.w	lr, r0, #12
  stm32_otg_t *otgp = usbp->otg;
 800361a:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800361e:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2
    if (usbp->epc[i]->out_state != NULL) {
 8003622:	f851 4f04 	ldr.w	r4, [r1, #4]!
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 8003626:	f102 0310 	add.w	r3, r2, #16
    }
    if (usbp->epc[i]->in_state != NULL) {
      otgp->DAINTMSK |= DAINTMSK_IEPM(i);
 800362a:	fa0c f002 	lsl.w	r0, ip, r2
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800362e:	3201      	adds	r2, #1
    if (usbp->epc[i]->out_state != NULL) {
 8003630:	69a6      	ldr	r6, [r4, #24]
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 8003632:	fa0c f303 	lsl.w	r3, ip, r3
    if (usbp->epc[i]->out_state != NULL) {
 8003636:	b126      	cbz	r6, 8003642 <otg_enable_ep+0x3e>
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 8003638:	f8d5 681c 	ldr.w	r6, [r5, #2076]	; 0x81c
 800363c:	4333      	orrs	r3, r6
 800363e:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
    if (usbp->epc[i]->in_state != NULL) {
 8003642:	6963      	ldr	r3, [r4, #20]
 8003644:	b123      	cbz	r3, 8003650 <otg_enable_ep+0x4c>
      otgp->DAINTMSK |= DAINTMSK_IEPM(i);
 8003646:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 800364a:	4318      	orrs	r0, r3
 800364c:	f8c5 081c 	str.w	r0, [r5, #2076]	; 0x81c
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003650:	4571      	cmp	r1, lr
 8003652:	d1e6      	bne.n	8003622 <otg_enable_ep+0x1e>
    }
  }
}
 8003654:	bd70      	pop	{r4, r5, r6, pc}
 8003656:	bf00      	nop

08003658 <otg_disable_ep.isra.0>:
static void otg_disable_ep(USBDriver *usbp) {
 8003658:	b470      	push	{r4, r5, r6}
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800365a:	2200      	movs	r2, #0
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800365c:	f04f 34ff 	mov.w	r4, #4294967295
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003660:	688e      	ldr	r6, [r1, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003662:	eb00 1142 	add.w	r1, r0, r2, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003666:	f102 0c01 	add.w	ip, r2, #1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 800366a:	f8d1 5900 	ldr.w	r5, [r1, #2304]	; 0x900
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800366e:	460b      	mov	r3, r1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8003670:	2d00      	cmp	r5, #0
 8003672:	da05      	bge.n	8003680 <otg_disable_ep.isra.0+0x28>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8003674:	f8d1 5900 	ldr.w	r5, [r1, #2304]	; 0x900
 8003678:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 800367c:	f8c1 5900 	str.w	r5, [r1, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8003680:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	; 0xb00
 8003684:	2d00      	cmp	r5, #0
 8003686:	da05      	bge.n	8003694 <otg_disable_ep.isra.0+0x3c>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8003688:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	; 0xb00
 800368c:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 8003690:	f8c1 5b00 	str.w	r5, [r1, #2816]	; 0xb00
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003694:	42b2      	cmp	r2, r6
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003696:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800369a:	4662      	mov	r2, ip
 800369c:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80036a0:	d1df      	bne.n	8003662 <otg_disable_ep.isra.0+0xa>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80036a2:	f04f 1301 	mov.w	r3, #65537	; 0x10001
}
 80036a6:	bc70      	pop	{r4, r5, r6}
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80036a8:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
}
 80036ac:	4770      	bx	lr
 80036ae:	bf00      	nop

080036b0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 80036b0:	b538      	push	{r3, r4, r5, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 80036b2:	4d08      	ldr	r5, [pc, #32]	; (80036d4 <usb_lld_init+0x24>)
  USBD1.otgparams = &fsparams;

#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
 80036b4:	4c08      	ldr	r4, [pc, #32]	; (80036d8 <usb_lld_init+0x28>)
  usbObjectInit(&USBD1);
 80036b6:	4628      	mov	r0, r5
 80036b8:	f7fe f840 	bl	800173c <usbObjectInit>
  USBD1.otg       = OTG_FS;
 80036bc:	4a07      	ldr	r2, [pc, #28]	; (80036dc <usb_lld_init+0x2c>)
  USBD1.otgparams = &fsparams;
 80036be:	4b08      	ldr	r3, [pc, #32]	; (80036e0 <usb_lld_init+0x30>)
  usbObjectInit(&USBD2);
 80036c0:	4620      	mov	r0, r4
  USBD1.otgparams = &fsparams;
 80036c2:	e9c5 2324 	strd	r2, r3, [r5, #144]	; 0x90
  usbObjectInit(&USBD2);
 80036c6:	f7fe f839 	bl	800173c <usbObjectInit>
  USBD2.otg       = OTG_HS;
 80036ca:	4a06      	ldr	r2, [pc, #24]	; (80036e4 <usb_lld_init+0x34>)
  USBD2.otgparams = &hsparams;
 80036cc:	4b06      	ldr	r3, [pc, #24]	; (80036e8 <usb_lld_init+0x38>)
 80036ce:	e9c4 2324 	strd	r2, r3, [r4, #144]	; 0x90
#endif
}
 80036d2:	bd38      	pop	{r3, r4, r5, pc}
 80036d4:	24000874 	.word	0x24000874
 80036d8:	24000910 	.word	0x24000910
 80036dc:	40080000 	.word	0x40080000
 80036e0:	08014e1c 	.word	0x08014e1c
 80036e4:	40040000 	.word	0x40040000
 80036e8:	08014e28 	.word	0x08014e28

080036ec <usb_lld_start>:
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 80036ec:	7803      	ldrb	r3, [r0, #0]
 80036ee:	2b01      	cmp	r3, #1
 80036f0:	d000      	beq.n	80036f4 <usb_lld_start+0x8>
 80036f2:	4770      	bx	lr
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 80036f4:	4b4b      	ldr	r3, [pc, #300]	; (8003824 <usb_lld_start+0x138>)
 80036f6:	4298      	cmp	r0, r3
void usb_lld_start(USBDriver *usbp) {
 80036f8:	b570      	push	{r4, r5, r6, lr}
 80036fa:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
 80036fc:	f8d0 6090 	ldr.w	r6, [r0, #144]	; 0x90
    if (&USBD1 == usbp) {
 8003700:	d06f      	beq.n	80037e2 <usb_lld_start+0xf6>
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
    }
#endif

#if STM32_USB_USE_OTG2
    if (&USBD2 == usbp) {
 8003702:	4b49      	ldr	r3, [pc, #292]	; (8003828 <usb_lld_start+0x13c>)
 8003704:	4298      	cmp	r0, r3
 8003706:	d035      	beq.n	8003774 <usb_lld_start+0x88>
  stm32_otg_t *otgp = usbp->otg;
 8003708:	4634      	mov	r4, r6

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 800370a:	23c0      	movs	r3, #192	; 0xc0
    otgp->PCGCCTL = 0;
 800370c:	2200      	movs	r2, #0
 800370e:	f8c6 2e00 	str.w	r2, [r6, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8003712:	6033      	str	r3, [r6, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8003714:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
 8003718:	63b3      	str	r3, [r6, #56]	; 0x38
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800371a:	6923      	ldr	r3, [r4, #16]
 800371c:	2b00      	cmp	r3, #0
 800371e:	dafc      	bge.n	800371a <usb_lld_start+0x2e>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8003720:	2301      	movs	r3, #1
  chSysPolledDelayX(cycles);
 8003722:	200c      	movs	r0, #12
 8003724:	6123      	str	r3, [r4, #16]
 8003726:	f002 faa9 	bl	8005c7c <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 800372a:	6923      	ldr	r3, [r4, #16]
 800372c:	07db      	lsls	r3, r3, #31
 800372e:	d4fc      	bmi.n	800372a <usb_lld_start+0x3e>
 8003730:	2012      	movs	r0, #18
 8003732:	f002 faa3 	bl	8005c7c <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8003736:	6923      	ldr	r3, [r4, #16]
 8003738:	2b00      	cmp	r3, #0
 800373a:	dafc      	bge.n	8003736 <usb_lld_start+0x4a>

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 800373c:	2400      	movs	r4, #0

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 800373e:	e9d5 0124 	ldrd	r0, r1, [r5, #144]	; 0x90
    otgp->GAHBCFG = 0;
 8003742:	60b4      	str	r4, [r6, #8]
    otg_disable_ep(usbp);
 8003744:	f7ff ff88 	bl	8003658 <otg_disable_ep.isra.0>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 8003748:	686b      	ldr	r3, [r5, #4]
    otgp->DIEPMSK  = 0;
 800374a:	f8c6 4810 	str.w	r4, [r6, #2064]	; 0x810
    if (usbp->config->sof_cb == NULL)
 800374e:	68db      	ldr	r3, [r3, #12]
    otgp->DOEPMSK  = 0;
 8003750:	f8c6 4814 	str.w	r4, [r6, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8003754:	f8c6 481c 	str.w	r4, [r6, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8003758:	b14b      	cbz	r3, 800376e <usb_lld_start+0x82>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 800375a:	4b34      	ldr	r3, [pc, #208]	; (800382c <usb_lld_start+0x140>)
 800375c:	61b3      	str	r3, [r6, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 800375e:	f04f 33ff 	mov.w	r3, #4294967295
 8003762:	6173      	str	r3, [r6, #20]

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8003764:	68b3      	ldr	r3, [r6, #8]
 8003766:	f043 0301 	orr.w	r3, r3, #1
 800376a:	60b3      	str	r3, [r6, #8]
  }
}
 800376c:	bd70      	pop	{r4, r5, r6, pc}
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 800376e:	4b30      	ldr	r3, [pc, #192]	; (8003830 <usb_lld_start+0x144>)
 8003770:	61b3      	str	r3, [r6, #24]
 8003772:	e7f4      	b.n	800375e <usb_lld_start+0x72>
  RCC_C1->AHB1ENR |= mask;
 8003774:	4b2f      	ldr	r3, [pc, #188]	; (8003834 <usb_lld_start+0x148>)
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
 8003776:	210e      	movs	r1, #14
 8003778:	204d      	movs	r0, #77	; 0x4d
 800377a:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 800377e:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8003782:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 8003786:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 800378a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800378e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8003792:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  RCC->AHB1RSTR |= mask;
 8003796:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800379a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800379e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  RCC->AHB1RSTR &= ~mask;
 80037a2:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80037a6:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 80037aa:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  (void)RCC->AHB1RSTR;
 80037ae:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
  RCC_C1->AHB1ENR &= ~mask;
 80037b2:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 80037b6:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 80037ba:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 80037be:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 80037c2:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 80037c6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 80037ca:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 80037ce:	f7fe fac5 	bl	8001d5c <nvicEnableVector>
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 80037d2:	4a19      	ldr	r2, [pc, #100]	; (8003838 <usb_lld_start+0x14c>)
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80037d4:	4b19      	ldr	r3, [pc, #100]	; (800383c <usb_lld_start+0x150>)
 80037d6:	f8d5 4090 	ldr.w	r4, [r5, #144]	; 0x90
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 80037da:	60f2      	str	r2, [r6, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80037dc:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800
 80037e0:	e793      	b.n	800370a <usb_lld_start+0x1e>
  RCC_C1->AHB1ENR |= mask;
 80037e2:	4b14      	ldr	r3, [pc, #80]	; (8003834 <usb_lld_start+0x148>)
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 80037e4:	210e      	movs	r1, #14
 80037e6:	2065      	movs	r0, #101	; 0x65
 80037e8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 80037ec:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80037f0:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 80037f4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 80037f8:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80037fc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8003800:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  RCC->AHB1RSTR |= mask;
 8003804:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8003808:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800380c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  RCC->AHB1RSTR &= ~mask;
 8003810:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8003814:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
 8003818:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  (void)RCC->AHB1RSTR;
 800381c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003820:	e7d5      	b.n	80037ce <usb_lld_start+0xe2>
 8003822:	bf00      	nop
 8003824:	24000874 	.word	0x24000874
 8003828:	24000910 	.word	0x24000910
 800382c:	c0303c08 	.word	0xc0303c08
 8003830:	c0303c00 	.word	0xc0303c00
 8003834:	58024400 	.word	0x58024400
 8003838:	40001440 	.word	0x40001440
 800383c:	02200003 	.word	0x02200003

08003840 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8003840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003842:	2320      	movs	r3, #32
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8003844:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
void usb_lld_reset(USBDriver *usbp) {
 8003848:	4607      	mov	r7, r0
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800384a:	612b      	str	r3, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800384c:	692c      	ldr	r4, [r5, #16]
 800384e:	f014 0420 	ands.w	r4, r4, #32
 8003852:	d1fb      	bne.n	800384c <usb_lld_reset+0xc>
 8003854:	2012      	movs	r0, #18
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8003856:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
 800385a:	f002 fa0f 	bl	8005c7c <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800385e:	f8d7 c094 	ldr.w	ip, [r7, #148]	; 0x94
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8003862:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003866:	f04f 31ff 	mov.w	r1, #4294967295
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800386a:	f8dc 0008 	ldr.w	r0, [ip, #8]
  otgp->DIEPEMPMSK = 0;
 800386e:	f8c5 4834 	str.w	r4, [r5, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8003872:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8003876:	eb05 1344 	add.w	r3, r5, r4, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800387a:	4284      	cmp	r4, r0
 800387c:	f104 0401 	add.w	r4, r4, #1
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8003880:	f8c3 6900 	str.w	r6, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8003884:	f8c3 6b00 	str.w	r6, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003888:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800388c:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003890:	d1f1      	bne.n	8003876 <usb_lld_reset+0x36>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8003892:	f8dc 3000 	ldr.w	r3, [ip]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8003896:	2110      	movs	r1, #16
 8003898:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800389c:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80038a0:	626b      	str	r3, [r5, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80038a2:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80038a4:	6914      	ldr	r4, [r2, #16]
 80038a6:	f014 0410 	ands.w	r4, r4, #16
 80038aa:	d1fb      	bne.n	80038a4 <usb_lld_reset+0x64>
 80038ac:	2012      	movs	r0, #18
 80038ae:	f002 f9e5 	bl	8005c7c <chSysPolledDelayX>
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0) | BOARD_OTG2_ULPI_CHIRP_DELAY_MASK;
 80038b2:	f8d5 2800 	ldr.w	r2, [r5, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80038b6:	4b12      	ldr	r3, [pc, #72]	; (8003900 <usb_lld_reset+0xc0>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0) | BOARD_OTG2_ULPI_CHIRP_DELAY_MASK;
 80038b8:	f422 62fe 	bic.w	r2, r2, #2032	; 0x7f0
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 80038bc:	4911      	ldr	r1, [pc, #68]	; (8003904 <usb_lld_reset+0xc4>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0) | BOARD_OTG2_ULPI_CHIRP_DELAY_MASK;
 80038be:	f8c5 2800 	str.w	r2, [r5, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80038c2:	69aa      	ldr	r2, [r5, #24]
 80038c4:	4313      	orrs	r3, r2
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 80038c6:	2209      	movs	r2, #9
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80038c8:	61ab      	str	r3, [r5, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 80038ca:	f8c5 2810 	str.w	r2, [r5, #2064]	; 0x810
  next = usbp->pmnext;
 80038ce:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 80038d2:	f8c5 2814 	str.w	r2, [r5, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
 80038d6:	60f9      	str	r1, [r7, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 80038d8:	f04f 41c0 	mov.w	r1, #1610612736	; 0x60000000
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80038dc:	4a0a      	ldr	r2, [pc, #40]	; (8003908 <usb_lld_reset+0xc8>)
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 80038de:	f8c5 1b10 	str.w	r1, [r5, #2832]	; 0xb10
  usbp->pmnext += size;
 80038e2:	f103 0110 	add.w	r1, r3, #16
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80038e6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80038ea:	f8c5 2b00 	str.w	r2, [r5, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 80038ee:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 80038f2:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
  usbp->pmnext += size;
 80038f6:	f8c7 1098 	str.w	r1, [r7, #152]	; 0x98
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80038fa:	62ab      	str	r3, [r5, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 80038fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80038fe:	bf00      	nop
 8003900:	000c0010 	.word	0x000c0010
 8003904:	08014df8 	.word	0x08014df8
 8003908:	10008040 	.word	0x10008040

0800390c <usb_lld_set_address>:
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 800390c:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8003910:	f890 108a 	ldrb.w	r1, [r0, #138]	; 0x8a
 8003914:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 8003918:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800391c:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8003920:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
}
 8003924:	4770      	bx	lr
 8003926:	bf00      	nop

08003928 <usb_lld_init_endpoint>:
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8003928:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 800392c:	68db      	ldr	r3, [r3, #12]
 800392e:	681a      	ldr	r2, [r3, #0]
 8003930:	f002 0203 	and.w	r2, r2, #3
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8003934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003938:	460d      	mov	r5, r1
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 800393a:	fa0f f881 	sxth.w	r8, r1
 800393e:	1e51      	subs	r1, r2, #1
  stm32_otg_t *otgp = usbp->otg;
 8003940:	f8d0 4090 	ldr.w	r4, [r0, #144]	; 0x90
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8003944:	4f46      	ldr	r7, [pc, #280]	; (8003a60 <usb_lld_init_endpoint+0x138>)
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8003946:	4606      	mov	r6, r0
 8003948:	2902      	cmp	r1, #2
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800394a:	f04f 0100 	mov.w	r1, #0
 800394e:	bf98      	it	ls
 8003950:	eb07 4782 	addls.w	r7, r7, r2, lsl #18
 8003954:	eb04 1245 	add.w	r2, r4, r5, lsl #5
 8003958:	f8c2 1b10 	str.w	r1, [r2, #2832]	; 0xb10
 800395c:	0169      	lsls	r1, r5, #5
  if (usbp->epc[ep]->out_state != NULL) {
 800395e:	699a      	ldr	r2, [r3, #24]
 8003960:	2a00      	cmp	r2, #0
 8003962:	d047      	beq.n	80039f4 <usb_lld_init_endpoint+0xcc>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8003964:	8a58      	ldrh	r0, [r3, #18]
 8003966:	f105 0258 	add.w	r2, r5, #88	; 0x58
 800396a:	4338      	orrs	r0, r7
 800396c:	0152      	lsls	r2, r2, #5
 800396e:	50a0      	str	r0, [r4, r2]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8003970:	f105 0010 	add.w	r0, r5, #16
 8003974:	2201      	movs	r2, #1
 8003976:	4082      	lsls	r2, r0
 8003978:	f8d4 081c 	ldr.w	r0, [r4, #2076]	; 0x81c
 800397c:	4302      	orrs	r2, r0
 800397e:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8003982:	1862      	adds	r2, r4, r1
 8003984:	2100      	movs	r1, #0
 8003986:	f8c2 1910 	str.w	r1, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 800398a:	695a      	ldr	r2, [r3, #20]
 800398c:	2a00      	cmp	r2, #0
 800398e:	d045      	beq.n	8003a1c <usb_lld_init_endpoint+0xf4>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 8003990:	8b99      	ldrh	r1, [r3, #28]
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8003992:	f105 003f 	add.w	r0, r5, #63	; 0x3f
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8003996:	8a1a      	ldrh	r2, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8003998:	2901      	cmp	r1, #1
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800399a:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800399e:	ea4f 0392 	mov.w	r3, r2, lsr #2
  next = usbp->pmnext;
 80039a2:	f8d6 2098 	ldr.w	r2, [r6, #152]	; 0x98
      fsize *= usbp->epc[ep]->in_multiplier;
 80039a6:	bf88      	it	hi
 80039a8:	434b      	mulhi	r3, r1
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80039aa:	01a9      	lsls	r1, r5, #6
  usbp->pmnext += size;
 80039ac:	eb03 0c02 	add.w	ip, r3, r2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80039b0:	f041 0120 	orr.w	r1, r1, #32
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80039b4:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  usbp->pmnext += size;
 80039b8:	f8c6 c098 	str.w	ip, [r6, #152]	; 0x98
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80039bc:	6042      	str	r2, [r0, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80039be:	6121      	str	r1, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80039c0:	6923      	ldr	r3, [r4, #16]
 80039c2:	069a      	lsls	r2, r3, #26
 80039c4:	d4fc      	bmi.n	80039c0 <usb_lld_init_endpoint+0x98>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 80039c6:	eb06 0688 	add.w	r6, r6, r8, lsl #2
 80039ca:	2012      	movs	r0, #18
 80039cc:	f002 f956 	bl	8005c7c <chSysPolledDelayX>
    otgp->ie[ep].DIEPCTL = ctl |
 80039d0:	f105 0248 	add.w	r2, r5, #72	; 0x48
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 80039d4:	68f3      	ldr	r3, [r6, #12]
    otgp->ie[ep].DIEPCTL = ctl |
 80039d6:	0152      	lsls	r2, r2, #5
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 80039d8:	8a1b      	ldrh	r3, [r3, #16]
                           DIEPCTL_TXFNUM(ep) |
 80039da:	ea43 5385 	orr.w	r3, r3, r5, lsl #22
 80039de:	433b      	orrs	r3, r7
    otgp->ie[ep].DIEPCTL = ctl |
 80039e0:	50a3      	str	r3, [r4, r2]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 80039e2:	2301      	movs	r3, #1
 80039e4:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 80039e8:	40ab      	lsls	r3, r5
 80039ea:	4313      	orrs	r3, r2
 80039ec:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  }
}
 80039f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 80039f4:	eb04 1248 	add.w	r2, r4, r8, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80039f8:	f105 0c10 	add.w	ip, r5, #16
 80039fc:	2001      	movs	r0, #1
 80039fe:	fa00 f00c 	lsl.w	r0, r0, ip
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8003a02:	f8d2 cb00 	ldr.w	ip, [r2, #2816]	; 0xb00
 8003a06:	f42c 4c00 	bic.w	ip, ip, #32768	; 0x8000
 8003a0a:	f8c2 cb00 	str.w	ip, [r2, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8003a0e:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 8003a12:	ea22 0200 	bic.w	r2, r2, r0
 8003a16:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
 8003a1a:	e7b2      	b.n	8003982 <usb_lld_init_endpoint+0x5a>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8003a1c:	f105 033f 	add.w	r3, r5, #63	; 0x3f
 8003a20:	4a10      	ldr	r2, [pc, #64]	; (8003a64 <usb_lld_init_endpoint+0x13c>)
 8003a22:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8003a26:	605a      	str	r2, [r3, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003a28:	01ab      	lsls	r3, r5, #6
 8003a2a:	f043 0320 	orr.w	r3, r3, #32
 8003a2e:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8003a30:	6923      	ldr	r3, [r4, #16]
 8003a32:	069b      	lsls	r3, r3, #26
 8003a34:	d4fc      	bmi.n	8003a30 <usb_lld_init_endpoint+0x108>
 8003a36:	eb04 1848 	add.w	r8, r4, r8, lsl #5
 8003a3a:	2012      	movs	r0, #18
 8003a3c:	f002 f91e 	bl	8005c7c <chSysPolledDelayX>
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8003a40:	2201      	movs	r2, #1
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8003a42:	f8d8 3900 	ldr.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8003a46:	40aa      	lsls	r2, r5
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8003a48:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003a4c:	f8c8 3900 	str.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8003a50:	f8d4 381c 	ldr.w	r3, [r4, #2076]	; 0x81c
 8003a54:	ea23 0302 	bic.w	r3, r3, r2
 8003a58:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
}
 8003a5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003a60:	10008000 	.word	0x10008000
 8003a64:	02000400 	.word	0x02000400

08003a68 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8003a68:	4603      	mov	r3, r0

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 8003a6a:	e9d0 0124 	ldrd	r0, r1, [r0, #144]	; 0x90
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8003a6e:	680a      	ldr	r2, [r1, #0]
 8003a70:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  otg_disable_ep(usbp);
 8003a74:	f7ff bdf0 	b.w	8003658 <otg_disable_ep.isra.0>

08003a78 <usb_lld_get_status_out>:
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8003a78:	3158      	adds	r1, #88	; 0x58
 8003a7a:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8003a7e:	0149      	lsls	r1, r1, #5
 8003a80:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8003a82:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 8003a86:	d004      	beq.n	8003a92 <usb_lld_get_status_out+0x1a>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
    return EP_STATUS_STALLED;
 8003a88:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8003a8c:	bf0c      	ite	eq
 8003a8e:	2002      	moveq	r0, #2
 8003a90:	2001      	movne	r0, #1
  return EP_STATUS_ACTIVE;
}
 8003a92:	4770      	bx	lr

08003a94 <usb_lld_get_status_in>:
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8003a94:	3148      	adds	r1, #72	; 0x48
 8003a96:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8003a9a:	0149      	lsls	r1, r1, #5
 8003a9c:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 8003a9e:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 8003aa2:	d004      	beq.n	8003aae <usb_lld_get_status_in+0x1a>
    return EP_STATUS_DISABLED;
  if (ctl & DIEPCTL_STALL)
    return EP_STATUS_STALLED;
 8003aa4:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8003aa8:	bf0c      	ite	eq
 8003aaa:	2002      	moveq	r0, #2
 8003aac:	2001      	movne	r0, #1
  return EP_STATUS_ACTIVE;
}
 8003aae:	4770      	bx	lr

08003ab0 <usb_lld_read_setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8003ab0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8003ab4:	68cb      	ldr	r3, [r1, #12]
 8003ab6:	6a1b      	ldr	r3, [r3, #32]
 8003ab8:	6819      	ldr	r1, [r3, #0]
 8003aba:	685b      	ldr	r3, [r3, #4]
 8003abc:	6011      	str	r1, [r2, #0]
 8003abe:	6053      	str	r3, [r2, #4]
}
 8003ac0:	4770      	bx	lr
 8003ac2:	bf00      	nop

08003ac4 <usb_lld_start_out>:
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8003ac4:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8003ac8:	68da      	ldr	r2, [r3, #12]
 8003aca:	6993      	ldr	r3, [r2, #24]
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8003acc:	b410      	push	{r4}

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 8003ace:	681c      	ldr	r4, [r3, #0]
 8003ad0:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8003ad2:	b909      	cbnz	r1, 8003ad8 <usb_lld_start_out+0x14>
 8003ad4:	2c40      	cmp	r4, #64	; 0x40
 8003ad6:	d826      	bhi.n	8003b26 <usb_lld_start_out+0x62>
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8003ad8:	8a53      	ldrh	r3, [r2, #18]
  /* Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8003ada:	6812      	ldr	r2, [r2, #0]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8003adc:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8003ae0:	f002 0c03 	and.w	ip, r2, #3
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8003ae4:	1e5a      	subs	r2, r3, #1
 8003ae6:	4422      	add	r2, r4
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8003ae8:	f1bc 0f01 	cmp.w	ip, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8003aec:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8003af0:	fb02 f303 	mul.w	r3, r2, r3
 8003af4:	f103 0303 	add.w	r3, r3, #3
 8003af8:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8003afc:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8003b00:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8003b04:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 8003b08:	f8c2 3b10 	str.w	r3, [r2, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8003b0c:	d00e      	beq.n	8003b2c <usb_lld_start_out+0x68>
 8003b0e:	b209      	sxth	r1, r1
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8003b10:	eb00 1041 	add.w	r0, r0, r1, lsl #5
}
 8003b14:	f85d 4b04 	ldr.w	r4, [sp], #4
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8003b18:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8003b1c:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8003b20:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8003b24:	4770      	bx	lr
    osp->rxsize = EP0_MAX_OUTSIZE;
 8003b26:	2440      	movs	r4, #64	; 0x40
 8003b28:	601c      	str	r4, [r3, #0]
 8003b2a:	e7d5      	b.n	8003ad8 <usb_lld_start_out+0x14>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8003b2c:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8003b30:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8003b34:	b209      	sxth	r1, r1
 8003b36:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8003b3a:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8003b3e:	bf14      	ite	ne
 8003b40:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8003b44:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8003b48:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8003b4c:	e7e0      	b.n	8003b10 <usb_lld_start_out+0x4c>
 8003b4e:	bf00      	nop

08003b50 <otg_epout_handler>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8003b50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8003b54:	f8d0 6090 	ldr.w	r6, [r0, #144]	; 0x90
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8003b58:	4607      	mov	r7, r0
 8003b5a:	460c      	mov	r4, r1
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8003b5c:	eb06 1341 	add.w	r3, r6, r1, lsl #5
 8003b60:	f8d3 5b08 	ldr.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8003b64:	072a      	lsls	r2, r5, #28
  otgp->oe[ep].DOEPINT = epint;
 8003b66:	f8c3 5b08 	str.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8003b6a:	d503      	bpl.n	8003b74 <otg_epout_handler+0x24>
 8003b6c:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8003b70:	071b      	lsls	r3, r3, #28
 8003b72:	d431      	bmi.n	8003bd8 <otg_epout_handler+0x88>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8003b74:	07ea      	lsls	r2, r5, #31
 8003b76:	d52d      	bpl.n	8003bd4 <otg_epout_handler+0x84>
 8003b78:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8003b7c:	07db      	lsls	r3, r3, #31
 8003b7e:	d529      	bpl.n	8003bd4 <otg_epout_handler+0x84>
    osp = usbp->epc[ep]->out_state;
 8003b80:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8003b84:	68d9      	ldr	r1, [r3, #12]
 8003b86:	698a      	ldr	r2, [r1, #24]
    if (ep == 0) {
 8003b88:	b954      	cbnz	r4, 8003ba0 <otg_epout_handler+0x50>
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8003b8a:	8a48      	ldrh	r0, [r1, #18]
 8003b8c:	6853      	ldr	r3, [r2, #4]
 8003b8e:	fbb3 f5f0 	udiv	r5, r3, r0
 8003b92:	fb00 3315 	mls	r3, r0, r5, r3
 8003b96:	b91b      	cbnz	r3, 8003ba0 <otg_epout_handler+0x50>
          (osp->rxsize < osp->totsize)) {
 8003b98:	6810      	ldr	r0, [r2, #0]
 8003b9a:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8003b9c:	4298      	cmp	r0, r3
 8003b9e:	d30d      	bcc.n	8003bbc <otg_epout_handler+0x6c>
    _usb_isr_invoke_out_cb(usbp, ep);
 8003ba0:	2201      	movs	r2, #1
 8003ba2:	897b      	ldrh	r3, [r7, #10]
 8003ba4:	68cd      	ldr	r5, [r1, #12]
 8003ba6:	40a2      	lsls	r2, r4
 8003ba8:	ea23 0302 	bic.w	r3, r3, r2
 8003bac:	817b      	strh	r3, [r7, #10]
 8003bae:	b18d      	cbz	r5, 8003bd4 <otg_epout_handler+0x84>
 8003bb0:	4621      	mov	r1, r4
 8003bb2:	4638      	mov	r0, r7
 8003bb4:	462b      	mov	r3, r5
}
 8003bb6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
 8003bba:	4718      	bx	r3
        osp->rxsize = osp->totsize - osp->rxsize;
 8003bbc:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
 8003bbe:	6054      	str	r4, [r2, #4]
 8003bc0:	2130      	movs	r1, #48	; 0x30
        osp->rxsize = osp->totsize - osp->rxsize;
 8003bc2:	6013      	str	r3, [r2, #0]
 8003bc4:	f381 8811 	msr	BASEPRI, r1
        usb_lld_start_out(usbp, ep);
 8003bc8:	4621      	mov	r1, r4
 8003bca:	4638      	mov	r0, r7
 8003bcc:	f7ff ff7a 	bl	8003ac4 <usb_lld_start_out>
 8003bd0:	f384 8811 	msr	BASEPRI, r4
}
 8003bd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_setup_cb(usbp, ep);
 8003bd8:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8003bdc:	68db      	ldr	r3, [r3, #12]
 8003bde:	685b      	ldr	r3, [r3, #4]
 8003be0:	4798      	blx	r3
 8003be2:	e7c7      	b.n	8003b74 <otg_epout_handler+0x24>

08003be4 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003be4:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8003be8:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003bea:	68dc      	ldr	r4, [r3, #12]
 8003bec:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8003bee:	6813      	ldr	r3, [r2, #0]
 8003bf0:	60d3      	str	r3, [r2, #12]
  if (isp->txsize == 0) {
 8003bf2:	b9fb      	cbnz	r3, 8003c34 <usb_lld_start_in+0x50>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8003bf4:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8003bf8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8003bfc:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 8003c00:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8003c04:	6823      	ldr	r3, [r4, #0]
 8003c06:	f003 0303 	and.w	r3, r3, #3
 8003c0a:	2b01      	cmp	r3, #1
 8003c0c:	d02b      	beq.n	8003c66 <usb_lld_start_in+0x82>
 8003c0e:	b208      	sxth	r0, r1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8003c10:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8003c14:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8003c16:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8003c1a:	408b      	lsls	r3, r1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8003c1c:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8003c20:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8003c24:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
}
 8003c28:	f85d 4b04 	ldr.w	r4, [sp], #4
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8003c2c:	430b      	orrs	r3, r1
 8003c2e:	f8c2 3834 	str.w	r3, [r2, #2100]	; 0x834
}
 8003c32:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8003c34:	b909      	cbnz	r1, 8003c3a <usb_lld_start_in+0x56>
 8003c36:	2b40      	cmp	r3, #64	; 0x40
 8003c38:	d826      	bhi.n	8003c88 <usb_lld_start_in+0xa4>
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8003c3a:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8003c3e:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8003c42:	f10c 30ff 	add.w	r0, ip, #4294967295
 8003c46:	4418      	add	r0, r3
 8003c48:	fbb0 f0fc 	udiv	r0, r0, ip
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8003c4c:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
 8003c50:	eb02 1041 	add.w	r0, r2, r1, lsl #5
 8003c54:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003c58:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8003c5c:	6823      	ldr	r3, [r4, #0]
 8003c5e:	f003 0303 	and.w	r3, r3, #3
 8003c62:	2b01      	cmp	r3, #1
 8003c64:	d1d3      	bne.n	8003c0e <usb_lld_start_in+0x2a>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8003c66:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
 8003c6a:	b208      	sxth	r0, r1
 8003c6c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8003c70:	eb02 1341 	add.w	r3, r2, r1, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8003c74:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 8003c78:	bf14      	ite	ne
 8003c7a:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8003c7e:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
 8003c82:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
 8003c86:	e7c3      	b.n	8003c10 <usb_lld_start_in+0x2c>
      isp->txsize = EP0_MAX_INSIZE;
 8003c88:	2340      	movs	r3, #64	; 0x40
 8003c8a:	6013      	str	r3, [r2, #0]
 8003c8c:	e7d5      	b.n	8003c3a <usb_lld_start_in+0x56>
 8003c8e:	bf00      	nop

08003c90 <otg_epin_handler>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8003c90:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 8003c94:	f8d0 6090 	ldr.w	r6, [r0, #144]	; 0x90
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8003c98:	4681      	mov	r9, r0
 8003c9a:	460c      	mov	r4, r1
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8003c9c:	ea4f 1b41 	mov.w	fp, r1, lsl #5
 8003ca0:	eb06 1341 	add.w	r3, r6, r1, lsl #5
 8003ca4:	f8d3 5908 	ldr.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8003ca8:	07ef      	lsls	r7, r5, #31
  otgp->ie[ep].DIEPINT = epint;
 8003caa:	f8c3 5908 	str.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8003cae:	d503      	bpl.n	8003cb8 <otg_epin_handler+0x28>
 8003cb0:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 8003cb4:	07da      	lsls	r2, r3, #31
 8003cb6:	d40c      	bmi.n	8003cd2 <otg_epin_handler+0x42>
  if ((epint & DIEPINT_TXFE) &&
 8003cb8:	062b      	lsls	r3, r5, #24
 8003cba:	d508      	bpl.n	8003cce <otg_epin_handler+0x3e>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8003cbc:	f04f 0801 	mov.w	r8, #1
 8003cc0:	f8d6 3834 	ldr.w	r3, [r6, #2100]	; 0x834
 8003cc4:	fa08 f804 	lsl.w	r8, r8, r4
  if ((epint & DIEPINT_TXFE) &&
 8003cc8:	ea13 0f08 	tst.w	r3, r8
 8003ccc:	d115      	bne.n	8003cfa <otg_epin_handler+0x6a>
}
 8003cce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003cd2:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8003cd6:	68df      	ldr	r7, [r3, #12]
 8003cd8:	697b      	ldr	r3, [r7, #20]
    if (isp->txsize < isp->totsize) {
 8003cda:	f8d3 c000 	ldr.w	ip, [r3]
 8003cde:	68da      	ldr	r2, [r3, #12]
 8003ce0:	4594      	cmp	ip, r2
 8003ce2:	d346      	bcc.n	8003d72 <otg_epin_handler+0xe2>
      _usb_isr_invoke_in_cb(usbp, ep);
 8003ce4:	2201      	movs	r2, #1
 8003ce6:	8903      	ldrh	r3, [r0, #8]
 8003ce8:	68bf      	ldr	r7, [r7, #8]
 8003cea:	408a      	lsls	r2, r1
 8003cec:	ea23 0302 	bic.w	r3, r3, r2
 8003cf0:	8103      	strh	r3, [r0, #8]
 8003cf2:	2f00      	cmp	r7, #0
 8003cf4:	d0e0      	beq.n	8003cb8 <otg_epin_handler+0x28>
 8003cf6:	47b8      	blx	r7
 8003cf8:	e7de      	b.n	8003cb8 <otg_epin_handler+0x28>
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8003cfa:	eb09 0384 	add.w	r3, r9, r4, lsl #2
 8003cfe:	68db      	ldr	r3, [r3, #12]
 8003d00:	695e      	ldr	r6, [r3, #20]
 8003d02:	e9d6 7500 	ldrd	r7, r5, [r6]
 8003d06:	42af      	cmp	r7, r5
 8003d08:	d940      	bls.n	8003d8c <otg_epin_handler+0xfc>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8003d0a:	1c61      	adds	r1, r4, #1
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8003d0c:	f8d9 a090 	ldr.w	sl, [r9, #144]	; 0x90
    if (n > usbp->epc[ep]->in_maxsize)
 8003d10:	f8b3 9010 	ldrh.w	r9, [r3, #16]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8003d14:	b2c9      	uxtb	r1, r1
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8003d16:	eb0a 0e0b 	add.w	lr, sl, fp
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8003d1a:	eb0a 3101 	add.w	r1, sl, r1, lsl #12
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8003d1e:	eba7 0c05 	sub.w	ip, r7, r5
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8003d22:	f8de 3918 	ldr.w	r3, [lr, #2328]	; 0x918
 8003d26:	45cc      	cmp	ip, r9
 8003d28:	b29b      	uxth	r3, r3
 8003d2a:	bf28      	it	cs
 8003d2c:	46cc      	movcs	ip, r9
 8003d2e:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
 8003d32:	d8cc      	bhi.n	8003cce <otg_epin_handler+0x3e>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8003d34:	68b4      	ldr	r4, [r6, #8]
    if (n <= 4) {
 8003d36:	f1bc 0f04 	cmp.w	ip, #4
    *fifop = *((uint32_t *)buf);
 8003d3a:	6823      	ldr	r3, [r4, #0]
 8003d3c:	600b      	str	r3, [r1, #0]
    if (n <= 4) {
 8003d3e:	d90b      	bls.n	8003d58 <otg_epin_handler+0xc8>
 8003d40:	f1ac 0005 	sub.w	r0, ip, #5
 8003d44:	4623      	mov	r3, r4
 8003d46:	f020 0003 	bic.w	r0, r0, #3
 8003d4a:	3004      	adds	r0, #4
 8003d4c:	4420      	add	r0, r4
    *fifop = *((uint32_t *)buf);
 8003d4e:	f853 2f04 	ldr.w	r2, [r3, #4]!
    if (n <= 4) {
 8003d52:	4298      	cmp	r0, r3
    *fifop = *((uint32_t *)buf);
 8003d54:	600a      	str	r2, [r1, #0]
    if (n <= 4) {
 8003d56:	d1fa      	bne.n	8003d4e <otg_epin_handler+0xbe>
    usbp->epc[ep]->in_state->txcnt += n;
 8003d58:	4465      	add	r5, ip
    usbp->epc[ep]->in_state->txbuf += n;
 8003d5a:	4464      	add	r4, ip
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8003d5c:	42bd      	cmp	r5, r7
    usbp->epc[ep]->in_state->txcnt += n;
 8003d5e:	e9c6 5401 	strd	r5, r4, [r6, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8003d62:	d3dc      	bcc.n	8003d1e <otg_epin_handler+0x8e>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8003d64:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 8003d68:	ea23 0308 	bic.w	r3, r3, r8
 8003d6c:	f8ca 3834 	str.w	r3, [sl, #2100]	; 0x834
      return true;
 8003d70:	e7ad      	b.n	8003cce <otg_epin_handler+0x3e>
      isp->txsize = isp->totsize - isp->txsize;
 8003d72:	eba2 020c 	sub.w	r2, r2, ip
      isp->txcnt  = 0;
 8003d76:	2700      	movs	r7, #0
      isp->txsize = isp->totsize - isp->txsize;
 8003d78:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 8003d7a:	605f      	str	r7, [r3, #4]
 8003d7c:	2330      	movs	r3, #48	; 0x30
 8003d7e:	f383 8811 	msr	BASEPRI, r3
      usb_lld_start_in(usbp, ep);
 8003d82:	f7ff ff2f 	bl	8003be4 <usb_lld_start_in>
 8003d86:	f387 8811 	msr	BASEPRI, r7
}
 8003d8a:	e795      	b.n	8003cb8 <otg_epin_handler+0x28>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8003d8c:	f8d9 a090 	ldr.w	sl, [r9, #144]	; 0x90
 8003d90:	e7e8      	b.n	8003d64 <otg_epin_handler+0xd4>
 8003d92:	bf00      	nop

08003d94 <usb_lld_serve_interrupt>:
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8003d94:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 8003d98:	f04f 0940 	mov.w	r9, #64	; 0x40
  if ((sts & IRQ_RETRY_MASK) && (--retry > 0U))
 8003d9c:	f8df a3c8 	ldr.w	sl, [pc, #968]	; 8004168 <usb_lld_serve_interrupt+0x3d4>
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8003da0:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
 8003da2:	f8d0 7090 	ldr.w	r7, [r0, #144]	; 0x90
  unsigned retry = 64U;
 8003da6:	e070      	b.n	8003e8a <usb_lld_serve_interrupt+0xf6>
  if (sts & GINTSTS_USBSUSP) {
 8003da8:	0532      	lsls	r2, r6, #20
 8003daa:	f100 8091 	bmi.w	8003ed0 <usb_lld_serve_interrupt+0x13c>
  if (sts & GINTSTS_ENUMDNE) {
 8003dae:	04b3      	lsls	r3, r6, #18
 8003db0:	d50c      	bpl.n	8003dcc <usb_lld_serve_interrupt+0x38>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8003db2:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
 8003db6:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8003dba:	68fb      	ldr	r3, [r7, #12]
 8003dbc:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8003dc0:	bf0c      	ite	eq
 8003dc2:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8003dc6:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 8003dca:	60fb      	str	r3, [r7, #12]
  if (sts & GINTSTS_SOF) {
 8003dcc:	0734      	lsls	r4, r6, #28
 8003dce:	d510      	bpl.n	8003df2 <usb_lld_serve_interrupt+0x5e>
    if (usbp->config->sof_cb == NULL) {
 8003dd0:	686b      	ldr	r3, [r5, #4]
 8003dd2:	68db      	ldr	r3, [r3, #12]
 8003dd4:	2b00      	cmp	r3, #0
 8003dd6:	f000 817e 	beq.w	80040d6 <usb_lld_serve_interrupt+0x342>
    if (usbp->state == USB_SUSPENDED) {
 8003dda:	782b      	ldrb	r3, [r5, #0]
 8003ddc:	2b05      	cmp	r3, #5
 8003dde:	f000 8182 	beq.w	80040e6 <usb_lld_serve_interrupt+0x352>
    otg_enable_ep(usbp);
 8003de2:	4628      	mov	r0, r5
 8003de4:	f7ff fc0e 	bl	8003604 <otg_enable_ep>
    _usb_isr_invoke_sof_cb(usbp);
 8003de8:	686b      	ldr	r3, [r5, #4]
 8003dea:	68db      	ldr	r3, [r3, #12]
 8003dec:	b10b      	cbz	r3, 8003df2 <usb_lld_serve_interrupt+0x5e>
 8003dee:	4628      	mov	r0, r5
 8003df0:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 8003df2:	02f0      	lsls	r0, r6, #11
 8003df4:	d474      	bmi.n	8003ee0 <usb_lld_serve_interrupt+0x14c>
  if (sts & GINTSTS_IISOOXFR) {
 8003df6:	02b1      	lsls	r1, r6, #10
 8003df8:	f100 80b4 	bmi.w	8003f64 <usb_lld_serve_interrupt+0x1d0>
  if (sts & GINTSTS_OEPINT) {
 8003dfc:	0333      	lsls	r3, r6, #12
  src = otgp->DAINT;
 8003dfe:	f8d7 4818 	ldr.w	r4, [r7, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8003e02:	d51a      	bpl.n	8003e3a <usb_lld_serve_interrupt+0xa6>
    if (src & (1 << 16))
 8003e04:	03e0      	lsls	r0, r4, #15
 8003e06:	f100 8139 	bmi.w	800407c <usb_lld_serve_interrupt+0x2e8>
    if (src & (1 << 17))
 8003e0a:	03a1      	lsls	r1, r4, #14
 8003e0c:	f100 8131 	bmi.w	8004072 <usb_lld_serve_interrupt+0x2de>
    if (src & (1 << 18))
 8003e10:	0362      	lsls	r2, r4, #13
 8003e12:	f100 8129 	bmi.w	8004068 <usb_lld_serve_interrupt+0x2d4>
    if (src & (1 << 19))
 8003e16:	0323      	lsls	r3, r4, #12
 8003e18:	f100 8121 	bmi.w	800405e <usb_lld_serve_interrupt+0x2ca>
    if (src & (1 << 20))
 8003e1c:	02e0      	lsls	r0, r4, #11
 8003e1e:	f100 8119 	bmi.w	8004054 <usb_lld_serve_interrupt+0x2c0>
    if (src & (1 << 21))
 8003e22:	02a1      	lsls	r1, r4, #10
 8003e24:	f100 8111 	bmi.w	800404a <usb_lld_serve_interrupt+0x2b6>
    if (src & (1 << 22))
 8003e28:	0262      	lsls	r2, r4, #9
 8003e2a:	f100 8109 	bmi.w	8004040 <usb_lld_serve_interrupt+0x2ac>
    if (src & (1 << 23))
 8003e2e:	0223      	lsls	r3, r4, #8
 8003e30:	f100 8101 	bmi.w	8004036 <usb_lld_serve_interrupt+0x2a2>
    if (src & (1 << 24))
 8003e34:	01e0      	lsls	r0, r4, #7
 8003e36:	f100 80f4 	bmi.w	8004022 <usb_lld_serve_interrupt+0x28e>
  if (sts & GINTSTS_IEPINT) {
 8003e3a:	0371      	lsls	r1, r6, #13
 8003e3c:	d51a      	bpl.n	8003e74 <usb_lld_serve_interrupt+0xe0>
    if (src & (1 << 0))
 8003e3e:	07e2      	lsls	r2, r4, #31
 8003e40:	f100 8144 	bmi.w	80040cc <usb_lld_serve_interrupt+0x338>
    if (src & (1 << 1))
 8003e44:	07a3      	lsls	r3, r4, #30
 8003e46:	f100 813c 	bmi.w	80040c2 <usb_lld_serve_interrupt+0x32e>
    if (src & (1 << 2))
 8003e4a:	0760      	lsls	r0, r4, #29
 8003e4c:	f100 8134 	bmi.w	80040b8 <usb_lld_serve_interrupt+0x324>
    if (src & (1 << 3))
 8003e50:	0721      	lsls	r1, r4, #28
 8003e52:	f100 812c 	bmi.w	80040ae <usb_lld_serve_interrupt+0x31a>
    if (src & (1 << 4))
 8003e56:	06e2      	lsls	r2, r4, #27
 8003e58:	f100 8124 	bmi.w	80040a4 <usb_lld_serve_interrupt+0x310>
    if (src & (1 << 5))
 8003e5c:	06a3      	lsls	r3, r4, #26
 8003e5e:	f100 811c 	bmi.w	800409a <usb_lld_serve_interrupt+0x306>
    if (src & (1 << 6))
 8003e62:	0660      	lsls	r0, r4, #25
 8003e64:	f100 8114 	bmi.w	8004090 <usb_lld_serve_interrupt+0x2fc>
    if (src & (1 << 7))
 8003e68:	0621      	lsls	r1, r4, #24
 8003e6a:	f100 810c 	bmi.w	8004086 <usb_lld_serve_interrupt+0x2f2>
    if (src & (1 << 8))
 8003e6e:	05e2      	lsls	r2, r4, #23
 8003e70:	f100 80dc 	bmi.w	800402c <usb_lld_serve_interrupt+0x298>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8003e74:	06f3      	lsls	r3, r6, #27
 8003e76:	f100 80a2 	bmi.w	8003fbe <usb_lld_serve_interrupt+0x22a>
  if ((sts & IRQ_RETRY_MASK) && (--retry > 0U))
 8003e7a:	ea16 0f0a 	tst.w	r6, sl
 8003e7e:	f000 80ce 	beq.w	800401e <usb_lld_serve_interrupt+0x28a>
 8003e82:	f1b9 0901 	subs.w	r9, r9, #1
 8003e86:	f000 80ca 	beq.w	800401e <usb_lld_serve_interrupt+0x28a>
  sts  = otgp->GINTSTS;
 8003e8a:	697e      	ldr	r6, [r7, #20]
  sts &= otgp->GINTMSK;
 8003e8c:	69bb      	ldr	r3, [r7, #24]
 8003e8e:	401e      	ands	r6, r3
  if (sts & GINTSTS_USBRST) {
 8003e90:	f416 5880 	ands.w	r8, r6, #4096	; 0x1000
  otgp->GINTSTS = sts;
 8003e94:	617e      	str	r6, [r7, #20]
  if (sts & GINTSTS_USBRST) {
 8003e96:	f040 8162 	bne.w	800415e <usb_lld_serve_interrupt+0x3ca>
  if (sts & GINTSTS_WKUPINT) {
 8003e9a:	2e00      	cmp	r6, #0
 8003e9c:	da84      	bge.n	8003da8 <usb_lld_serve_interrupt+0x14>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8003e9e:	f8d7 3e00 	ldr.w	r3, [r7, #3584]	; 0xe00
 8003ea2:	0799      	lsls	r1, r3, #30
 8003ea4:	d005      	beq.n	8003eb2 <usb_lld_serve_interrupt+0x11e>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8003ea6:	f8d7 3e00 	ldr.w	r3, [r7, #3584]	; 0xe00
 8003eaa:	f023 0303 	bic.w	r3, r3, #3
 8003eae:	f8c7 3e00 	str.w	r3, [r7, #3584]	; 0xe00
    otg_enable_ep(usbp);
 8003eb2:	4628      	mov	r0, r5
 8003eb4:	f7ff fba6 	bl	8003604 <otg_enable_ep>
    otgp->DCTL &= ~DCTL_RWUSIG;
 8003eb8:	f8d7 3804 	ldr.w	r3, [r7, #2052]	; 0x804
    _usb_wakeup(usbp);
 8003ebc:	4628      	mov	r0, r5
    otgp->DCTL &= ~DCTL_RWUSIG;
 8003ebe:	f023 0301 	bic.w	r3, r3, #1
 8003ec2:	f8c7 3804 	str.w	r3, [r7, #2052]	; 0x804
    _usb_wakeup(usbp);
 8003ec6:	f7fd fcd1 	bl	800186c <_usb_wakeup>
  if (sts & GINTSTS_USBSUSP) {
 8003eca:	0532      	lsls	r2, r6, #20
 8003ecc:	f57f af6f 	bpl.w	8003dae <usb_lld_serve_interrupt+0x1a>
    otg_disable_ep(usbp);
 8003ed0:	e9d5 0124 	ldrd	r0, r1, [r5, #144]	; 0x90
 8003ed4:	f7ff fbc0 	bl	8003658 <otg_disable_ep.isra.0>
    _usb_suspend(usbp);
 8003ed8:	4628      	mov	r0, r5
 8003eda:	f7fd fcb5 	bl	8001848 <_usb_suspend>
 8003ede:	e766      	b.n	8003dae <usb_lld_serve_interrupt+0x1a>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003ee0:	2000      	movs	r0, #0
  stm32_otg_t *otgp = usbp->otg;
 8003ee2:	f8d5 b090 	ldr.w	fp, [r5, #144]	; 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003ee6:	4604      	mov	r4, r0
 8003ee8:	e008      	b.n	8003efc <usb_lld_serve_interrupt+0x168>
 8003eea:	3401      	adds	r4, #1
 8003eec:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8003ef0:	b2e4      	uxtb	r4, r4
 8003ef2:	689b      	ldr	r3, [r3, #8]
 8003ef4:	429c      	cmp	r4, r3
 8003ef6:	4620      	mov	r0, r4
 8003ef8:	f63f af7d 	bhi.w	8003df6 <usb_lld_serve_interrupt+0x62>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8003efc:	eb0b 1144 	add.w	r1, fp, r4, lsl #5
 8003f00:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8003f04:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8003f08:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003f0c:	d1ed      	bne.n	8003eea <usb_lld_serve_interrupt+0x156>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8003f0e:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8003f12:	2b00      	cmp	r3, #0
 8003f14:	dae9      	bge.n	8003eea <usb_lld_serve_interrupt+0x156>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8003f16:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8003f1a:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 8003f1e:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8003f22:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8003f26:	2b00      	cmp	r3, #0
 8003f28:	dbfb      	blt.n	8003f22 <usb_lld_serve_interrupt+0x18e>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003f2a:	0180      	lsls	r0, r0, #6
 8003f2c:	f8d5 1090 	ldr.w	r1, [r5, #144]	; 0x90
 8003f30:	f040 0020 	orr.w	r0, r0, #32
 8003f34:	6108      	str	r0, [r1, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8003f36:	690b      	ldr	r3, [r1, #16]
 8003f38:	069a      	lsls	r2, r3, #26
 8003f3a:	d4fc      	bmi.n	8003f36 <usb_lld_serve_interrupt+0x1a2>
  chSysPolledDelayX(cycles);
 8003f3c:	2012      	movs	r0, #18
 8003f3e:	f001 fe9d 	bl	8005c7c <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
 8003f42:	2301      	movs	r3, #1
 8003f44:	8929      	ldrh	r1, [r5, #8]
 8003f46:	fa03 f004 	lsl.w	r0, r3, r4
 8003f4a:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8003f4e:	68db      	ldr	r3, [r3, #12]
 8003f50:	ea21 0100 	bic.w	r1, r1, r0
 8003f54:	689b      	ldr	r3, [r3, #8]
 8003f56:	8129      	strh	r1, [r5, #8]
 8003f58:	2b00      	cmp	r3, #0
 8003f5a:	d0c6      	beq.n	8003eea <usb_lld_serve_interrupt+0x156>
 8003f5c:	4621      	mov	r1, r4
 8003f5e:	4628      	mov	r0, r5
 8003f60:	4798      	blx	r3
 8003f62:	e7c2      	b.n	8003eea <usb_lld_serve_interrupt+0x156>
  stm32_otg_t *otgp = usbp->otg;
 8003f64:	f8d5 b090 	ldr.w	fp, [r5, #144]	; 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003f68:	2400      	movs	r4, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 8003f6a:	2201      	movs	r2, #1
 8003f6c:	e007      	b.n	8003f7e <usb_lld_serve_interrupt+0x1ea>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003f6e:	3401      	adds	r4, #1
 8003f70:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8003f74:	b2e4      	uxtb	r4, r4
 8003f76:	689b      	ldr	r3, [r3, #8]
 8003f78:	429c      	cmp	r4, r3
 8003f7a:	f63f af3f 	bhi.w	8003dfc <usb_lld_serve_interrupt+0x68>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8003f7e:	eb0b 1144 	add.w	r1, fp, r4, lsl #5
 8003f82:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8003f86:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8003f8a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003f8e:	d1ee      	bne.n	8003f6e <usb_lld_serve_interrupt+0x1da>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8003f90:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
      _usb_isr_invoke_out_cb(usbp, ep);
 8003f94:	eb05 0084 	add.w	r0, r5, r4, lsl #2
 8003f98:	fa02 fe04 	lsl.w	lr, r2, r4
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8003f9c:	2b00      	cmp	r3, #0
 8003f9e:	dae6      	bge.n	8003f6e <usb_lld_serve_interrupt+0x1da>
      _usb_isr_invoke_out_cb(usbp, ep);
 8003fa0:	68c3      	ldr	r3, [r0, #12]
 8003fa2:	4621      	mov	r1, r4
 8003fa4:	f8b5 c00a 	ldrh.w	ip, [r5, #10]
 8003fa8:	4628      	mov	r0, r5
 8003faa:	68db      	ldr	r3, [r3, #12]
 8003fac:	ea2c 0c0e 	bic.w	ip, ip, lr
 8003fb0:	f8a5 c00a 	strh.w	ip, [r5, #10]
 8003fb4:	2b00      	cmp	r3, #0
 8003fb6:	d0da      	beq.n	8003f6e <usb_lld_serve_interrupt+0x1da>
 8003fb8:	4798      	blx	r3
 8003fba:	2201      	movs	r2, #1
 8003fbc:	e7d7      	b.n	8003f6e <usb_lld_serve_interrupt+0x1da>
  sts = usbp->otg->GRXSTSP;
 8003fbe:	f8d5 4090 	ldr.w	r4, [r5, #144]	; 0x90
 8003fc2:	6a23      	ldr	r3, [r4, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8003fc4:	f403 11f0 	and.w	r1, r3, #1966080	; 0x1e0000
  n  = (size_t)((sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF);
 8003fc8:	f3c3 120a 	ubfx	r2, r3, #4, #11
  ep = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8003fcc:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8003fd0:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 8003fd4:	f000 8091 	beq.w	80040fa <usb_lld_serve_interrupt+0x366>
 8003fd8:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 8003fdc:	f47f af4d 	bne.w	8003e7a <usb_lld_serve_interrupt+0xe6>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8003fe0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8003fe4:	68db      	ldr	r3, [r3, #12]
 8003fe6:	6a18      	ldr	r0, [r3, #32]
  while (i < n) {
 8003fe8:	2a00      	cmp	r2, #0
 8003fea:	f43f af46 	beq.w	8003e7a <usb_lld_serve_interrupt+0xe6>
      w = *fifop;
 8003fee:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  size_t i = 0;
 8003ff2:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8003ff4:	f013 0f03 	tst.w	r3, #3
      *buf++ = (uint8_t)w;
 8003ff8:	4601      	mov	r1, r0
    if ((i & 3) == 0) {
 8003ffa:	d101      	bne.n	8004000 <usb_lld_serve_interrupt+0x26c>
      w = *fifop;
 8003ffc:	f8d4 8000 	ldr.w	r8, [r4]
    if (i < max) {
 8004000:	2b07      	cmp	r3, #7
    i++;
 8004002:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 8004006:	d804      	bhi.n	8004012 <usb_lld_serve_interrupt+0x27e>
      *buf++ = (uint8_t)w;
 8004008:	f801 8b01 	strb.w	r8, [r1], #1
      w >>= 8;
 800400c:	ea4f 2818 	mov.w	r8, r8, lsr #8
      *buf++ = (uint8_t)w;
 8004010:	4608      	mov	r0, r1
  while (i < n) {
 8004012:	429a      	cmp	r2, r3
 8004014:	d1ee      	bne.n	8003ff4 <usb_lld_serve_interrupt+0x260>
  if ((sts & IRQ_RETRY_MASK) && (--retry > 0U))
 8004016:	ea16 0f0a 	tst.w	r6, sl
 800401a:	f47f af32 	bne.w	8003e82 <usb_lld_serve_interrupt+0xee>
}
 800401e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      otg_epout_handler(usbp, 8);
 8004022:	2108      	movs	r1, #8
 8004024:	4628      	mov	r0, r5
 8004026:	f7ff fd93 	bl	8003b50 <otg_epout_handler>
 800402a:	e706      	b.n	8003e3a <usb_lld_serve_interrupt+0xa6>
      otg_epin_handler(usbp, 8);
 800402c:	2108      	movs	r1, #8
 800402e:	4628      	mov	r0, r5
 8004030:	f7ff fe2e 	bl	8003c90 <otg_epin_handler>
 8004034:	e71e      	b.n	8003e74 <usb_lld_serve_interrupt+0xe0>
      otg_epout_handler(usbp, 7);
 8004036:	2107      	movs	r1, #7
 8004038:	4628      	mov	r0, r5
 800403a:	f7ff fd89 	bl	8003b50 <otg_epout_handler>
 800403e:	e6f9      	b.n	8003e34 <usb_lld_serve_interrupt+0xa0>
      otg_epout_handler(usbp, 6);
 8004040:	2106      	movs	r1, #6
 8004042:	4628      	mov	r0, r5
 8004044:	f7ff fd84 	bl	8003b50 <otg_epout_handler>
 8004048:	e6f1      	b.n	8003e2e <usb_lld_serve_interrupt+0x9a>
      otg_epout_handler(usbp, 5);
 800404a:	2105      	movs	r1, #5
 800404c:	4628      	mov	r0, r5
 800404e:	f7ff fd7f 	bl	8003b50 <otg_epout_handler>
 8004052:	e6e9      	b.n	8003e28 <usb_lld_serve_interrupt+0x94>
      otg_epout_handler(usbp, 4);
 8004054:	2104      	movs	r1, #4
 8004056:	4628      	mov	r0, r5
 8004058:	f7ff fd7a 	bl	8003b50 <otg_epout_handler>
 800405c:	e6e1      	b.n	8003e22 <usb_lld_serve_interrupt+0x8e>
      otg_epout_handler(usbp, 3);
 800405e:	2103      	movs	r1, #3
 8004060:	4628      	mov	r0, r5
 8004062:	f7ff fd75 	bl	8003b50 <otg_epout_handler>
 8004066:	e6d9      	b.n	8003e1c <usb_lld_serve_interrupt+0x88>
      otg_epout_handler(usbp, 2);
 8004068:	2102      	movs	r1, #2
 800406a:	4628      	mov	r0, r5
 800406c:	f7ff fd70 	bl	8003b50 <otg_epout_handler>
 8004070:	e6d1      	b.n	8003e16 <usb_lld_serve_interrupt+0x82>
      otg_epout_handler(usbp, 1);
 8004072:	2101      	movs	r1, #1
 8004074:	4628      	mov	r0, r5
 8004076:	f7ff fd6b 	bl	8003b50 <otg_epout_handler>
 800407a:	e6c9      	b.n	8003e10 <usb_lld_serve_interrupt+0x7c>
      otg_epout_handler(usbp, 0);
 800407c:	2100      	movs	r1, #0
 800407e:	4628      	mov	r0, r5
 8004080:	f7ff fd66 	bl	8003b50 <otg_epout_handler>
 8004084:	e6c1      	b.n	8003e0a <usb_lld_serve_interrupt+0x76>
      otg_epin_handler(usbp, 7);
 8004086:	2107      	movs	r1, #7
 8004088:	4628      	mov	r0, r5
 800408a:	f7ff fe01 	bl	8003c90 <otg_epin_handler>
 800408e:	e6ee      	b.n	8003e6e <usb_lld_serve_interrupt+0xda>
      otg_epin_handler(usbp, 6);
 8004090:	2106      	movs	r1, #6
 8004092:	4628      	mov	r0, r5
 8004094:	f7ff fdfc 	bl	8003c90 <otg_epin_handler>
 8004098:	e6e6      	b.n	8003e68 <usb_lld_serve_interrupt+0xd4>
      otg_epin_handler(usbp, 5);
 800409a:	2105      	movs	r1, #5
 800409c:	4628      	mov	r0, r5
 800409e:	f7ff fdf7 	bl	8003c90 <otg_epin_handler>
 80040a2:	e6de      	b.n	8003e62 <usb_lld_serve_interrupt+0xce>
      otg_epin_handler(usbp, 4);
 80040a4:	2104      	movs	r1, #4
 80040a6:	4628      	mov	r0, r5
 80040a8:	f7ff fdf2 	bl	8003c90 <otg_epin_handler>
 80040ac:	e6d6      	b.n	8003e5c <usb_lld_serve_interrupt+0xc8>
      otg_epin_handler(usbp, 3);
 80040ae:	2103      	movs	r1, #3
 80040b0:	4628      	mov	r0, r5
 80040b2:	f7ff fded 	bl	8003c90 <otg_epin_handler>
 80040b6:	e6ce      	b.n	8003e56 <usb_lld_serve_interrupt+0xc2>
      otg_epin_handler(usbp, 2);
 80040b8:	2102      	movs	r1, #2
 80040ba:	4628      	mov	r0, r5
 80040bc:	f7ff fde8 	bl	8003c90 <otg_epin_handler>
 80040c0:	e6c6      	b.n	8003e50 <usb_lld_serve_interrupt+0xbc>
      otg_epin_handler(usbp, 1);
 80040c2:	2101      	movs	r1, #1
 80040c4:	4628      	mov	r0, r5
 80040c6:	f7ff fde3 	bl	8003c90 <otg_epin_handler>
 80040ca:	e6be      	b.n	8003e4a <usb_lld_serve_interrupt+0xb6>
      otg_epin_handler(usbp, 0);
 80040cc:	2100      	movs	r1, #0
 80040ce:	4628      	mov	r0, r5
 80040d0:	f7ff fdde 	bl	8003c90 <otg_epin_handler>
 80040d4:	e6b6      	b.n	8003e44 <usb_lld_serve_interrupt+0xb0>
      otgp->GINTMSK &= ~GINTMSK_SOFM;
 80040d6:	69bb      	ldr	r3, [r7, #24]
 80040d8:	f023 0308 	bic.w	r3, r3, #8
 80040dc:	61bb      	str	r3, [r7, #24]
    if (usbp->state == USB_SUSPENDED) {
 80040de:	782b      	ldrb	r3, [r5, #0]
 80040e0:	2b05      	cmp	r3, #5
 80040e2:	f47f ae7e 	bne.w	8003de2 <usb_lld_serve_interrupt+0x4e>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 80040e6:	f8d7 3e00 	ldr.w	r3, [r7, #3584]	; 0xe00
      _usb_wakeup(usbp);
 80040ea:	4628      	mov	r0, r5
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 80040ec:	f023 0303 	bic.w	r3, r3, #3
 80040f0:	f8c7 3e00 	str.w	r3, [r7, #3584]	; 0xe00
      _usb_wakeup(usbp);
 80040f4:	f7fd fbba 	bl	800186c <_usb_wakeup>
 80040f8:	e673      	b.n	8003de2 <usb_lld_serve_interrupt+0x4e>
    max = usbp->epc[ep]->out_state->rxsize - usbp->epc[ep]->out_state->rxcnt;
 80040fa:	eb05 0083 	add.w	r0, r5, r3, lsl #2
 80040fe:	68c1      	ldr	r1, [r0, #12]
 8004100:	698b      	ldr	r3, [r1, #24]
 8004102:	e9d3 1b00 	ldrd	r1, fp, [r3]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8004106:	f8d3 c008 	ldr.w	ip, [r3, #8]
    max = usbp->epc[ep]->out_state->rxsize - usbp->epc[ep]->out_state->rxcnt;
 800410a:	eba1 0e0b 	sub.w	lr, r1, fp
  while (i < n) {
 800410e:	b1ba      	cbz	r2, 8004140 <usb_lld_serve_interrupt+0x3ac>
      w = *fifop;
 8004110:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  size_t i = 0;
 8004114:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8004116:	f013 0f03 	tst.w	r3, #3
      *buf++ = (uint8_t)w;
 800411a:	4661      	mov	r1, ip
    if ((i & 3) == 0) {
 800411c:	d101      	bne.n	8004122 <usb_lld_serve_interrupt+0x38e>
      w = *fifop;
 800411e:	f8d4 8000 	ldr.w	r8, [r4]
    if (i < max) {
 8004122:	459e      	cmp	lr, r3
    i++;
 8004124:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 8004128:	d904      	bls.n	8004134 <usb_lld_serve_interrupt+0x3a0>
      *buf++ = (uint8_t)w;
 800412a:	f801 8b01 	strb.w	r8, [r1], #1
      w >>= 8;
 800412e:	ea4f 2818 	mov.w	r8, r8, lsr #8
      *buf++ = (uint8_t)w;
 8004132:	468c      	mov	ip, r1
  while (i < n) {
 8004134:	429a      	cmp	r2, r3
 8004136:	d1ee      	bne.n	8004116 <usb_lld_serve_interrupt+0x382>
      usbp->epc[ep]->out_state->rxbuf += n;
 8004138:	68c3      	ldr	r3, [r0, #12]
 800413a:	699b      	ldr	r3, [r3, #24]
      usbp->epc[ep]->out_state->rxcnt += n;
 800413c:	e9d3 bc01 	ldrd	fp, ip, [r3, #4]
    if (n < max) {
 8004140:	4572      	cmp	r2, lr
 8004142:	d205      	bcs.n	8004150 <usb_lld_serve_interrupt+0x3bc>
      usbp->epc[ep]->out_state->rxbuf += n;
 8004144:	eb0c 0102 	add.w	r1, ip, r2
      usbp->epc[ep]->out_state->rxcnt += n;
 8004148:	445a      	add	r2, fp
 800414a:	e9c3 2101 	strd	r2, r1, [r3, #4]
 800414e:	e694      	b.n	8003e7a <usb_lld_serve_interrupt+0xe6>
      usbp->epc[ep]->out_state->rxbuf += max;
 8004150:	eb0c 020e 	add.w	r2, ip, lr
      usbp->epc[ep]->out_state->rxcnt += max;
 8004154:	eb0e 010b 	add.w	r1, lr, fp
 8004158:	e9c3 1201 	strd	r1, r2, [r3, #4]
 800415c:	e68d      	b.n	8003e7a <usb_lld_serve_interrupt+0xe6>
    _usb_reset(usbp);
 800415e:	4628      	mov	r0, r5
}
 8004160:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _usb_reset(usbp);
 8004164:	f7fd bb54 	b.w	8001810 <_usb_reset>
 8004168:	04000030 	.word	0x04000030

0800416c <Vector1D4>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 800416c:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 800416e:	4c07      	ldr	r4, [pc, #28]	; (800418c <Vector1D4+0x20>)
 8004170:	4620      	mov	r0, r4
 8004172:	f001 fdf3 	bl	8005d5c <__trace_isr_enter>
  usb_lld_serve_interrupt(&USBD1);
 8004176:	4806      	ldr	r0, [pc, #24]	; (8004190 <Vector1D4+0x24>)
 8004178:	f7ff fe0c 	bl	8003d94 <usb_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 800417c:	4620      	mov	r0, r4
 800417e:	f001 fe05 	bl	8005d8c <__trace_isr_leave>
}
 8004182:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004186:	f002 bd79 	b.w	8006c7c <__port_irq_epilogue>
 800418a:	bf00      	nop
 800418c:	08014dec 	.word	0x08014dec
 8004190:	24000874 	.word	0x24000874

08004194 <Vector174>:
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8004194:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004196:	4c07      	ldr	r4, [pc, #28]	; (80041b4 <Vector174+0x20>)
 8004198:	4620      	mov	r0, r4
 800419a:	f001 fddf 	bl	8005d5c <__trace_isr_enter>
  usb_lld_serve_interrupt(&USBD2);
 800419e:	4806      	ldr	r0, [pc, #24]	; (80041b8 <Vector174+0x24>)
 80041a0:	f7ff fdf8 	bl	8003d94 <usb_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 80041a4:	4620      	mov	r0, r4
 80041a6:	f001 fdf1 	bl	8005d8c <__trace_isr_leave>
}
 80041aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80041ae:	f002 bd65 	b.w	8006c7c <__port_irq_epilogue>
 80041b2:	bf00      	nop
 80041b4:	08014de0 	.word	0x08014de0
 80041b8:	24000910 	.word	0x24000910

080041bc <usb_lld_stall_out>:
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80041bc:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 80041c0:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 80041c4:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80041c8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80041cc:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 80041d0:	4770      	bx	lr
 80041d2:	bf00      	nop

080041d4 <usb_lld_stall_in>:
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80041d4:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 80041d8:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 80041dc:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 80041e0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80041e4:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
}
 80041e8:	4770      	bx	lr
 80041ea:	bf00      	nop

080041ec <usb_lld_clear_out>:
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80041ec:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 80041f0:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 80041f4:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80041f8:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80041fc:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8004200:	4770      	bx	lr
 8004202:	bf00      	nop

08004204 <usb_lld_clear_in>:
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8004204:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8004208:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 800420c:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8004210:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8004214:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
}
 8004218:	4770      	bx	lr
 800421a:	bf00      	nop

0800421c <sdc_lld_collect_errors>:
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
  uint32_t errors = SDC_NO_ERROR;

  if (sta & SDMMC_STA_CCRCFAIL)
 800421c:	f001 0301 	and.w	r3, r1, #1
    errors |= SDC_CMD_CRC_ERROR;
  if (sta & SDMMC_STA_DCRCFAIL)
 8004220:	078a      	lsls	r2, r1, #30
    errors |= SDC_DATA_CRC_ERROR;
 8004222:	bf48      	it	mi
 8004224:	f043 0302 	orrmi.w	r3, r3, #2
  if (sta & SDMMC_STA_CTIMEOUT)
 8004228:	074a      	lsls	r2, r1, #29
    errors |= SDC_COMMAND_TIMEOUT;
 800422a:	bf48      	it	mi
 800422c:	f043 0308 	orrmi.w	r3, r3, #8
  if (sta & SDMMC_STA_DTIMEOUT)
 8004230:	070a      	lsls	r2, r1, #28
    errors |= SDC_DATA_TIMEOUT;
 8004232:	bf48      	it	mi
 8004234:	f043 0304 	orrmi.w	r3, r3, #4
  if (sta & SDMMC_STA_TXUNDERR)
 8004238:	06ca      	lsls	r2, r1, #27
    errors |= SDC_TX_UNDERRUN;
 800423a:	bf48      	it	mi
 800423c:	f043 0310 	orrmi.w	r3, r3, #16
  if (sta & SDMMC_STA_RXOVERR)
 8004240:	068a      	lsls	r2, r1, #26
    errors |= SDC_RX_OVERRUN;
/*  if (sta & SDMMC_STA_STBITERR)
    errors |= SDC_STARTBIT_ERROR;*/

  sdcp->errors |= errors;
 8004242:	6b42      	ldr	r2, [r0, #52]	; 0x34
    errors |= SDC_RX_OVERRUN;
 8004244:	bf48      	it	mi
 8004246:	f043 0320 	orrmi.w	r3, r3, #32
  sdcp->errors |= errors;
 800424a:	431a      	orrs	r2, r3
 800424c:	6342      	str	r2, [r0, #52]	; 0x34
}
 800424e:	4770      	bx	lr

08004250 <sdc_lld_wait_transaction_end>:
                                         uint32_t *resp) {
 8004250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004252:	2330      	movs	r3, #48	; 0x30
 8004254:	4605      	mov	r5, r0
 8004256:	460f      	mov	r7, r1
 8004258:	4616      	mov	r6, r2
 800425a:	f383 8811 	msr	BASEPRI, r3
  if (sdcp->sdmmc->MASK != 0U) {
 800425e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8004260:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004262:	b9a3      	cbnz	r3, 800428e <sdc_lld_wait_transaction_end+0x3e>
  sdcp->sdmmc->IDMACTRL = 0U;
 8004264:	2300      	movs	r3, #0
 8004266:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->MASK     = 0U;
 8004268:	63e3      	str	r3, [r4, #60]	; 0x3c
  sdcp->sdmmc->DCTRL    = 0U;
 800426a:	62e3      	str	r3, [r4, #44]	; 0x2c
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0U) {
 800426c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800426e:	f410 7080 	ands.w	r0, r0, #256	; 0x100
 8004272:	d008      	beq.n	8004286 <sdc_lld_wait_transaction_end+0x36>
  sdcp->sdmmc->ICR = SDMMC_ICR_ALL_FLAGS;
 8004274:	f04f 32ff 	mov.w	r2, #4294967295
 8004278:	63a2      	str	r2, [r4, #56]	; 0x38
 800427a:	f383 8811 	msr	BASEPRI, r3
  if (n > 1U) {
 800427e:	2f01      	cmp	r7, #1
 8004280:	d80c      	bhi.n	800429c <sdc_lld_wait_transaction_end+0x4c>
  return HAL_SUCCESS;
 8004282:	4618      	mov	r0, r3
}
 8004284:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004286:	f380 8811 	msr	BASEPRI, r0
    return HAL_FAILED;
 800428a:	2001      	movs	r0, #1
}
 800428c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 800428e:	f04f 31ff 	mov.w	r1, #4294967295
 8004292:	3040      	adds	r0, #64	; 0x40
 8004294:	f002 f9cc 	bl	8006630 <chThdSuspendTimeoutS>
  sdcp->sdmmc->IDMACTRL = 0U;
 8004298:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 800429a:	e7e3      	b.n	8004264 <sdc_lld_wait_transaction_end+0x14>
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 800429c:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800429e:	f241 110c 	movw	r1, #4364	; 0x110c
  sdcp->sdmmc->ARG = arg;
 80042a2:	6093      	str	r3, [r2, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80042a4:	60d1      	str	r1, [r2, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80042a6:	6b51      	ldr	r1, [r2, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 80042a8:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 80042ac:	d0fb      	beq.n	80042a6 <sdc_lld_wait_transaction_end+0x56>
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80042ae:	6393      	str	r3, [r2, #56]	; 0x38
                            SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 80042b0:	f011 0305 	ands.w	r3, r1, #5
 80042b4:	d103      	bne.n	80042be <sdc_lld_wait_transaction_end+0x6e>
    sdc_lld_collect_errors(sdcp, sta);
    return HAL_FAILED;
  }
  *resp = sdcp->sdmmc->RESP1;
 80042b6:	6952      	ldr	r2, [r2, #20]
  return HAL_SUCCESS;
 80042b8:	4618      	mov	r0, r3
  *resp = sdcp->sdmmc->RESP1;
 80042ba:	6032      	str	r2, [r6, #0]
}
 80042bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    sdc_lld_collect_errors(sdcp, sta);
 80042be:	4628      	mov	r0, r5
 80042c0:	f7ff ffac 	bl	800421c <sdc_lld_collect_errors>
    return HAL_FAILED;
 80042c4:	2001      	movs	r0, #1
}
 80042c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080042c8 <sdc_lld_init>:
void sdc_lld_init(void) {
 80042c8:	b510      	push	{r4, lr}
  sdcObjectInit(&SDCD1);
 80042ca:	4c07      	ldr	r4, [pc, #28]	; (80042e8 <sdc_lld_init+0x20>)
 80042cc:	4620      	mov	r0, r4
 80042ce:	f7fd f94d 	bl	800156c <sdcObjectInit>
  SDCD1.sdmmc   = SDMMC1;
 80042d2:	4b06      	ldr	r3, [pc, #24]	; (80042ec <sdc_lld_init+0x24>)
  SDCD1.thread  = NULL;
 80042d4:	2000      	movs	r0, #0
  SDCD1.clkfreq = STM32_SDMMC1CLK;
 80042d6:	4906      	ldr	r1, [pc, #24]	; (80042f0 <sdc_lld_init+0x28>)
  SDCD1.buf     = __nocache_sd1_buf;
 80042d8:	4a06      	ldr	r2, [pc, #24]	; (80042f4 <sdc_lld_init+0x2c>)
  SDCD1.clkfreq = STM32_SDMMC1CLK;
 80042da:	64a1      	str	r1, [r4, #72]	; 0x48
  SDCD1.buf     = __nocache_sd1_buf;
 80042dc:	63e2      	str	r2, [r4, #60]	; 0x3c
  SDCD1.sdmmc   = SDMMC1;
 80042de:	e9c4 0310 	strd	r0, r3, [r4, #64]	; 0x40
  SDCD1.resp    = __nocache_sd1_wbuf;
 80042e2:	4b05      	ldr	r3, [pc, #20]	; (80042f8 <sdc_lld_init+0x30>)
 80042e4:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 80042e6:	bd10      	pop	{r4, pc}
 80042e8:	240009c4 	.word	0x240009c4
 80042ec:	52007000 	.word	0x52007000
 80042f0:	02dc6c00 	.word	0x02dc6c00
 80042f4:	20000000 	.word	0x20000000
 80042f8:	20000200 	.word	0x20000200

080042fc <sdc_lld_start>:
  if (sdcp->config == NULL) {
 80042fc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80042fe:	b183      	cbz	r3, 8004322 <sdc_lld_start+0x26>
  if (sdcp->state == BLK_STOP) {
 8004300:	7903      	ldrb	r3, [r0, #4]
    if (&SDCD1 == sdcp) {
 8004302:	2b01      	cmp	r3, #1
 8004304:	d102      	bne.n	800430c <sdc_lld_start+0x10>
 8004306:	4b10      	ldr	r3, [pc, #64]	; (8004348 <sdc_lld_start+0x4c>)
 8004308:	4298      	cmp	r0, r3
 800430a:	d00d      	beq.n	8004328 <sdc_lld_start+0x2c>
  sdcp->sdmmc->IDMACTRL = 0U;
 800430c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800430e:	2200      	movs	r2, #0
  sdcp->sdmmc->ICR      = SDMMC_ICR_ALL_FLAGS;
 8004310:	f04f 31ff 	mov.w	r1, #4294967295
  sdcp->sdmmc->IDMACTRL = 0U;
 8004314:	651a      	str	r2, [r3, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 8004316:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->sdmmc->POWER    = 0U;
 8004318:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR    = 0U;
 800431a:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->DTIMER   = 0U;
 800431c:	625a      	str	r2, [r3, #36]	; 0x24
  sdcp->sdmmc->ICR      = SDMMC_ICR_ALL_FLAGS;
 800431e:	6399      	str	r1, [r3, #56]	; 0x38
}
 8004320:	4770      	bx	lr
    sdcp->config = &sdc_default_cfg;
 8004322:	4b0a      	ldr	r3, [pc, #40]	; (800434c <sdc_lld_start+0x50>)
 8004324:	62c3      	str	r3, [r0, #44]	; 0x2c
 8004326:	e7eb      	b.n	8004300 <sdc_lld_start+0x4>
  RCC_C1->AHB3ENR |= mask;
 8004328:	4b09      	ldr	r3, [pc, #36]	; (8004350 <sdc_lld_start+0x54>)
 800432a:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 800432e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004332:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
    RCC_C1->AHB3LPENR |= mask;
 8004336:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
 800433a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800433e:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
  (void)RCC_C1->AHB3LPENR;
 8004342:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
}
 8004346:	e7e1      	b.n	800430c <sdc_lld_start+0x10>
 8004348:	240009c4 	.word	0x240009c4
 800434c:	08014e34 	.word	0x08014e34
 8004350:	58024400 	.word	0x58024400

08004354 <sdc_lld_start_clk>:
  if (f >= sdcp->clkfreq) {
 8004354:	4b0e      	ldr	r3, [pc, #56]	; (8004390 <sdc_lld_start_clk+0x3c>)
  sdcp->sdmmc->CLKCR  = sdc_lld_clkdiv(sdcp, 400000U);
 8004356:	e9d0 2111 	ldrd	r2, r1, [r0, #68]	; 0x44
void sdc_lld_start_clk(SDCDriver *sdcp) {
 800435a:	b410      	push	{r4}
  if (f >= sdcp->clkfreq) {
 800435c:	4299      	cmp	r1, r3
 800435e:	d913      	bls.n	8004388 <sdc_lld_start_clk+0x34>
  return sdcp->config->slowdown + ((sdcp->clkfreq + (f * 2U) - 1U) / (f * 2U));
 8004360:	4b0c      	ldr	r3, [pc, #48]	; (8004394 <sdc_lld_start_clk+0x40>)
 8004362:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8004364:	440b      	add	r3, r1
 8004366:	480c      	ldr	r0, [pc, #48]	; (8004398 <sdc_lld_start_clk+0x44>)
 8004368:	6861      	ldr	r1, [r4, #4]
 800436a:	0a1b      	lsrs	r3, r3, #8
 800436c:	fba0 0303 	umull	r0, r3, r0, r3
 8004370:	eb01 1313 	add.w	r3, r1, r3, lsr #4
  sdcp->sdmmc->CLKCR  = sdc_lld_clkdiv(sdcp, 400000U);
 8004374:	6053      	str	r3, [r2, #4]
  chThdSleep(delay);
 8004376:	2064      	movs	r0, #100	; 0x64
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
 8004378:	6813      	ldr	r3, [r2, #0]
}
 800437a:	f85d 4b04 	ldr.w	r4, [sp], #4
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
 800437e:	f043 0303 	orr.w	r3, r3, #3
 8004382:	6013      	str	r3, [r2, #0]
 8004384:	f002 b93e 	b.w	8006604 <chThdSleep>
    return sdcp->config->slowdown;
 8004388:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800438a:	685b      	ldr	r3, [r3, #4]
 800438c:	e7f2      	b.n	8004374 <sdc_lld_start_clk+0x20>
 800438e:	bf00      	nop
 8004390:	00061a80 	.word	0x00061a80
 8004394:	000c34ff 	.word	0x000c34ff
 8004398:	014f8b59 	.word	0x014f8b59

0800439c <sdc_lld_set_data_clk>:
  if (SDC_CLK_50MHz == clk) {
 800439c:	2901      	cmp	r1, #1
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & ~(SDMMC_CLKCR_PWRSAV_Msk |
 800439e:	4b16      	ldr	r3, [pc, #88]	; (80043f8 <sdc_lld_set_data_clk+0x5c>)
  if (f >= sdcp->clkfreq) {
 80043a0:	6c81      	ldr	r1, [r0, #72]	; 0x48
void sdc_lld_set_data_clk(SDCDriver *sdcp, sdcbusclk_t clk) {
 80043a2:	b430      	push	{r4, r5}
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & ~(SDMMC_CLKCR_PWRSAV_Msk |
 80043a4:	6c44      	ldr	r4, [r0, #68]	; 0x44
  if (SDC_CLK_50MHz == clk) {
 80043a6:	d017      	beq.n	80043d8 <sdc_lld_set_data_clk+0x3c>
  if (f >= sdcp->clkfreq) {
 80043a8:	4a14      	ldr	r2, [pc, #80]	; (80043fc <sdc_lld_set_data_clk+0x60>)
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & ~(SDMMC_CLKCR_PWRSAV_Msk |
 80043aa:	6865      	ldr	r5, [r4, #4]
  if (f >= sdcp->clkfreq) {
 80043ac:	4291      	cmp	r1, r2
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & ~(SDMMC_CLKCR_PWRSAV_Msk |
 80043ae:	ea03 0305 	and.w	r3, r3, r5
  if (f >= sdcp->clkfreq) {
 80043b2:	d90e      	bls.n	80043d2 <sdc_lld_set_data_clk+0x36>
  return sdcp->config->slowdown + ((sdcp->clkfreq + (f * 2U) - 1U) / (f * 2U));
 80043b4:	4a12      	ldr	r2, [pc, #72]	; (8004400 <sdc_lld_set_data_clk+0x64>)
 80043b6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80043b8:	440a      	add	r2, r1
 80043ba:	4812      	ldr	r0, [pc, #72]	; (8004404 <sdc_lld_set_data_clk+0x68>)
 80043bc:	6869      	ldr	r1, [r5, #4]
 80043be:	fba0 0202 	umull	r0, r2, r0, r2
 80043c2:	eb01 6212 	add.w	r2, r1, r2, lsr #24
                                                 SDMMC_CLKCR_CLKDIV_Msk)) |
 80043c6:	4313      	orrs	r3, r2
                         sdc_lld_clkdiv(sdcp, 25000000U) | SDMMC_CLKCR_PWRSAV;
 80043c8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & ~(SDMMC_CLKCR_PWRSAV_Msk |
 80043cc:	6063      	str	r3, [r4, #4]
}
 80043ce:	bc30      	pop	{r4, r5}
 80043d0:	4770      	bx	lr
    return sdcp->config->slowdown;
 80043d2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80043d4:	6852      	ldr	r2, [r2, #4]
 80043d6:	e7f6      	b.n	80043c6 <sdc_lld_set_data_clk+0x2a>
  if (f >= sdcp->clkfreq) {
 80043d8:	4a0b      	ldr	r2, [pc, #44]	; (8004408 <sdc_lld_set_data_clk+0x6c>)
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & ~(SDMMC_CLKCR_PWRSAV_Msk |
 80043da:	6865      	ldr	r5, [r4, #4]
  if (f >= sdcp->clkfreq) {
 80043dc:	4291      	cmp	r1, r2
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & ~(SDMMC_CLKCR_PWRSAV_Msk |
 80043de:	ea03 0305 	and.w	r3, r3, r5
  if (f >= sdcp->clkfreq) {
 80043e2:	d9f6      	bls.n	80043d2 <sdc_lld_set_data_clk+0x36>
  return sdcp->config->slowdown + ((sdcp->clkfreq + (f * 2U) - 1U) / (f * 2U));
 80043e4:	4a09      	ldr	r2, [pc, #36]	; (800440c <sdc_lld_set_data_clk+0x70>)
 80043e6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80043e8:	440a      	add	r2, r1
 80043ea:	4806      	ldr	r0, [pc, #24]	; (8004404 <sdc_lld_set_data_clk+0x68>)
 80043ec:	6869      	ldr	r1, [r5, #4]
 80043ee:	fba0 0202 	umull	r0, r2, r0, r2
 80043f2:	eb01 6252 	add.w	r2, r1, r2, lsr #25
 80043f6:	e7e6      	b.n	80043c6 <sdc_lld_set_data_clk+0x2a>
 80043f8:	ffffec00 	.word	0xffffec00
 80043fc:	017d7840 	.word	0x017d7840
 8004400:	02faf07f 	.word	0x02faf07f
 8004404:	55e63b89 	.word	0x55e63b89
 8004408:	02faf080 	.word	0x02faf080
 800440c:	05f5e0ff 	.word	0x05f5e0ff

08004410 <sdc_lld_stop_clk>:
  sdcp->sdmmc->CLKCR = 0U;
 8004410:	2200      	movs	r2, #0
 8004412:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8004414:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER = 0U;
 8004416:	601a      	str	r2, [r3, #0]
}
 8004418:	4770      	bx	lr
 800441a:	bf00      	nop

0800441c <sdc_lld_set_bus_mode>:
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 800441c:	6c42      	ldr	r2, [r0, #68]	; 0x44
  switch (mode) {
 800441e:	2901      	cmp	r1, #1
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 8004420:	6853      	ldr	r3, [r2, #4]
 8004422:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  switch (mode) {
 8004426:	d007      	beq.n	8004438 <sdc_lld_set_bus_mode+0x1c>
 8004428:	2902      	cmp	r1, #2
 800442a:	d001      	beq.n	8004430 <sdc_lld_set_bus_mode+0x14>
 800442c:	b111      	cbz	r1, 8004434 <sdc_lld_set_bus_mode+0x18>
}
 800442e:	4770      	bx	lr
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
 8004430:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004434:	6053      	str	r3, [r2, #4]
}
 8004436:	4770      	bx	lr
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
 8004438:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800443c:	6053      	str	r3, [r2, #4]
    break;
 800443e:	4770      	bx	lr

08004440 <sdc_lld_send_cmd_none>:
  sdcp->sdmmc->ARG = arg;
 8004440:	6c40      	ldr	r0, [r0, #68]	; 0x44
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 8004442:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
  sdcp->sdmmc->ARG = arg;
 8004446:	6082      	str	r2, [r0, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 8004448:	60c1      	str	r1, [r0, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0U) {
 800444a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800444c:	061b      	lsls	r3, r3, #24
 800444e:	d5fc      	bpl.n	800444a <sdc_lld_send_cmd_none+0xa>
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 8004450:	2380      	movs	r3, #128	; 0x80
 8004452:	6383      	str	r3, [r0, #56]	; 0x38
}
 8004454:	4770      	bx	lr
 8004456:	bf00      	nop

08004458 <sdc_lld_send_cmd_short>:
                            uint32_t *resp) {
 8004458:	b510      	push	{r4, lr}
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800445a:	f441 5188 	orr.w	r1, r1, #4352	; 0x1100
  sdcp->sdmmc->ARG = arg;
 800445e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8004460:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8004462:	60e1      	str	r1, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004464:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 8004466:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 800446a:	d0fb      	beq.n	8004464 <sdc_lld_send_cmd_short+0xc>
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800446c:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0U) {
 800446e:	f011 0204 	ands.w	r2, r1, #4
 8004472:	d103      	bne.n	800447c <sdc_lld_send_cmd_short+0x24>
  *resp = sdcp->sdmmc->RESP1;
 8004474:	6961      	ldr	r1, [r4, #20]
  return HAL_SUCCESS;
 8004476:	4610      	mov	r0, r2
  *resp = sdcp->sdmmc->RESP1;
 8004478:	6019      	str	r1, [r3, #0]
}
 800447a:	bd10      	pop	{r4, pc}
    sdc_lld_collect_errors(sdcp, sta);
 800447c:	f7ff fece 	bl	800421c <sdc_lld_collect_errors>
    return HAL_FAILED;
 8004480:	2001      	movs	r0, #1
}
 8004482:	bd10      	pop	{r4, pc}

08004484 <sdc_lld_send_cmd_short_crc>:
                                uint32_t *resp) {
 8004484:	b510      	push	{r4, lr}
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8004486:	f441 5188 	orr.w	r1, r1, #4352	; 0x1100
  sdcp->sdmmc->ARG = arg;
 800448a:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800448c:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800448e:	60e1      	str	r1, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004490:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 8004492:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 8004496:	d0fb      	beq.n	8004490 <sdc_lld_send_cmd_short_crc+0xc>
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004498:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 800449a:	f011 0205 	ands.w	r2, r1, #5
 800449e:	d103      	bne.n	80044a8 <sdc_lld_send_cmd_short_crc+0x24>
  *resp = sdcp->sdmmc->RESP1;
 80044a0:	6961      	ldr	r1, [r4, #20]
  return HAL_SUCCESS;
 80044a2:	4610      	mov	r0, r2
  *resp = sdcp->sdmmc->RESP1;
 80044a4:	6019      	str	r1, [r3, #0]
}
 80044a6:	bd10      	pop	{r4, pc}
    sdc_lld_collect_errors(sdcp, sta);
 80044a8:	f7ff feb8 	bl	800421c <sdc_lld_collect_errors>
    return HAL_FAILED;
 80044ac:	2001      	movs	r0, #1
}
 80044ae:	bd10      	pop	{r4, pc}

080044b0 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 80044b0:	b510      	push	{r4, lr}
  uint32_t sta;

  (void)sdcp;

  sdcp->sdmmc->ARG = arg;
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 80044b2:	f441 5198 	orr.w	r1, r1, #4864	; 0x1300
  sdcp->sdmmc->ARG = arg;
 80044b6:	6c44      	ldr	r4, [r0, #68]	; 0x44
 80044b8:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 80044ba:	60e1      	str	r1, [r4, #12]
                                    SDMMC_CMD_CPSMEN;
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80044bc:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 80044be:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 80044c2:	d0fb      	beq.n	80044bc <sdc_lld_send_cmd_long_crc+0xc>
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80044c4:	63a2      	str	r2, [r4, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0U) {
 80044c6:	f011 023f 	ands.w	r2, r1, #63	; 0x3f
 80044ca:	d109      	bne.n	80044e0 <sdc_lld_send_cmd_long_crc+0x30>
    sdc_lld_collect_errors(sdcp, sta);
    return HAL_FAILED;
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdmmc->RESP4;
 80044cc:	6a21      	ldr	r1, [r4, #32]
  *resp++ = sdcp->sdmmc->RESP3;
  *resp++ = sdcp->sdmmc->RESP2;
  *resp   = sdcp->sdmmc->RESP1;
  return HAL_SUCCESS;
 80044ce:	4610      	mov	r0, r2
  *resp++ = sdcp->sdmmc->RESP4;
 80044d0:	6019      	str	r1, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP3;
 80044d2:	69e2      	ldr	r2, [r4, #28]
 80044d4:	605a      	str	r2, [r3, #4]
  *resp++ = sdcp->sdmmc->RESP2;
 80044d6:	69a2      	ldr	r2, [r4, #24]
 80044d8:	609a      	str	r2, [r3, #8]
  *resp   = sdcp->sdmmc->RESP1;
 80044da:	6962      	ldr	r2, [r4, #20]
 80044dc:	60da      	str	r2, [r3, #12]
}
 80044de:	bd10      	pop	{r4, pc}
    sdc_lld_collect_errors(sdcp, sta);
 80044e0:	f7ff fe9c 	bl	800421c <sdc_lld_collect_errors>
    return HAL_FAILED;
 80044e4:	2001      	movs	r0, #1
}
 80044e6:	bd10      	pop	{r4, pc}

080044e8 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 80044e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80044ec:	4616      	mov	r6, r2
 80044ee:	4698      	mov	r8, r3
 80044f0:	460f      	mov	r7, r1
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 80044f2:	4937      	ldr	r1, [pc, #220]	; (80045d0 <sdc_lld_read_special+0xe8>)
                          uint8_t cmd, uint32_t arg) {
 80044f4:	4605      	mov	r5, r0
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 80044f6:	e9d0 2411 	ldrd	r2, r4, [r0, #68]	; 0x44
  uint32_t div = (sdcp->sdmmc->CLKCR & SDMMC_CLKCR_CLKDIV_Msk) + 1U;
 80044fa:	6853      	ldr	r3, [r2, #4]
 80044fc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004500:	3301      	adds	r3, #1
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 8004502:	005b      	lsls	r3, r3, #1
 8004504:	fbb4 f4f3 	udiv	r4, r4, r3
 8004508:	fba1 1404 	umull	r1, r4, r1, r4
 800450c:	f242 7310 	movw	r3, #10000	; 0x2710
 8004510:	09a4      	lsrs	r4, r4, #6
 8004512:	fb03 f404 	mul.w	r4, r3, r4
  sdcp->sdmmc->DTIMER = sdc_lld_get_timeout(sdcp, STM32_SDC_SDMMC_READ_TIMEOUT);
 8004516:	6254      	str	r4, [r2, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8004518:	f7fd f802 	bl	8001520 <_sdc_wait_for_transfer_state>
 800451c:	2800      	cmp	r0, #0
 800451e:	d12e      	bne.n	800457e <sdc_lld_read_special+0x96>
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 8004520:	6c6c      	ldr	r4, [r5, #68]	; 0x44
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 8004522:	2201      	movs	r2, #1
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8004524:	f448 5388 	orr.w	r3, r8, #4352	; 0x1100
 8004528:	4681      	mov	r9, r0
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 800452a:	65a7      	str	r7, [r4, #88]	; 0x58
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 800452c:	6522      	str	r2, [r4, #80]	; 0x50
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800452e:	f04f 32ff 	mov.w	r2, #4294967295

  if (sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, sdcp->resp) ||
 8004532:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8004534:	63a2      	str	r2, [r4, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 8004536:	f44f 7295 	mov.w	r2, #298	; 0x12a
 800453a:	63e2      	str	r2, [r4, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800453c:	f242 0207 	movw	r2, #8199	; 0x2007
  sdcp->sdmmc->DLEN  = bytes;
 8004540:	62a6      	str	r6, [r4, #40]	; 0x28
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 8004542:	62e2      	str	r2, [r4, #44]	; 0x2c
  sdcp->sdmmc->ARG = arg;
 8004544:	9a08      	ldr	r2, [sp, #32]
 8004546:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8004548:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800454a:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 800454c:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8004550:	d0fb      	beq.n	800454a <sdc_lld_read_special+0x62>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004552:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004556:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004558:	d129      	bne.n	80045ae <sdc_lld_read_special+0xc6>
  *resp = sdcp->sdmmc->RESP1;
 800455a:	6962      	ldr	r2, [r4, #20]
      MMCSD_R1_ERROR(sdcp->resp[0]))
 800455c:	4b1d      	ldr	r3, [pc, #116]	; (80045d4 <sdc_lld_read_special+0xec>)
  *resp = sdcp->sdmmc->RESP1;
 800455e:	6002      	str	r2, [r0, #0]
      MMCSD_R1_ERROR(sdcp->resp[0]))
 8004560:	4013      	ands	r3, r2
  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, sdcp->resp) ||
 8004562:	b173      	cbz	r3, 8004582 <sdc_lld_read_special+0x9a>
  sta                   = sdcp->sdmmc->STA;
 8004564:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->IDMACTRL = 0U;
 8004566:	2300      	movs	r3, #0

  return HAL_SUCCESS;

error:
  sdc_lld_error_cleanup(sdcp, 1, sdcp->resp);
  return HAL_FAILED;
 8004568:	f04f 0901 	mov.w	r9, #1
  sdc_lld_collect_errors(sdcp, sta);
 800456c:	4628      	mov	r0, r5
  sdcp->sdmmc->ICR      = sta;
 800456e:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 8004570:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 8004572:	62e3      	str	r3, [r4, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 8004574:	f7ff fe52 	bl	800421c <sdc_lld_collect_errors>
}
 8004578:	4648      	mov	r0, r9
 800457a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 800457e:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 8004580:	e7f0      	b.n	8004564 <sdc_lld_read_special+0x7c>
 8004582:	2330      	movs	r3, #48	; 0x30
 8004584:	f383 8811 	msr	BASEPRI, r3
  if (sdcp->sdmmc->MASK != 0U) {
 8004588:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800458a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800458c:	b9ba      	cbnz	r2, 80045be <sdc_lld_read_special+0xd6>
  sdcp->sdmmc->IDMACTRL = 0U;
 800458e:	2200      	movs	r2, #0
 8004590:	651a      	str	r2, [r3, #80]	; 0x50
  sdcp->sdmmc->MASK     = 0U;
 8004592:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdmmc->DCTRL    = 0U;
 8004594:	62da      	str	r2, [r3, #44]	; 0x2c
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0U) {
 8004596:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8004598:	f411 7180 	ands.w	r1, r1, #256	; 0x100
 800459c:	d00b      	beq.n	80045b6 <sdc_lld_read_special+0xce>
  sdcp->sdmmc->ICR = SDMMC_ICR_ALL_FLAGS;
 800459e:	f04f 31ff 	mov.w	r1, #4294967295
 80045a2:	6399      	str	r1, [r3, #56]	; 0x38
 80045a4:	f382 8811 	msr	BASEPRI, r2
}
 80045a8:	4648      	mov	r0, r9
 80045aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    sdc_lld_collect_errors(sdcp, sta);
 80045ae:	4628      	mov	r0, r5
 80045b0:	f7ff fe34 	bl	800421c <sdc_lld_collect_errors>
    return HAL_FAILED;
 80045b4:	e7d6      	b.n	8004564 <sdc_lld_read_special+0x7c>
 80045b6:	f381 8811 	msr	BASEPRI, r1
  sta                   = sdcp->sdmmc->STA;
 80045ba:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 80045bc:	e7d2      	b.n	8004564 <sdc_lld_read_special+0x7c>
  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
 80045be:	f04f 31ff 	mov.w	r1, #4294967295
 80045c2:	f105 0040 	add.w	r0, r5, #64	; 0x40
 80045c6:	f002 f833 	bl	8006630 <chThdSuspendTimeoutS>
  sdcp->sdmmc->IDMACTRL = 0U;
 80045ca:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80045cc:	e7df      	b.n	800458e <sdc_lld_read_special+0xa6>
 80045ce:	bf00      	nop
 80045d0:	10624dd3 	.word	0x10624dd3
 80045d4:	fdffe008 	.word	0xfdffe008

080045d8 <sdc_lld_read_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
                          uint8_t *buf, uint32_t blocks) {
 80045d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80045dc:	4616      	mov	r6, r2
 80045de:	4698      	mov	r8, r3
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 80045e0:	f8df c164 	ldr.w	ip, [pc, #356]	; 8004748 <sdc_lld_read_aligned+0x170>
                          uint8_t *buf, uint32_t blocks) {
 80045e4:	460d      	mov	r5, r1
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 80045e6:	f242 7110 	movw	r1, #10000	; 0x2710
                          uint8_t *buf, uint32_t blocks) {
 80045ea:	4607      	mov	r7, r0
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 80045ec:	e9d0 2411 	ldrd	r2, r4, [r0, #68]	; 0x44
  uint32_t div = (sdcp->sdmmc->CLKCR & SDMMC_CLKCR_CLKDIV_Msk) + 1U;
 80045f0:	6853      	ldr	r3, [r2, #4]
 80045f2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80045f6:	3301      	adds	r3, #1
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 80045f8:	005b      	lsls	r3, r3, #1
 80045fa:	fbb4 f4f3 	udiv	r4, r4, r3
 80045fe:	fbac c404 	umull	ip, r4, ip, r4
 8004602:	09a4      	lsrs	r4, r4, #6
 8004604:	fb01 f404 	mul.w	r4, r1, r4

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = sdc_lld_get_timeout(sdcp, STM32_SDC_SDMMC_READ_TIMEOUT);
 8004608:	6254      	str	r4, [r2, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800460a:	f7fc ff89 	bl	8001520 <_sdc_wait_for_transfer_state>
 800460e:	4681      	mov	r9, r0
 8004610:	b110      	cbz	r0, 8004618 <sdc_lld_read_aligned+0x40>
  return HAL_SUCCESS;

error:
  sdc_lld_error_cleanup(sdcp, blocks, sdcp->resp);
  return HAL_FAILED;
}
 8004612:	4648      	mov	r0, r9
 8004614:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 8004618:	6c7c      	ldr	r4, [r7, #68]	; 0x44
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 800461a:	2301      	movs	r3, #1
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 800461c:	65a6      	str	r6, [r4, #88]	; 0x58
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 800461e:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8004620:	f04f 33ff 	mov.w	r3, #4294967295
  if (sdc_lld_prepare_read(sdcp, startblk, blocks, sdcp->resp) == true)
 8004624:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8004626:	63a3      	str	r3, [r4, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 8004628:	f44f 7395 	mov.w	r3, #298	; 0x12a
 800462c:	63e3      	str	r3, [r4, #60]	; 0x3c
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800462e:	ea4f 2348 	mov.w	r3, r8, lsl #9
 8004632:	62a3      	str	r3, [r4, #40]	; 0x28
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8004634:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004636:	06db      	lsls	r3, r3, #27
    startblk *= MMCSD_BLOCK_SIZE;
 8004638:	bf58      	it	pl
 800463a:	026d      	lslpl	r5, r5, #9
  if (n > 1U) {
 800463c:	f1b8 0f01 	cmp.w	r8, #1
  sdcp->sdmmc->ARG = arg;
 8004640:	60a5      	str	r5, [r4, #8]
  if (n > 1U) {
 8004642:	d924      	bls.n	800468e <sdc_lld_read_aligned+0xb6>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8004644:	f241 1312 	movw	r3, #4370	; 0x1112
 8004648:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800464a:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 800464c:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8004650:	d0fb      	beq.n	800464a <sdc_lld_read_aligned+0x72>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004652:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004656:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004658:	d13f      	bne.n	80046da <sdc_lld_read_aligned+0x102>
  *resp = sdcp->sdmmc->RESP1;
 800465a:	6963      	ldr	r3, [r4, #20]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 800465c:	4d39      	ldr	r5, [pc, #228]	; (8004744 <sdc_lld_read_aligned+0x16c>)
  *resp = sdcp->sdmmc->RESP1;
 800465e:	6033      	str	r3, [r6, #0]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 8004660:	401d      	ands	r5, r3
 8004662:	2d00      	cmp	r5, #0
 8004664:	d13c      	bne.n	80046e0 <sdc_lld_read_aligned+0x108>
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 8004666:	f242 0393 	movw	r3, #8339	; 0x2093
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 800466a:	4632      	mov	r2, r6
 800466c:	4641      	mov	r1, r8
 800466e:	4638      	mov	r0, r7
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 8004670:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 8004672:	f7ff fded 	bl	8004250 <sdc_lld_wait_transaction_end>
 8004676:	2800      	cmp	r0, #0
 8004678:	d0cb      	beq.n	8004612 <sdc_lld_read_aligned+0x3a>
  sta                   = sdcp->sdmmc->STA;
 800467a:	6c7c      	ldr	r4, [r7, #68]	; 0x44
  sdc_lld_collect_errors(sdcp, sta);
 800467c:	4638      	mov	r0, r7
  sdc_lld_error_cleanup(sdcp, blocks, sdcp->resp);
 800467e:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
  sta                   = sdcp->sdmmc->STA;
 8004680:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->ICR      = sta;
 8004682:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 8004684:	6525      	str	r5, [r4, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 8004686:	62e5      	str	r5, [r4, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 8004688:	f7ff fdc8 	bl	800421c <sdc_lld_collect_errors>
  if (n > 1U) {
 800468c:	e030      	b.n	80046f0 <sdc_lld_read_aligned+0x118>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800468e:	f241 1311 	movw	r3, #4369	; 0x1111
 8004692:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004694:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 8004696:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 800469a:	d0fb      	beq.n	8004694 <sdc_lld_read_aligned+0xbc>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 800469c:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80046a0:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 80046a2:	d139      	bne.n	8004718 <sdc_lld_read_aligned+0x140>
  *resp = sdcp->sdmmc->RESP1;
 80046a4:	6963      	ldr	r3, [r4, #20]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 80046a6:	4d27      	ldr	r5, [pc, #156]	; (8004744 <sdc_lld_read_aligned+0x16c>)
  *resp = sdcp->sdmmc->RESP1;
 80046a8:	6033      	str	r3, [r6, #0]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 80046aa:	401d      	ands	r5, r3
 80046ac:	2d00      	cmp	r5, #0
 80046ae:	d136      	bne.n	800471e <sdc_lld_read_aligned+0x146>
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 80046b0:	f242 0393 	movw	r3, #8339	; 0x2093
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 80046b4:	4632      	mov	r2, r6
 80046b6:	4641      	mov	r1, r8
 80046b8:	4638      	mov	r0, r7
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 80046ba:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 80046bc:	f7ff fdc8 	bl	8004250 <sdc_lld_wait_transaction_end>
 80046c0:	4603      	mov	r3, r0
 80046c2:	2800      	cmp	r0, #0
 80046c4:	d0a5      	beq.n	8004612 <sdc_lld_read_aligned+0x3a>
  sta                   = sdcp->sdmmc->STA;
 80046c6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  sdc_lld_collect_errors(sdcp, sta);
 80046c8:	4638      	mov	r0, r7
  return HAL_FAILED;
 80046ca:	4699      	mov	r9, r3
  sta                   = sdcp->sdmmc->STA;
 80046cc:	6b51      	ldr	r1, [r2, #52]	; 0x34
  sdcp->sdmmc->ICR      = sta;
 80046ce:	6391      	str	r1, [r2, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 80046d0:	6515      	str	r5, [r2, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 80046d2:	62d5      	str	r5, [r2, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 80046d4:	f7ff fda2 	bl	800421c <sdc_lld_collect_errors>
  if (n > 1U) {
 80046d8:	e79b      	b.n	8004612 <sdc_lld_read_aligned+0x3a>
    sdc_lld_collect_errors(sdcp, sta);
 80046da:	4638      	mov	r0, r7
 80046dc:	f7ff fd9e 	bl	800421c <sdc_lld_collect_errors>
  sta                   = sdcp->sdmmc->STA;
 80046e0:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->IDMACTRL = 0U;
 80046e2:	2300      	movs	r3, #0
  sdc_lld_collect_errors(sdcp, sta);
 80046e4:	4638      	mov	r0, r7
  sdcp->sdmmc->ICR      = sta;
 80046e6:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 80046e8:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 80046ea:	62e3      	str	r3, [r4, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 80046ec:	f7ff fd96 	bl	800421c <sdc_lld_collect_errors>
  sdcp->sdmmc->ARG = arg;
 80046f0:	2200      	movs	r2, #0
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80046f2:	f241 130c 	movw	r3, #4364	; 0x110c
  sdcp->sdmmc->ARG = arg;
 80046f6:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80046f8:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80046fa:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 80046fc:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8004700:	d0fb      	beq.n	80046fa <sdc_lld_read_aligned+0x122>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004702:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004706:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004708:	d116      	bne.n	8004738 <sdc_lld_read_aligned+0x160>
  *resp = sdcp->sdmmc->RESP1;
 800470a:	6963      	ldr	r3, [r4, #20]
  return HAL_FAILED;
 800470c:	f04f 0901 	mov.w	r9, #1
  *resp = sdcp->sdmmc->RESP1;
 8004710:	6033      	str	r3, [r6, #0]
}
 8004712:	4648      	mov	r0, r9
 8004714:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    sdc_lld_collect_errors(sdcp, sta);
 8004718:	4638      	mov	r0, r7
 800471a:	f7ff fd7f 	bl	800421c <sdc_lld_collect_errors>
  sta                   = sdcp->sdmmc->STA;
 800471e:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->IDMACTRL = 0U;
 8004720:	2300      	movs	r3, #0
  return HAL_FAILED;
 8004722:	f04f 0901 	mov.w	r9, #1
  sdc_lld_collect_errors(sdcp, sta);
 8004726:	4638      	mov	r0, r7
  sdcp->sdmmc->ICR      = sta;
 8004728:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 800472a:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 800472c:	62e3      	str	r3, [r4, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 800472e:	f7ff fd75 	bl	800421c <sdc_lld_collect_errors>
}
 8004732:	4648      	mov	r0, r9
 8004734:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    sdc_lld_collect_errors(sdcp, sta);
 8004738:	4638      	mov	r0, r7
  return HAL_FAILED;
 800473a:	f04f 0901 	mov.w	r9, #1
    sdc_lld_collect_errors(sdcp, sta);
 800473e:	f7ff fd6d 	bl	800421c <sdc_lld_collect_errors>
    return HAL_FAILED;
 8004742:	e766      	b.n	8004612 <sdc_lld_read_aligned+0x3a>
 8004744:	fdffe008 	.word	0xfdffe008
 8004748:	10624dd3 	.word	0x10624dd3

0800474c <sdc_lld_write_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
                           const uint8_t *buf, uint32_t blocks) {
 800474c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004750:	4616      	mov	r6, r2
 8004752:	4698      	mov	r8, r3
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 8004754:	f8df c164 	ldr.w	ip, [pc, #356]	; 80048bc <sdc_lld_write_aligned+0x170>
                           const uint8_t *buf, uint32_t blocks) {
 8004758:	460d      	mov	r5, r1
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 800475a:	f242 7110 	movw	r1, #10000	; 0x2710
                           const uint8_t *buf, uint32_t blocks) {
 800475e:	4607      	mov	r7, r0
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 8004760:	e9d0 2411 	ldrd	r2, r4, [r0, #68]	; 0x44
  uint32_t div = (sdcp->sdmmc->CLKCR & SDMMC_CLKCR_CLKDIV_Msk) + 1U;
 8004764:	6853      	ldr	r3, [r2, #4]
 8004766:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800476a:	3301      	adds	r3, #1
  return (((sdcp->clkfreq / (div * 2U)) / 1000U) * ms);
 800476c:	005b      	lsls	r3, r3, #1
 800476e:	fbb4 f4f3 	udiv	r4, r4, r3
 8004772:	fbac c404 	umull	ip, r4, ip, r4
 8004776:	09a4      	lsrs	r4, r4, #6
 8004778:	fb01 f404 	mul.w	r4, r1, r4

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = sdc_lld_get_timeout(sdcp, STM32_SDC_SDMMC_WRITE_TIMEOUT);
 800477c:	6254      	str	r4, [r2, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800477e:	f7fc fecf 	bl	8001520 <_sdc_wait_for_transfer_state>
 8004782:	4681      	mov	r9, r0
 8004784:	b110      	cbz	r0, 800478c <sdc_lld_write_aligned+0x40>
  return HAL_SUCCESS;

error:
  sdc_lld_error_cleanup(sdcp, blocks, sdcp->resp);
  return HAL_FAILED;
}
 8004786:	4648      	mov	r0, r9
 8004788:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 800478c:	6c7c      	ldr	r4, [r7, #68]	; 0x44
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 800478e:	2301      	movs	r3, #1
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 8004790:	65a6      	str	r6, [r4, #88]	; 0x58
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 8004792:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8004794:	f04f 33ff 	mov.w	r3, #4294967295
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, sdcp->resp) == true)
 8004798:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800479a:	63a3      	str	r3, [r4, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800479c:	f44f 738d 	mov.w	r3, #282	; 0x11a
 80047a0:	63e3      	str	r3, [r4, #60]	; 0x3c
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 80047a2:	ea4f 2348 	mov.w	r3, r8, lsl #9
 80047a6:	62a3      	str	r3, [r4, #40]	; 0x28
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 80047a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80047aa:	06db      	lsls	r3, r3, #27
    startblk *= MMCSD_BLOCK_SIZE;
 80047ac:	bf58      	it	pl
 80047ae:	026d      	lslpl	r5, r5, #9
  if (n > 1U) {
 80047b0:	f1b8 0f01 	cmp.w	r8, #1
  sdcp->sdmmc->ARG = arg;
 80047b4:	60a5      	str	r5, [r4, #8]
  if (n > 1U) {
 80047b6:	d924      	bls.n	8004802 <sdc_lld_write_aligned+0xb6>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80047b8:	f241 1319 	movw	r3, #4377	; 0x1119
 80047bc:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80047be:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 80047c0:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 80047c4:	d0fb      	beq.n	80047be <sdc_lld_write_aligned+0x72>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 80047c6:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80047ca:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 80047cc:	d13f      	bne.n	800484e <sdc_lld_write_aligned+0x102>
  *resp = sdcp->sdmmc->RESP1;
 80047ce:	6963      	ldr	r3, [r4, #20]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 80047d0:	4d39      	ldr	r5, [pc, #228]	; (80048b8 <sdc_lld_write_aligned+0x16c>)
  *resp = sdcp->sdmmc->RESP1;
 80047d2:	6033      	str	r3, [r6, #0]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 80047d4:	401d      	ands	r5, r3
 80047d6:	2d00      	cmp	r5, #0
 80047d8:	d13c      	bne.n	8004854 <sdc_lld_write_aligned+0x108>
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_FIFORST |
 80047da:	f242 0391 	movw	r3, #8337	; 0x2091
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 80047de:	4632      	mov	r2, r6
 80047e0:	4641      	mov	r1, r8
 80047e2:	4638      	mov	r0, r7
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_FIFORST |
 80047e4:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 80047e6:	f7ff fd33 	bl	8004250 <sdc_lld_wait_transaction_end>
 80047ea:	2800      	cmp	r0, #0
 80047ec:	d0cb      	beq.n	8004786 <sdc_lld_write_aligned+0x3a>
  sta                   = sdcp->sdmmc->STA;
 80047ee:	6c7c      	ldr	r4, [r7, #68]	; 0x44
  sdc_lld_collect_errors(sdcp, sta);
 80047f0:	4638      	mov	r0, r7
  sdc_lld_error_cleanup(sdcp, blocks, sdcp->resp);
 80047f2:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
  sta                   = sdcp->sdmmc->STA;
 80047f4:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->ICR      = sta;
 80047f6:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 80047f8:	6525      	str	r5, [r4, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 80047fa:	62e5      	str	r5, [r4, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 80047fc:	f7ff fd0e 	bl	800421c <sdc_lld_collect_errors>
  if (n > 1U) {
 8004800:	e030      	b.n	8004864 <sdc_lld_write_aligned+0x118>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8004802:	f241 1318 	movw	r3, #4376	; 0x1118
 8004806:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004808:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 800480a:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 800480e:	d0fb      	beq.n	8004808 <sdc_lld_write_aligned+0xbc>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004810:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8004814:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004816:	d139      	bne.n	800488c <sdc_lld_write_aligned+0x140>
  *resp = sdcp->sdmmc->RESP1;
 8004818:	6963      	ldr	r3, [r4, #20]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 800481a:	4d27      	ldr	r5, [pc, #156]	; (80048b8 <sdc_lld_write_aligned+0x16c>)
  *resp = sdcp->sdmmc->RESP1;
 800481c:	6033      	str	r3, [r6, #0]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0])) {
 800481e:	401d      	ands	r5, r3
 8004820:	2d00      	cmp	r5, #0
 8004822:	d136      	bne.n	8004892 <sdc_lld_write_aligned+0x146>
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_FIFORST |
 8004824:	f242 0391 	movw	r3, #8337	; 0x2091
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 8004828:	4632      	mov	r2, r6
 800482a:	4641      	mov	r1, r8
 800482c:	4638      	mov	r0, r7
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_FIFORST |
 800482e:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 8004830:	f7ff fd0e 	bl	8004250 <sdc_lld_wait_transaction_end>
 8004834:	4603      	mov	r3, r0
 8004836:	2800      	cmp	r0, #0
 8004838:	d0a5      	beq.n	8004786 <sdc_lld_write_aligned+0x3a>
  sta                   = sdcp->sdmmc->STA;
 800483a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  sdc_lld_collect_errors(sdcp, sta);
 800483c:	4638      	mov	r0, r7
  return HAL_FAILED;
 800483e:	4699      	mov	r9, r3
  sta                   = sdcp->sdmmc->STA;
 8004840:	6b51      	ldr	r1, [r2, #52]	; 0x34
  sdcp->sdmmc->ICR      = sta;
 8004842:	6391      	str	r1, [r2, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 8004844:	6515      	str	r5, [r2, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 8004846:	62d5      	str	r5, [r2, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 8004848:	f7ff fce8 	bl	800421c <sdc_lld_collect_errors>
  if (n > 1U) {
 800484c:	e79b      	b.n	8004786 <sdc_lld_write_aligned+0x3a>
    sdc_lld_collect_errors(sdcp, sta);
 800484e:	4638      	mov	r0, r7
 8004850:	f7ff fce4 	bl	800421c <sdc_lld_collect_errors>
  sta                   = sdcp->sdmmc->STA;
 8004854:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->IDMACTRL = 0U;
 8004856:	2300      	movs	r3, #0
  sdc_lld_collect_errors(sdcp, sta);
 8004858:	4638      	mov	r0, r7
  sdcp->sdmmc->ICR      = sta;
 800485a:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 800485c:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 800485e:	62e3      	str	r3, [r4, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 8004860:	f7ff fcdc 	bl	800421c <sdc_lld_collect_errors>
  sdcp->sdmmc->ARG = arg;
 8004864:	2200      	movs	r2, #0
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8004866:	f241 130c 	movw	r3, #4364	; 0x110c
  sdcp->sdmmc->ARG = arg;
 800486a:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800486c:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800486e:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0U)
 8004870:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8004874:	d0fb      	beq.n	800486e <sdc_lld_write_aligned+0x122>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 8004876:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800487a:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0U) {
 800487c:	d116      	bne.n	80048ac <sdc_lld_write_aligned+0x160>
  *resp = sdcp->sdmmc->RESP1;
 800487e:	6963      	ldr	r3, [r4, #20]
  return HAL_FAILED;
 8004880:	f04f 0901 	mov.w	r9, #1
  *resp = sdcp->sdmmc->RESP1;
 8004884:	6033      	str	r3, [r6, #0]
}
 8004886:	4648      	mov	r0, r9
 8004888:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    sdc_lld_collect_errors(sdcp, sta);
 800488c:	4638      	mov	r0, r7
 800488e:	f7ff fcc5 	bl	800421c <sdc_lld_collect_errors>
  sta                   = sdcp->sdmmc->STA;
 8004892:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->IDMACTRL = 0U;
 8004894:	2300      	movs	r3, #0
  return HAL_FAILED;
 8004896:	f04f 0901 	mov.w	r9, #1
  sdc_lld_collect_errors(sdcp, sta);
 800489a:	4638      	mov	r0, r7
  sdcp->sdmmc->ICR      = sta;
 800489c:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->IDMACTRL = 0U;
 800489e:	6523      	str	r3, [r4, #80]	; 0x50
  sdcp->sdmmc->DCTRL    = 0U;
 80048a0:	62e3      	str	r3, [r4, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 80048a2:	f7ff fcbb 	bl	800421c <sdc_lld_collect_errors>
}
 80048a6:	4648      	mov	r0, r9
 80048a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    sdc_lld_collect_errors(sdcp, sta);
 80048ac:	4638      	mov	r0, r7
  return HAL_FAILED;
 80048ae:	f04f 0901 	mov.w	r9, #1
    sdc_lld_collect_errors(sdcp, sta);
 80048b2:	f7ff fcb3 	bl	800421c <sdc_lld_collect_errors>
    return HAL_FAILED;
 80048b6:	e766      	b.n	8004786 <sdc_lld_write_aligned+0x3a>
 80048b8:	fdffe008 	.word	0xfdffe008
 80048bc:	10624dd3 	.word	0x10624dd3

080048c0 <sdc_lld_read>:
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3U) != 0U) {
 80048c0:	f012 0f03 	tst.w	r2, #3
 80048c4:	d022      	beq.n	800490c <sdc_lld_read+0x4c>
                  uint8_t *buf, uint32_t blocks) {
 80048c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80048ca:	461f      	mov	r7, r3
    uint32_t i;
    for (i = 0U; i < blocks; i++) {
 80048cc:	b1d3      	cbz	r3, 8004904 <sdc_lld_read+0x44>
 80048ce:	4606      	mov	r6, r0
 80048d0:	4615      	mov	r5, r2
 80048d2:	460c      	mov	r4, r1
 80048d4:	440f      	add	r7, r1
 80048d6:	e004      	b.n	80048e2 <sdc_lld_read+0x22>
      if (sdc_lld_read_aligned(sdcp, startblk, sdcp->buf, 1)) {
        return HAL_FAILED;
      }
      memcpy(buf, sdcp->buf, MMCSD_BLOCK_SIZE);
 80048d8:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
 80048da:	f7fb ff4f 	bl	800077c <memcpy>
    for (i = 0U; i < blocks; i++) {
 80048de:	42a7      	cmp	r7, r4
 80048e0:	d010      	beq.n	8004904 <sdc_lld_read+0x44>
      if (sdc_lld_read_aligned(sdcp, startblk, sdcp->buf, 1)) {
 80048e2:	4621      	mov	r1, r4
 80048e4:	2301      	movs	r3, #1
 80048e6:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 80048e8:	4630      	mov	r0, r6
 80048ea:	f7ff fe75 	bl	80045d8 <sdc_lld_read_aligned>
      memcpy(buf, sdcp->buf, MMCSD_BLOCK_SIZE);
 80048ee:	f44f 7200 	mov.w	r2, #512	; 0x200
      if (sdc_lld_read_aligned(sdcp, startblk, sdcp->buf, 1)) {
 80048f2:	4603      	mov	r3, r0
      buf += MMCSD_BLOCK_SIZE;
      startblk++;
 80048f4:	3401      	adds	r4, #1
      memcpy(buf, sdcp->buf, MMCSD_BLOCK_SIZE);
 80048f6:	4628      	mov	r0, r5
      buf += MMCSD_BLOCK_SIZE;
 80048f8:	4415      	add	r5, r2
      if (sdc_lld_read_aligned(sdcp, startblk, sdcp->buf, 1)) {
 80048fa:	2b00      	cmp	r3, #0
 80048fc:	d0ec      	beq.n	80048d8 <sdc_lld_read+0x18>
  }
#else /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  osalDbgAssert((((unsigned)buf & 3U) == 0U), "unaligned buffer");
#endif /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
}
 80048fe:	4618      	mov	r0, r3
 8004900:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_SUCCESS;
 8004904:	2300      	movs	r3, #0
}
 8004906:	4618      	mov	r0, r3
 8004908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
 800490c:	f7ff be64 	b.w	80045d8 <sdc_lld_read_aligned>

08004910 <sdc_lld_write>:
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3U) != 0U) {
 8004910:	f012 0f03 	tst.w	r2, #3
 8004914:	d01f      	beq.n	8004956 <sdc_lld_write+0x46>
                   const uint8_t *buf, uint32_t blocks) {
 8004916:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800491a:	461f      	mov	r7, r3
    uint32_t i;
    for (i = 0U; i < blocks; i++) {
 800491c:	b1c3      	cbz	r3, 8004950 <sdc_lld_write+0x40>
 800491e:	4606      	mov	r6, r0
 8004920:	4615      	mov	r5, r2
 8004922:	460c      	mov	r4, r1
 8004924:	440f      	add	r7, r1
 8004926:	e001      	b.n	800492c <sdc_lld_write+0x1c>
 8004928:	42a7      	cmp	r7, r4
 800492a:	d011      	beq.n	8004950 <sdc_lld_write+0x40>
      memcpy(sdcp->buf, buf, MMCSD_BLOCK_SIZE);
 800492c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004930:	4629      	mov	r1, r5
 8004932:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
      buf += MMCSD_BLOCK_SIZE;
 8004934:	4415      	add	r5, r2
      memcpy(sdcp->buf, buf, MMCSD_BLOCK_SIZE);
 8004936:	f7fb ff21 	bl	800077c <memcpy>
      if (sdc_lld_write_aligned(sdcp, startblk, sdcp->buf, 1))
 800493a:	4621      	mov	r1, r4
 800493c:	2301      	movs	r3, #1
 800493e:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 8004940:	4630      	mov	r0, r6
        return HAL_FAILED;
      startblk++;
 8004942:	3401      	adds	r4, #1
      if (sdc_lld_write_aligned(sdcp, startblk, sdcp->buf, 1))
 8004944:	f7ff ff02 	bl	800474c <sdc_lld_write_aligned>
 8004948:	2800      	cmp	r0, #0
 800494a:	d0ed      	beq.n	8004928 <sdc_lld_write+0x18>
  }
#else /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  osalDbgAssert((((unsigned)buf & 3U) == 0U), "unaligned buffer");
#endif /* !STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
}
 800494c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_SUCCESS;
 8004950:	2000      	movs	r0, #0
}
 8004952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
 8004956:	f7ff bef9 	b.w	800474c <sdc_lld_write_aligned>
 800495a:	bf00      	nop

0800495c <sdc_lld_sync>:
bool sdc_lld_sync(SDCDriver *sdcp) {

  /* CHTODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
}
 800495c:	2000      	movs	r0, #0
 800495e:	4770      	bx	lr

08004960 <sdc_lld_serve_interrupt>:
 8004960:	2330      	movs	r3, #48	; 0x30
/**
 * @brief   Shared service routine.
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 */
void sdc_lld_serve_interrupt(SDCDriver *sdcp) {
 8004962:	b510      	push	{r4, lr}
 8004964:	f383 8811 	msr	BASEPRI, r3

  osalSysLockFromISR();

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  sdcp->sdmmc->MASK = 0U;
 8004968:	2400      	movs	r4, #0
 800496a:	6c43      	ldr	r3, [r0, #68]	; 0x44
  chThdResumeI(trp, msg);
 800496c:	3040      	adds	r0, #64	; 0x40
 800496e:	4621      	mov	r1, r4
 8004970:	63dc      	str	r4, [r3, #60]	; 0x3c
 8004972:	f001 fe6b 	bl	800664c <chThdResumeI>
 8004976:	f384 8811 	msr	BASEPRI, r4
  osalThreadResumeI(&sdcp->thread, MSG_OK);

  osalSysUnlockFromISR();
}
 800497a:	bd10      	pop	{r4, pc}

0800497c <spi_lld_configure.isra.0>:
/*===========================================================================*/

static void spi_lld_configure(SPIDriver *spip) {

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0U;
 800497c:	2200      	movs	r2, #0
  spip->spi->CR2  = 0U;
  spip->spi->IER  = SPI_IER_OVRIE;
  spip->spi->IFCR = 0xFFFFFFFFU;
  spip->spi->CFG1 = (spip->config->cfg1 & ~SPI_CFG1_FTHLV_Msk) |
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 800497e:	4b13      	ldr	r3, [pc, #76]	; (80049cc <spi_lld_configure.isra.0+0x50>)
  spip->spi->CR1  = 0U;
 8004980:	600a      	str	r2, [r1, #0]
  spip->spi->CR2  = 0U;
 8004982:	604a      	str	r2, [r1, #4]
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8004984:	6942      	ldr	r2, [r0, #20]
static void spi_lld_configure(SPIDriver *spip) {
 8004986:	b410      	push	{r4}
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8004988:	4013      	ands	r3, r2
  spip->spi->IER  = SPI_IER_OVRIE;
 800498a:	2440      	movs	r4, #64	; 0x40
  if (spip->config->slave) {
 800498c:	7842      	ldrb	r2, [r0, #1]
  spip->spi->IER  = SPI_IER_OVRIE;
 800498e:	610c      	str	r4, [r1, #16]
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8004990:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
  spip->spi->IFCR = 0xFFFFFFFFU;
 8004994:	f04f 34ff 	mov.w	r4, #4294967295
 8004998:	618c      	str	r4, [r1, #24]
  spip->spi->CFG1 = (spip->config->cfg1 & ~SPI_CFG1_FTHLV_Msk) |
 800499a:	608b      	str	r3, [r1, #8]
  if (spip->config->slave) {
 800499c:	b14a      	cbz	r2, 80049b2 <spi_lld_configure.isra.0+0x36>
    spip->spi->CFG2 = spip->config->cfg2 & ~SPI_CFG2_COMM_Msk;
 800499e:	6983      	ldr	r3, [r0, #24]
  else {
    spip->spi->CFG2 = (spip->config->cfg2 | SPI_CFG2_MASTER | SPI_CFG2_SSOE) &
                      ~SPI_CFG2_COMM_Msk;
  }
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
}
 80049a0:	f85d 4b04 	ldr.w	r4, [sp], #4
    spip->spi->CFG2 = spip->config->cfg2 & ~SPI_CFG2_COMM_Msk;
 80049a4:	f423 23c0 	bic.w	r3, r3, #393216	; 0x60000
 80049a8:	60cb      	str	r3, [r1, #12]
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
 80049aa:	f240 1301 	movw	r3, #257	; 0x101
 80049ae:	600b      	str	r3, [r1, #0]
}
 80049b0:	4770      	bx	lr
    spip->spi->CFG2 = (spip->config->cfg2 | SPI_CFG2_MASTER | SPI_CFG2_SSOE) &
 80049b2:	6982      	ldr	r2, [r0, #24]
 80049b4:	4b06      	ldr	r3, [pc, #24]	; (80049d0 <spi_lld_configure.isra.0+0x54>)
}
 80049b6:	f85d 4b04 	ldr.w	r4, [sp], #4
    spip->spi->CFG2 = (spip->config->cfg2 | SPI_CFG2_MASTER | SPI_CFG2_SSOE) &
 80049ba:	4013      	ands	r3, r2
 80049bc:	f043 5301 	orr.w	r3, r3, #541065216	; 0x20400000
 80049c0:	60cb      	str	r3, [r1, #12]
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
 80049c2:	f240 1301 	movw	r3, #257	; 0x101
 80049c6:	600b      	str	r3, [r1, #0]
}
 80049c8:	4770      	bx	lr
 80049ca:	bf00      	nop
 80049cc:	ffff3e1f 	.word	0xffff3e1f
 80049d0:	dfb9ffff 	.word	0xdfb9ffff

080049d4 <spi_lld_stop_abort>:
 */
static void spi_lld_stop_abort(SPIDriver *spip) {

  /* Stopping DMAs and waiting for FIFOs to be empty.*/
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  if (spip->is_bdma)
 80049d4:	f890 3020 	ldrb.w	r3, [r0, #32]
static void spi_lld_stop_abort(SPIDriver *spip) {
 80049d8:	b410      	push	{r4}
  if (spip->is_bdma)
 80049da:	2b00      	cmp	r3, #0
 80049dc:	d038      	beq.n	8004a50 <spi_lld_stop_abort+0x7c>
#endif
#if defined(STM32_SPI_BDMA_REQUIRED)
  {
    bdmaStreamDisable(spip->tx.bdma);
 80049de:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80049e0:	e9d3 4100 	ldrd	r4, r1, [r3]
 80049e4:	680a      	ldr	r2, [r1, #0]
 80049e6:	f022 020f 	bic.w	r2, r2, #15
 80049ea:	600a      	str	r2, [r1, #0]
 80049ec:	7a19      	ldrb	r1, [r3, #8]
 80049ee:	230e      	movs	r3, #14
    bdmaStreamDisable(spip->rx.bdma);
 80049f0:	6a42      	ldr	r2, [r0, #36]	; 0x24
    bdmaStreamDisable(spip->tx.bdma);
 80049f2:	fa03 f101 	lsl.w	r1, r3, r1
 80049f6:	6061      	str	r1, [r4, #4]
    bdmaStreamDisable(spip->rx.bdma);
 80049f8:	6854      	ldr	r4, [r2, #4]
 80049fa:	6821      	ldr	r1, [r4, #0]
 80049fc:	f021 010f 	bic.w	r1, r1, #15
 8004a00:	6021      	str	r1, [r4, #0]
 8004a02:	7a11      	ldrb	r1, [r2, #8]
 8004a04:	6812      	ldr	r2, [r2, #0]
 8004a06:	408b      	lsls	r3, r1
 8004a08:	6053      	str	r3, [r2, #4]
     in a clean state.*/
  if (false) {
  }

#if STM32_SPI_USE_SPI1
  else if (&SPID1 == spip) {
 8004a0a:	4b53      	ldr	r3, [pc, #332]	; (8004b58 <spi_lld_stop_abort+0x184>)
 8004a0c:	4298      	cmp	r0, r3
 8004a0e:	d03e      	beq.n	8004a8e <spi_lld_stop_abort+0xba>
    rccResetSPI1();
  }
#endif

#if STM32_SPI_USE_SPI2
  else if (&SPID2 == spip) {
 8004a10:	4b52      	ldr	r3, [pc, #328]	; (8004b5c <spi_lld_stop_abort+0x188>)
 8004a12:	4298      	cmp	r0, r3
 8004a14:	d050      	beq.n	8004ab8 <spi_lld_stop_abort+0xe4>
    rccResetSPI2();
  }
#endif

#if STM32_SPI_USE_SPI3
  else if (&SPID3 == spip) {
 8004a16:	4b52      	ldr	r3, [pc, #328]	; (8004b60 <spi_lld_stop_abort+0x18c>)
 8004a18:	4298      	cmp	r0, r3
 8004a1a:	d072      	beq.n	8004b02 <spi_lld_stop_abort+0x12e>
    rccResetSPI3();
  }
#endif

#if STM32_SPI_USE_SPI4
  else if (&SPID4 == spip) {
 8004a1c:	4b51      	ldr	r3, [pc, #324]	; (8004b64 <spi_lld_stop_abort+0x190>)
 8004a1e:	4298      	cmp	r0, r3
 8004a20:	f000 8084 	beq.w	8004b2c <spi_lld_stop_abort+0x158>
    rccResetSPI4();
  }
#endif

#if STM32_SPI_USE_SPI5
  else if (&SPID5 == spip) {
 8004a24:	4b50      	ldr	r3, [pc, #320]	; (8004b68 <spi_lld_stop_abort+0x194>)
 8004a26:	4298      	cmp	r0, r3
 8004a28:	d05b      	beq.n	8004ae2 <spi_lld_stop_abort+0x10e>
    rccResetSPI5();
  }
#endif

#if STM32_SPI_USE_SPI6
  else if (&SPID6 == spip) {
 8004a2a:	4b50      	ldr	r3, [pc, #320]	; (8004b6c <spi_lld_stop_abort+0x198>)
 8004a2c:	4298      	cmp	r0, r3
 8004a2e:	d152      	bne.n	8004ad6 <spi_lld_stop_abort+0x102>
  RCC->APB4RSTR |= mask;
 8004a30:	4b4f      	ldr	r3, [pc, #316]	; (8004b70 <spi_lld_stop_abort+0x19c>)
 8004a32:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8004a36:	f042 0220 	orr.w	r2, r2, #32
 8004a3a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  RCC->APB4RSTR &= ~mask;
 8004a3e:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8004a42:	f022 0220 	bic.w	r2, r2, #32
 8004a46:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  (void)RCC->APB4RSTR;
 8004a4a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
}
 8004a4e:	e042      	b.n	8004ad6 <spi_lld_stop_abort+0x102>
    dmaStreamDisable(spip->tx.dma);
 8004a50:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8004a52:	6822      	ldr	r2, [r4, #0]
 8004a54:	6813      	ldr	r3, [r2, #0]
 8004a56:	f023 031f 	bic.w	r3, r3, #31
 8004a5a:	6013      	str	r3, [r2, #0]
 8004a5c:	6813      	ldr	r3, [r2, #0]
 8004a5e:	07d9      	lsls	r1, r3, #31
 8004a60:	d4fc      	bmi.n	8004a5c <spi_lld_stop_abort+0x88>
 8004a62:	7b22      	ldrb	r2, [r4, #12]
 8004a64:	233d      	movs	r3, #61	; 0x3d
    dmaStreamDisable(spip->rx.dma);
 8004a66:	6a41      	ldr	r1, [r0, #36]	; 0x24
    dmaStreamDisable(spip->tx.dma);
 8004a68:	4093      	lsls	r3, r2
 8004a6a:	6864      	ldr	r4, [r4, #4]
    dmaStreamDisable(spip->rx.dma);
 8004a6c:	680a      	ldr	r2, [r1, #0]
    dmaStreamDisable(spip->tx.dma);
 8004a6e:	6023      	str	r3, [r4, #0]
    dmaStreamDisable(spip->rx.dma);
 8004a70:	6813      	ldr	r3, [r2, #0]
 8004a72:	f023 031f 	bic.w	r3, r3, #31
 8004a76:	6013      	str	r3, [r2, #0]
 8004a78:	6813      	ldr	r3, [r2, #0]
 8004a7a:	07db      	lsls	r3, r3, #31
 8004a7c:	d4fc      	bmi.n	8004a78 <spi_lld_stop_abort+0xa4>
 8004a7e:	7b0c      	ldrb	r4, [r1, #12]
 8004a80:	233d      	movs	r3, #61	; 0x3d
 8004a82:	684a      	ldr	r2, [r1, #4]
 8004a84:	40a3      	lsls	r3, r4
 8004a86:	6013      	str	r3, [r2, #0]
  else if (&SPID1 == spip) {
 8004a88:	4b33      	ldr	r3, [pc, #204]	; (8004b58 <spi_lld_stop_abort+0x184>)
 8004a8a:	4298      	cmp	r0, r3
 8004a8c:	d1c0      	bne.n	8004a10 <spi_lld_stop_abort+0x3c>
  RCC->APB2RSTR |= mask;
 8004a8e:	4b38      	ldr	r3, [pc, #224]	; (8004b70 <spi_lld_stop_abort+0x19c>)
  else {
    osalDbgAssert(false, "invalid SPI instance");
  }

  /* Reconfiguring SPI.*/
  spi_lld_configure(spip);
 8004a90:	69c1      	ldr	r1, [r0, #28]
 8004a92:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8004a96:	6840      	ldr	r0, [r0, #4]
 8004a98:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
}
 8004a9c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004aa0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8004aa4:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8004aa8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8004aac:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8004ab0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  spi_lld_configure(spip);
 8004ab4:	f7ff bf62 	b.w	800497c <spi_lld_configure.isra.0>
  RCC->APB1LRSTR |= mask;
 8004ab8:	4b2d      	ldr	r3, [pc, #180]	; (8004b70 <spi_lld_stop_abort+0x19c>)
 8004aba:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8004abe:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004ac2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 8004ac6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8004aca:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8004ace:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8004ad2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004ad6:	69c1      	ldr	r1, [r0, #28]
}
 8004ad8:	f85d 4b04 	ldr.w	r4, [sp], #4
  spi_lld_configure(spip);
 8004adc:	6840      	ldr	r0, [r0, #4]
 8004ade:	f7ff bf4d 	b.w	800497c <spi_lld_configure.isra.0>
  RCC->APB2RSTR |= mask;
 8004ae2:	4b23      	ldr	r3, [pc, #140]	; (8004b70 <spi_lld_stop_abort+0x19c>)
 8004ae4:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8004ae8:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8004aec:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8004af0:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8004af4:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8004af8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8004afc:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
}
 8004b00:	e7e9      	b.n	8004ad6 <spi_lld_stop_abort+0x102>
  RCC->APB1LRSTR |= mask;
 8004b02:	4b1b      	ldr	r3, [pc, #108]	; (8004b70 <spi_lld_stop_abort+0x19c>)
 8004b04:	69c1      	ldr	r1, [r0, #28]
 8004b06:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8004b0a:	6840      	ldr	r0, [r0, #4]
 8004b0c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
}
 8004b10:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004b14:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 8004b18:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8004b1c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004b20:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8004b24:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  spi_lld_configure(spip);
 8004b28:	f7ff bf28 	b.w	800497c <spi_lld_configure.isra.0>
  RCC->APB2RSTR |= mask;
 8004b2c:	4b10      	ldr	r3, [pc, #64]	; (8004b70 <spi_lld_stop_abort+0x19c>)
 8004b2e:	69c1      	ldr	r1, [r0, #28]
 8004b30:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8004b34:	6840      	ldr	r0, [r0, #4]
 8004b36:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
}
 8004b3a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004b3e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8004b42:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8004b46:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8004b4a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8004b4e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  spi_lld_configure(spip);
 8004b52:	f7ff bf13 	b.w	800497c <spi_lld_configure.isra.0>
 8004b56:	bf00      	nop
 8004b58:	24000a14 	.word	0x24000a14
 8004b5c:	24000a50 	.word	0x24000a50
 8004b60:	24000a8c 	.word	0x24000a8c
 8004b64:	24000ac8 	.word	0x24000ac8
 8004b68:	24000b04 	.word	0x24000b04
 8004b6c:	24000b40 	.word	0x24000b40
 8004b70:	58024400 	.word	0x58024400

08004b74 <spi_lld_stop_nicely>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 */
static msg_t spi_lld_stop_nicely(SPIDriver *spip) {

  if (spip->config->slave) {
 8004b74:	6843      	ldr	r3, [r0, #4]
 8004b76:	785b      	ldrb	r3, [r3, #1]
static msg_t spi_lld_stop_nicely(SPIDriver *spip) {
 8004b78:	b510      	push	{r4, lr}
  if (spip->config->slave) {
 8004b7a:	2b00      	cmp	r3, #0
 8004b7c:	d150      	bne.n	8004c20 <spi_lld_stop_nicely+0xac>
    return HAL_RET_SUCCESS;
  }

  /* Stopping DMAs and waiting for FIFOs to be empty.*/
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  if (spip->is_bdma)
 8004b7e:	f890 3020 	ldrb.w	r3, [r0, #32]
 8004b82:	4601      	mov	r1, r0
 8004b84:	b1db      	cbz	r3, 8004bbe <spi_lld_stop_nicely+0x4a>
#endif
#if defined(STM32_SPI_BDMA_REQUIRED)
  {
    bdmaStreamDisable(spip->tx.bdma);
 8004b86:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8004b88:	e9d3 4000 	ldrd	r4, r0, [r3]
 8004b8c:	6802      	ldr	r2, [r0, #0]
 8004b8e:	f022 020f 	bic.w	r2, r2, #15
 8004b92:	6002      	str	r2, [r0, #0]
 8004b94:	220e      	movs	r2, #14
 8004b96:	7a18      	ldrb	r0, [r3, #8]

    /* Waiting for the RX FIFO to become empty.*/
    while ((spip->spi->SR & (SPI_SR_RXWNE | SPI_SR_RXPLVL)) != 0U) {
 8004b98:	69cb      	ldr	r3, [r1, #28]
    bdmaStreamDisable(spip->tx.bdma);
 8004b9a:	4082      	lsls	r2, r0
 8004b9c:	6062      	str	r2, [r4, #4]
    while ((spip->spi->SR & (SPI_SR_RXWNE | SPI_SR_RXPLVL)) != 0U) {
 8004b9e:	695a      	ldr	r2, [r3, #20]
 8004ba0:	f412 4f60 	tst.w	r2, #57344	; 0xe000
 8004ba4:	d1fb      	bne.n	8004b9e <spi_lld_stop_nicely+0x2a>
      /* Waiting.*/
    }

    bdmaStreamDisable(spip->rx.bdma);
 8004ba6:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8004ba8:	e9d1 4000 	ldrd	r4, r0, [r1]
 8004bac:	6802      	ldr	r2, [r0, #0]
 8004bae:	f022 020f 	bic.w	r2, r2, #15
 8004bb2:	6002      	str	r2, [r0, #0]
 8004bb4:	220e      	movs	r2, #14
 8004bb6:	7a09      	ldrb	r1, [r1, #8]
 8004bb8:	408a      	lsls	r2, r1
 8004bba:	6062      	str	r2, [r4, #4]
 8004bbc:	e024      	b.n	8004c08 <spi_lld_stop_nicely+0x94>
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  else
#endif
#if defined(STM32_SPI_DMA_REQUIRED)
  {
    dmaStreamDisable(spip->tx.dma);
 8004bbe:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8004bc0:	6802      	ldr	r2, [r0, #0]
 8004bc2:	6813      	ldr	r3, [r2, #0]
 8004bc4:	f023 031f 	bic.w	r3, r3, #31
 8004bc8:	6013      	str	r3, [r2, #0]
 8004bca:	6813      	ldr	r3, [r2, #0]
 8004bcc:	07db      	lsls	r3, r3, #31
 8004bce:	d4fc      	bmi.n	8004bca <spi_lld_stop_nicely+0x56>
 8004bd0:	f890 c00c 	ldrb.w	ip, [r0, #12]
 8004bd4:	223d      	movs	r2, #61	; 0x3d
 8004bd6:	6840      	ldr	r0, [r0, #4]
 8004bd8:	fa02 f20c 	lsl.w	r2, r2, ip

    /* Waiting for the RX FIFO to become empty.*/
    while ((spip->spi->SR & (SPI_SR_RXWNE | SPI_SR_RXPLVL)) != 0U) {
 8004bdc:	69cb      	ldr	r3, [r1, #28]
    dmaStreamDisable(spip->tx.dma);
 8004bde:	6002      	str	r2, [r0, #0]
    while ((spip->spi->SR & (SPI_SR_RXWNE | SPI_SR_RXPLVL)) != 0U) {
 8004be0:	695a      	ldr	r2, [r3, #20]
 8004be2:	f412 4f60 	tst.w	r2, #57344	; 0xe000
 8004be6:	d1fb      	bne.n	8004be0 <spi_lld_stop_nicely+0x6c>
      /* Waiting.*/
    }

    dmaStreamDisable(spip->rx.dma);
 8004be8:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8004bea:	6801      	ldr	r1, [r0, #0]
 8004bec:	680a      	ldr	r2, [r1, #0]
 8004bee:	f022 021f 	bic.w	r2, r2, #31
 8004bf2:	600a      	str	r2, [r1, #0]
 8004bf4:	680a      	ldr	r2, [r1, #0]
 8004bf6:	07d4      	lsls	r4, r2, #31
 8004bf8:	d4fc      	bmi.n	8004bf4 <spi_lld_stop_nicely+0x80>
 8004bfa:	f890 c00c 	ldrb.w	ip, [r0, #12]
 8004bfe:	223d      	movs	r2, #61	; 0x3d
 8004c00:	6841      	ldr	r1, [r0, #4]
 8004c02:	fa02 f20c 	lsl.w	r2, r2, ip
 8004c06:	600a      	str	r2, [r1, #0]
    spip->spi->CR1 |= SPI_CR1_CSUSP;
 8004c08:	681a      	ldr	r2, [r3, #0]
 8004c0a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8004c0e:	601a      	str	r2, [r3, #0]
    while ((spip->spi->CR1 & SPI_CR1_CSTART) != 0U) {
 8004c10:	681a      	ldr	r2, [r3, #0]
 8004c12:	0592      	lsls	r2, r2, #22
 8004c14:	d4fc      	bmi.n	8004c10 <spi_lld_stop_nicely+0x9c>
  spip->spi->IFCR = 0xFFFFFFFF;
 8004c16:	f04f 32ff 	mov.w	r2, #4294967295
  /* Stopping SPI.*/
  spi_lld_suspend(spip);
//  spip->spi->CR1 &= ~SPI_CR1_SPE;

  return HAL_RET_SUCCESS;
}
 8004c1a:	2000      	movs	r0, #0
  spip->spi->IFCR = 0xFFFFFFFF;
 8004c1c:	619a      	str	r2, [r3, #24]
}
 8004c1e:	bd10      	pop	{r4, pc}
    spi_lld_stop_abort(spip);
 8004c20:	f7ff fed8 	bl	80049d4 <spi_lld_stop_abort>
}
 8004c24:	2000      	movs	r0, #0
 8004c26:	bd10      	pop	{r4, pc}

08004c28 <spi_lld_serve_bdma_tx_interrupt.part.0>:
 * @brief   Shared DMA end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_dma_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8004c28:	b510      	push	{r4, lr}
 8004c2a:	4604      	mov	r4, r0
  chSysHalt(reason);
 8004c2c:	480b      	ldr	r0, [pc, #44]	; (8004c5c <spi_lld_serve_bdma_tx_interrupt.part.0+0x34>)
 8004c2e:	f001 f813 	bl	8005c58 <chSysHalt>
#if defined(STM32_SPI_DMA_ERROR_HOOK)
    STM32_SPI_DMA_ERROR_HOOK(spip);
#endif

    /* Aborting the transfer.*/
    spi_lld_stop_abort(spip);
 8004c32:	4620      	mov	r0, r4
 8004c34:	f7ff fece 	bl	80049d4 <spi_lld_stop_abort>

    /* Reporting the failure.*/
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004c38:	6863      	ldr	r3, [r4, #4]
 8004c3a:	689b      	ldr	r3, [r3, #8]
 8004c3c:	b10b      	cbz	r3, 8004c42 <spi_lld_serve_bdma_tx_interrupt.part.0+0x1a>
 8004c3e:	4620      	mov	r0, r4
 8004c40:	4798      	blx	r3
 8004c42:	2330      	movs	r3, #48	; 0x30
 8004c44:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8004c48:	f06f 0112 	mvn.w	r1, #18
 8004c4c:	f104 0008 	add.w	r0, r4, #8
 8004c50:	f001 fcfc 	bl	800664c <chThdResumeI>
 8004c54:	2300      	movs	r3, #0
 8004c56:	f383 8811 	msr	BASEPRI, r3
  }
}
 8004c5a:	bd10      	pop	{r4, pc}
 8004c5c:	08014e3c 	.word	0x08014e3c

08004c60 <spi_lld_serve_bdma_tx_interrupt>:
  if ((flags & STM32_BDMA_ISR_TEIF) != 0) {
 8004c60:	070b      	lsls	r3, r1, #28
 8004c62:	d400      	bmi.n	8004c66 <spi_lld_serve_bdma_tx_interrupt+0x6>
}
 8004c64:	4770      	bx	lr
 8004c66:	f7ff bfdf 	b.w	8004c28 <spi_lld_serve_bdma_tx_interrupt.part.0>
 8004c6a:	bf00      	nop

08004c6c <spi_lld_serve_dma_tx_interrupt>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004c6c:	f011 0f0c 	tst.w	r1, #12
 8004c70:	d100      	bne.n	8004c74 <spi_lld_serve_dma_tx_interrupt+0x8>
}
 8004c72:	4770      	bx	lr
 8004c74:	f7ff bfd8 	b.w	8004c28 <spi_lld_serve_bdma_tx_interrupt.part.0>

08004c78 <spi_lld_serve_dma_rx_interrupt>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0U) {
 8004c78:	f011 0f0c 	tst.w	r1, #12
static void spi_lld_serve_dma_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8004c7c:	b570      	push	{r4, r5, r6, lr}
 8004c7e:	460d      	mov	r5, r1
 8004c80:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0U) {
 8004c82:	d12d      	bne.n	8004ce0 <spi_lld_serve_dma_rx_interrupt+0x68>
  if (spip->config->circular) {
 8004c84:	6866      	ldr	r6, [r4, #4]
 8004c86:	7833      	ldrb	r3, [r6, #0]
 8004c88:	b193      	cbz	r3, 8004cb0 <spi_lld_serve_dma_rx_interrupt+0x38>
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
 8004c8a:	06ea      	lsls	r2, r5, #27
 8004c8c:	d503      	bpl.n	8004c96 <spi_lld_serve_dma_rx_interrupt+0x1e>
      __spi_isr_half_code(spip);
 8004c8e:	6873      	ldr	r3, [r6, #4]
 8004c90:	b16b      	cbz	r3, 8004cae <spi_lld_serve_dma_rx_interrupt+0x36>
 8004c92:	4620      	mov	r0, r4
 8004c94:	4798      	blx	r3
    if ((flags & STM32_DMA_ISR_TCIF) != 0U) {
 8004c96:	06ab      	lsls	r3, r5, #26
 8004c98:	d509      	bpl.n	8004cae <spi_lld_serve_dma_rx_interrupt+0x36>
      __spi_isr_full_code(spip);
 8004c9a:	6863      	ldr	r3, [r4, #4]
 8004c9c:	685b      	ldr	r3, [r3, #4]
 8004c9e:	b133      	cbz	r3, 8004cae <spi_lld_serve_dma_rx_interrupt+0x36>
 8004ca0:	2204      	movs	r2, #4
 8004ca2:	4620      	mov	r0, r4
 8004ca4:	7022      	strb	r2, [r4, #0]
 8004ca6:	4798      	blx	r3
 8004ca8:	7823      	ldrb	r3, [r4, #0]
 8004caa:	2b04      	cmp	r3, #4
 8004cac:	d030      	beq.n	8004d10 <spi_lld_serve_dma_rx_interrupt+0x98>
}
 8004cae:	bd70      	pop	{r4, r5, r6, pc}
    (void) spi_lld_stop_nicely(spip);
 8004cb0:	4620      	mov	r0, r4
 8004cb2:	f7ff ff5f 	bl	8004b74 <spi_lld_stop_nicely>
    __spi_isr_complete_code(spip);
 8004cb6:	6873      	ldr	r3, [r6, #4]
 8004cb8:	b36b      	cbz	r3, 8004d16 <spi_lld_serve_dma_rx_interrupt+0x9e>
 8004cba:	2204      	movs	r2, #4
 8004cbc:	4620      	mov	r0, r4
 8004cbe:	7022      	strb	r2, [r4, #0]
 8004cc0:	4798      	blx	r3
 8004cc2:	7823      	ldrb	r3, [r4, #0]
 8004cc4:	2b04      	cmp	r3, #4
 8004cc6:	d026      	beq.n	8004d16 <spi_lld_serve_dma_rx_interrupt+0x9e>
 8004cc8:	2330      	movs	r3, #48	; 0x30
 8004cca:	f383 8811 	msr	BASEPRI, r3
 8004cce:	2100      	movs	r1, #0
 8004cd0:	f104 0008 	add.w	r0, r4, #8
 8004cd4:	f001 fcba 	bl	800664c <chThdResumeI>
 8004cd8:	2300      	movs	r3, #0
 8004cda:	f383 8811 	msr	BASEPRI, r3
}
 8004cde:	bd70      	pop	{r4, r5, r6, pc}
  chSysHalt(reason);
 8004ce0:	480e      	ldr	r0, [pc, #56]	; (8004d1c <spi_lld_serve_dma_rx_interrupt+0xa4>)
 8004ce2:	f000 ffb9 	bl	8005c58 <chSysHalt>
    spi_lld_stop_abort(spip);
 8004ce6:	4620      	mov	r0, r4
 8004ce8:	f7ff fe74 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004cec:	6863      	ldr	r3, [r4, #4]
 8004cee:	689b      	ldr	r3, [r3, #8]
 8004cf0:	b10b      	cbz	r3, 8004cf6 <spi_lld_serve_dma_rx_interrupt+0x7e>
 8004cf2:	4620      	mov	r0, r4
 8004cf4:	4798      	blx	r3
 8004cf6:	2330      	movs	r3, #48	; 0x30
 8004cf8:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8004cfc:	f06f 0112 	mvn.w	r1, #18
 8004d00:	f104 0008 	add.w	r0, r4, #8
 8004d04:	f001 fca2 	bl	800664c <chThdResumeI>
 8004d08:	2300      	movs	r3, #0
 8004d0a:	f383 8811 	msr	BASEPRI, r3
}
 8004d0e:	e7b9      	b.n	8004c84 <spi_lld_serve_dma_rx_interrupt+0xc>
      __spi_isr_full_code(spip);
 8004d10:	2303      	movs	r3, #3
 8004d12:	7023      	strb	r3, [r4, #0]
}
 8004d14:	bd70      	pop	{r4, r5, r6, pc}
    __spi_isr_complete_code(spip);
 8004d16:	2302      	movs	r3, #2
 8004d18:	7023      	strb	r3, [r4, #0]
 8004d1a:	e7d5      	b.n	8004cc8 <spi_lld_serve_dma_rx_interrupt+0x50>
 8004d1c:	08014e3c 	.word	0x08014e3c

08004d20 <spi_lld_serve_bdma_rx_interrupt>:
static void spi_lld_serve_bdma_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8004d20:	b570      	push	{r4, r5, r6, lr}
 8004d22:	460d      	mov	r5, r1
  if ((flags & STM32_BDMA_ISR_TEIF) != 0U) {
 8004d24:	0709      	lsls	r1, r1, #28
static void spi_lld_serve_bdma_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8004d26:	4604      	mov	r4, r0
  if ((flags & STM32_BDMA_ISR_TEIF) != 0U) {
 8004d28:	d42d      	bmi.n	8004d86 <spi_lld_serve_bdma_rx_interrupt+0x66>
  if (spip->config->circular) {
 8004d2a:	6866      	ldr	r6, [r4, #4]
 8004d2c:	7833      	ldrb	r3, [r6, #0]
 8004d2e:	b193      	cbz	r3, 8004d56 <spi_lld_serve_bdma_rx_interrupt+0x36>
    if ((flags & STM32_BDMA_ISR_HTIF) != 0U) {
 8004d30:	076a      	lsls	r2, r5, #29
 8004d32:	d503      	bpl.n	8004d3c <spi_lld_serve_bdma_rx_interrupt+0x1c>
      __spi_isr_half_code(spip);
 8004d34:	6873      	ldr	r3, [r6, #4]
 8004d36:	b16b      	cbz	r3, 8004d54 <spi_lld_serve_bdma_rx_interrupt+0x34>
 8004d38:	4620      	mov	r0, r4
 8004d3a:	4798      	blx	r3
    if ((flags & STM32_BDMA_ISR_TCIF) != 0U) {
 8004d3c:	07ab      	lsls	r3, r5, #30
 8004d3e:	d509      	bpl.n	8004d54 <spi_lld_serve_bdma_rx_interrupt+0x34>
      __spi_isr_full_code(spip);
 8004d40:	6863      	ldr	r3, [r4, #4]
 8004d42:	685b      	ldr	r3, [r3, #4]
 8004d44:	b133      	cbz	r3, 8004d54 <spi_lld_serve_bdma_rx_interrupt+0x34>
 8004d46:	2204      	movs	r2, #4
 8004d48:	4620      	mov	r0, r4
 8004d4a:	7022      	strb	r2, [r4, #0]
 8004d4c:	4798      	blx	r3
 8004d4e:	7823      	ldrb	r3, [r4, #0]
 8004d50:	2b04      	cmp	r3, #4
 8004d52:	d030      	beq.n	8004db6 <spi_lld_serve_bdma_rx_interrupt+0x96>
}
 8004d54:	bd70      	pop	{r4, r5, r6, pc}
    (void) spi_lld_stop_nicely(spip);
 8004d56:	4620      	mov	r0, r4
 8004d58:	f7ff ff0c 	bl	8004b74 <spi_lld_stop_nicely>
    __spi_isr_complete_code(spip);
 8004d5c:	6873      	ldr	r3, [r6, #4]
 8004d5e:	b36b      	cbz	r3, 8004dbc <spi_lld_serve_bdma_rx_interrupt+0x9c>
 8004d60:	2204      	movs	r2, #4
 8004d62:	4620      	mov	r0, r4
 8004d64:	7022      	strb	r2, [r4, #0]
 8004d66:	4798      	blx	r3
 8004d68:	7823      	ldrb	r3, [r4, #0]
 8004d6a:	2b04      	cmp	r3, #4
 8004d6c:	d026      	beq.n	8004dbc <spi_lld_serve_bdma_rx_interrupt+0x9c>
 8004d6e:	2330      	movs	r3, #48	; 0x30
 8004d70:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8004d74:	2100      	movs	r1, #0
 8004d76:	f104 0008 	add.w	r0, r4, #8
 8004d7a:	f001 fc67 	bl	800664c <chThdResumeI>
 8004d7e:	2300      	movs	r3, #0
 8004d80:	f383 8811 	msr	BASEPRI, r3
}
 8004d84:	bd70      	pop	{r4, r5, r6, pc}
  chSysHalt(reason);
 8004d86:	480f      	ldr	r0, [pc, #60]	; (8004dc4 <spi_lld_serve_bdma_rx_interrupt+0xa4>)
 8004d88:	f000 ff66 	bl	8005c58 <chSysHalt>
    spi_lld_stop_abort(spip);
 8004d8c:	4620      	mov	r0, r4
 8004d8e:	f7ff fe21 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004d92:	6863      	ldr	r3, [r4, #4]
 8004d94:	689b      	ldr	r3, [r3, #8]
 8004d96:	b10b      	cbz	r3, 8004d9c <spi_lld_serve_bdma_rx_interrupt+0x7c>
 8004d98:	4620      	mov	r0, r4
 8004d9a:	4798      	blx	r3
 8004d9c:	2330      	movs	r3, #48	; 0x30
 8004d9e:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8004da2:	f06f 0112 	mvn.w	r1, #18
 8004da6:	f104 0008 	add.w	r0, r4, #8
 8004daa:	f001 fc4f 	bl	800664c <chThdResumeI>
 8004dae:	2300      	movs	r3, #0
 8004db0:	f383 8811 	msr	BASEPRI, r3
}
 8004db4:	e7b9      	b.n	8004d2a <spi_lld_serve_bdma_rx_interrupt+0xa>
      __spi_isr_full_code(spip);
 8004db6:	2303      	movs	r3, #3
 8004db8:	7023      	strb	r3, [r4, #0]
}
 8004dba:	bd70      	pop	{r4, r5, r6, pc}
    __spi_isr_complete_code(spip);
 8004dbc:	2302      	movs	r3, #2
 8004dbe:	7023      	strb	r3, [r4, #0]
 8004dc0:	e7d5      	b.n	8004d6e <spi_lld_serve_bdma_rx_interrupt+0x4e>
 8004dc2:	bf00      	nop
 8004dc4:	08014e3c 	.word	0x08014e3c

08004dc8 <VectorCC>:
/**
 * @brief   SPI1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI1_HANDLER) {
 8004dc8:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8004dca:	4c16      	ldr	r4, [pc, #88]	; (8004e24 <VectorCC+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8004dcc:	4816      	ldr	r0, [pc, #88]	; (8004e28 <VectorCC+0x60>)
 8004dce:	f000 ffc5 	bl	8005d5c <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 8004dd2:	69e2      	ldr	r2, [r4, #28]
 8004dd4:	6953      	ldr	r3, [r2, #20]
 8004dd6:	6911      	ldr	r1, [r2, #16]
 8004dd8:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004dda:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8004ddc:	065b      	lsls	r3, r3, #25
 8004dde:	d406      	bmi.n	8004dee <VectorCC+0x26>

  spi_lld_serve_interrupt(&SPID1);

  OSAL_IRQ_EPILOGUE();
 8004de0:	4811      	ldr	r0, [pc, #68]	; (8004e28 <VectorCC+0x60>)
 8004de2:	f000 ffd3 	bl	8005d8c <__trace_isr_leave>
}
 8004de6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004dea:	f001 bf47 	b.w	8006c7c <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8004dee:	4620      	mov	r0, r4
 8004df0:	f7ff fdf0 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004df4:	6863      	ldr	r3, [r4, #4]
 8004df6:	689b      	ldr	r3, [r3, #8]
 8004df8:	b10b      	cbz	r3, 8004dfe <VectorCC+0x36>
 8004dfa:	4620      	mov	r0, r4
 8004dfc:	4798      	blx	r3
 8004dfe:	2330      	movs	r3, #48	; 0x30
 8004e00:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8004e04:	f06f 0112 	mvn.w	r1, #18
 8004e08:	4808      	ldr	r0, [pc, #32]	; (8004e2c <VectorCC+0x64>)
 8004e0a:	f001 fc1f 	bl	800664c <chThdResumeI>
 8004e0e:	2300      	movs	r3, #0
 8004e10:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8004e14:	4804      	ldr	r0, [pc, #16]	; (8004e28 <VectorCC+0x60>)
 8004e16:	f000 ffb9 	bl	8005d8c <__trace_isr_leave>
}
 8004e1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004e1e:	f001 bf2d 	b.w	8006c7c <__port_irq_epilogue>
 8004e22:	bf00      	nop
 8004e24:	24000a14 	.word	0x24000a14
 8004e28:	08014e84 	.word	0x08014e84
 8004e2c:	24000a1c 	.word	0x24000a1c

08004e30 <VectorD0>:
/**
 * @brief   SPI2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI2_HANDLER) {
 8004e30:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8004e32:	4c16      	ldr	r4, [pc, #88]	; (8004e8c <VectorD0+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8004e34:	4816      	ldr	r0, [pc, #88]	; (8004e90 <VectorD0+0x60>)
 8004e36:	f000 ff91 	bl	8005d5c <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 8004e3a:	69e2      	ldr	r2, [r4, #28]
 8004e3c:	6953      	ldr	r3, [r2, #20]
 8004e3e:	6911      	ldr	r1, [r2, #16]
 8004e40:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004e42:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8004e44:	065b      	lsls	r3, r3, #25
 8004e46:	d406      	bmi.n	8004e56 <VectorD0+0x26>

  spi_lld_serve_interrupt(&SPID2);

  OSAL_IRQ_EPILOGUE();
 8004e48:	4811      	ldr	r0, [pc, #68]	; (8004e90 <VectorD0+0x60>)
 8004e4a:	f000 ff9f 	bl	8005d8c <__trace_isr_leave>
}
 8004e4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004e52:	f001 bf13 	b.w	8006c7c <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8004e56:	4620      	mov	r0, r4
 8004e58:	f7ff fdbc 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004e5c:	6863      	ldr	r3, [r4, #4]
 8004e5e:	689b      	ldr	r3, [r3, #8]
 8004e60:	b10b      	cbz	r3, 8004e66 <VectorD0+0x36>
 8004e62:	4620      	mov	r0, r4
 8004e64:	4798      	blx	r3
 8004e66:	2330      	movs	r3, #48	; 0x30
 8004e68:	f383 8811 	msr	BASEPRI, r3
 8004e6c:	f06f 0112 	mvn.w	r1, #18
 8004e70:	4808      	ldr	r0, [pc, #32]	; (8004e94 <VectorD0+0x64>)
 8004e72:	f001 fbeb 	bl	800664c <chThdResumeI>
 8004e76:	2300      	movs	r3, #0
 8004e78:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8004e7c:	4804      	ldr	r0, [pc, #16]	; (8004e90 <VectorD0+0x60>)
 8004e7e:	f000 ff85 	bl	8005d8c <__trace_isr_leave>
}
 8004e82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004e86:	f001 bef9 	b.w	8006c7c <__port_irq_epilogue>
 8004e8a:	bf00      	nop
 8004e8c:	24000a50 	.word	0x24000a50
 8004e90:	08014e78 	.word	0x08014e78
 8004e94:	24000a58 	.word	0x24000a58

08004e98 <Vector10C>:
/**
 * @brief   SPI3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI3_HANDLER) {
 8004e98:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8004e9a:	4c16      	ldr	r4, [pc, #88]	; (8004ef4 <Vector10C+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8004e9c:	4816      	ldr	r0, [pc, #88]	; (8004ef8 <Vector10C+0x60>)
 8004e9e:	f000 ff5d 	bl	8005d5c <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 8004ea2:	69e2      	ldr	r2, [r4, #28]
 8004ea4:	6953      	ldr	r3, [r2, #20]
 8004ea6:	6911      	ldr	r1, [r2, #16]
 8004ea8:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004eaa:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8004eac:	065b      	lsls	r3, r3, #25
 8004eae:	d406      	bmi.n	8004ebe <Vector10C+0x26>

  spi_lld_serve_interrupt(&SPID3);

  OSAL_IRQ_EPILOGUE();
 8004eb0:	4811      	ldr	r0, [pc, #68]	; (8004ef8 <Vector10C+0x60>)
 8004eb2:	f000 ff6b 	bl	8005d8c <__trace_isr_leave>
}
 8004eb6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004eba:	f001 bedf 	b.w	8006c7c <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8004ebe:	4620      	mov	r0, r4
 8004ec0:	f7ff fd88 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004ec4:	6863      	ldr	r3, [r4, #4]
 8004ec6:	689b      	ldr	r3, [r3, #8]
 8004ec8:	b10b      	cbz	r3, 8004ece <Vector10C+0x36>
 8004eca:	4620      	mov	r0, r4
 8004ecc:	4798      	blx	r3
 8004ece:	2330      	movs	r3, #48	; 0x30
 8004ed0:	f383 8811 	msr	BASEPRI, r3
 8004ed4:	f06f 0112 	mvn.w	r1, #18
 8004ed8:	4808      	ldr	r0, [pc, #32]	; (8004efc <Vector10C+0x64>)
 8004eda:	f001 fbb7 	bl	800664c <chThdResumeI>
 8004ede:	2300      	movs	r3, #0
 8004ee0:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8004ee4:	4804      	ldr	r0, [pc, #16]	; (8004ef8 <Vector10C+0x60>)
 8004ee6:	f000 ff51 	bl	8005d8c <__trace_isr_leave>
}
 8004eea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004eee:	f001 bec5 	b.w	8006c7c <__port_irq_epilogue>
 8004ef2:	bf00      	nop
 8004ef4:	24000a8c 	.word	0x24000a8c
 8004ef8:	08014e6c 	.word	0x08014e6c
 8004efc:	24000a94 	.word	0x24000a94

08004f00 <Vector190>:
/**
 * @brief   SPI4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI4_HANDLER) {
 8004f00:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8004f02:	4c16      	ldr	r4, [pc, #88]	; (8004f5c <Vector190+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8004f04:	4816      	ldr	r0, [pc, #88]	; (8004f60 <Vector190+0x60>)
 8004f06:	f000 ff29 	bl	8005d5c <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 8004f0a:	69e2      	ldr	r2, [r4, #28]
 8004f0c:	6953      	ldr	r3, [r2, #20]
 8004f0e:	6911      	ldr	r1, [r2, #16]
 8004f10:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004f12:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8004f14:	065b      	lsls	r3, r3, #25
 8004f16:	d406      	bmi.n	8004f26 <Vector190+0x26>

  spi_lld_serve_interrupt(&SPID4);

  OSAL_IRQ_EPILOGUE();
 8004f18:	4811      	ldr	r0, [pc, #68]	; (8004f60 <Vector190+0x60>)
 8004f1a:	f000 ff37 	bl	8005d8c <__trace_isr_leave>
}
 8004f1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004f22:	f001 beab 	b.w	8006c7c <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8004f26:	4620      	mov	r0, r4
 8004f28:	f7ff fd54 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004f2c:	6863      	ldr	r3, [r4, #4]
 8004f2e:	689b      	ldr	r3, [r3, #8]
 8004f30:	b10b      	cbz	r3, 8004f36 <Vector190+0x36>
 8004f32:	4620      	mov	r0, r4
 8004f34:	4798      	blx	r3
 8004f36:	2330      	movs	r3, #48	; 0x30
 8004f38:	f383 8811 	msr	BASEPRI, r3
 8004f3c:	f06f 0112 	mvn.w	r1, #18
 8004f40:	4808      	ldr	r0, [pc, #32]	; (8004f64 <Vector190+0x64>)
 8004f42:	f001 fb83 	bl	800664c <chThdResumeI>
 8004f46:	2300      	movs	r3, #0
 8004f48:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8004f4c:	4804      	ldr	r0, [pc, #16]	; (8004f60 <Vector190+0x60>)
 8004f4e:	f000 ff1d 	bl	8005d8c <__trace_isr_leave>
}
 8004f52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004f56:	f001 be91 	b.w	8006c7c <__port_irq_epilogue>
 8004f5a:	bf00      	nop
 8004f5c:	24000ac8 	.word	0x24000ac8
 8004f60:	08014e60 	.word	0x08014e60
 8004f64:	24000ad0 	.word	0x24000ad0

08004f68 <Vector194>:
/**
 * @brief   SPI5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI5_HANDLER) {
 8004f68:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8004f6a:	4c16      	ldr	r4, [pc, #88]	; (8004fc4 <Vector194+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8004f6c:	4816      	ldr	r0, [pc, #88]	; (8004fc8 <Vector194+0x60>)
 8004f6e:	f000 fef5 	bl	8005d5c <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 8004f72:	69e2      	ldr	r2, [r4, #28]
 8004f74:	6953      	ldr	r3, [r2, #20]
 8004f76:	6911      	ldr	r1, [r2, #16]
 8004f78:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004f7a:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8004f7c:	065b      	lsls	r3, r3, #25
 8004f7e:	d406      	bmi.n	8004f8e <Vector194+0x26>

  spi_lld_serve_interrupt(&SPID5);

  OSAL_IRQ_EPILOGUE();
 8004f80:	4811      	ldr	r0, [pc, #68]	; (8004fc8 <Vector194+0x60>)
 8004f82:	f000 ff03 	bl	8005d8c <__trace_isr_leave>
}
 8004f86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004f8a:	f001 be77 	b.w	8006c7c <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8004f8e:	4620      	mov	r0, r4
 8004f90:	f7ff fd20 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004f94:	6863      	ldr	r3, [r4, #4]
 8004f96:	689b      	ldr	r3, [r3, #8]
 8004f98:	b10b      	cbz	r3, 8004f9e <Vector194+0x36>
 8004f9a:	4620      	mov	r0, r4
 8004f9c:	4798      	blx	r3
 8004f9e:	2330      	movs	r3, #48	; 0x30
 8004fa0:	f383 8811 	msr	BASEPRI, r3
 8004fa4:	f06f 0112 	mvn.w	r1, #18
 8004fa8:	4808      	ldr	r0, [pc, #32]	; (8004fcc <Vector194+0x64>)
 8004faa:	f001 fb4f 	bl	800664c <chThdResumeI>
 8004fae:	2300      	movs	r3, #0
 8004fb0:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8004fb4:	4804      	ldr	r0, [pc, #16]	; (8004fc8 <Vector194+0x60>)
 8004fb6:	f000 fee9 	bl	8005d8c <__trace_isr_leave>
}
 8004fba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004fbe:	f001 be5d 	b.w	8006c7c <__port_irq_epilogue>
 8004fc2:	bf00      	nop
 8004fc4:	24000b04 	.word	0x24000b04
 8004fc8:	08014e54 	.word	0x08014e54
 8004fcc:	24000b0c 	.word	0x24000b0c

08004fd0 <Vector198>:
/**
 * @brief   SPI6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI6_HANDLER) {
 8004fd0:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8004fd2:	4c16      	ldr	r4, [pc, #88]	; (800502c <Vector198+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8004fd4:	4816      	ldr	r0, [pc, #88]	; (8005030 <Vector198+0x60>)
 8004fd6:	f000 fec1 	bl	8005d5c <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 8004fda:	69e2      	ldr	r2, [r4, #28]
 8004fdc:	6953      	ldr	r3, [r2, #20]
 8004fde:	6911      	ldr	r1, [r2, #16]
 8004fe0:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004fe2:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8004fe4:	065b      	lsls	r3, r3, #25
 8004fe6:	d406      	bmi.n	8004ff6 <Vector198+0x26>

  spi_lld_serve_interrupt(&SPID6);

  OSAL_IRQ_EPILOGUE();
 8004fe8:	4811      	ldr	r0, [pc, #68]	; (8005030 <Vector198+0x60>)
 8004fea:	f000 fecf 	bl	8005d8c <__trace_isr_leave>
}
 8004fee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004ff2:	f001 be43 	b.w	8006c7c <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8004ff6:	4620      	mov	r0, r4
 8004ff8:	f7ff fcec 	bl	80049d4 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 8004ffc:	6863      	ldr	r3, [r4, #4]
 8004ffe:	689b      	ldr	r3, [r3, #8]
 8005000:	b10b      	cbz	r3, 8005006 <Vector198+0x36>
 8005002:	4620      	mov	r0, r4
 8005004:	4798      	blx	r3
 8005006:	2330      	movs	r3, #48	; 0x30
 8005008:	f383 8811 	msr	BASEPRI, r3
 800500c:	f06f 0112 	mvn.w	r1, #18
 8005010:	4808      	ldr	r0, [pc, #32]	; (8005034 <Vector198+0x64>)
 8005012:	f001 fb1b 	bl	800664c <chThdResumeI>
 8005016:	2300      	movs	r3, #0
 8005018:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 800501c:	4804      	ldr	r0, [pc, #16]	; (8005030 <Vector198+0x60>)
 800501e:	f000 feb5 	bl	8005d8c <__trace_isr_leave>
}
 8005022:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8005026:	f001 be29 	b.w	8006c7c <__port_irq_epilogue>
 800502a:	bf00      	nop
 800502c:	24000b40 	.word	0x24000b40
 8005030:	08014e48 	.word	0x08014e48
 8005034:	24000b48 	.word	0x24000b48

08005038 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8005038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 800503c:	4d35      	ldr	r5, [pc, #212]	; (8005114 <spi_lld_init+0xdc>)
  SPID1.spi       = SPI1;
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  SPID1.is_bdma   = false;
 800503e:	2400      	movs	r4, #0
#endif
  SPID1.rx.dma    = NULL;
  SPID1.tx.dma    = NULL;
  SPID1.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
 8005040:	f8df 8104 	ldr.w	r8, [pc, #260]	; 8005148 <spi_lld_init+0x110>
  spiObjectInit(&SPID1);
 8005044:	4628      	mov	r0, r5
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
 8005046:	4f34      	ldr	r7, [pc, #208]	; (8005118 <spi_lld_init+0xe0>)
  spiObjectInit(&SPID1);
 8005048:	f7fc fb22 	bl	8001690 <spiObjectInit>
  SPID1.spi       = SPI1;
 800504c:	4b33      	ldr	r3, [pc, #204]	; (800511c <spi_lld_init+0xe4>)
  SPID1.is_bdma   = false;
 800504e:	f885 4020 	strb.w	r4, [r5, #32]
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#if !defined(STM32_SPI1_SUPPRESS_ISR)
  nvicEnableVector(STM32_SPI1_NUMBER, STM32_SPI_SPI1_IRQ_PRIORITY);
 8005052:	210a      	movs	r1, #10
  SPID1.spi       = SPI1;
 8005054:	61eb      	str	r3, [r5, #28]
  nvicEnableVector(STM32_SPI1_NUMBER, STM32_SPI_SPI1_IRQ_PRIORITY);
 8005056:	2023      	movs	r0, #35	; 0x23
  SPID1.rx.dma    = NULL;
 8005058:	626c      	str	r4, [r5, #36]	; 0x24
  SPID1.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
 800505a:	632f      	str	r7, [r5, #48]	; 0x30
  nvicEnableVector(STM32_SPI4_NUMBER, STM32_SPI_SPI4_IRQ_PRIORITY);
#endif
#endif

#if STM32_SPI_USE_SPI5
  spiObjectInit(&SPID5);
 800505c:	4e30      	ldr	r6, [pc, #192]	; (8005120 <spi_lld_init+0xe8>)
  SPID1.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
 800505e:	e9c5 480a 	strd	r4, r8, [r5, #40]	; 0x28
  spiObjectInit(&SPID2);
 8005062:	4d30      	ldr	r5, [pc, #192]	; (8005124 <spi_lld_init+0xec>)
  nvicEnableVector(STM32_SPI1_NUMBER, STM32_SPI_SPI1_IRQ_PRIORITY);
 8005064:	f7fc fe7a 	bl	8001d5c <nvicEnableVector>
  spiObjectInit(&SPID2);
 8005068:	4628      	mov	r0, r5
 800506a:	f7fc fb11 	bl	8001690 <spiObjectInit>
  SPID2.spi       = SPI2;
 800506e:	4b2e      	ldr	r3, [pc, #184]	; (8005128 <spi_lld_init+0xf0>)
  SPID2.is_bdma   = false;
 8005070:	f885 4020 	strb.w	r4, [r5, #32]
  nvicEnableVector(STM32_SPI2_NUMBER, STM32_SPI_SPI2_IRQ_PRIORITY);
 8005074:	210a      	movs	r1, #10
  SPID2.spi       = SPI2;
 8005076:	61eb      	str	r3, [r5, #28]
  nvicEnableVector(STM32_SPI2_NUMBER, STM32_SPI_SPI2_IRQ_PRIORITY);
 8005078:	2024      	movs	r0, #36	; 0x24
  SPID2.rx.dma    = NULL;
 800507a:	626c      	str	r4, [r5, #36]	; 0x24
  SPID2.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
 800507c:	632f      	str	r7, [r5, #48]	; 0x30
  SPID2.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
 800507e:	e9c5 480a 	strd	r4, r8, [r5, #40]	; 0x28
  spiObjectInit(&SPID3);
 8005082:	4d2a      	ldr	r5, [pc, #168]	; (800512c <spi_lld_init+0xf4>)
  nvicEnableVector(STM32_SPI2_NUMBER, STM32_SPI_SPI2_IRQ_PRIORITY);
 8005084:	f7fc fe6a 	bl	8001d5c <nvicEnableVector>
  spiObjectInit(&SPID3);
 8005088:	4628      	mov	r0, r5
 800508a:	f7fc fb01 	bl	8001690 <spiObjectInit>
  SPID3.spi       = SPI3;
 800508e:	4b28      	ldr	r3, [pc, #160]	; (8005130 <spi_lld_init+0xf8>)
  SPID3.is_bdma   = false;
 8005090:	f885 4020 	strb.w	r4, [r5, #32]
  nvicEnableVector(STM32_SPI3_NUMBER, STM32_SPI_SPI3_IRQ_PRIORITY);
 8005094:	210a      	movs	r1, #10
  SPID3.spi       = SPI3;
 8005096:	61eb      	str	r3, [r5, #28]
  nvicEnableVector(STM32_SPI3_NUMBER, STM32_SPI_SPI3_IRQ_PRIORITY);
 8005098:	2033      	movs	r0, #51	; 0x33
  SPID3.rx.dma    = NULL;
 800509a:	626c      	str	r4, [r5, #36]	; 0x24
  SPID3.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
 800509c:	632f      	str	r7, [r5, #48]	; 0x30
  SPID3.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
 800509e:	e9c5 480a 	strd	r4, r8, [r5, #40]	; 0x28
  spiObjectInit(&SPID4);
 80050a2:	4d24      	ldr	r5, [pc, #144]	; (8005134 <spi_lld_init+0xfc>)
  nvicEnableVector(STM32_SPI3_NUMBER, STM32_SPI_SPI3_IRQ_PRIORITY);
 80050a4:	f7fc fe5a 	bl	8001d5c <nvicEnableVector>
  spiObjectInit(&SPID4);
 80050a8:	4628      	mov	r0, r5
 80050aa:	f7fc faf1 	bl	8001690 <spiObjectInit>
  SPID4.spi       = SPI4;
 80050ae:	4b22      	ldr	r3, [pc, #136]	; (8005138 <spi_lld_init+0x100>)
  nvicEnableVector(STM32_SPI4_NUMBER, STM32_SPI_SPI4_IRQ_PRIORITY);
 80050b0:	210a      	movs	r1, #10
 80050b2:	2054      	movs	r0, #84	; 0x54
  SPID4.spi       = SPI4;
 80050b4:	61eb      	str	r3, [r5, #28]
  SPID4.is_bdma   = false;
 80050b6:	f885 4020 	strb.w	r4, [r5, #32]
  SPID4.rx.dma    = NULL;
 80050ba:	626c      	str	r4, [r5, #36]	; 0x24
  SPID4.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI4_DMA_PRIORITY) |
 80050bc:	632f      	str	r7, [r5, #48]	; 0x30
  SPID4.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI4_DMA_PRIORITY) |
 80050be:	e9c5 480a 	strd	r4, r8, [r5, #40]	; 0x28
  nvicEnableVector(STM32_SPI4_NUMBER, STM32_SPI_SPI4_IRQ_PRIORITY);
 80050c2:	f7fc fe4b 	bl	8001d5c <nvicEnableVector>
  spiObjectInit(&SPID5);
 80050c6:	4630      	mov	r0, r6
 80050c8:	f7fc fae2 	bl	8001690 <spiObjectInit>
  nvicEnableVector(STM32_SPI5_NUMBER, STM32_SPI_SPI5_IRQ_PRIORITY);
#endif
#endif

#if STM32_SPI_USE_SPI6
  spiObjectInit(&SPID6);
 80050cc:	4d1b      	ldr	r5, [pc, #108]	; (800513c <spi_lld_init+0x104>)
  SPID5.spi       = SPI5;
 80050ce:	4b1c      	ldr	r3, [pc, #112]	; (8005140 <spi_lld_init+0x108>)
  nvicEnableVector(STM32_SPI5_NUMBER, STM32_SPI_SPI5_IRQ_PRIORITY);
 80050d0:	210a      	movs	r1, #10
 80050d2:	2055      	movs	r0, #85	; 0x55
  SPID5.is_bdma   = false;
 80050d4:	f886 4020 	strb.w	r4, [r6, #32]
  SPID5.spi       = SPI5;
 80050d8:	61f3      	str	r3, [r6, #28]
  SPID5.rx.dma    = NULL;
 80050da:	6274      	str	r4, [r6, #36]	; 0x24
  SPID5.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI5_DMA_PRIORITY) |
 80050dc:	6337      	str	r7, [r6, #48]	; 0x30
  SPID5.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI5_DMA_PRIORITY) |
 80050de:	e9c6 480a 	strd	r4, r8, [r6, #40]	; 0x28
  nvicEnableVector(STM32_SPI5_NUMBER, STM32_SPI_SPI5_IRQ_PRIORITY);
 80050e2:	f7fc fe3b 	bl	8001d5c <nvicEnableVector>
  spiObjectInit(&SPID6);
 80050e6:	4628      	mov	r0, r5
 80050e8:	f7fc fad2 	bl	8001690 <spiObjectInit>
  SPID6.spi       = SPI6;
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  SPID6.is_bdma   = true;
 80050ec:	2301      	movs	r3, #1
  SPID6.spi       = SPI6;
 80050ee:	4915      	ldr	r1, [pc, #84]	; (8005144 <spi_lld_init+0x10c>)
#endif
  SPID6.rx.bdma   = NULL;
  SPID6.tx.bdma   = NULL;
  SPID6.rxdmamode = STM32_BDMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
 80050f0:	f241 020a 	movw	r2, #4106	; 0x100a
  SPID6.is_bdma   = true;
 80050f4:	f885 3020 	strb.w	r3, [r5, #32]
                    STM32_BDMA_CR_DIR_P2M |
                    STM32_BDMA_CR_TCIE |
                    STM32_BDMA_CR_TEIE;
  SPID6.txdmamode = STM32_BDMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
 80050f8:	f241 0318 	movw	r3, #4120	; 0x1018
  SPID6.spi       = SPI6;
 80050fc:	61e9      	str	r1, [r5, #28]
                    STM32_BDMA_CR_DIR_M2P |
                    STM32_BDMA_CR_TEIE;
#if !defined(STM32_SPI6_SUPPRESS_ISR)
  nvicEnableVector(STM32_SPI6_NUMBER, STM32_SPI_SPI6_IRQ_PRIORITY);
 80050fe:	2056      	movs	r0, #86	; 0x56
  SPID6.rx.bdma   = NULL;
 8005100:	626c      	str	r4, [r5, #36]	; 0x24
  nvicEnableVector(STM32_SPI6_NUMBER, STM32_SPI_SPI6_IRQ_PRIORITY);
 8005102:	210a      	movs	r1, #10
  SPID6.txdmamode = STM32_BDMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
 8005104:	632b      	str	r3, [r5, #48]	; 0x30
  SPID6.rxdmamode = STM32_BDMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
 8005106:	e9c5 420a 	strd	r4, r2, [r5, #40]	; 0x28
#endif
#endif
}
 800510a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  nvicEnableVector(STM32_SPI6_NUMBER, STM32_SPI_SPI6_IRQ_PRIORITY);
 800510e:	f7fc be25 	b.w	8001d5c <nvicEnableVector>
 8005112:	bf00      	nop
 8005114:	24000a14 	.word	0x24000a14
 8005118:	00010046 	.word	0x00010046
 800511c:	40013000 	.word	0x40013000
 8005120:	24000b04 	.word	0x24000b04
 8005124:	24000a50 	.word	0x24000a50
 8005128:	40003800 	.word	0x40003800
 800512c:	24000a8c 	.word	0x24000a8c
 8005130:	40003c00 	.word	0x40003c00
 8005134:	24000ac8 	.word	0x24000ac8
 8005138:	40013400 	.word	0x40013400
 800513c:	24000b40 	.word	0x24000b40
 8005140:	40015000 	.word	0x40015000
 8005144:	58001400 	.word	0x58001400
 8005148:	00010016 	.word	0x00010016

0800514c <spi_lld_start>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @return              The operation status.
 *
 * @notapi
 */
msg_t spi_lld_start(SPIDriver *spip) {
 800514c:	b510      	push	{r4, lr}

  /* Resetting TX pattern source.*/
  spip->txsource = (uint32_t)STM32_SPI_FILLER_PATTERN;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800514e:	7803      	ldrb	r3, [r0, #0]
  spip->txsource = (uint32_t)STM32_SPI_FILLER_PATTERN;
 8005150:	f04f 32ff 	mov.w	r2, #4294967295
msg_t spi_lld_start(SPIDriver *spip) {
 8005154:	4604      	mov	r4, r0
  if (spip->state == SPI_STOP) {
 8005156:	2b01      	cmp	r3, #1
  spip->txsource = (uint32_t)STM32_SPI_FILLER_PATTERN;
 8005158:	6382      	str	r2, [r0, #56]	; 0x38
  if (spip->state == SPI_STOP) {
 800515a:	d020      	beq.n	800519e <spi_lld_start+0x52>
    }
#endif
 }

  /* Configuration-specific DMA setup.*/
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 800515c:	6840      	ldr	r0, [r0, #4]
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  if (spip->is_bdma)
 800515e:	f894 2020 	ldrb.w	r2, [r4, #32]
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 8005162:	6943      	ldr	r3, [r0, #20]
 8005164:	f003 031f 	and.w	r3, r3, #31
 8005168:	3301      	adds	r3, #1
  if (spip->is_bdma)
 800516a:	2a00      	cmp	r2, #0
 800516c:	d17b      	bne.n	8005266 <spi_lld_start+0x11a>
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  else
#endif
#if defined(STM32_SPI_DMA_REQUIRED)
  {
    if (dsize <= 8U) {
 800516e:	2b08      	cmp	r3, #8
      /* Frame width is between 4 and 8 bits.*/
      spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                        STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8005170:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    if (dsize <= 8U) {
 8005172:	f200 809d 	bhi.w	80052b0 <spi_lld_start+0x164>
      spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                        STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8005176:	6b23      	ldr	r3, [r4, #48]	; 0x30
                        STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8005178:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
                        STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800517c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
      spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                        STM32_DMA_CR_PSIZE_WORD | STM32_DMA_CR_MSIZE_WORD;
      spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                        STM32_DMA_CR_PSIZE_WORD | STM32_DMA_CR_MSIZE_WORD;
    }
    if (spip->config->circular) {
 8005180:	7801      	ldrb	r1, [r0, #0]
 8005182:	2900      	cmp	r1, #0
 8005184:	f000 808f 	beq.w	80052a6 <spi_lld_start+0x15a>
      spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8005188:	f442 7284 	orr.w	r2, r2, #264	; 0x108
      spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800518c:	f443 7384 	orr.w	r3, r3, #264	; 0x108
    }
  }
#endif

  /* SPI setup and enable.*/
  spi_lld_configure(spip);
 8005190:	69e1      	ldr	r1, [r4, #28]
      spip->txdmamode &= ~(STM32_BDMA_CR_CIRC | STM32_BDMA_CR_HTIE);
 8005192:	e9c4 230b 	strd	r2, r3, [r4, #44]	; 0x2c
  spi_lld_configure(spip);
 8005196:	f7ff fbf1 	bl	800497c <spi_lld_configure.isra.0>

  return HAL_RET_SUCCESS;
 800519a:	2000      	movs	r0, #0
}
 800519c:	bd10      	pop	{r4, pc}
    else if (&SPID1 == spip) {
 800519e:	4bc8      	ldr	r3, [pc, #800]	; (80054c0 <spi_lld_start+0x374>)
 80051a0:	4298      	cmp	r0, r3
 80051a2:	f000 80a6 	beq.w	80052f2 <spi_lld_start+0x1a6>
    else if (&SPID2 == spip) {
 80051a6:	4bc7      	ldr	r3, [pc, #796]	; (80054c4 <spi_lld_start+0x378>)
 80051a8:	4298      	cmp	r0, r3
 80051aa:	f000 8116 	beq.w	80053da <spi_lld_start+0x28e>
    else if (&SPID3 == spip) {
 80051ae:	4bc6      	ldr	r3, [pc, #792]	; (80054c8 <spi_lld_start+0x37c>)
 80051b0:	4298      	cmp	r0, r3
 80051b2:	f000 80d8 	beq.w	8005366 <spi_lld_start+0x21a>
    else if (&SPID4 == spip) {
 80051b6:	4bc5      	ldr	r3, [pc, #788]	; (80054cc <spi_lld_start+0x380>)
 80051b8:	4298      	cmp	r0, r3
 80051ba:	f000 8148 	beq.w	800544e <spi_lld_start+0x302>
    else if (&SPID5 == spip) {
 80051be:	4bc4      	ldr	r3, [pc, #784]	; (80054d0 <spi_lld_start+0x384>)
 80051c0:	4298      	cmp	r0, r3
 80051c2:	f000 8193 	beq.w	80054ec <spi_lld_start+0x3a0>
    else if (&SPID6 == spip) {
 80051c6:	4bc3      	ldr	r3, [pc, #780]	; (80054d4 <spi_lld_start+0x388>)
 80051c8:	4298      	cmp	r0, r3
 80051ca:	f040 81c5 	bne.w	8005558 <spi_lld_start+0x40c>
  spip->rx.bdma = bdmaStreamAllocI(rxstream, priority,
 80051ce:	4603      	mov	r3, r0
 80051d0:	4ac1      	ldr	r2, [pc, #772]	; (80054d8 <spi_lld_start+0x38c>)
 80051d2:	210a      	movs	r1, #10
 80051d4:	2008      	movs	r0, #8
 80051d6:	f7fd fbed 	bl	80029b4 <bdmaStreamAllocI>
 80051da:	6260      	str	r0, [r4, #36]	; 0x24
  if (spip->rx.bdma == NULL) {
 80051dc:	2800      	cmp	r0, #0
 80051de:	f000 81c1 	beq.w	8005564 <spi_lld_start+0x418>
  spip->tx.bdma = bdmaStreamAllocI(txstream, priority,
 80051e2:	4623      	mov	r3, r4
 80051e4:	4abd      	ldr	r2, [pc, #756]	; (80054dc <spi_lld_start+0x390>)
 80051e6:	210a      	movs	r1, #10
 80051e8:	2008      	movs	r0, #8
 80051ea:	f7fd fbe3 	bl	80029b4 <bdmaStreamAllocI>
 80051ee:	62a0      	str	r0, [r4, #40]	; 0x28
  if (spip->tx.bdma == NULL) {
 80051f0:	2800      	cmp	r0, #0
 80051f2:	f000 81b4 	beq.w	800555e <spi_lld_start+0x412>
      bdmaSetRequestSource(spip->rx.bdma, STM32_DMAMUX2_SPI6_RX);
 80051f6:	210b      	movs	r1, #11
 80051f8:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80051fa:	f7fd fc59 	bl	8002ab0 <bdmaSetRequestSource>
      bdmaSetRequestSource(spip->tx.bdma, STM32_DMAMUX2_SPI6_TX);
 80051fe:	210c      	movs	r1, #12
 8005200:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005202:	f7fd fc55 	bl	8002ab0 <bdmaSetRequestSource>
  RCC_C1->APB4ENR |= mask;
 8005206:	4bb6      	ldr	r3, [pc, #728]	; (80054e0 <spi_lld_start+0x394>)
 8005208:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 800520c:	f042 0220 	orr.w	r2, r2, #32
 8005210:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    RCC_C1->APB4LPENR |= mask;
 8005214:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
 8005218:	f042 0220 	orr.w	r2, r2, #32
 800521c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
  (void)RCC_C1->APB4LPENR;
 8005220:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
  RCC->APB4RSTR |= mask;
 8005224:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8005228:	f042 0220 	orr.w	r2, r2, #32
 800522c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  RCC->APB4RSTR &= ~mask;
 8005230:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8005234:	f022 0220 	bic.w	r2, r2, #32
 8005238:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  (void)RCC->APB4RSTR;
 800523c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
      bdmaStreamSetPeripheral(spip->rx.bdma, &spip->spi->RXDR);
 8005240:	69e2      	ldr	r2, [r4, #28]
    if (spip->is_bdma)
 8005242:	f894 3020 	ldrb.w	r3, [r4, #32]
      bdmaStreamSetPeripheral(spip->rx.bdma, &spip->spi->RXDR);
 8005246:	f102 0130 	add.w	r1, r2, #48	; 0x30
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 800524a:	6860      	ldr	r0, [r4, #4]
      bdmaStreamSetPeripheral(spip->tx.bdma, &spip->spi->TXDR);
 800524c:	3220      	adds	r2, #32
    if (spip->is_bdma)
 800524e:	2b00      	cmp	r3, #0
 8005250:	d044      	beq.n	80052dc <spi_lld_start+0x190>
      bdmaStreamSetPeripheral(spip->rx.bdma, &spip->spi->RXDR);
 8005252:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005254:	685b      	ldr	r3, [r3, #4]
 8005256:	6099      	str	r1, [r3, #8]
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 8005258:	6943      	ldr	r3, [r0, #20]
      bdmaStreamSetPeripheral(spip->tx.bdma, &spip->spi->TXDR);
 800525a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 800525c:	f003 031f 	and.w	r3, r3, #31
      bdmaStreamSetPeripheral(spip->tx.bdma, &spip->spi->TXDR);
 8005260:	6849      	ldr	r1, [r1, #4]
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 8005262:	3301      	adds	r3, #1
      bdmaStreamSetPeripheral(spip->tx.bdma, &spip->spi->TXDR);
 8005264:	608a      	str	r2, [r1, #8]
    if (dsize <= 8U) {
 8005266:	2b08      	cmp	r3, #8
                        STM32_BDMA_CR_PSIZE_BYTE | STM32_BDMA_CR_MSIZE_BYTE;
 8005268:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    if (dsize <= 8U) {
 800526a:	d810      	bhi.n	800528e <spi_lld_start+0x142>
                        STM32_BDMA_CR_PSIZE_BYTE | STM32_BDMA_CR_MSIZE_BYTE;
 800526c:	6b23      	ldr	r3, [r4, #48]	; 0x30
                        STM32_BDMA_CR_PSIZE_BYTE | STM32_BDMA_CR_MSIZE_BYTE;
 800526e:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
                        STM32_BDMA_CR_PSIZE_BYTE | STM32_BDMA_CR_MSIZE_BYTE;
 8005272:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
    if (spip->config->circular) {
 8005276:	7801      	ldrb	r1, [r0, #0]
 8005278:	b121      	cbz	r1, 8005284 <spi_lld_start+0x138>
      spip->rxdmamode |= (STM32_BDMA_CR_CIRC | STM32_BDMA_CR_HTIE);
 800527a:	f042 0224 	orr.w	r2, r2, #36	; 0x24
      spip->txdmamode |= (STM32_BDMA_CR_CIRC | STM32_BDMA_CR_HTIE);
 800527e:	f043 0324 	orr.w	r3, r3, #36	; 0x24
 8005282:	e785      	b.n	8005190 <spi_lld_start+0x44>
      spip->rxdmamode &= ~(STM32_BDMA_CR_CIRC | STM32_BDMA_CR_HTIE);
 8005284:	f022 0224 	bic.w	r2, r2, #36	; 0x24
      spip->txdmamode &= ~(STM32_BDMA_CR_CIRC | STM32_BDMA_CR_HTIE);
 8005288:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800528c:	e780      	b.n	8005190 <spi_lld_start+0x44>
    else if (dsize <= 16U) {
 800528e:	2b10      	cmp	r3, #16
      spip->txdmamode = (spip->txdmamode & ~STM32_BDMA_CR_SIZE_MASK) |
 8005290:	6b23      	ldr	r3, [r4, #48]	; 0x30
      spip->rxdmamode = (spip->rxdmamode & ~STM32_BDMA_CR_SIZE_MASK) |
 8005292:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
      spip->txdmamode = (spip->txdmamode & ~STM32_BDMA_CR_SIZE_MASK) |
 8005296:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
    else if (dsize <= 16U) {
 800529a:	d81a      	bhi.n	80052d2 <spi_lld_start+0x186>
                        STM32_BDMA_CR_PSIZE_HWORD | STM32_BDMA_CR_MSIZE_HWORD;
 800529c:	f442 62a0 	orr.w	r2, r2, #1280	; 0x500
                        STM32_BDMA_CR_PSIZE_HWORD | STM32_BDMA_CR_MSIZE_HWORD;
 80052a0:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
 80052a4:	e7e7      	b.n	8005276 <spi_lld_start+0x12a>
      spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80052a6:	f422 7284 	bic.w	r2, r2, #264	; 0x108
      spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80052aa:	f423 7384 	bic.w	r3, r3, #264	; 0x108
 80052ae:	e76f      	b.n	8005190 <spi_lld_start+0x44>
    else if (dsize <= 16U) {
 80052b0:	2b10      	cmp	r3, #16
      spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80052b2:	6b23      	ldr	r3, [r4, #48]	; 0x30
      spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80052b4:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
      spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80052b8:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    else if (dsize <= 16U) {
 80052bc:	d804      	bhi.n	80052c8 <spi_lld_start+0x17c>
                        STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80052be:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
                        STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80052c2:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
 80052c6:	e75b      	b.n	8005180 <spi_lld_start+0x34>
                        STM32_DMA_CR_PSIZE_WORD | STM32_DMA_CR_MSIZE_WORD;
 80052c8:	f442 42a0 	orr.w	r2, r2, #20480	; 0x5000
                        STM32_DMA_CR_PSIZE_WORD | STM32_DMA_CR_MSIZE_WORD;
 80052cc:	f443 43a0 	orr.w	r3, r3, #20480	; 0x5000
 80052d0:	e756      	b.n	8005180 <spi_lld_start+0x34>
                        STM32_BDMA_CR_PSIZE_WORD | STM32_BDMA_CR_MSIZE_WORD;
 80052d2:	f442 6220 	orr.w	r2, r2, #2560	; 0xa00
                        STM32_BDMA_CR_PSIZE_WORD | STM32_BDMA_CR_MSIZE_WORD;
 80052d6:	f443 6320 	orr.w	r3, r3, #2560	; 0xa00
 80052da:	e7cc      	b.n	8005276 <spi_lld_start+0x12a>
      dmaStreamSetPeripheral(spip->rx.dma, &spip->spi->RXDR);
 80052dc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80052de:	681b      	ldr	r3, [r3, #0]
 80052e0:	6099      	str	r1, [r3, #8]
      dmaStreamSetPeripheral(spip->tx.dma, &spip->spi->TXDR);
 80052e2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 80052e4:	6943      	ldr	r3, [r0, #20]
      dmaStreamSetPeripheral(spip->tx.dma, &spip->spi->TXDR);
 80052e6:	6809      	ldr	r1, [r1, #0]
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 80052e8:	f003 031f 	and.w	r3, r3, #31
      dmaStreamSetPeripheral(spip->tx.dma, &spip->spi->TXDR);
 80052ec:	608a      	str	r2, [r1, #8]
  dsize = (spip->config->cfg1 & SPI_CFG1_DSIZE_Msk) + 1U;
 80052ee:	3301      	adds	r3, #1
  if (spip->is_bdma)
 80052f0:	e73d      	b.n	800516e <spi_lld_start+0x22>
  spip->rx.dma = dmaStreamAllocI(rxstream, priority,
 80052f2:	4603      	mov	r3, r0
 80052f4:	4a7b      	ldr	r2, [pc, #492]	; (80054e4 <spi_lld_start+0x398>)
 80052f6:	210a      	movs	r1, #10
 80052f8:	2010      	movs	r0, #16
 80052fa:	f7fd fddb 	bl	8002eb4 <dmaStreamAllocI>
 80052fe:	6260      	str	r0, [r4, #36]	; 0x24
  if (spip->rx.dma == NULL) {
 8005300:	2800      	cmp	r0, #0
 8005302:	f000 812f 	beq.w	8005564 <spi_lld_start+0x418>
  spip->tx.dma = dmaStreamAllocI(txstream, priority,
 8005306:	4623      	mov	r3, r4
 8005308:	4a77      	ldr	r2, [pc, #476]	; (80054e8 <spi_lld_start+0x39c>)
 800530a:	210a      	movs	r1, #10
 800530c:	2010      	movs	r0, #16
 800530e:	f7fd fdd1 	bl	8002eb4 <dmaStreamAllocI>
 8005312:	62a0      	str	r0, [r4, #40]	; 0x28
  if (spip->tx.dma == NULL) {
 8005314:	2800      	cmp	r0, #0
 8005316:	f000 8128 	beq.w	800556a <spi_lld_start+0x41e>
      dmaSetRequestSource(spip->rx.dma, STM32_DMAMUX1_SPI1_RX);
 800531a:	2125      	movs	r1, #37	; 0x25
 800531c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800531e:	f7fd fe95 	bl	800304c <dmaSetRequestSource>
      dmaSetRequestSource(spip->tx.dma, STM32_DMAMUX1_SPI1_TX);
 8005322:	2126      	movs	r1, #38	; 0x26
 8005324:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005326:	f7fd fe91 	bl	800304c <dmaSetRequestSource>
  RCC_C1->APB2ENR |= mask;
 800532a:	4b6d      	ldr	r3, [pc, #436]	; (80054e0 <spi_lld_start+0x394>)
 800532c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 8005330:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8005334:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    RCC_C1->APB2LPENR |= mask;
 8005338:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800533c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8005340:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
  (void)RCC_C1->APB2LPENR;
 8005344:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
  RCC->APB2RSTR |= mask;
 8005348:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800534c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8005350:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8005354:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8005358:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800535c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8005360:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
}
 8005364:	e76c      	b.n	8005240 <spi_lld_start+0xf4>
  spip->rx.dma = dmaStreamAllocI(rxstream, priority,
 8005366:	4603      	mov	r3, r0
 8005368:	4a5e      	ldr	r2, [pc, #376]	; (80054e4 <spi_lld_start+0x398>)
 800536a:	210a      	movs	r1, #10
 800536c:	2010      	movs	r0, #16
 800536e:	f7fd fda1 	bl	8002eb4 <dmaStreamAllocI>
 8005372:	6260      	str	r0, [r4, #36]	; 0x24
  if (spip->rx.dma == NULL) {
 8005374:	2800      	cmp	r0, #0
 8005376:	f000 80f5 	beq.w	8005564 <spi_lld_start+0x418>
  spip->tx.dma = dmaStreamAllocI(txstream, priority,
 800537a:	4623      	mov	r3, r4
 800537c:	4a5a      	ldr	r2, [pc, #360]	; (80054e8 <spi_lld_start+0x39c>)
 800537e:	210a      	movs	r1, #10
 8005380:	2010      	movs	r0, #16
 8005382:	f7fd fd97 	bl	8002eb4 <dmaStreamAllocI>
 8005386:	62a0      	str	r0, [r4, #40]	; 0x28
  if (spip->tx.dma == NULL) {
 8005388:	2800      	cmp	r0, #0
 800538a:	f000 80ee 	beq.w	800556a <spi_lld_start+0x41e>
      dmaSetRequestSource(spip->rx.dma, STM32_DMAMUX1_SPI3_RX);
 800538e:	213d      	movs	r1, #61	; 0x3d
 8005390:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005392:	f7fd fe5b 	bl	800304c <dmaSetRequestSource>
      dmaSetRequestSource(spip->tx.dma, STM32_DMAMUX1_SPI3_TX);
 8005396:	213e      	movs	r1, #62	; 0x3e
 8005398:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800539a:	f7fd fe57 	bl	800304c <dmaSetRequestSource>
  RCC_C1->APB1LENR |= mask;
 800539e:	4b50      	ldr	r3, [pc, #320]	; (80054e0 <spi_lld_start+0x394>)
 80053a0:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 80053a4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80053a8:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 80053ac:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 80053b0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80053b4:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 80053b8:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
  RCC->APB1LRSTR |= mask;
 80053bc:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80053c0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80053c4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 80053c8:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80053cc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80053d0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 80053d4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
}
 80053d8:	e732      	b.n	8005240 <spi_lld_start+0xf4>
  spip->rx.dma = dmaStreamAllocI(rxstream, priority,
 80053da:	4603      	mov	r3, r0
 80053dc:	4a41      	ldr	r2, [pc, #260]	; (80054e4 <spi_lld_start+0x398>)
 80053de:	210a      	movs	r1, #10
 80053e0:	2010      	movs	r0, #16
 80053e2:	f7fd fd67 	bl	8002eb4 <dmaStreamAllocI>
 80053e6:	6260      	str	r0, [r4, #36]	; 0x24
  if (spip->rx.dma == NULL) {
 80053e8:	2800      	cmp	r0, #0
 80053ea:	f000 80bb 	beq.w	8005564 <spi_lld_start+0x418>
  spip->tx.dma = dmaStreamAllocI(txstream, priority,
 80053ee:	4623      	mov	r3, r4
 80053f0:	4a3d      	ldr	r2, [pc, #244]	; (80054e8 <spi_lld_start+0x39c>)
 80053f2:	210a      	movs	r1, #10
 80053f4:	2010      	movs	r0, #16
 80053f6:	f7fd fd5d 	bl	8002eb4 <dmaStreamAllocI>
 80053fa:	62a0      	str	r0, [r4, #40]	; 0x28
  if (spip->tx.dma == NULL) {
 80053fc:	2800      	cmp	r0, #0
 80053fe:	f000 80b4 	beq.w	800556a <spi_lld_start+0x41e>
      dmaSetRequestSource(spip->rx.dma, STM32_DMAMUX1_SPI2_RX);
 8005402:	2127      	movs	r1, #39	; 0x27
 8005404:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005406:	f7fd fe21 	bl	800304c <dmaSetRequestSource>
      dmaSetRequestSource(spip->tx.dma, STM32_DMAMUX1_SPI2_TX);
 800540a:	2128      	movs	r1, #40	; 0x28
 800540c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800540e:	f7fd fe1d 	bl	800304c <dmaSetRequestSource>
  RCC_C1->APB1LENR |= mask;
 8005412:	4b33      	ldr	r3, [pc, #204]	; (80054e0 <spi_lld_start+0x394>)
 8005414:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 8005418:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800541c:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 8005420:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 8005424:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005428:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 800542c:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
  RCC->APB1LRSTR |= mask;
 8005430:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005434:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005438:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 800543c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8005440:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8005444:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8005448:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
}
 800544c:	e6f8      	b.n	8005240 <spi_lld_start+0xf4>
  spip->rx.dma = dmaStreamAllocI(rxstream, priority,
 800544e:	4603      	mov	r3, r0
 8005450:	4a24      	ldr	r2, [pc, #144]	; (80054e4 <spi_lld_start+0x398>)
 8005452:	210a      	movs	r1, #10
 8005454:	2010      	movs	r0, #16
 8005456:	f7fd fd2d 	bl	8002eb4 <dmaStreamAllocI>
 800545a:	6260      	str	r0, [r4, #36]	; 0x24
  if (spip->rx.dma == NULL) {
 800545c:	2800      	cmp	r0, #0
 800545e:	f000 8081 	beq.w	8005564 <spi_lld_start+0x418>
  spip->tx.dma = dmaStreamAllocI(txstream, priority,
 8005462:	4623      	mov	r3, r4
 8005464:	4a20      	ldr	r2, [pc, #128]	; (80054e8 <spi_lld_start+0x39c>)
 8005466:	210a      	movs	r1, #10
 8005468:	2010      	movs	r0, #16
 800546a:	f7fd fd23 	bl	8002eb4 <dmaStreamAllocI>
 800546e:	62a0      	str	r0, [r4, #40]	; 0x28
  if (spip->tx.dma == NULL) {
 8005470:	2800      	cmp	r0, #0
 8005472:	d07a      	beq.n	800556a <spi_lld_start+0x41e>
      dmaSetRequestSource(spip->rx.dma, STM32_DMAMUX1_SPI4_RX);
 8005474:	2153      	movs	r1, #83	; 0x53
 8005476:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005478:	f7fd fde8 	bl	800304c <dmaSetRequestSource>
      dmaSetRequestSource(spip->tx.dma, STM32_DMAMUX1_SPI4_TX);
 800547c:	2154      	movs	r1, #84	; 0x54
 800547e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005480:	f7fd fde4 	bl	800304c <dmaSetRequestSource>
  RCC_C1->APB2ENR |= mask;
 8005484:	4b16      	ldr	r3, [pc, #88]	; (80054e0 <spi_lld_start+0x394>)
 8005486:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 800548a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800548e:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    RCC_C1->APB2LPENR |= mask;
 8005492:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8005496:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800549a:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
  (void)RCC_C1->APB2LPENR;
 800549e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
  RCC->APB2RSTR |= mask;
 80054a2:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 80054a6:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80054aa:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 80054ae:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 80054b2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80054b6:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 80054ba:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
}
 80054be:	e6bf      	b.n	8005240 <spi_lld_start+0xf4>
 80054c0:	24000a14 	.word	0x24000a14
 80054c4:	24000a50 	.word	0x24000a50
 80054c8:	24000a8c 	.word	0x24000a8c
 80054cc:	24000ac8 	.word	0x24000ac8
 80054d0:	24000b04 	.word	0x24000b04
 80054d4:	24000b40 	.word	0x24000b40
 80054d8:	08004d21 	.word	0x08004d21
 80054dc:	08004c61 	.word	0x08004c61
 80054e0:	58024400 	.word	0x58024400
 80054e4:	08004c79 	.word	0x08004c79
 80054e8:	08004c6d 	.word	0x08004c6d
  spip->rx.dma = dmaStreamAllocI(rxstream, priority,
 80054ec:	4603      	mov	r3, r0
 80054ee:	4a22      	ldr	r2, [pc, #136]	; (8005578 <spi_lld_start+0x42c>)
 80054f0:	210a      	movs	r1, #10
 80054f2:	2010      	movs	r0, #16
 80054f4:	f7fd fcde 	bl	8002eb4 <dmaStreamAllocI>
 80054f8:	6260      	str	r0, [r4, #36]	; 0x24
  if (spip->rx.dma == NULL) {
 80054fa:	b398      	cbz	r0, 8005564 <spi_lld_start+0x418>
  spip->tx.dma = dmaStreamAllocI(txstream, priority,
 80054fc:	4623      	mov	r3, r4
 80054fe:	4a1f      	ldr	r2, [pc, #124]	; (800557c <spi_lld_start+0x430>)
 8005500:	210a      	movs	r1, #10
 8005502:	2010      	movs	r0, #16
 8005504:	f7fd fcd6 	bl	8002eb4 <dmaStreamAllocI>
 8005508:	62a0      	str	r0, [r4, #40]	; 0x28
  if (spip->tx.dma == NULL) {
 800550a:	b370      	cbz	r0, 800556a <spi_lld_start+0x41e>
      dmaSetRequestSource(spip->rx.dma, STM32_DMAMUX1_SPI5_RX);
 800550c:	2155      	movs	r1, #85	; 0x55
 800550e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005510:	f7fd fd9c 	bl	800304c <dmaSetRequestSource>
      dmaSetRequestSource(spip->tx.dma, STM32_DMAMUX1_SPI5_TX);
 8005514:	2156      	movs	r1, #86	; 0x56
 8005516:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005518:	f7fd fd98 	bl	800304c <dmaSetRequestSource>
  RCC_C1->APB2ENR |= mask;
 800551c:	4b18      	ldr	r3, [pc, #96]	; (8005580 <spi_lld_start+0x434>)
 800551e:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 8005522:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005526:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    RCC_C1->APB2LPENR |= mask;
 800552a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800552e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005532:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
  (void)RCC_C1->APB2LPENR;
 8005536:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
  RCC->APB2RSTR |= mask;
 800553a:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800553e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005542:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8005546:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800554a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800554e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8005552:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
}
 8005556:	e673      	b.n	8005240 <spi_lld_start+0xf4>
      return HAL_RET_IS_INVALID;
 8005558:	f06f 0014 	mvn.w	r0, #20
}
 800555c:	bd10      	pop	{r4, pc}
    bdmaStreamFreeI(spip->rx.bdma);
 800555e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005560:	f7fd fa7e 	bl	8002a60 <bdmaStreamFreeI>
    return HAL_RET_NO_RESOURCE;
 8005564:	f06f 0010 	mvn.w	r0, #16
}
 8005568:	bd10      	pop	{r4, pc}
    dmaStreamFreeI(spip->rx.dma);
 800556a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800556c:	f7fd fd38 	bl	8002fe0 <dmaStreamFreeI>
    return HAL_RET_NO_RESOURCE;
 8005570:	f06f 0010 	mvn.w	r0, #16
}
 8005574:	bd10      	pop	{r4, pc}
 8005576:	bf00      	nop
 8005578:	08004c79 	.word	0x08004c79
 800557c:	08004c6d 	.word	0x08004c6d
 8005580:	58024400 	.word	0x58024400

08005584 <spi_lld_send>:
msg_t spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  osalDbgAssert(n <= STM32_DMA_MAX_TRANSFER, "unsupported DMA transfer size");

#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  if (spip->is_bdma)
 8005584:	f890 3020 	ldrb.w	r3, [r0, #32]
msg_t spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 8005588:	b410      	push	{r4}
#endif
#if defined(STM32_SPI_BDMA_REQUIRED)
  {
    bdmaStreamSetMemory(spip->rx.bdma, &spip->rxsink);
 800558a:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (spip->is_bdma)
 800558c:	b313      	cbz	r3, 80055d4 <spi_lld_send+0x50>
    bdmaStreamSetMemory(spip->rx.bdma, &spip->rxsink);
 800558e:	6864      	ldr	r4, [r4, #4]
 8005590:	f100 0334 	add.w	r3, r0, #52	; 0x34
 8005594:	60e3      	str	r3, [r4, #12]
    bdmaStreamSetTransactionSize(spip->rx.bdma, n);
    bdmaStreamSetMode(spip->rx.bdma, spip->rxdmamode);
 8005596:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    bdmaStreamSetTransactionSize(spip->rx.bdma, n);
 8005598:	6061      	str	r1, [r4, #4]
    bdmaStreamSetMode(spip->rx.bdma, spip->rxdmamode);
 800559a:	6023      	str	r3, [r4, #0]

    bdmaStreamSetMemory(spip->tx.bdma, txbuf);
 800559c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800559e:	685b      	ldr	r3, [r3, #4]
 80055a0:	60da      	str	r2, [r3, #12]
    bdmaStreamSetTransactionSize(spip->tx.bdma, n);
    bdmaStreamSetMode(spip->tx.bdma, spip->txdmamode | STM32_BDMA_CR_MINC);
 80055a2:	6b02      	ldr	r2, [r0, #48]	; 0x30
    bdmaStreamSetTransactionSize(spip->tx.bdma, n);
 80055a4:	6059      	str	r1, [r3, #4]
    bdmaStreamSetMode(spip->tx.bdma, spip->txdmamode | STM32_BDMA_CR_MINC);
 80055a6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    dmaStreamSetTransactionSize(spip->rx.dma, n);
    dmaStreamSetMode(spip->rx.dma, spip->rxdmamode);

    dmaStreamSetMemory0(spip->tx.dma, txbuf);
    dmaStreamSetTransactionSize(spip->tx.dma, n);
    dmaStreamSetMode(spip->tx.dma, spip->txdmamode | STM32_DMA_CR_MINC);
 80055aa:	601a      	str	r2, [r3, #0]

    dmaStreamEnable(spip->rx.dma);
 80055ac:	6822      	ldr	r2, [r4, #0]
 80055ae:	f042 0201 	orr.w	r2, r2, #1
 80055b2:	6022      	str	r2, [r4, #0]
    dmaStreamEnable(spip->tx.dma);
 80055b4:	681a      	ldr	r2, [r3, #0]
 80055b6:	f042 0201 	orr.w	r2, r2, #1
 80055ba:	601a      	str	r2, [r3, #0]
  if (!spip->config->slave) {
 80055bc:	6843      	ldr	r3, [r0, #4]
 80055be:	785b      	ldrb	r3, [r3, #1]
 80055c0:	b923      	cbnz	r3, 80055cc <spi_lld_send+0x48>
 80055c2:	69c2      	ldr	r2, [r0, #28]
    spip->spi->CR1 |= SPI_CR1_CSTART;
 80055c4:	6813      	ldr	r3, [r2, #0]
 80055c6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80055ca:	6013      	str	r3, [r2, #0]
#endif

  spi_lld_resume(spip);

  return HAL_RET_SUCCESS;
}
 80055cc:	2000      	movs	r0, #0
 80055ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 80055d2:	4770      	bx	lr
    dmaStreamSetMemory0(spip->rx.dma, &spip->rxsink);
 80055d4:	6824      	ldr	r4, [r4, #0]
 80055d6:	f100 0334 	add.w	r3, r0, #52	; 0x34
 80055da:	60e3      	str	r3, [r4, #12]
    dmaStreamSetMode(spip->rx.dma, spip->rxdmamode);
 80055dc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    dmaStreamSetTransactionSize(spip->rx.dma, n);
 80055de:	6061      	str	r1, [r4, #4]
    dmaStreamSetMode(spip->rx.dma, spip->rxdmamode);
 80055e0:	6023      	str	r3, [r4, #0]
    dmaStreamSetMemory0(spip->tx.dma, txbuf);
 80055e2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80055e4:	681b      	ldr	r3, [r3, #0]
 80055e6:	60da      	str	r2, [r3, #12]
    dmaStreamSetMode(spip->tx.dma, spip->txdmamode | STM32_DMA_CR_MINC);
 80055e8:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dmaStreamSetTransactionSize(spip->tx.dma, n);
 80055ea:	6059      	str	r1, [r3, #4]
    dmaStreamSetMode(spip->tx.dma, spip->txdmamode | STM32_DMA_CR_MINC);
 80055ec:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80055f0:	e7db      	b.n	80055aa <spi_lld_send+0x26>
 80055f2:	bf00      	nop

080055f4 <spi_lld_receive>:
msg_t spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  osalDbgAssert(n <= STM32_DMA_MAX_TRANSFER, "unsupported DMA transfer size");

#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  if (spip->is_bdma)
 80055f4:	f890 3020 	ldrb.w	r3, [r0, #32]
msg_t spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 80055f8:	b410      	push	{r4}
#endif
#if defined(STM32_SPI_BDMA_REQUIRED)
  {
    bdmaStreamSetMemory(spip->rx.bdma, rxbuf);
 80055fa:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (spip->is_bdma)
 80055fc:	b313      	cbz	r3, 8005644 <spi_lld_receive+0x50>
    bdmaStreamSetTransactionSize(spip->rx.bdma, n);
    bdmaStreamSetMode(spip->rx.bdma, spip->rxdmamode | STM32_BDMA_CR_MINC);
 80055fe:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    bdmaStreamSetMemory(spip->rx.bdma, rxbuf);
 8005600:	6864      	ldr	r4, [r4, #4]
    bdmaStreamSetMode(spip->rx.bdma, spip->rxdmamode | STM32_BDMA_CR_MINC);
 8005602:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    bdmaStreamSetMemory(spip->rx.bdma, rxbuf);
 8005606:	60e2      	str	r2, [r4, #12]

    bdmaStreamSetMemory(spip->tx.bdma, &spip->txsource);
 8005608:	f100 0238 	add.w	r2, r0, #56	; 0x38
    bdmaStreamSetTransactionSize(spip->rx.bdma, n);
 800560c:	6061      	str	r1, [r4, #4]
    bdmaStreamSetMode(spip->rx.bdma, spip->rxdmamode | STM32_BDMA_CR_MINC);
 800560e:	6023      	str	r3, [r4, #0]
    bdmaStreamSetMemory(spip->tx.bdma, &spip->txsource);
 8005610:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8005612:	685b      	ldr	r3, [r3, #4]
  {
    dmaStreamSetMemory0(spip->rx.dma, rxbuf);
    dmaStreamSetTransactionSize(spip->rx.dma, n);
    dmaStreamSetMode(spip->rx.dma, spip->rxdmamode | STM32_DMA_CR_MINC);

    dmaStreamSetMemory0(spip->tx.dma, &spip->txsource);
 8005614:	60da      	str	r2, [r3, #12]
    dmaStreamSetTransactionSize(spip->tx.dma, n);
    dmaStreamSetMode(spip->tx.dma, spip->txdmamode);
 8005616:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dmaStreamSetTransactionSize(spip->tx.dma, n);
 8005618:	6059      	str	r1, [r3, #4]
    dmaStreamSetMode(spip->tx.dma, spip->txdmamode);
 800561a:	601a      	str	r2, [r3, #0]

    dmaStreamEnable(spip->rx.dma);
 800561c:	6822      	ldr	r2, [r4, #0]
 800561e:	f042 0201 	orr.w	r2, r2, #1
 8005622:	6022      	str	r2, [r4, #0]
    dmaStreamEnable(spip->tx.dma);
 8005624:	681a      	ldr	r2, [r3, #0]
 8005626:	f042 0201 	orr.w	r2, r2, #1
 800562a:	601a      	str	r2, [r3, #0]
  if (!spip->config->slave) {
 800562c:	6843      	ldr	r3, [r0, #4]
 800562e:	785b      	ldrb	r3, [r3, #1]
 8005630:	b923      	cbnz	r3, 800563c <spi_lld_receive+0x48>
 8005632:	69c2      	ldr	r2, [r0, #28]
    spip->spi->CR1 |= SPI_CR1_CSTART;
 8005634:	6813      	ldr	r3, [r2, #0]
 8005636:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800563a:	6013      	str	r3, [r2, #0]
#endif

  spi_lld_resume(spip);

  return HAL_RET_SUCCESS;
}
 800563c:	2000      	movs	r0, #0
 800563e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005642:	4770      	bx	lr
    dmaStreamSetMode(spip->rx.dma, spip->rxdmamode | STM32_DMA_CR_MINC);
 8005644:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    dmaStreamSetMemory0(spip->rx.dma, rxbuf);
 8005646:	6824      	ldr	r4, [r4, #0]
    dmaStreamSetMode(spip->rx.dma, spip->rxdmamode | STM32_DMA_CR_MINC);
 8005648:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    dmaStreamSetMemory0(spip->rx.dma, rxbuf);
 800564c:	60e2      	str	r2, [r4, #12]
    dmaStreamSetMemory0(spip->tx.dma, &spip->txsource);
 800564e:	f100 0238 	add.w	r2, r0, #56	; 0x38
    dmaStreamSetTransactionSize(spip->rx.dma, n);
 8005652:	6061      	str	r1, [r4, #4]
    dmaStreamSetMode(spip->rx.dma, spip->rxdmamode | STM32_DMA_CR_MINC);
 8005654:	6023      	str	r3, [r4, #0]
    dmaStreamSetMemory0(spip->tx.dma, &spip->txsource);
 8005656:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8005658:	681b      	ldr	r3, [r3, #0]
 800565a:	e7db      	b.n	8005614 <spi_lld_receive+0x20>

0800565c <st_lld_init>:
  RCC_C1->APB1LENR |= mask;
 800565c:	4a12      	ldr	r2, [pc, #72]	; (80056a8 <st_lld_init+0x4c>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800565e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8005662:	2100      	movs	r1, #0
 8005664:	f8d2 00e8 	ldr.w	r0, [r2, #232]	; 0xe8
 8005668:	f040 0001 	orr.w	r0, r0, #1
void st_lld_init(void) {
 800566c:	b430      	push	{r4, r5}
 800566e:	f8c2 00e8 	str.w	r0, [r2, #232]	; 0xe8
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005672:	f242 557f 	movw	r5, #9599	; 0x257f
    RCC_C1->APB1LLPENR |= mask;
 8005676:	f8d2 0110 	ldr.w	r0, [r2, #272]	; 0x110
  ST_ENABLE_STOP();
 800567a:	4c0c      	ldr	r4, [pc, #48]	; (80056ac <st_lld_init+0x50>)
 800567c:	f040 0001 	orr.w	r0, r0, #1
 8005680:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8005684:	2001      	movs	r0, #1
  (void)RCC_C1->APB1LLPENR;
 8005686:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
  ST_ENABLE_STOP();
 800568a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800568c:	4302      	orrs	r2, r0
 800568e:	63e2      	str	r2, [r4, #60]	; 0x3c
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005690:	f04f 32ff 	mov.w	r2, #4294967295
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005694:	629d      	str	r5, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005696:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8005698:	6199      	str	r1, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 800569a:	6359      	str	r1, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800569c:	60d9      	str	r1, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 800569e:	6059      	str	r1, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80056a0:	6158      	str	r0, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80056a2:	6018      	str	r0, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80056a4:	bc30      	pop	{r4, r5}
 80056a6:	4770      	bx	lr
 80056a8:	58024400 	.word	0x58024400
 80056ac:	5c001000 	.word	0x5c001000

080056b0 <st_lld_serve_interrupt>:
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 80056b0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
void st_lld_serve_interrupt(void) {
 80056b4:	b508      	push	{r3, lr}
  sr  = timp->SR;
 80056b6:	6911      	ldr	r1, [r2, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 80056b8:	68d3      	ldr	r3, [r2, #12]
 80056ba:	400b      	ands	r3, r1
 80056bc:	b2d9      	uxtb	r1, r3
  timp->SR = ~sr;

  if ((sr & TIM_SR_CC1IF) != 0U)
 80056be:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 80056c0:	ea6f 0101 	mvn.w	r1, r1
 80056c4:	6111      	str	r1, [r2, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 80056c6:	d400      	bmi.n	80056ca <st_lld_serve_interrupt+0x1a>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 80056c8:	bd08      	pop	{r3, pc}
 80056ca:	2330      	movs	r3, #48	; 0x30
 80056cc:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 80056d0:	f000 fad2 	bl	8005c78 <chSysTimerHandlerI>
 80056d4:	2300      	movs	r3, #0
 80056d6:	f383 8811 	msr	BASEPRI, r3
 80056da:	bd08      	pop	{r3, pc}

080056dc <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 80056dc:	b510      	push	{r4, lr}
  PWMD5.has_bdtr = false;
#endif

#if STM32_PWM_USE_TIM8
  /* Driver initialization.*/
  pwmObjectInit(&PWMD8);
 80056de:	4c05      	ldr	r4, [pc, #20]	; (80056f4 <pwm_lld_init+0x18>)
 80056e0:	4620      	mov	r0, r4
 80056e2:	f7fb fcf7 	bl	80010d4 <pwmObjectInit>
  PWMD8.channels = STM32_TIM8_CHANNELS;
 80056e6:	2106      	movs	r1, #6
  PWMD8.tim = STM32_TIM8;
 80056e8:	4a03      	ldr	r2, [pc, #12]	; (80056f8 <pwm_lld_init+0x1c>)
  PWMD8.has_bdtr = true;
 80056ea:	2301      	movs	r3, #1
  PWMD8.channels = STM32_TIM8_CHANNELS;
 80056ec:	7421      	strb	r1, [r4, #16]
  PWMD8.tim = STM32_TIM8;
 80056ee:	61e2      	str	r2, [r4, #28]
  PWMD8.has_bdtr = true;
 80056f0:	7623      	strb	r3, [r4, #24]
  pwmObjectInit(&PWMD22);
  PWMD22.channels = STM32_TIM22_CHANNELS;
  PWMD22.tim = STM32_TIM22;
  PWMD22.has_bdtr = false;
#endif
}
 80056f2:	bd10      	pop	{r4, pc}
 80056f4:	24000b7c 	.word	0x24000b7c
 80056f8:	40010400 	.word	0x40010400

080056fc <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 80056fc:	69c3      	ldr	r3, [r0, #28]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 80056fe:	b570      	push	{r4, r5, r6, lr}
  sr  = pwmp->tim->SR;
 8005700:	691a      	ldr	r2, [r3, #16]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8005702:	4605      	mov	r5, r0
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8005704:	68dc      	ldr	r4, [r3, #12]
 8005706:	4014      	ands	r4, r2
 8005708:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800570a:	07a6      	lsls	r6, r4, #30
  pwmp->tim->SR = ~sr;
 800570c:	ea6f 0202 	mvn.w	r2, r2
 8005710:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8005712:	d503      	bpl.n	800571c <pwm_lld_serve_interrupt+0x20>
      (pwmp->config->channels[0].callback != NULL))
 8005714:	6843      	ldr	r3, [r0, #4]
 8005716:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8005718:	b103      	cbz	r3, 800571c <pwm_lld_serve_interrupt+0x20>
    pwmp->config->channels[0].callback(pwmp);
 800571a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800571c:	0760      	lsls	r0, r4, #29
 800571e:	d504      	bpl.n	800572a <pwm_lld_serve_interrupt+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 8005720:	686b      	ldr	r3, [r5, #4]
 8005722:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8005724:	b10b      	cbz	r3, 800572a <pwm_lld_serve_interrupt+0x2e>
    pwmp->config->channels[1].callback(pwmp);
 8005726:	4628      	mov	r0, r5
 8005728:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800572a:	0721      	lsls	r1, r4, #28
 800572c:	d504      	bpl.n	8005738 <pwm_lld_serve_interrupt+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 800572e:	686b      	ldr	r3, [r5, #4]
 8005730:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8005732:	b10b      	cbz	r3, 8005738 <pwm_lld_serve_interrupt+0x3c>
    pwmp->config->channels[2].callback(pwmp);
 8005734:	4628      	mov	r0, r5
 8005736:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8005738:	06e2      	lsls	r2, r4, #27
 800573a:	d504      	bpl.n	8005746 <pwm_lld_serve_interrupt+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 800573c:	686b      	ldr	r3, [r5, #4]
 800573e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8005740:	b10b      	cbz	r3, 8005746 <pwm_lld_serve_interrupt+0x4a>
    pwmp->config->channels[3].callback(pwmp);
 8005742:	4628      	mov	r0, r5
 8005744:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8005746:	07e3      	lsls	r3, r4, #31
 8005748:	d506      	bpl.n	8005758 <pwm_lld_serve_interrupt+0x5c>
 800574a:	686b      	ldr	r3, [r5, #4]
 800574c:	689b      	ldr	r3, [r3, #8]
 800574e:	b11b      	cbz	r3, 8005758 <pwm_lld_serve_interrupt+0x5c>
    pwmp->config->callback(pwmp);
 8005750:	4628      	mov	r0, r5
}
 8005752:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
 8005756:	4718      	bx	r3
}
 8005758:	bd70      	pop	{r4, r5, r6, pc}
 800575a:	bf00      	nop

0800575c <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 800575c:	4a02      	ldr	r2, [pc, #8]	; (8005768 <notify3+0xc>)
 800575e:	6813      	ldr	r3, [r2, #0]
 8005760:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8005764:	6013      	str	r3, [r2, #0]
}
 8005766:	4770      	bx	lr
 8005768:	40004800 	.word	0x40004800

0800576c <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 800576c:	b510      	push	{r4, lr}
  nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3);
 800576e:	4c0d      	ldr	r4, [pc, #52]	; (80057a4 <sd_lld_init+0x38>)
void sd_lld_init(void) {
 8005770:	b082      	sub	sp, #8
  sdObjectInit(&SD3);
 8005772:	4620      	mov	r0, r4
 8005774:	f7fb ff4e 	bl	8001614 <sdObjectInit>
  iqObjectInit(&SD3.iqueue, sd_in_buf3, sizeof sd_in_buf3, NULL, &SD3);
 8005778:	f104 000c 	add.w	r0, r4, #12
 800577c:	2300      	movs	r3, #0
 800577e:	2210      	movs	r2, #16
 8005780:	4909      	ldr	r1, [pc, #36]	; (80057a8 <sd_lld_init+0x3c>)
 8005782:	9400      	str	r4, [sp, #0]
 8005784:	f7fb fab4 	bl	8000cf0 <iqObjectInit>
  oqObjectInit(&SD3.oqueue, sd_out_buf3, sizeof sd_out_buf3, notify3, &SD3);
 8005788:	4b08      	ldr	r3, [pc, #32]	; (80057ac <sd_lld_init+0x40>)
 800578a:	2210      	movs	r2, #16
 800578c:	4908      	ldr	r1, [pc, #32]	; (80057b0 <sd_lld_init+0x44>)
 800578e:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8005792:	9400      	str	r4, [sp, #0]
 8005794:	f7fb fb3c 	bl	8000e10 <oqObjectInit>
  SD3.usart = USART3;
  SD3.clock = STM32_USART3CLK;
 8005798:	4a06      	ldr	r2, [pc, #24]	; (80057b4 <sd_lld_init+0x48>)
 800579a:	4b07      	ldr	r3, [pc, #28]	; (80057b8 <sd_lld_init+0x4c>)
 800579c:	e9c4 2315 	strd	r2, r3, [r4, #84]	; 0x54
  LPSD1.clock = STM32_LPUART1CLK;
#if !defined(STM32_LPUART1_SUPPRESS_ISR) && defined(STM32_LPUART1_NUMBER)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_SERIAL_LPUART1_PRIORITY);
#endif
#endif
}
 80057a0:	b002      	add	sp, #8
 80057a2:	bd10      	pop	{r4, pc}
 80057a4:	24000b9c 	.word	0x24000b9c
 80057a8:	24000bfc 	.word	0x24000bfc
 80057ac:	0800575d 	.word	0x0800575d
 80057b0:	24000c0c 	.word	0x24000c0c
 80057b4:	40004800 	.word	0x40004800
 80057b8:	02dc6c00 	.word	0x02dc6c00

080057bc <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 80057bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  if (config == NULL)
 80057c0:	2900      	cmp	r1, #0
 80057c2:	d036      	beq.n	8005832 <sd_lld_start+0x76>
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80057c4:	7a03      	ldrb	r3, [r0, #8]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80057c6:	f240 162d 	movw	r6, #301	; 0x12d
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 80057ca:	e9d1 c200 	ldrd	ip, r2, [r1]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80057ce:	e9d1 7502 	ldrd	r7, r5, [r1, #8]
  if (sdp->state == SD_STOP) {
 80057d2:	2b01      	cmp	r3, #1
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80057d4:	ea46 0602 	orr.w	r6, r6, r2
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 80057d8:	ea4f 035c 	mov.w	r3, ip, lsr #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80057dc:	f047 0740 	orr.w	r7, r7, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80057e0:	f045 0501 	orr.w	r5, r5, #1
    if (config->cr1 & USART_CR1_OVER8)
 80057e4:	f402 4e00 	and.w	lr, r2, #32768	; 0x8000
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
 80057e8:	f402 6180 	and.w	r1, r2, #1024	; 0x400
  if (sdp->state == SD_STOP) {
 80057ec:	d045      	beq.n	800587a <sd_lld_start+0xbe>
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 80057ee:	6d84      	ldr	r4, [r0, #88]	; 0x58
 80057f0:	4423      	add	r3, r4
  USART_TypeDef *u = sdp->usart;
 80057f2:	6d44      	ldr	r4, [r0, #84]	; 0x54
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 80057f4:	fbb3 f3fc 	udiv	r3, r3, ip
    if (config->cr1 & USART_CR1_OVER8)
 80057f8:	f1be 0f00 	cmp.w	lr, #0
 80057fc:	d005      	beq.n	800580a <sd_lld_start+0x4e>
      brr = ((brr & ~7) * 2) | (brr & 7);
 80057fe:	f023 0c07 	bic.w	ip, r3, #7
 8005802:	f003 0307 	and.w	r3, r3, #7
 8005806:	ea43 034c 	orr.w	r3, r3, ip, lsl #1
  u->BRR = brr;
 800580a:	60e3      	str	r3, [r4, #12]
  u->ICR = 0xFFFFFFFFU;
 800580c:	f04f 33ff 	mov.w	r3, #4294967295
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005810:	6067      	str	r7, [r4, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005812:	60a5      	str	r5, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8005814:	6026      	str	r6, [r4, #0]
  u->ICR = 0xFFFFFFFFU;
 8005816:	6223      	str	r3, [r4, #32]
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
 8005818:	b309      	cbz	r1, 800585e <sd_lld_start+0xa2>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 800581a:	f012 2210 	ands.w	r2, r2, #268439552	; 0x10001000
 800581e:	d047      	beq.n	80058b0 <sd_lld_start+0xf4>
 8005820:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 8005824:	bf14      	ite	ne
 8005826:	23ff      	movne	r3, #255	; 0xff
 8005828:	233f      	moveq	r3, #63	; 0x3f
      sdp->rxmask = 0x7F;
 800582a:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
      rccEnableLPUART1(true);
    }
#endif
  }
  usart_init(sdp, config);
}
 800582e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (sdp->state == SD_STOP) {
 8005832:	7a05      	ldrb	r5, [r0, #8]
 8005834:	2d01      	cmp	r5, #1
 8005836:	d017      	beq.n	8005868 <sd_lld_start+0xac>
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8005838:	6d83      	ldr	r3, [r0, #88]	; 0x58
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800583a:	2440      	movs	r4, #64	; 0x40
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800583c:	491f      	ldr	r1, [pc, #124]	; (80058bc <sd_lld_start+0x100>)
 800583e:	f503 4396 	add.w	r3, r3, #19200	; 0x4b00
  USART_TypeDef *u = sdp->usart;
 8005842:	6d42      	ldr	r2, [r0, #84]	; 0x54
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8005844:	fba1 1303 	umull	r1, r3, r1, r3
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8005848:	f240 112d 	movw	r1, #301	; 0x12d
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800584c:	0b1b      	lsrs	r3, r3, #12
  u->BRR = brr;
 800584e:	60d3      	str	r3, [r2, #12]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005850:	2301      	movs	r3, #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005852:	6054      	str	r4, [r2, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005854:	6093      	str	r3, [r2, #8]
  u->ICR = 0xFFFFFFFFU;
 8005856:	f04f 33ff 	mov.w	r3, #4294967295
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800585a:	6011      	str	r1, [r2, #0]
  u->ICR = 0xFFFFFFFFU;
 800585c:	6213      	str	r3, [r2, #32]
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 800585e:	23ff      	movs	r3, #255	; 0xff
      sdp->rxmask = 0x7F;
 8005860:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
}
 8005864:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (sdp->state == SD_STOP) {
 8005868:	f240 162d 	movw	r6, #301	; 0x12d
 800586c:	2740      	movs	r7, #64	; 0x40
 800586e:	468e      	mov	lr, r1
 8005870:	460a      	mov	r2, r1
 8005872:	f44f 4396 	mov.w	r3, #19200	; 0x4b00
 8005876:	f44f 4c16 	mov.w	ip, #38400	; 0x9600
    if (&SD3 == sdp) {
 800587a:	4c11      	ldr	r4, [pc, #68]	; (80058c0 <sd_lld_start+0x104>)
 800587c:	42a0      	cmp	r0, r4
 800587e:	d1b6      	bne.n	80057ee <sd_lld_start+0x32>
  RCC_C1->APB1LENR |= mask;
 8005880:	4c10      	ldr	r4, [pc, #64]	; (80058c4 <sd_lld_start+0x108>)
 8005882:	f8d4 80e8 	ldr.w	r8, [r4, #232]	; 0xe8
 8005886:	f448 2880 	orr.w	r8, r8, #262144	; 0x40000
 800588a:	f8c4 80e8 	str.w	r8, [r4, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 800588e:	f8d4 8110 	ldr.w	r8, [r4, #272]	; 0x110
 8005892:	f448 2880 	orr.w	r8, r8, #262144	; 0x40000
 8005896:	f8c4 8110 	str.w	r8, [r4, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 800589a:	f8d4 4110 	ldr.w	r4, [r4, #272]	; 0x110
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800589e:	6d84      	ldr	r4, [r0, #88]	; 0x58
 80058a0:	4423      	add	r3, r4
  USART_TypeDef *u = sdp->usart;
 80058a2:	6d44      	ldr	r4, [r0, #84]	; 0x54
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 80058a4:	fbb3 f3fc 	udiv	r3, r3, ip
    if (config->cr1 & USART_CR1_OVER8)
 80058a8:	f1be 0f00 	cmp.w	lr, #0
 80058ac:	d1a7      	bne.n	80057fe <sd_lld_start+0x42>
 80058ae:	e7ac      	b.n	800580a <sd_lld_start+0x4e>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 80058b0:	237f      	movs	r3, #127	; 0x7f
      sdp->rxmask = 0x7F;
 80058b2:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
}
 80058b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80058ba:	bf00      	nop
 80058bc:	1b4e81b5 	.word	0x1b4e81b5
 80058c0:	24000b9c 	.word	0x24000b9c
 80058c4:	58024400 	.word	0x58024400

080058c8 <sd_lld_serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 80058c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 80058cc:	6d45      	ldr	r5, [r0, #84]	; 0x54
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 80058ce:	4606      	mov	r6, r0
  uint32_t cr1;
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80058d0:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80058d2:	0722      	lsls	r2, r4, #28
  u->ICR = isr;
 80058d4:	622c      	str	r4, [r5, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80058d6:	d156      	bne.n	8005986 <sd_lld_serve_interrupt+0xbe>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80058d8:	05e2      	lsls	r2, r4, #23
 80058da:	d448      	bmi.n	800596e <sd_lld_serve_interrupt+0xa6>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 80058dc:	06a0      	lsls	r0, r4, #26
 80058de:	d510      	bpl.n	8005902 <sd_lld_serve_interrupt+0x3a>
 80058e0:	f04f 0830 	mov.w	r8, #48	; 0x30
 80058e4:	2700      	movs	r7, #0
 80058e6:	f388 8811 	msr	BASEPRI, r8
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 80058ea:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80058ec:	4630      	mov	r0, r6
 80058ee:	f896 105c 	ldrb.w	r1, [r6, #92]	; 0x5c
 80058f2:	4019      	ands	r1, r3
 80058f4:	f7fb fea8 	bl	8001648 <sdIncomingDataI>
 80058f8:	f387 8811 	msr	BASEPRI, r7
    osalSysUnlockFromISR();

    isr = u->ISR;
 80058fc:	69ec      	ldr	r4, [r5, #28]
  while (isr & USART_ISR_RXNE) {
 80058fe:	06a3      	lsls	r3, r4, #26
 8005900:	d4f1      	bmi.n	80058e6 <sd_lld_serve_interrupt+0x1e>
  }

  /* Caching CR1.*/
  cr1 = u->CR1;
 8005902:	f8d5 a000 	ldr.w	sl, [r5]
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 8005906:	f01a 0f80 	tst.w	sl, #128	; 0x80
 800590a:	d01d      	beq.n	8005948 <sd_lld_serve_interrupt+0x80>
    while (isr & USART_ISR_TXE) {
 800590c:	0621      	lsls	r1, r4, #24
 800590e:	d51b      	bpl.n	8005948 <sd_lld_serve_interrupt+0x80>
      msg_t b;

      osalSysLockFromISR();
      b = oqGetI(&sdp->oqueue);
 8005910:	f106 0830 	add.w	r8, r6, #48	; 0x30
 8005914:	2730      	movs	r7, #48	; 0x30
 8005916:	f04f 0900 	mov.w	r9, #0
 800591a:	e005      	b.n	8005928 <sd_lld_serve_interrupt+0x60>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        cr1 &= ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
 800591c:	62a8      	str	r0, [r5, #40]	; 0x28
 800591e:	f389 8811 	msr	BASEPRI, r9
      osalSysUnlockFromISR();

      isr = u->ISR;
 8005922:	69ec      	ldr	r4, [r5, #28]
    while (isr & USART_ISR_TXE) {
 8005924:	0622      	lsls	r2, r4, #24
 8005926:	d50f      	bpl.n	8005948 <sd_lld_serve_interrupt+0x80>
 8005928:	f387 8811 	msr	BASEPRI, r7
      b = oqGetI(&sdp->oqueue);
 800592c:	4640      	mov	r0, r8
 800592e:	f7fb faab 	bl	8000e88 <oqGetI>
      if (b < MSG_OK) {
 8005932:	2800      	cmp	r0, #0
 8005934:	daf2      	bge.n	800591c <sd_lld_serve_interrupt+0x54>
  chEvtBroadcastFlagsI(esp, flags);
 8005936:	2108      	movs	r1, #8
 8005938:	1d30      	adds	r0, r6, #4
 800593a:	f000 ffed 	bl	8006918 <chEvtBroadcastFlagsI>
        cr1 &= ~USART_CR1_TXEIE;
 800593e:	f02a 0a80 	bic.w	sl, sl, #128	; 0x80
 8005942:	2300      	movs	r3, #0
 8005944:	f383 8811 	msr	BASEPRI, r3
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 8005948:	f01a 0f40 	tst.w	sl, #64	; 0x40
 800594c:	d00b      	beq.n	8005966 <sd_lld_serve_interrupt+0x9e>
 800594e:	0663      	lsls	r3, r4, #25
 8005950:	d509      	bpl.n	8005966 <sd_lld_serve_interrupt+0x9e>
 8005952:	2330      	movs	r3, #48	; 0x30
 8005954:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 8005958:	e9d6 2311 	ldrd	r2, r3, [r6, #68]	; 0x44
 800595c:	429a      	cmp	r2, r3
 800595e:	d02d      	beq.n	80059bc <sd_lld_serve_interrupt+0xf4>
 8005960:	2300      	movs	r3, #0
 8005962:	f383 8811 	msr	BASEPRI, r3
    }
    osalSysUnlockFromISR();
  }

  /* Writing CR1 once.*/
  u->CR1 = cr1;
 8005966:	f8c5 a000 	str.w	sl, [r5]
}
 800596a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800596e:	2330      	movs	r3, #48	; 0x30
 8005970:	f383 8811 	msr	BASEPRI, r3
 8005974:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8005978:	1d30      	adds	r0, r6, #4
 800597a:	f000 ffcd 	bl	8006918 <chEvtBroadcastFlagsI>
 800597e:	2300      	movs	r3, #0
 8005980:	f383 8811 	msr	BASEPRI, r3
}
 8005984:	e7aa      	b.n	80058dc <sd_lld_serve_interrupt+0x14>
  if (isr & USART_ISR_ORE)
 8005986:	f3c4 01c0 	ubfx	r1, r4, #3, #1
  if (isr & USART_ISR_PE)
 800598a:	07e3      	lsls	r3, r4, #31
 800598c:	f04f 0330 	mov.w	r3, #48	; 0x30
  if (isr & USART_ISR_ORE)
 8005990:	ea4f 2101 	mov.w	r1, r1, lsl #8
    sts |= SD_PARITY_ERROR;
 8005994:	bf48      	it	mi
 8005996:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 800599a:	07a7      	lsls	r7, r4, #30
    sts |= SD_FRAMING_ERROR;
 800599c:	bf48      	it	mi
 800599e:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 80059a2:	0760      	lsls	r0, r4, #29
    sts |= SD_NOISE_ERROR;
 80059a4:	bf48      	it	mi
 80059a6:	f041 0180 	orrmi.w	r1, r1, #128	; 0x80
 80059aa:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 80059ae:	1d30      	adds	r0, r6, #4
 80059b0:	f000 ffb2 	bl	8006918 <chEvtBroadcastFlagsI>
 80059b4:	2300      	movs	r3, #0
 80059b6:	f383 8811 	msr	BASEPRI, r3
}
 80059ba:	e78d      	b.n	80058d8 <sd_lld_serve_interrupt+0x10>
    if (oqIsEmptyI(&sdp->oqueue)) {
 80059bc:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 80059be:	2b00      	cmp	r3, #0
 80059c0:	d0ce      	beq.n	8005960 <sd_lld_serve_interrupt+0x98>
 80059c2:	2110      	movs	r1, #16
 80059c4:	1d30      	adds	r0, r6, #4
      cr1 &= ~USART_CR1_TCIE;
 80059c6:	f02a 0a40 	bic.w	sl, sl, #64	; 0x40
 80059ca:	f000 ffa5 	bl	8006918 <chEvtBroadcastFlagsI>
 80059ce:	e7c7      	b.n	8005960 <sd_lld_serve_interrupt+0x98>

080059d0 <__early_init>:
  RCC->AHB4RSTR |= mask;
 80059d0:	4a66      	ldr	r2, [pc, #408]	; (8005b6c <__early_init+0x19c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059d2:	2300      	movs	r3, #0
  RCC->AHB4RSTR &= ~mask;
 80059d4:	4866      	ldr	r0, [pc, #408]	; (8005b70 <__early_init+0x1a0>)
  RCC->AHB4RSTR |= mask;
 80059d6:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80059da:	b470      	push	{r4, r5, r6}
 80059dc:	f240 74ff 	movw	r4, #2047	; 0x7ff
  gpiop->OSPEEDR = config->ospeedr;
 80059e0:	4d64      	ldr	r5, [pc, #400]	; (8005b74 <__early_init+0x1a4>)
  gpiop->AFRL    = config->afrl;
 80059e2:	f245 5650 	movw	r6, #21840	; 0x5550
 80059e6:	4321      	orrs	r1, r4
 80059e8:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 80059ec:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 80059f0:	4008      	ands	r0, r1
  gpiop->OTYPER  = config->otyper;
 80059f2:	4961      	ldr	r1, [pc, #388]	; (8005b78 <__early_init+0x1a8>)
 80059f4:	f8c2 0088 	str.w	r0, [r2, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 80059f8:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
  RCC_C1->AHB4ENR |= mask;
 80059fc:	f8d2 00e0 	ldr.w	r0, [r2, #224]	; 0xe0
 8005a00:	4320      	orrs	r0, r4
 8005a02:	f8c2 00e0 	str.w	r0, [r2, #224]	; 0xe0
    RCC_C1->AHB4LPENR |= mask;
 8005a06:	f8d2 0108 	ldr.w	r0, [r2, #264]	; 0x108
 8005a0a:	4320      	orrs	r0, r4
 8005a0c:	4c5b      	ldr	r4, [pc, #364]	; (8005b7c <__early_init+0x1ac>)
 8005a0e:	f8c2 0108 	str.w	r0, [r2, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 8005a12:	f8d2 2108 	ldr.w	r2, [r2, #264]	; 0x108
  gpiop->ODR     = config->odr;
 8005a16:	f64f 728f 	movw	r2, #65423	; 0xff8f
  gpiop->OTYPER  = config->otyper;
 8005a1a:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005a1c:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8005a1e:	f04f 3555 	mov.w	r5, #1431655765	; 0x55555555
 8005a22:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 8005a24:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8005a26:	4a56      	ldr	r2, [pc, #344]	; (8005b80 <__early_init+0x1b0>)
  gpiop->OTYPER  = config->otyper;
 8005a28:	4856      	ldr	r0, [pc, #344]	; (8005b84 <__early_init+0x1b4>)
  gpiop->AFRL    = config->afrl;
 8005a2a:	620a      	str	r2, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8005a2c:	4a56      	ldr	r2, [pc, #344]	; (8005b88 <__early_init+0x1b8>)
 8005a2e:	624a      	str	r2, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a30:	4a56      	ldr	r2, [pc, #344]	; (8005b8c <__early_init+0x1bc>)
 8005a32:	600a      	str	r2, [r1, #0]
  gpiop->ODR     = config->odr;
 8005a34:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->OSPEEDR = config->ospeedr;
 8005a38:	4a55      	ldr	r2, [pc, #340]	; (8005b90 <__early_init+0x1c0>)
  gpiop->OTYPER  = config->otyper;
 8005a3a:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005a3c:	60a2      	str	r2, [r4, #8]
  gpiop->ODR     = config->odr;
 8005a3e:	f64b 727e 	movw	r2, #49022	; 0xbf7e
  gpiop->PUPDR   = config->pupdr;
 8005a42:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 8005a44:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8005a46:	4a53      	ldr	r2, [pc, #332]	; (8005b94 <__early_init+0x1c4>)
 8005a48:	6222      	str	r2, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8005a4a:	4a53      	ldr	r2, [pc, #332]	; (8005b98 <__early_init+0x1c8>)
 8005a4c:	6262      	str	r2, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a4e:	4a53      	ldr	r2, [pc, #332]	; (8005b9c <__early_init+0x1cc>)
 8005a50:	6022      	str	r2, [r4, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8005a52:	4c53      	ldr	r4, [pc, #332]	; (8005ba0 <__early_init+0x1d0>)
  gpiop->OTYPER  = config->otyper;
 8005a54:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005a56:	6084      	str	r4, [r0, #8]
  gpiop->AFRL    = config->afrl;
 8005a58:	4c52      	ldr	r4, [pc, #328]	; (8005ba4 <__early_init+0x1d4>)
  gpiop->PUPDR   = config->pupdr;
 8005a5a:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 8005a5c:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8005a5e:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8005a60:	4c51      	ldr	r4, [pc, #324]	; (8005ba8 <__early_init+0x1d8>)
  gpiop->OTYPER  = config->otyper;
 8005a62:	4a52      	ldr	r2, [pc, #328]	; (8005bac <__early_init+0x1dc>)
  gpiop->AFRH    = config->afrh;
 8005a64:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a66:	4c52      	ldr	r4, [pc, #328]	; (8005bb0 <__early_init+0x1e0>)
 8005a68:	6004      	str	r4, [r0, #0]
  gpiop->OTYPER  = config->otyper;
 8005a6a:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 8005a6e:	4c51      	ldr	r4, [pc, #324]	; (8005bb4 <__early_init+0x1e4>)
  gpiop->OTYPER  = config->otyper;
 8005a70:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005a72:	6094      	str	r4, [r2, #8]
  gpiop->AFRL    = config->afrl;
 8005a74:	4c50      	ldr	r4, [pc, #320]	; (8005bb8 <__early_init+0x1e8>)
  gpiop->PUPDR   = config->pupdr;
 8005a76:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 8005a78:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8005a7a:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8005a7c:	f104 44f8 	add.w	r4, r4, #2080374784	; 0x7c000000
 8005a80:	f504 1408 	add.w	r4, r4, #2228224	; 0x220000
 8005a84:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a86:	4c4d      	ldr	r4, [pc, #308]	; (8005bbc <__early_init+0x1ec>)
 8005a88:	6014      	str	r4, [r2, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8005a8a:	f46f 5440 	mvn.w	r4, #12288	; 0x3000
  gpiop->OTYPER  = config->otyper;
 8005a8e:	6043      	str	r3, [r0, #4]
 8005a90:	f502 6200 	add.w	r2, r2, #2048	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 8005a94:	6084      	str	r4, [r0, #8]
  gpiop->AFRL    = config->afrl;
 8005a96:	f1a4 547e 	sub.w	r4, r4, #1065353216	; 0x3f800000
  gpiop->PUPDR   = config->pupdr;
 8005a9a:	60c3      	str	r3, [r0, #12]
  gpiop->AFRL    = config->afrl;
 8005a9c:	f5a4 14cb 	sub.w	r4, r4, #1662976	; 0x196000
  gpiop->ODR     = config->odr;
 8005aa0:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8005aa2:	f6a4 1433 	subw	r4, r4, #2355	; 0x933
 8005aa6:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8005aa8:	f04f 34cc 	mov.w	r4, #3435973836	; 0xcccccccc
 8005aac:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005aae:	4c44      	ldr	r4, [pc, #272]	; (8005bc0 <__early_init+0x1f0>)
 8005ab0:	6004      	str	r4, [r0, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8005ab2:	4c44      	ldr	r4, [pc, #272]	; (8005bc4 <__early_init+0x1f4>)
  gpiop->OTYPER  = config->otyper;
 8005ab4:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005ab6:	6094      	str	r4, [r2, #8]
  gpiop->AFRL    = config->afrl;
 8005ab8:	4c43      	ldr	r4, [pc, #268]	; (8005bc8 <__early_init+0x1f8>)
  gpiop->PUPDR   = config->pupdr;
 8005aba:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 8005abc:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8005abe:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8005ac0:	f104 44f8 	add.w	r4, r4, #2080374784	; 0x7c000000
 8005ac4:	f6a4 4477 	subw	r4, r4, #3191	; 0xc77
 8005ac8:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005aca:	f104 445e 	add.w	r4, r4, #3724541952	; 0xde000000
 8005ace:	f5a4 1490 	sub.w	r4, r4, #1179648	; 0x120000
 8005ad2:	f2a4 54ab 	subw	r4, r4, #1451	; 0x5ab
 8005ad6:	6014      	str	r4, [r2, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8005ad8:	4c3c      	ldr	r4, [pc, #240]	; (8005bcc <__early_init+0x1fc>)
  gpiop->OTYPER  = config->otyper;
 8005ada:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8005ade:	f8c0 4808 	str.w	r4, [r0, #2056]	; 0x808
  gpiop->ODR     = config->odr;
 8005ae2:	f64f 74bf 	movw	r4, #65471	; 0xffbf
  gpiop->PUPDR   = config->pupdr;
 8005ae6:	f8c0 380c 	str.w	r3, [r0, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8005aea:	f8c0 4814 	str.w	r4, [r0, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 8005aee:	4c38      	ldr	r4, [pc, #224]	; (8005bd0 <__early_init+0x200>)
 8005af0:	f8c0 4820 	str.w	r4, [r0, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8005af4:	4c37      	ldr	r4, [pc, #220]	; (8005bd4 <__early_init+0x204>)
 8005af6:	f8c0 4824 	str.w	r4, [r0, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 8005afa:	4c37      	ldr	r4, [pc, #220]	; (8005bd8 <__early_init+0x208>)
 8005afc:	f8c0 4800 	str.w	r4, [r0, #2048]	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 8005b00:	4836      	ldr	r0, [pc, #216]	; (8005bdc <__early_init+0x20c>)
  gpiop->OTYPER  = config->otyper;
 8005b02:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8005b06:	f8c2 0808 	str.w	r0, [r2, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 8005b0a:	f44f 30a0 	mov.w	r0, #81920	; 0x14000
  gpiop->OTYPER  = config->otyper;
 8005b0e:	4c34      	ldr	r4, [pc, #208]	; (8005be0 <__early_init+0x210>)
  gpiop->PUPDR   = config->pupdr;
 8005b10:	f8c2 080c 	str.w	r0, [r2, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8005b14:	f64f 70e3 	movw	r0, #65507	; 0xffe3
 8005b18:	f8c2 0814 	str.w	r0, [r2, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 8005b1c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005b20:	f8c2 0820 	str.w	r0, [r2, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8005b24:	f242 2004 	movw	r0, #8708	; 0x2204
 8005b28:	f8c2 0824 	str.w	r0, [r2, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 8005b2c:	482d      	ldr	r0, [pc, #180]	; (8005be4 <__early_init+0x214>)
 8005b2e:	f8c2 0800 	str.w	r0, [r2, #2048]	; 0x800
  gpiop->ODR     = config->odr;
 8005b32:	f64f 72cf 	movw	r2, #65487	; 0xffcf
  gpiop->OTYPER  = config->otyper;
 8005b36:	6063      	str	r3, [r4, #4]
 8005b38:	482b      	ldr	r0, [pc, #172]	; (8005be8 <__early_init+0x218>)
  gpiop->OSPEEDR = config->ospeedr;
 8005b3a:	60a1      	str	r1, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8005b3c:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 8005b3e:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8005b40:	6226      	str	r6, [r4, #32]
  gpiop->OTYPER  = config->otyper;
 8005b42:	4a2a      	ldr	r2, [pc, #168]	; (8005bec <__early_init+0x21c>)
  gpiop->MODER   = config->moder;
 8005b44:	4e2a      	ldr	r6, [pc, #168]	; (8005bf0 <__early_init+0x220>)
  gpiop->AFRH    = config->afrh;
 8005b46:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005b48:	6026      	str	r6, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 8005b4a:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005b4c:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8005b4e:	60c5      	str	r5, [r0, #12]
  gpiop->ODR     = config->odr;
 8005b50:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8005b52:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8005b54:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005b56:	6003      	str	r3, [r0, #0]
  gpiop->OTYPER  = config->otyper;
 8005b58:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005b5a:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8005b5c:	60d5      	str	r5, [r2, #12]
  gpiop->ODR     = config->odr;
 8005b5e:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8005b60:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8005b62:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005b64:	6013      	str	r3, [r2, #0]

  stm32_gpio_init();
  stm32_clock_init();
}
 8005b66:	bc70      	pop	{r4, r5, r6}
  stm32_clock_init();
 8005b68:	f7fc ba3c 	b.w	8001fe4 <stm32_clock_init>
 8005b6c:	58024400 	.word	0x58024400
 8005b70:	fffff800 	.word	0xfffff800
 8005b74:	abf300fc 	.word	0xabf300fc
 8005b78:	58020000 	.word	0x58020000
 8005b7c:	58020400 	.word	0x58020400
 8005b80:	b0000bb0 	.word	0xb0000bb0
 8005b84:	58020800 	.word	0x58020800
 8005b88:	000aaa0a 	.word	0x000aaa0a
 8005b8c:	aaaed56b 	.word	0xaaaed56b
 8005b90:	fca0cfca 	.word	0xfca0cfca
 8005b94:	00666022 	.word	0x00666022
 8005b98:	ccb01100 	.word	0xccb01100
 8005b9c:	abaf7aba 	.word	0xabaf7aba
 8005ba0:	03ffccff 	.word	0x03ffccff
 8005ba4:	30bbccbc 	.word	0x30bbccbc
 8005ba8:	000ccccc 	.word	0x000ccccc
 8005bac:	58020c00 	.word	0x58020c00
 8005bb0:	02aabbaa 	.word	0x02aabbaa
 8005bb4:	fa3ff03f 	.word	0xfa3ff03f
 8005bb8:	50000ccc 	.word	0x50000ccc
 8005bbc:	aaea9fea 	.word	0xaaea9fea
 8005bc0:	aaaabaaa 	.word	0xaaaabaaa
 8005bc4:	ffcfcfff 	.word	0xffcfcfff
 8005bc8:	50cccccc 	.word	0x50cccccc
 8005bcc:	ffff0f3f 	.word	0xffff0f3f
 8005bd0:	00cc0ccc 	.word	0x00cc0ccc
 8005bd4:	c555505c 	.word	0xc555505c
 8005bd8:	aa9a1aea 	.word	0xaa9a1aea
 8005bdc:	00a14005 	.word	0x00a14005
 8005be0:	58022000 	.word	0x58022000
 8005be4:	ffaebd5a 	.word	0xffaebd5a
 8005be8:	58022400 	.word	0x58022400
 8005bec:	58022800 	.word	0x58022800
 8005bf0:	ffff55a9 	.word	0xffff55a9

08005bf4 <sdc_lld_is_card_inserted>:
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {

  (void)sdcp;
  /* CHTODO: Fill the implementation.*/
  return true;
}
 8005bf4:	2001      	movs	r0, #1
 8005bf6:	4770      	bx	lr

08005bf8 <sdc_lld_is_write_protected>:
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {

  (void)sdcp;
  /* CHTODO: Fill the implementation.*/
  return false;
}
 8005bf8:	2000      	movs	r0, #0
 8005bfa:	4770      	bx	lr

08005bfc <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 8005bfc:	4770      	bx	lr
 8005bfe:	bf00      	nop

08005c00 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 8005c00:	b530      	push	{r4, r5, lr}
 8005c02:	b087      	sub	sp, #28
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8005c04:	4d11      	ldr	r5, [pc, #68]	; (8005c4c <chSysInit+0x4c>)
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
    ch_system.instances[i] = NULL;
 8005c06:	2300      	movs	r3, #0
  ch_system.state = ch_sys_initializing;
 8005c08:	2201      	movs	r2, #1

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
 8005c0a:	4668      	mov	r0, sp
 8005c0c:	2404      	movs	r4, #4
 8005c0e:	702a      	strb	r2, [r5, #0]
  tcp->offset = (rtcnt_t)0;
 8005c10:	e9c5 3301 	strd	r3, r3, [r5, #4]
  chTMObjectInit(&tm);
 8005c14:	f000 fd48 	bl	80066a8 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 8005c18:	4668      	mov	r0, sp
 8005c1a:	f000 fd55 	bl	80066c8 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8005c1e:	4668      	mov	r0, sp
 8005c20:	f000 fd58 	bl	80066d4 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 8005c24:	3c01      	subs	r4, #1
 8005c26:	d1f7      	bne.n	8005c18 <chSysInit+0x18>
  tcp->offset = tm.best;
 8005c28:	9b00      	ldr	r3, [sp, #0]
 8005c2a:	60ab      	str	r3, [r5, #8]
 * @notapi
 */
static inline void __oslib_init(void) {

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8005c2c:	f000 ff42 	bl	8006ab4 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8005c30:	f000 ff8c 	bl	8006b4c <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 8005c34:	f000 ffae 	bl	8006b94 <__factory_init>

  /* OS library modules.*/
  __oslib_init();

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 8005c38:	4905      	ldr	r1, [pc, #20]	; (8005c50 <chSysInit+0x50>)
 8005c3a:	4806      	ldr	r0, [pc, #24]	; (8005c54 <chSysInit+0x54>)
 8005c3c:	f000 fb72 	bl	8006324 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 8005c40:	2302      	movs	r3, #2
 8005c42:	702b      	strb	r3, [r5, #0]
 8005c44:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
}
 8005c48:	b007      	add	sp, #28
 8005c4a:	bd30      	pop	{r4, r5, pc}
 8005c4c:	240016e0 	.word	0x240016e0
 8005c50:	08014e94 	.word	0x08014e94
 8005c54:	24000c20 	.word	0x24000c20

08005c58 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8005c58:	b508      	push	{r3, lr}
 8005c5a:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8005c5c:	b672      	cpsid	i

  port_disable();

  /* Logging the event.*/
  __trace_halt(reason);
 8005c5e:	f000 f8ad 	bl	8005dbc <__trace_halt>

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 8005c62:	4903      	ldr	r1, [pc, #12]	; (8005c70 <chSysHalt+0x18>)
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 8005c64:	4b03      	ldr	r3, [pc, #12]	; (8005c74 <chSysHalt+0x1c>)
 8005c66:	2203      	movs	r2, #3
  currcore->dbg.panic_msg = reason;
 8005c68:	f8c1 40e4 	str.w	r4, [r1, #228]	; 0xe4
  ch_system.state = ch_sys_halted;
 8005c6c:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
 8005c6e:	e7fe      	b.n	8005c6e <chSysHalt+0x16>
 8005c70:	24000c20 	.word	0x24000c20
 8005c74:	240016e0 	.word	0x240016e0

08005c78 <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8005c78:	f000 b988 	b.w	8005f8c <chVTDoTickI>

08005c7c <chSysPolledDelayX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005c7c:	4a03      	ldr	r2, [pc, #12]	; (8005c8c <chSysPolledDelayX+0x10>)
 8005c7e:	6851      	ldr	r1, [r2, #4]
 8005c80:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8005c82:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8005c84:	4298      	cmp	r0, r3
 8005c86:	d8fb      	bhi.n	8005c80 <chSysPolledDelayX+0x4>
  }
}
 8005c88:	4770      	bx	lr
 8005c8a:	bf00      	nop
 8005c8c:	e0001000 	.word	0xe0001000

08005c90 <chRFCUCollectFaultsI>:
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8005c90:	4a02      	ldr	r2, [pc, #8]	; (8005c9c <chRFCUCollectFaultsI+0xc>)
 8005c92:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8005c94:	4318      	orrs	r0, r3
 8005c96:	63d0      	str	r0, [r2, #60]	; 0x3c
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8005c98:	4770      	bx	lr
 8005c9a:	bf00      	nop
 8005c9c:	24000c20 	.word	0x24000c20

08005ca0 <trace_next.constprop.0>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {
 8005ca0:	b538      	push	{r3, r4, r5, lr}

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8005ca2:	4c0c      	ldr	r4, [pc, #48]	; (8005cd4 <trace_next.constprop.0+0x34>)
 8005ca4:	f8d4 50ec 	ldr.w	r5, [r4, #236]	; 0xec
 8005ca8:	f7fa ffa8 	bl	8000bfc <stGetCounter>
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8005cac:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8005cb0:	f504 610f 	add.w	r1, r4, #2288	; 0x8f0
 8005cb4:	4a08      	ldr	r2, [pc, #32]	; (8005cd8 <trace_next.constprop.0+0x38>)
  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8005cb6:	6068      	str	r0, [r5, #4]
 8005cb8:	6850      	ldr	r0, [r2, #4]
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8005cba:	681a      	ldr	r2, [r3, #0]
 8005cbc:	f360 221f 	bfi	r2, r0, #8, #24
 8005cc0:	f843 2b10 	str.w	r2, [r3], #16
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8005cc4:	f104 02f0 	add.w	r2, r4, #240	; 0xf0
 8005cc8:	428b      	cmp	r3, r1
 8005cca:	bf28      	it	cs
 8005ccc:	4613      	movcs	r3, r2
 8005cce:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
  }
}
 8005cd2:	bd38      	pop	{r3, r4, r5, pc}
 8005cd4:	24000c20 	.word	0x24000c20
 8005cd8:	e0001000 	.word	0xe0001000

08005cdc <__trace_object_init>:
 * @notapi
 */
void __trace_object_init(trace_buffer_t *tbp) {
  unsigned i;

  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8005cdc:	4602      	mov	r2, r0
 8005cde:	4907      	ldr	r1, [pc, #28]	; (8005cfc <__trace_object_init+0x20>)
  tbp->size      = CH_DBG_TRACE_BUFFER_SIZE;
  tbp->ptr       = &tbp->buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005ce0:	2300      	movs	r3, #0
  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8005ce2:	f842 1b08 	str.w	r1, [r2], #8
  tbp->ptr       = &tbp->buffer[0];
 8005ce6:	6042      	str	r2, [r0, #4]
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005ce8:	eb00 1203 	add.w	r2, r0, r3, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005cec:	3301      	adds	r3, #1
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005cee:	7a11      	ldrb	r1, [r2, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005cf0:	2b80      	cmp	r3, #128	; 0x80
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005cf2:	f36f 0102 	bfc	r1, #0, #3
 8005cf6:	7211      	strb	r1, [r2, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005cf8:	d1f6      	bne.n	8005ce8 <__trace_object_init+0xc>
  }
}
 8005cfa:	4770      	bx	lr
 8005cfc:	0080ffff 	.word	0x0080ffff

08005d00 <__trace_ready>:
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8005d00:	4b09      	ldr	r3, [pc, #36]	; (8005d28 <__trace_ready+0x28>)
 8005d02:	f8b3 20e8 	ldrh.w	r2, [r3, #232]	; 0xe8
 8005d06:	07d2      	lsls	r2, r2, #31
 8005d08:	d500      	bpl.n	8005d0c <__trace_ready+0xc>
 8005d0a:	4770      	bx	lr
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8005d0c:	7f02      	ldrb	r2, [r0, #28]
void __trace_ready(thread_t *tp, msg_t msg) {
 8005d0e:	b410      	push	{r4}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8005d10:	f8d3 40ec 	ldr.w	r4, [r3, #236]	; 0xec
 8005d14:	00d3      	lsls	r3, r2, #3
 8005d16:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8005d1a:	e9c4 0102 	strd	r0, r1, [r4, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8005d1e:	7023      	strb	r3, [r4, #0]
    trace_next(oip);
  }
}
 8005d20:	f85d 4b04 	ldr.w	r4, [sp], #4
    trace_next(oip);
 8005d24:	f7ff bfbc 	b.w	8005ca0 <trace_next.constprop.0>
 8005d28:	24000c20 	.word	0x24000c20

08005d2c <__trace_switch>:
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8005d2c:	4b0a      	ldr	r3, [pc, #40]	; (8005d58 <__trace_switch+0x2c>)
 8005d2e:	f8b3 20e8 	ldrh.w	r2, [r3, #232]	; 0xe8
 8005d32:	0792      	lsls	r2, r2, #30
 8005d34:	d500      	bpl.n	8005d38 <__trace_switch+0xc>
 8005d36:	4770      	bx	lr
void __trace_switch(thread_t *ntp, thread_t *otp) {
 8005d38:	b410      	push	{r4}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005d3a:	7f0a      	ldrb	r2, [r1, #28]
 8005d3c:	f8d3 40ec 	ldr.w	r4, [r3, #236]	; 0xec
 8005d40:	00d3      	lsls	r3, r2, #3
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005d42:	6b49      	ldr	r1, [r1, #52]	; 0x34
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005d44:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005d48:	e9c4 0102 	strd	r0, r1, [r4, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005d4c:	7023      	strb	r3, [r4, #0]
    trace_next(oip);
  }
}
 8005d4e:	f85d 4b04 	ldr.w	r4, [sp], #4
    trace_next(oip);
 8005d52:	f7ff bfa5 	b.w	8005ca0 <trace_next.constprop.0>
 8005d56:	bf00      	nop
 8005d58:	24000c20 	.word	0x24000c20

08005d5c <__trace_isr_enter>:
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8005d5c:	4a0a      	ldr	r2, [pc, #40]	; (8005d88 <__trace_isr_enter+0x2c>)
 8005d5e:	f8b2 30e8 	ldrh.w	r3, [r2, #232]	; 0xe8
void __trace_isr_enter(const char *isr) {
 8005d62:	b510      	push	{r4, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8005d64:	f013 0404 	ands.w	r4, r3, #4
 8005d68:	d000      	beq.n	8005d6c <__trace_isr_enter+0x10>
    oip->trace_buffer.ptr->state       = 0U;
    oip->trace_buffer.ptr->u.isr.name  = isr;
    trace_next(oip);
    port_unlock_from_isr();
  }
}
 8005d6a:	bd10      	pop	{r4, pc}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005d6c:	2330      	movs	r3, #48	; 0x30
 8005d6e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8005d72:	2103      	movs	r1, #3
 8005d74:	f8d2 30ec 	ldr.w	r3, [r2, #236]	; 0xec
 8005d78:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8005d7a:	6098      	str	r0, [r3, #8]
    trace_next(oip);
 8005d7c:	f7ff ff90 	bl	8005ca0 <trace_next.constprop.0>
 8005d80:	f384 8811 	msr	BASEPRI, r4
}
 8005d84:	bd10      	pop	{r4, pc}
 8005d86:	bf00      	nop
 8005d88:	24000c20 	.word	0x24000c20

08005d8c <__trace_isr_leave>:
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8005d8c:	4a0a      	ldr	r2, [pc, #40]	; (8005db8 <__trace_isr_leave+0x2c>)
 8005d8e:	f8b2 30e8 	ldrh.w	r3, [r2, #232]	; 0xe8
void __trace_isr_leave(const char *isr) {
 8005d92:	b510      	push	{r4, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8005d94:	f013 0404 	ands.w	r4, r3, #4
 8005d98:	d000      	beq.n	8005d9c <__trace_isr_leave+0x10>
    oip->trace_buffer.ptr->state       = 0U;
    oip->trace_buffer.ptr->u.isr.name  = isr;
    trace_next(oip);
    port_unlock_from_isr();
  }
}
 8005d9a:	bd10      	pop	{r4, pc}
 8005d9c:	2330      	movs	r3, #48	; 0x30
 8005d9e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8005da2:	2104      	movs	r1, #4
 8005da4:	f8d2 30ec 	ldr.w	r3, [r2, #236]	; 0xec
 8005da8:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8005daa:	6098      	str	r0, [r3, #8]
    trace_next(oip);
 8005dac:	f7ff ff78 	bl	8005ca0 <trace_next.constprop.0>
 8005db0:	f384 8811 	msr	BASEPRI, r4
}
 8005db4:	bd10      	pop	{r4, pc}
 8005db6:	bf00      	nop
 8005db8:	24000c20 	.word	0x24000c20

08005dbc <__trace_halt>:
 * @notapi
 */
void __trace_halt(const char *reason) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8005dbc:	4b06      	ldr	r3, [pc, #24]	; (8005dd8 <__trace_halt+0x1c>)
 8005dbe:	f8b3 20e8 	ldrh.w	r2, [r3, #232]	; 0xe8
 8005dc2:	0712      	lsls	r2, r2, #28
 8005dc4:	d500      	bpl.n	8005dc8 <__trace_halt+0xc>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
    oip->trace_buffer.ptr->state         = 0;
    oip->trace_buffer.ptr->u.halt.reason = reason;
    trace_next(oip);
  }
}
 8005dc6:	4770      	bx	lr
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8005dc8:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8005dcc:	2205      	movs	r2, #5
    oip->trace_buffer.ptr->u.halt.reason = reason;
 8005dce:	6098      	str	r0, [r3, #8]
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8005dd0:	701a      	strb	r2, [r3, #0]
    trace_next(oip);
 8005dd2:	f7ff bf65 	b.w	8005ca0 <trace_next.constprop.0>
 8005dd6:	bf00      	nop
 8005dd8:	24000c20 	.word	0x24000c20

08005ddc <vt_insert_first.constprop.0>:
 * @param[in] vtlp      pointer to a @p virtual_timers_list_t structure
 * @param[in] vtp       pointer to a @p virtual_timer_t object
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8005ddc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8005dde:	4d15      	ldr	r5, [pc, #84]	; (8005e34 <vt_insert_first.constprop.0+0x58>)
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8005de0:	460e      	mov	r6, r1
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);

  /* Initial delta is what is configured statically.*/
  currdelta = vtlp->lastdelta;
 8005de2:	6a2f      	ldr	r7, [r5, #32]
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 8005de4:	f105 0310 	add.w	r3, r5, #16
  vtlp->lasttime = now;
 8005de8:	61e9      	str	r1, [r5, #28]
  dlp->delta      = delta;
 8005dea:	42ba      	cmp	r2, r7
  dlp->prev       = dlhp;
 8005dec:	e9c0 3201 	strd	r3, r2, [r0, #4]
  dlp->next       = dlp->prev->next;
 8005df0:	692b      	ldr	r3, [r5, #16]
 8005df2:	bf38      	it	cc
 8005df4:	463a      	movcc	r2, r7
 8005df6:	6003      	str	r3, [r0, #0]
  dlp->next->prev = dlp;
 8005df8:	4614      	mov	r4, r2
 8005dfa:	6058      	str	r0, [r3, #4]
  dlhp->next      = dlp;
 8005dfc:	6128      	str	r0, [r5, #16]
  stStartAlarm(time);
 8005dfe:	1888      	adds	r0, r1, r2
 8005e00:	f7fa ff00 	bl	8000c04 <stStartAlarm>
  return stGetCounter();
 8005e04:	f7fa fefa 	bl	8000bfc <stGetCounter>
  return (sysinterval_t)((systime_t)(end - start));
 8005e08:	1b82      	subs	r2, r0, r6
 8005e0a:	4603      	mov	r3, r0
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8005e0c:	42a2      	cmp	r2, r4
 8005e0e:	d209      	bcs.n	8005e24 <vt_insert_first.constprop.0+0x48>
    delay = currdelta;
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > vtlp->lastdelta) {
 8005e10:	6a2b      	ldr	r3, [r5, #32]
 8005e12:	429f      	cmp	r7, r3
 8005e14:	d800      	bhi.n	8005e18 <vt_insert_first.constprop.0+0x3c>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8005e16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    vtlp->lastdelta = currdelta;
 8005e18:	622f      	str	r7, [r5, #32]
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8005e1a:	2001      	movs	r0, #1
}
 8005e1c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8005e20:	f7ff bf36 	b.w	8005c90 <chRFCUCollectFaultsI>
    currdelta += (sysinterval_t)1;
 8005e24:	1c7c      	adds	r4, r7, #1
  stSetAlarm(time);
 8005e26:	1930      	adds	r0, r6, r4
 8005e28:	4627      	mov	r7, r4
    now = newnow;
 8005e2a:	461e      	mov	r6, r3
 8005e2c:	f7fa fef8 	bl	8000c20 <stSetAlarm>
  while (true) {
 8005e30:	e7e8      	b.n	8005e04 <vt_insert_first.constprop.0+0x28>
 8005e32:	bf00      	nop
 8005e34:	24000c20 	.word	0x24000c20

08005e38 <vt_enqueue.constprop.0>:
 *
 * @param[in] vtlp      pointer to a @p virtual_timers_list_t structure
 * @param[in] vtp       pointer to a @p virtual_timer_t object
 * @param[in] delay     delay over current system time
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
 8005e38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return (bool)(dlhp == dlhp->next);
 8005e3c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8005ee4 <vt_enqueue.constprop.0+0xac>
 8005e40:	4607      	mov	r7, r0
 8005e42:	460e      	mov	r6, r1
  return stGetCounter();
 8005e44:	f7fa feda 	bl	8000bfc <stGetCounter>
 8005e48:	464b      	mov	r3, r9
 8005e4a:	4680      	mov	r8, r0
 8005e4c:	f853 5f10 	ldr.w	r5, [r3, #16]!
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8005e50:	429d      	cmp	r5, r3
 8005e52:	d03b      	beq.n	8005ecc <vt_enqueue.constprop.0+0x94>
 8005e54:	f8d9 401c 	ldr.w	r4, [r9, #28]
      delta = delay;
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8005e58:	68ab      	ldr	r3, [r5, #8]
 8005e5a:	1b04      	subs	r4, r0, r4
      delta = delay;
 8005e5c:	1934      	adds	r4, r6, r4
 8005e5e:	bf28      	it	cs
 8005e60:	4634      	movcs	r4, r6
    if (delta < vtlp->dlist.next->delta) {
 8005e62:	42a3      	cmp	r3, r4
 8005e64:	d815      	bhi.n	8005e92 <vt_enqueue.constprop.0+0x5a>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
 8005e66:	429c      	cmp	r4, r3
 8005e68:	d904      	bls.n	8005e74 <vt_enqueue.constprop.0+0x3c>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
    dlp = dlp->next;
 8005e6a:	682d      	ldr	r5, [r5, #0]
    delta -= dlp->delta;
 8005e6c:	1ae4      	subs	r4, r4, r3
  while (likely(dlp->delta < delta)) {
 8005e6e:	68ab      	ldr	r3, [r5, #8]
 8005e70:	42a3      	cmp	r3, r4
 8005e72:	d3fa      	bcc.n	8005e6a <vt_enqueue.constprop.0+0x32>
  dlp->prev       = dlp->next->prev;
 8005e74:	686b      	ldr	r3, [r5, #4]
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8005e76:	f04f 32ff 	mov.w	r2, #4294967295
  dlp->delta      = delta;
 8005e7a:	60bc      	str	r4, [r7, #8]
  dlp->prev       = dlp->next->prev;
 8005e7c:	e9c7 5300 	strd	r5, r3, [r7]
  dlp->prev->next = dlp;
 8005e80:	601f      	str	r7, [r3, #0]
  dlp->delta -= delta;
 8005e82:	68ab      	ldr	r3, [r5, #8]
  dlhp->prev      = dlp;
 8005e84:	606f      	str	r7, [r5, #4]
  dlp->delta -= delta;
 8005e86:	1b1b      	subs	r3, r3, r4
 8005e88:	60ab      	str	r3, [r5, #8]
  dlhp->delta = (sysinterval_t)-1;
 8005e8a:	f8c9 2018 	str.w	r2, [r9, #24]
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
}
 8005e8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  currdelta = vtlp->lastdelta;
 8005e92:	f8d9 5020 	ldr.w	r5, [r9, #32]
  if (delay < currdelta) {
 8005e96:	42ae      	cmp	r6, r5
 8005e98:	bf38      	it	cc
 8005e9a:	462e      	movcc	r6, r5
  stSetAlarm(time);
 8005e9c:	eb08 0006 	add.w	r0, r8, r6
 8005ea0:	f7fa febe 	bl	8000c20 <stSetAlarm>
  return stGetCounter();
 8005ea4:	f7fa feaa 	bl	8000bfc <stGetCounter>
 8005ea8:	eba0 0808 	sub.w	r8, r0, r8
    if (likely(nowdelta < delay)) {
 8005eac:	4546      	cmp	r6, r8
 8005eae:	d914      	bls.n	8005eda <vt_enqueue.constprop.0+0xa2>
  if (currdelta > vtlp->lastdelta) {
 8005eb0:	f8d9 3020 	ldr.w	r3, [r9, #32]
 8005eb4:	429d      	cmp	r5, r3
 8005eb6:	d803      	bhi.n	8005ec0 <vt_enqueue.constprop.0+0x88>
  dlp = dlhp->next;
 8005eb8:	f8d9 5010 	ldr.w	r5, [r9, #16]
  while (likely(dlp->delta < delta)) {
 8005ebc:	68ab      	ldr	r3, [r5, #8]
 8005ebe:	e7d2      	b.n	8005e66 <vt_enqueue.constprop.0+0x2e>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8005ec0:	2001      	movs	r0, #1
    vtlp->lastdelta = currdelta;
 8005ec2:	f8c9 5020 	str.w	r5, [r9, #32]
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8005ec6:	f7ff fee3 	bl	8005c90 <chRFCUCollectFaultsI>
 8005eca:	e7f5      	b.n	8005eb8 <vt_enqueue.constprop.0+0x80>
      vt_insert_first(vtlp, vtp, now, delay);
 8005ecc:	4632      	mov	r2, r6
 8005ece:	4601      	mov	r1, r0
 8005ed0:	4638      	mov	r0, r7
}
 8005ed2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      vt_insert_first(vtlp, vtp, now, delay);
 8005ed6:	f7ff bf81 	b.w	8005ddc <vt_insert_first.constprop.0>
    currdelta += (sysinterval_t)1;
 8005eda:	3501      	adds	r5, #1
    now = newnow;
 8005edc:	4680      	mov	r8, r0
    currdelta += (sysinterval_t)1;
 8005ede:	462e      	mov	r6, r5
  while (true) {
 8005ee0:	e7dc      	b.n	8005e9c <vt_enqueue.constprop.0+0x64>
 8005ee2:	bf00      	nop
 8005ee4:	24000c20 	.word	0x24000c20

08005ee8 <chVTDoSetI>:

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
 8005ee8:	6103      	str	r3, [r0, #16]
  vtp->func    = vtfunc;
  vtp->reload  = (sysinterval_t)0;
 8005eea:	2300      	movs	r3, #0
  vtp->func    = vtfunc;
 8005eec:	60c2      	str	r2, [r0, #12]
  vtp->reload  = (sysinterval_t)0;
 8005eee:	6143      	str	r3, [r0, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8005ef0:	f7ff bfa2 	b.w	8005e38 <vt_enqueue.constprop.0>

08005ef4 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t object
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8005ef4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return (bool)(dlhp->next == dlp);
 8005ef6:	4c24      	ldr	r4, [pc, #144]	; (8005f88 <chVTDoResetI+0x94>)
 8005ef8:	6923      	ldr	r3, [r4, #16]
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8005efa:	4298      	cmp	r0, r3
 8005efc:	d00d      	beq.n	8005f1a <chVTDoResetI+0x26>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 8005efe:	6803      	ldr	r3, [r0, #0]
 8005f00:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8005f04:	6013      	str	r3, [r2, #0]
  dlp->next->prev = dlp->prev;
 8005f06:	605a      	str	r2, [r3, #4]

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8005f08:	689a      	ldr	r2, [r3, #8]
 8005f0a:	440a      	add	r2, r1

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8005f0c:	2100      	movs	r1, #0
    vtp->dlist.next->delta += vtp->dlist.delta;
 8005f0e:	609a      	str	r2, [r3, #8]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8005f10:	f04f 33ff 	mov.w	r3, #4294967295
    vtp->dlist.next = NULL;
 8005f14:	6001      	str	r1, [r0, #0]
    vtlp->dlist.delta = (sysinterval_t)-1;
 8005f16:	61a3      	str	r3, [r4, #24]
  delta = vtlp->dlist.next->delta - nowdelta;

  /* Setting up the alarm.*/
  vt_set_alarm(vtlp, now, delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005f18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dlhp->next       = dlp->next;
 8005f1a:	6802      	ldr	r2, [r0, #0]
 8005f1c:	4623      	mov	r3, r4
  vtp->dlist.next = NULL;
 8005f1e:	2100      	movs	r1, #0
 8005f20:	f843 2f10 	str.w	r2, [r3, #16]!
  dlhp->next->prev = dlhp;
 8005f24:	6053      	str	r3, [r2, #4]
 8005f26:	6001      	str	r1, [r0, #0]
  return (bool)(dlhp == dlhp->next);
 8005f28:	6922      	ldr	r2, [r4, #16]
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8005f2a:	429a      	cmp	r2, r3
 8005f2c:	d023      	beq.n	8005f76 <chVTDoResetI+0x82>
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8005f2e:	6893      	ldr	r3, [r2, #8]
 8005f30:	6881      	ldr	r1, [r0, #8]
 8005f32:	440b      	add	r3, r1
 8005f34:	6093      	str	r3, [r2, #8]
 8005f36:	f7fa fe61 	bl	8000bfc <stGetCounter>
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8005f3a:	69e3      	ldr	r3, [r4, #28]
  if (nowdelta >= vtlp->dlist.next->delta) {
 8005f3c:	6922      	ldr	r2, [r4, #16]
 8005f3e:	4605      	mov	r5, r0
 8005f40:	1ac1      	subs	r1, r0, r3
 8005f42:	6896      	ldr	r6, [r2, #8]
 8005f44:	428e      	cmp	r6, r1
 8005f46:	d9e7      	bls.n	8005f18 <chVTDoResetI+0x24>
  delta = vtlp->dlist.next->delta - nowdelta;
 8005f48:	441e      	add	r6, r3
  currdelta = vtlp->lastdelta;
 8005f4a:	6a27      	ldr	r7, [r4, #32]
  delta = vtlp->dlist.next->delta - nowdelta;
 8005f4c:	1a36      	subs	r6, r6, r0
 8005f4e:	42be      	cmp	r6, r7
 8005f50:	bf38      	it	cc
 8005f52:	463e      	movcc	r6, r7
  stSetAlarm(time);
 8005f54:	19a8      	adds	r0, r5, r6
 8005f56:	f7fa fe63 	bl	8000c20 <stSetAlarm>
  return stGetCounter();
 8005f5a:	f7fa fe4f 	bl	8000bfc <stGetCounter>
 8005f5e:	1b45      	subs	r5, r0, r5
    if (likely(nowdelta < delay)) {
 8005f60:	42ae      	cmp	r6, r5
 8005f62:	d90c      	bls.n	8005f7e <chVTDoResetI+0x8a>
  if (currdelta > vtlp->lastdelta) {
 8005f64:	6a23      	ldr	r3, [r4, #32]
 8005f66:	429f      	cmp	r7, r3
 8005f68:	d9d6      	bls.n	8005f18 <chVTDoResetI+0x24>
    vtlp->lastdelta = currdelta;
 8005f6a:	6227      	str	r7, [r4, #32]
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8005f6c:	2001      	movs	r0, #1
}
 8005f6e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8005f72:	f7ff be8d 	b.w	8005c90 <chRFCUCollectFaultsI>
}
 8005f76:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  stStopAlarm();
 8005f7a:	f7fa be4b 	b.w	8000c14 <stStopAlarm>
    currdelta += (sysinterval_t)1;
 8005f7e:	3701      	adds	r7, #1
    now = newnow;
 8005f80:	4605      	mov	r5, r0
    currdelta += (sysinterval_t)1;
 8005f82:	463e      	mov	r6, r7
  while (true) {
 8005f84:	e7e6      	b.n	8005f54 <chVTDoResetI+0x60>
 8005f86:	bf00      	nop
 8005f88:	24000c20 	.word	0x24000c20

08005f8c <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8005f8c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f90:	4e3d      	ldr	r6, [pc, #244]	; (8006088 <chVTDoTickI+0xfc>)
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 8005f92:	2700      	movs	r7, #0
 8005f94:	f04f 0930 	mov.w	r9, #48	; 0x30
 8005f98:	f106 0810 	add.w	r8, r6, #16
 8005f9c:	e009      	b.n	8005fb2 <chVTDoTickI+0x26>
 8005f9e:	f387 8811 	msr	BASEPRI, r7
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 8005fa2:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
 8005fa6:	4620      	mov	r0, r4
 8005fa8:	4798      	blx	r3
 8005faa:	f389 8811 	msr	BASEPRI, r9

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8005fae:	6963      	ldr	r3, [r4, #20]
 8005fb0:	b9ab      	cbnz	r3, 8005fde <chVTDoTickI+0x52>
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8005fb2:	6934      	ldr	r4, [r6, #16]
  return stGetCounter();
 8005fb4:	f7fa fe22 	bl	8000bfc <stGetCounter>
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8005fb8:	69f3      	ldr	r3, [r6, #28]
 8005fba:	4605      	mov	r5, r0
    if (nowdelta < vtp->dlist.delta) {
 8005fbc:	68a2      	ldr	r2, [r4, #8]
 8005fbe:	1ac1      	subs	r1, r0, r3
 8005fc0:	428a      	cmp	r2, r1
 8005fc2:	d82c      	bhi.n	800601e <chVTDoTickI+0x92>
  return systime + (systime_t)interval;
 8005fc4:	189d      	adds	r5, r3, r2
  dlp->prev->next = dlp->next;
 8005fc6:	e9d4 1000 	ldrd	r1, r0, [r4]
    vtlp->lasttime = lasttime;
 8005fca:	61f5      	str	r5, [r6, #28]
 8005fcc:	6001      	str	r1, [r0, #0]
  dlp->next->prev = dlp->prev;
 8005fce:	6048      	str	r0, [r1, #4]
    vtp->dlist.next = NULL;
 8005fd0:	6027      	str	r7, [r4, #0]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8005fd2:	6933      	ldr	r3, [r6, #16]
 8005fd4:	4543      	cmp	r3, r8
 8005fd6:	d1e2      	bne.n	8005f9e <chVTDoTickI+0x12>
  stStopAlarm();
 8005fd8:	f7fa fe1c 	bl	8000c14 <stStopAlarm>
}
 8005fdc:	e7df      	b.n	8005f9e <chVTDoTickI+0x12>
  return stGetCounter();
 8005fde:	f7fa fe0d 	bl	8000bfc <stGetCounter>
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8005fe2:	6962      	ldr	r2, [r4, #20]
  return (sysinterval_t)((systime_t)(end - start));
 8005fe4:	eba0 0b05 	sub.w	fp, r0, r5
 8005fe8:	4682      	mov	sl, r0
 8005fea:	455a      	cmp	r2, fp
 8005fec:	d330      	bcc.n	8006050 <chVTDoTickI+0xc4>
  return (bool)(dlhp == dlhp->next);
 8005fee:	6933      	ldr	r3, [r6, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8005ff0:	4543      	cmp	r3, r8
 8005ff2:	d03f      	beq.n	8006074 <chVTDoTickI+0xe8>
  while (likely(dlp->delta < delta)) {
 8005ff4:	6899      	ldr	r1, [r3, #8]
 8005ff6:	428a      	cmp	r2, r1
 8005ff8:	d904      	bls.n	8006004 <chVTDoTickI+0x78>
    dlp = dlp->next;
 8005ffa:	681b      	ldr	r3, [r3, #0]
    delta -= dlp->delta;
 8005ffc:	1a52      	subs	r2, r2, r1
  while (likely(dlp->delta < delta)) {
 8005ffe:	6899      	ldr	r1, [r3, #8]
 8006000:	4291      	cmp	r1, r2
 8006002:	d3fa      	bcc.n	8005ffa <chVTDoTickI+0x6e>
  dlp->prev       = dlp->next->prev;
 8006004:	6859      	ldr	r1, [r3, #4]
  dlp->delta      = delta;
 8006006:	60a2      	str	r2, [r4, #8]
  dlp->prev       = dlp->next->prev;
 8006008:	e9c4 3100 	strd	r3, r1, [r4]
  dlp->prev->next = dlp;
 800600c:	600c      	str	r4, [r1, #0]
  dlp->delta -= delta;
 800600e:	6899      	ldr	r1, [r3, #8]
  dlhp->prev      = dlp;
 8006010:	605c      	str	r4, [r3, #4]
  dlp->delta -= delta;
 8006012:	1a89      	subs	r1, r1, r2
  dlhp->delta = (sysinterval_t)-1;
 8006014:	f04f 32ff 	mov.w	r2, #4294967295
  dlp->delta -= delta;
 8006018:	6099      	str	r1, [r3, #8]
  dlhp->delta = (sysinterval_t)-1;
 800601a:	61b2      	str	r2, [r6, #24]
}
 800601c:	e7c9      	b.n	8005fb2 <chVTDoTickI+0x26>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 800601e:	6931      	ldr	r1, [r6, #16]
 8006020:	4541      	cmp	r1, r8
 8006022:	d013      	beq.n	800604c <chVTDoTickI+0xc0>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 8006024:	4413      	add	r3, r2
  currdelta = vtlp->lastdelta;
 8006026:	6a37      	ldr	r7, [r6, #32]
  vtlp->lasttime += nowdelta;
 8006028:	61f0      	str	r0, [r6, #28]
  vtp->dlist.delta -= nowdelta;
 800602a:	1a1b      	subs	r3, r3, r0
 800602c:	42bb      	cmp	r3, r7
 800602e:	60a3      	str	r3, [r4, #8]
  if (delay < currdelta) {
 8006030:	bf38      	it	cc
 8006032:	463b      	movcc	r3, r7
 8006034:	461c      	mov	r4, r3
  stSetAlarm(time);
 8006036:	1928      	adds	r0, r5, r4
 8006038:	f7fa fdf2 	bl	8000c20 <stSetAlarm>
  return stGetCounter();
 800603c:	f7fa fdde 	bl	8000bfc <stGetCounter>
 8006040:	1b45      	subs	r5, r0, r5
    if (likely(nowdelta < delay)) {
 8006042:	42ac      	cmp	r4, r5
 8006044:	d912      	bls.n	800606c <chVTDoTickI+0xe0>
  if (currdelta > vtlp->lastdelta) {
 8006046:	6a33      	ldr	r3, [r6, #32]
 8006048:	429f      	cmp	r7, r3
 800604a:	d809      	bhi.n	8006060 <chVTDoTickI+0xd4>

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800604c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8006050:	2002      	movs	r0, #2
 8006052:	f7ff fe1d 	bl	8005c90 <chRFCUCollectFaultsI>
  return (bool)(dlhp == dlhp->next);
 8006056:	6933      	ldr	r3, [r6, #16]
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8006058:	4543      	cmp	r3, r8
 800605a:	d013      	beq.n	8006084 <chVTDoTickI+0xf8>
 800605c:	465a      	mov	r2, fp
 800605e:	e7c9      	b.n	8005ff4 <chVTDoTickI+0x68>
    vtlp->lastdelta = currdelta;
 8006060:	6237      	str	r7, [r6, #32]
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8006062:	2001      	movs	r0, #1
}
 8006064:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8006068:	f7ff be12 	b.w	8005c90 <chRFCUCollectFaultsI>
    currdelta += (sysinterval_t)1;
 800606c:	3701      	adds	r7, #1
    now = newnow;
 800606e:	4605      	mov	r5, r0
    currdelta += (sysinterval_t)1;
 8006070:	463c      	mov	r4, r7
  while (true) {
 8006072:	e7e0      	b.n	8006036 <chVTDoTickI+0xaa>
        delay = vtp->reload - nowdelta;
 8006074:	442a      	add	r2, r5
 8006076:	1a12      	subs	r2, r2, r0
        vt_insert_first(vtlp, vtp, now, delay);
 8006078:	4651      	mov	r1, sl
 800607a:	4620      	mov	r0, r4
}
 800607c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vt_insert_first(vtlp, vtp, now, delay);
 8006080:	f7ff beac 	b.w	8005ddc <vt_insert_first.constprop.0>
        delay = (sysinterval_t)0;
 8006084:	2200      	movs	r2, #0
 8006086:	e7f7      	b.n	8006078 <chVTDoTickI+0xec>
 8006088:	24000c20 	.word	0x24000c20

0800608c <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 800608c:	b510      	push	{r4, lr}
 800608e:	2330      	movs	r3, #48	; 0x30
 8006090:	460c      	mov	r4, r1
 8006092:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
 8006096:	7f0b      	ldrb	r3, [r1, #28]
 8006098:	2b0c      	cmp	r3, #12
 800609a:	d810      	bhi.n	80060be <__sch_wakeup+0x32>
 800609c:	e8df f003 	tbb	[pc, r3]
 80060a0:	260f0f2a 	.word	0x260f0f2a
 80060a4:	0b0f070b 	.word	0x0b0f070b
 80060a8:	0f0f0f0f 	.word	0x0f0f0f0f
 80060ac:	0b          	.byte	0x0b
 80060ad:	00          	.byte	0x00
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80060ae:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 80060b0:	6893      	ldr	r3, [r2, #8]
 80060b2:	3301      	adds	r3, #1
 80060b4:	6093      	str	r3, [r2, #8]
  p->prev->next = p->next;
 80060b6:	e9d4 3200 	ldrd	r3, r2, [r4]
 80060ba:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80060bc:	605a      	str	r2, [r3, #4]
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 80060be:	f04f 31ff 	mov.w	r1, #4294967295
  __trace_ready(tp, tp->u.rdymsg);
 80060c2:	4620      	mov	r0, r4
  tp->u.rdymsg = MSG_TIMEOUT;
 80060c4:	6361      	str	r1, [r4, #52]	; 0x34
  __trace_ready(tp, tp->u.rdymsg);
 80060c6:	f7ff fe1b 	bl	8005d00 <__trace_ready>
  tp->state = CH_STATE_READY;
 80060ca:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80060cc:	6923      	ldr	r3, [r4, #16]
  } while (unlikely(pqp->prio >= p->prio));
 80060ce:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 80060d0:	7722      	strb	r2, [r4, #28]
    ch_priority_queue_t *next = pqp->next;
 80060d2:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80060d4:	689a      	ldr	r2, [r3, #8]
 80060d6:	428a      	cmp	r2, r1
 80060d8:	d2fb      	bcs.n	80060d2 <__sch_wakeup+0x46>
  p->prev       = pqp->prev;
 80060da:	685a      	ldr	r2, [r3, #4]
 80060dc:	2100      	movs	r1, #0
  p->next       = pqp;
 80060de:	6023      	str	r3, [r4, #0]
  p->prev       = pqp->prev;
 80060e0:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 80060e2:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 80060e4:	605c      	str	r4, [r3, #4]
 80060e6:	f381 8811 	msr	BASEPRI, r1
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
 80060ea:	bd10      	pop	{r4, pc}
    *tp->u.wttrp = NULL;
 80060ec:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80060ee:	2200      	movs	r2, #0
 80060f0:	601a      	str	r2, [r3, #0]
    break;
 80060f2:	e7e4      	b.n	80060be <__sch_wakeup+0x32>
 80060f4:	2300      	movs	r3, #0
 80060f6:	f383 8811 	msr	BASEPRI, r3
}
 80060fa:	bd10      	pop	{r4, pc}

080060fc <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80060fc:	b510      	push	{r4, lr}
 80060fe:	4604      	mov	r4, r0
  __trace_ready(tp, tp->u.rdymsg);
 8006100:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8006102:	f7ff fdfd 	bl	8005d00 <__trace_ready>
  tp->state = CH_STATE_READY;
 8006106:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8006108:	6923      	ldr	r3, [r4, #16]
  } while (unlikely(pqp->prio >= p->prio));
 800610a:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 800610c:	7722      	strb	r2, [r4, #28]
    ch_priority_queue_t *next = pqp->next;
 800610e:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8006110:	689a      	ldr	r2, [r3, #8]
 8006112:	428a      	cmp	r2, r1
 8006114:	d2fb      	bcs.n	800610e <chSchReadyI+0x12>
  p->prev       = pqp->prev;
 8006116:	685a      	ldr	r2, [r3, #4]
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
 8006118:	4620      	mov	r0, r4
  p->next       = pqp;
 800611a:	6023      	str	r3, [r4, #0]
  p->prev       = pqp->prev;
 800611c:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 800611e:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8006120:	605c      	str	r4, [r3, #4]
 8006122:	bd10      	pop	{r4, pc}

08006124 <chSchGoSleepS>:
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 8006124:	4b0c      	ldr	r3, [pc, #48]	; (8006158 <chSchGoSleepS+0x34>)
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8006126:	f04f 0c01 	mov.w	ip, #1
void chSchGoSleepS(tstate_t newstate) {
 800612a:	b510      	push	{r4, lr}
  thread_t *otp = __instance_get_currthread(oip);
 800612c:	68d9      	ldr	r1, [r3, #12]
void chSchGoSleepS(tstate_t newstate) {
 800612e:	b082      	sub	sp, #8
  ch_priority_queue_t *p = pqp->next;
 8006130:	681c      	ldr	r4, [r3, #0]
  otp->state = newstate;
 8006132:	7708      	strb	r0, [r1, #28]
  pqp->next       = p->next;
 8006134:	6822      	ldr	r2, [r4, #0]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8006136:	4620      	mov	r0, r4
 8006138:	9101      	str	r1, [sp, #4]
  pqp->next->prev = pqp;
 800613a:	6053      	str	r3, [r2, #4]
  pqp->next       = p->next;
 800613c:	601a      	str	r2, [r3, #0]
  ntp->state = CH_STATE_CURRENT;
 800613e:	f884 c01c 	strb.w	ip, [r4, #28]
  __instance_set_currthread(oip, ntp);
 8006142:	60dc      	str	r4, [r3, #12]
  chSysSwitch(ntp, otp);
 8006144:	f7ff fdf2 	bl	8005d2c <__trace_switch>
 8006148:	9901      	ldr	r1, [sp, #4]
 800614a:	4620      	mov	r0, r4
}
 800614c:	b002      	add	sp, #8
 800614e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chSysSwitch(ntp, otp);
 8006152:	f7fa b967 	b.w	8000424 <__port_switch>
 8006156:	bf00      	nop
 8006158:	24000c20 	.word	0x24000c20

0800615c <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 800615c:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp = __instance_get_currthread(currcore);

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 800615e:	1c4b      	adds	r3, r1, #1
  thread_t *tp = __instance_get_currthread(currcore);
 8006160:	4c1a      	ldr	r4, [pc, #104]	; (80061cc <chSchGoSleepTimeoutS+0x70>)
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8006162:	b089      	sub	sp, #36	; 0x24
 8006164:	4605      	mov	r5, r0
  thread_t *tp = __instance_get_currthread(currcore);
 8006166:	68e6      	ldr	r6, [r4, #12]
  if (TIME_INFINITE != timeout) {
 8006168:	d01d      	beq.n	80061a6 <chSchGoSleepTimeoutS+0x4a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 800616a:	4633      	mov	r3, r6
 800616c:	4a18      	ldr	r2, [pc, #96]	; (80061d0 <chSchGoSleepTimeoutS+0x74>)
 800616e:	a802      	add	r0, sp, #8
 8006170:	f7ff feba 	bl	8005ee8 <chVTDoSetI>
  thread_t *otp = __instance_get_currthread(oip);
 8006174:	68e1      	ldr	r1, [r4, #12]
  ntp->state = CH_STATE_CURRENT;
 8006176:	2201      	movs	r2, #1
  otp->state = newstate;
 8006178:	770d      	strb	r5, [r1, #28]
  ch_priority_queue_t *p = pqp->next;
 800617a:	6825      	ldr	r5, [r4, #0]
  chSysSwitch(ntp, otp);
 800617c:	9101      	str	r1, [sp, #4]
  pqp->next       = p->next;
 800617e:	682b      	ldr	r3, [r5, #0]
 8006180:	4628      	mov	r0, r5
  pqp->next->prev = pqp;
 8006182:	605c      	str	r4, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 8006184:	772a      	strb	r2, [r5, #28]
  pqp->next       = p->next;
 8006186:	6023      	str	r3, [r4, #0]
  __instance_set_currthread(oip, ntp);
 8006188:	60e5      	str	r5, [r4, #12]
  chSysSwitch(ntp, otp);
 800618a:	f7ff fdcf 	bl	8005d2c <__trace_switch>
 800618e:	9901      	ldr	r1, [sp, #4]
 8006190:	4628      	mov	r0, r5
 8006192:	f7fa f947 	bl	8000424 <__port_switch>
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 8006196:	9b02      	ldr	r3, [sp, #8]
 8006198:	b113      	cbz	r3, 80061a0 <chSchGoSleepTimeoutS+0x44>
      chVTDoResetI(&vt);
 800619a:	a802      	add	r0, sp, #8
 800619c:	f7ff feaa 	bl	8005ef4 <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
 80061a0:	6b70      	ldr	r0, [r6, #52]	; 0x34
 80061a2:	b009      	add	sp, #36	; 0x24
 80061a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ch_priority_queue_t *p = pqp->next;
 80061a6:	6827      	ldr	r7, [r4, #0]
  ntp->state = CH_STATE_CURRENT;
 80061a8:	2201      	movs	r2, #1
  otp->state = newstate;
 80061aa:	7730      	strb	r0, [r6, #28]
  chSysSwitch(ntp, otp);
 80061ac:	4631      	mov	r1, r6
  pqp->next       = p->next;
 80061ae:	683b      	ldr	r3, [r7, #0]
 80061b0:	4638      	mov	r0, r7
  pqp->next->prev = pqp;
 80061b2:	605c      	str	r4, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 80061b4:	773a      	strb	r2, [r7, #28]
  pqp->next       = p->next;
 80061b6:	6023      	str	r3, [r4, #0]
  __instance_set_currthread(oip, ntp);
 80061b8:	60e7      	str	r7, [r4, #12]
  chSysSwitch(ntp, otp);
 80061ba:	f7ff fdb7 	bl	8005d2c <__trace_switch>
 80061be:	4638      	mov	r0, r7
 80061c0:	4631      	mov	r1, r6
 80061c2:	f7fa f92f 	bl	8000424 <__port_switch>
}
 80061c6:	6b70      	ldr	r0, [r6, #52]	; 0x34
 80061c8:	b009      	add	sp, #36	; 0x24
 80061ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80061cc:	24000c20 	.word	0x24000c20
 80061d0:	0800608d 	.word	0x0800608d

080061d4 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80061d4:	b570      	push	{r4, r5, r6, lr}
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 80061d6:	4e1b      	ldr	r6, [pc, #108]	; (8006244 <chSchWakeupS+0x70>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80061d8:	4605      	mov	r5, r0
     one then it is just inserted in the ready list else it is made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 80061da:	6882      	ldr	r2, [r0, #8]
  thread_t *otp = __instance_get_currthread(oip);
 80061dc:	68f4      	ldr	r4, [r6, #12]
  ntp->u.rdymsg = msg;
 80061de:	6341      	str	r1, [r0, #52]	; 0x34
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 80061e0:	68a3      	ldr	r3, [r4, #8]
 80061e2:	429a      	cmp	r2, r3
 80061e4:	d91d      	bls.n	8006222 <chSchWakeupS+0x4e>
  __trace_ready(tp, tp->u.rdymsg);
 80061e6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80061e8:	4620      	mov	r0, r4
 80061ea:	f7ff fd89 	bl	8005d00 <__trace_ready>
  tp->state = CH_STATE_READY;
 80061ee:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 80061f0:	6923      	ldr	r3, [r4, #16]
  } while (unlikely(pqp->prio > p->prio));
 80061f2:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 80061f4:	7722      	strb	r2, [r4, #28]
    ch_priority_queue_t *next = pqp->next;
 80061f6:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 80061f8:	689a      	ldr	r2, [r3, #8]
 80061fa:	428a      	cmp	r2, r1
 80061fc:	d8fb      	bhi.n	80061f6 <chSchWakeupS+0x22>
  p->prev       = pqp->prev;
 80061fe:	685a      	ldr	r2, [r3, #4]
    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8006200:	4621      	mov	r1, r4
 8006202:	4628      	mov	r0, r5
 8006204:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 8006208:	6014      	str	r4, [r2, #0]
    ntp->state = CH_STATE_CURRENT;
 800620a:	2201      	movs	r2, #1
  pqp->prev     = p;
 800620c:	605c      	str	r4, [r3, #4]
 800620e:	772a      	strb	r2, [r5, #28]
    __instance_set_currthread(oip, ntp);
 8006210:	60f5      	str	r5, [r6, #12]
    chSysSwitch(ntp, otp);
 8006212:	f7ff fd8b 	bl	8005d2c <__trace_switch>
 8006216:	4621      	mov	r1, r4
 8006218:	4628      	mov	r0, r5
  }
}
 800621a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 800621e:	f7fa b901 	b.w	8000424 <__port_switch>
  __trace_ready(tp, tp->u.rdymsg);
 8006222:	f7ff fd6d 	bl	8005d00 <__trace_ready>
  tp->state = CH_STATE_READY;
 8006226:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8006228:	692b      	ldr	r3, [r5, #16]
  } while (unlikely(pqp->prio >= p->prio));
 800622a:	68a9      	ldr	r1, [r5, #8]
  tp->state = CH_STATE_READY;
 800622c:	772a      	strb	r2, [r5, #28]
    ch_priority_queue_t *next = pqp->next;
 800622e:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8006230:	689a      	ldr	r2, [r3, #8]
 8006232:	428a      	cmp	r2, r1
 8006234:	d2fb      	bcs.n	800622e <chSchWakeupS+0x5a>
  p->prev       = pqp->prev;
 8006236:	685a      	ldr	r2, [r3, #4]
 8006238:	e9c5 3200 	strd	r3, r2, [r5]
  p->prev->next = p;
 800623c:	6015      	str	r5, [r2, #0]
  pqp->prev     = p;
 800623e:	605d      	str	r5, [r3, #4]
}
 8006240:	bd70      	pop	{r4, r5, r6, pc}
 8006242:	bf00      	nop
 8006244:	24000c20 	.word	0x24000c20

08006248 <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8006248:	4b04      	ldr	r3, [pc, #16]	; (800625c <chSchIsPreemptionRequired+0x14>)
 800624a:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 800624c:	68db      	ldr	r3, [r3, #12]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800624e:	6890      	ldr	r0, [r2, #8]
 8006250:	689b      	ldr	r3, [r3, #8]
#endif
}
 8006252:	4298      	cmp	r0, r3
 8006254:	bf94      	ite	ls
 8006256:	2000      	movls	r0, #0
 8006258:	2001      	movhi	r0, #1
 800625a:	4770      	bx	lr
 800625c:	24000c20 	.word	0x24000c20

08006260 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8006260:	b538      	push	{r3, r4, r5, lr}
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 8006262:	4b12      	ldr	r3, [pc, #72]	; (80062ac <chSchDoPreemption+0x4c>)
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8006264:	2101      	movs	r1, #1
  ch_priority_queue_t *p = pqp->next;
 8006266:	681d      	ldr	r5, [r3, #0]
  thread_t *otp = __instance_get_currthread(oip);
 8006268:	68dc      	ldr	r4, [r3, #12]
  pqp->next       = p->next;
 800626a:	682a      	ldr	r2, [r5, #0]
  __trace_ready(tp, tp->u.rdymsg);
 800626c:	4620      	mov	r0, r4
  pqp->next->prev = pqp;
 800626e:	6053      	str	r3, [r2, #4]
  pqp->next       = p->next;
 8006270:	601a      	str	r2, [r3, #0]
  ntp->state = CH_STATE_CURRENT;
 8006272:	7729      	strb	r1, [r5, #28]
  __trace_ready(tp, tp->u.rdymsg);
 8006274:	6b61      	ldr	r1, [r4, #52]	; 0x34
  __instance_set_currthread(oip, ntp);
 8006276:	60dd      	str	r5, [r3, #12]
  __trace_ready(tp, tp->u.rdymsg);
 8006278:	f7ff fd42 	bl	8005d00 <__trace_ready>
  tp->state = CH_STATE_READY;
 800627c:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 800627e:	6923      	ldr	r3, [r4, #16]
  } while (unlikely(pqp->prio > p->prio));
 8006280:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8006282:	7722      	strb	r2, [r4, #28]
    ch_priority_queue_t *next = pqp->next;
 8006284:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 8006286:	689a      	ldr	r2, [r3, #8]
 8006288:	428a      	cmp	r2, r1
 800628a:	d8fb      	bhi.n	8006284 <chSchDoPreemption+0x24>
  p->prev       = pqp->prev;
 800628c:	685a      	ldr	r2, [r3, #4]
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800628e:	4621      	mov	r1, r4
  p->next       = pqp;
 8006290:	6023      	str	r3, [r4, #0]
 8006292:	4628      	mov	r0, r5
  p->prev       = pqp->prev;
 8006294:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 8006296:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8006298:	605c      	str	r4, [r3, #4]
 800629a:	f7ff fd47 	bl	8005d2c <__trace_switch>
 800629e:	4621      	mov	r1, r4
 80062a0:	4628      	mov	r0, r5
}
 80062a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 80062a6:	f7fa b8bd 	b.w	8000424 <__port_switch>
 80062aa:	bf00      	nop
 80062ac:	24000c20 	.word	0x24000c20

080062b0 <chSchRescheduleS>:
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 80062b0:	4b04      	ldr	r3, [pc, #16]	; (80062c4 <chSchRescheduleS+0x14>)
 80062b2:	681a      	ldr	r2, [r3, #0]
 80062b4:	68db      	ldr	r3, [r3, #12]
 80062b6:	6892      	ldr	r2, [r2, #8]
 80062b8:	689b      	ldr	r3, [r3, #8]
 80062ba:	429a      	cmp	r2, r3
 80062bc:	d901      	bls.n	80062c2 <chSchRescheduleS+0x12>
    __sch_reschedule_ahead();
 80062be:	f7ff bfcf 	b.w	8006260 <chSchDoPreemption>
}
 80062c2:	4770      	bx	lr
 80062c4:	24000c20 	.word	0x24000c20

080062c8 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
void chSchDoYieldS(void) {
 80062c8:	b538      	push	{r3, r4, r5, lr}
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);
 80062ca:	4b14      	ldr	r3, [pc, #80]	; (800631c <chSchDoYieldS+0x54>)
 80062cc:	68dc      	ldr	r4, [r3, #12]

  chDbgCheckClassS();

  /* If this function has been called then it is likely there are threads
     at same priority level.*/
  if (likely(firstprio(&oip->rlist.pqueue) >= tp->hdr.pqueue.prio)) {
 80062ce:	681d      	ldr	r5, [r3, #0]
 80062d0:	68a2      	ldr	r2, [r4, #8]
 80062d2:	68a9      	ldr	r1, [r5, #8]
 80062d4:	4291      	cmp	r1, r2
 80062d6:	d320      	bcc.n	800631a <chSchDoYieldS+0x52>
  pqp->next       = p->next;
 80062d8:	682a      	ldr	r2, [r5, #0]
  ntp->state = CH_STATE_CURRENT;
 80062da:	2101      	movs	r1, #1
  __trace_ready(tp, tp->u.rdymsg);
 80062dc:	4620      	mov	r0, r4
  pqp->next->prev = pqp;
 80062de:	6053      	str	r3, [r2, #4]
  pqp->next       = p->next;
 80062e0:	601a      	str	r2, [r3, #0]
  ntp->state = CH_STATE_CURRENT;
 80062e2:	7729      	strb	r1, [r5, #28]
  __trace_ready(tp, tp->u.rdymsg);
 80062e4:	6b61      	ldr	r1, [r4, #52]	; 0x34
  __instance_set_currthread(oip, ntp);
 80062e6:	60dd      	str	r5, [r3, #12]
  __trace_ready(tp, tp->u.rdymsg);
 80062e8:	f7ff fd0a 	bl	8005d00 <__trace_ready>
  tp->state = CH_STATE_READY;
 80062ec:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80062ee:	6923      	ldr	r3, [r4, #16]
  } while (unlikely(pqp->prio >= p->prio));
 80062f0:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 80062f2:	7722      	strb	r2, [r4, #28]
    ch_priority_queue_t *next = pqp->next;
 80062f4:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80062f6:	689a      	ldr	r2, [r3, #8]
 80062f8:	428a      	cmp	r2, r1
 80062fa:	d2fb      	bcs.n	80062f4 <chSchDoYieldS+0x2c>
  p->prev       = pqp->prev;
 80062fc:	685a      	ldr	r2, [r3, #4]
  chSysSwitch(ntp, otp);
 80062fe:	4621      	mov	r1, r4
  p->next       = pqp;
 8006300:	6023      	str	r3, [r4, #0]
 8006302:	4628      	mov	r0, r5
  p->prev       = pqp->prev;
 8006304:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 8006306:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8006308:	605c      	str	r4, [r3, #4]
 800630a:	f7ff fd0f 	bl	8005d2c <__trace_switch>
 800630e:	4621      	mov	r1, r4
 8006310:	4628      	mov	r0, r5
    __sch_reschedule_behind();
  }
}
 8006312:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 8006316:	f7fa b885 	b.w	8000424 <__port_switch>
}
 800631a:	bd38      	pop	{r3, r4, r5, pc}
 800631c:	24000c20 	.word	0x24000c20

08006320 <__idle_thread>:
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8006320:	e7fe      	b.n	8006320 <__idle_thread>
 8006322:	bf00      	nop

08006324 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to an @p os_instance_config_t object
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8006324:	b5f0      	push	{r4, r5, r6, r7, lr}
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 8006326:	4b2a      	ldr	r3, [pc, #168]	; (80063d0 <chInstanceObjectInit+0xac>)

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8006328:	2500      	movs	r5, #0
                          const os_instance_config_t *oicp) {
 800632a:	4604      	mov	r4, r0
 800632c:	b089      	sub	sp, #36	; 0x24
  oip->core_id = core_id;
 800632e:	6385      	str	r5, [r0, #56]	; 0x38
                          const os_instance_config_t *oicp) {
 8006330:	460e      	mov	r6, r1

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 8006332:	6401      	str	r1, [r0, #64]	; 0x40
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
 8006334:	f100 0730 	add.w	r7, r0, #48	; 0x30
  ch_system.instances[core_id] = oip;
 8006338:	6058      	str	r0, [r3, #4]

  /* Port initialization for the current instance.*/
  port_init(oip);
 800633a:	f000 fc65 	bl	8006c08 <port_init>
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 800633e:	f104 0310 	add.w	r3, r4, #16
  pqp->prio = (tprio_t)0;
 8006342:	60a5      	str	r5, [r4, #8]
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 8006344:	63e5      	str	r5, [r4, #60]	; 0x3c

  ch_dlist_init(&vtlp->dlist);
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 8006346:	61e5      	str	r5, [r4, #28]
  dlhp->prev  = dlhp;
 8006348:	e9c4 3304 	strd	r3, r3, [r4, #16]
  dlhp->delta = (sysinterval_t)-1;
 800634c:	f04f 33ff 	mov.w	r3, #4294967295
 8006350:	61a3      	str	r3, [r4, #24]
  vtlp->lastdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8006352:	2302      	movs	r3, #2
  qp->prev = qp;
 8006354:	e9c4 770c 	strd	r7, r7, [r4, #48]	; 0x30
 8006358:	6223      	str	r3, [r4, #32]
  pqp->prev = pqp;
 800635a:	e9c4 4400 	strd	r4, r4, [r4]
 800635e:	f7fa fc4d 	bl	8000bfc <stGetCounter>
 8006362:	4601      	mov	r1, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8006364:	462b      	mov	r3, r5
  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);

#if CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED
  /* Trace buffer initialization.*/
  __trace_object_init(&oip->trace_buffer);
 8006366:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
 800636a:	460a      	mov	r2, r1
 800636c:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
 8006370:	f8c4 50e4 	str.w	r5, [r4, #228]	; 0xe4
 8006374:	f7ff fcb2 	bl	8005cdc <__trace_object_init>

  /* Now this instruction flow becomes the main thread or the idle thread
     depending on the CH_CFG_NO_IDLE_THREAD setting.*/
  {
#if CH_CFG_NO_IDLE_THREAD == FALSE
    const THD_DECL(main_thd_desc,
 8006378:	6873      	ldr	r3, [r6, #4]
                   "main", oicp->cstack_base, oicp->cstack_end,
                   NORMALPRIO, NULL, NULL, oip
    );

    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
 800637a:	a901      	add	r1, sp, #4
 800637c:	f104 0094 	add.w	r0, r4, #148	; 0x94
    const THD_DECL(main_thd_desc,
 8006380:	9302      	str	r3, [sp, #8]
 8006382:	68b3      	ldr	r3, [r6, #8]
 8006384:	9407      	str	r4, [sp, #28]
 8006386:	9303      	str	r3, [sp, #12]
 8006388:	4b12      	ldr	r3, [pc, #72]	; (80063d4 <chInstanceObjectInit+0xb0>)
 800638a:	9301      	str	r3, [sp, #4]
 800638c:	2380      	movs	r3, #128	; 0x80
 800638e:	e9cd 5505 	strd	r5, r5, [sp, #20]
 8006392:	9304      	str	r3, [sp, #16]
    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
 8006394:	f000 f824 	bl	80063e0 <chThdObjectInit>
  p->prev       = qp->prev;
 8006398:	6b62      	ldr	r2, [r4, #52]	; 0x34
    oip->rlist.current = chThdObjectInit(&oip->idlethread, &idle_thd_desc);
#endif
  }

#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(oip, oip->rlist.current);
 800639a:	f100 0324 	add.w	r3, r0, #36	; 0x24
    oip->rlist.current = chThdObjectInit(&oip->mainthread, &main_thd_desc);
 800639e:	60e0      	str	r0, [r4, #12]
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdSpawnRunningI(&oip->idlethread, &idle_thd_desc);
 80063a0:	a901      	add	r1, sp, #4
  p->next       = qp;
 80063a2:	6247      	str	r7, [r0, #36]	; 0x24
  p->prev       = qp->prev;
 80063a4:	6282      	str	r2, [r0, #40]	; 0x28
  p->prev->next = p;
 80063a6:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 80063a8:	6363      	str	r3, [r4, #52]	; 0x34
  oip->rlist.current->state = CH_STATE_CURRENT;
 80063aa:	2301      	movs	r3, #1
 80063ac:	7703      	strb	r3, [r0, #28]
    (void) chThdSpawnRunningI(&oip->idlethread, &idle_thd_desc);
 80063ae:	f104 0044 	add.w	r0, r4, #68	; 0x44
    const THD_DECL(idle_thd_desc,
 80063b2:	9304      	str	r3, [sp, #16]
 80063b4:	4b08      	ldr	r3, [pc, #32]	; (80063d8 <chInstanceObjectInit+0xb4>)
 80063b6:	9407      	str	r4, [sp, #28]
 80063b8:	9305      	str	r3, [sp, #20]
 80063ba:	4c08      	ldr	r4, [pc, #32]	; (80063dc <chInstanceObjectInit+0xb8>)
 80063bc:	9506      	str	r5, [sp, #24]
 80063be:	e9d6 2303 	ldrd	r2, r3, [r6, #12]
 80063c2:	e9cd 4201 	strd	r4, r2, [sp, #4]
 80063c6:	9303      	str	r3, [sp, #12]
    (void) chThdSpawnRunningI(&oip->idlethread, &idle_thd_desc);
 80063c8:	f000 f866 	bl	8006498 <chThdSpawnRunningI>
  }
#endif /* CH_CFG_NO_IDLE_THREAD == FALSE */
}
 80063cc:	b009      	add	sp, #36	; 0x24
 80063ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80063d0:	240016e0 	.word	0x240016e0
 80063d4:	08014ea8 	.word	0x08014ea8
 80063d8:	08006321 	.word	0x08006321
 80063dc:	08014eb0 	.word	0x08014eb0

080063e0 <chThdObjectInit>:
  tp->wabase = (void *)tdp->wbase;
  tp->waend  = (void *)tdp->wend;

  /* Thread-related fields.*/
  tp->hdr.pqueue.prio   = tdp->prio;
  tp->state             = CH_STATE_WTSTART;
 80063e0:	2302      	movs	r3, #2
                          const thread_descriptor_t *tdp) {
 80063e2:	b410      	push	{r4}
  tp->waend  = (void *)tdp->wend;
 80063e4:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 80063e8:	e9c0 4205 	strd	r4, r2, [r0, #20]
  tp->hdr.pqueue.prio   = tdp->prio;
 80063ec:	68cc      	ldr	r4, [r1, #12]
  tp->state             = CH_STATE_WTSTART;
 80063ee:	8383      	strh	r3, [r0, #28]
  tp->flags             = (tmode_t)0;
  if (tdp->owner != NULL) {
 80063f0:	698a      	ldr	r2, [r1, #24]
  tp->hdr.pqueue.prio   = tdp->prio;
 80063f2:	6084      	str	r4, [r0, #8]
  if (tdp->owner != NULL) {
 80063f4:	b1a2      	cbz	r2, 8006420 <chThdObjectInit+0x40>
  }
  else {
    tp->owner           = currcore;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->dispose           = NULL;
 80063f6:	2300      	movs	r3, #0
  ch_list_init(&tp->waiting);
#endif

  /* Mutex-related fields.*/
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = tdp->prio;
 80063f8:	64c4      	str	r4, [r0, #76]	; 0x4c
  tp->time              = (systime_t)0;
#endif

  /* Registry-related fields.*/
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 80063fa:	2401      	movs	r4, #1
 80063fc:	6102      	str	r2, [r0, #16]
  tp->name              = tdp->name;
#endif

  /* Messages-related fields.*/
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 80063fe:	f100 023c 	add.w	r2, r0, #60	; 0x3c
  tp->refs              = (trefs_t)1;
 8006402:	7784      	strb	r4, [r0, #30]
  tp->name              = tdp->name;
 8006404:	6809      	ldr	r1, [r1, #0]

  /* Custom thread initialization code.*/
  CH_CFG_THREAD_INIT_HOOK(tp);

  return tp;
}
 8006406:	f85d 4b04 	ldr.w	r4, [sp], #4
  qp->next = qp;
 800640a:	63c2      	str	r2, [r0, #60]	; 0x3c
  tp->name              = tdp->name;
 800640c:	6201      	str	r1, [r0, #32]
  qp->prev = qp;
 800640e:	6402      	str	r2, [r0, #64]	; 0x40
  tp->object            = NULL;
 8006410:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
  tp->epending          = (eventmask_t)0;
 8006414:	e9c0 3311 	strd	r3, r3, [r0, #68]	; 0x44
  ch_list_init(&tp->waiting);
 8006418:	f100 0338 	add.w	r3, r0, #56	; 0x38
  lp->next = lp;
 800641c:	6383      	str	r3, [r0, #56]	; 0x38
}
 800641e:	4770      	bx	lr
    tp->owner           = currcore;
 8006420:	4a00      	ldr	r2, [pc, #0]	; (8006424 <chThdObjectInit+0x44>)
 8006422:	e7e8      	b.n	80063f6 <chThdObjectInit+0x16>
 8006424:	24000c20 	.word	0x24000c20

08006428 <chThdSpawnSuspendedI>:
  tp->state             = CH_STATE_WTSTART;
 8006428:	2302      	movs	r3, #2
 * @return              Reference to the @p thread_t object.
 *
 * @api
 */
thread_t *chThdSpawnSuspendedI(thread_t *tp,
                               const thread_descriptor_t *tdp) {
 800642a:	b4f0      	push	{r4, r5, r6, r7}
  tp->waend  = (void *)tdp->wend;
 800642c:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 8006430:	e9c0 4205 	strd	r4, r2, [r0, #20]
  tp->hdr.pqueue.prio   = tdp->prio;
 8006434:	68cc      	ldr	r4, [r1, #12]
  tp->state             = CH_STATE_WTSTART;
 8006436:	8383      	strh	r3, [r0, #28]
  if (tdp->owner != NULL) {
 8006438:	698b      	ldr	r3, [r1, #24]
  tp->hdr.pqueue.prio   = tdp->prio;
 800643a:	6084      	str	r4, [r0, #8]
  if (tdp->owner != NULL) {
 800643c:	b333      	cbz	r3, 800648c <chThdSpawnSuspendedI+0x64>
  tp->realprio          = tdp->prio;
 800643e:	64c4      	str	r4, [r0, #76]	; 0x4c
  tp->refs              = (trefs_t)1;
 8006440:	2401      	movs	r4, #1
  ch_list_init(&tp->waiting);
 8006442:	f100 0738 	add.w	r7, r0, #56	; 0x38
 8006446:	6103      	str	r3, [r0, #16]
  tp->refs              = (trefs_t)1;
 8006448:	7784      	strb	r4, [r0, #30]
  tp->name              = tdp->name;
 800644a:	680c      	ldr	r4, [r1, #0]
 800644c:	6204      	str	r4, [r0, #32]
  ch_queue_init(&tp->msgqueue);
 800644e:	f100 043c 	add.w	r4, r0, #60	; 0x3c

  /* Thread object initialization.*/
  tp = chThdObjectInit(tp, tdp);

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 8006452:	e9d1 6504 	ldrd	r6, r5, [r1, #16]
  qp->next = qp;
 8006456:	e9c0 440f 	strd	r4, r4, [r0, #60]	; 0x3c
  tp->dispose           = NULL;
 800645a:	2100      	movs	r1, #0
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 800645c:	f1a2 0464 	sub.w	r4, r2, #100	; 0x64
  tp->object            = NULL;
 8006460:	e9c0 110b 	strd	r1, r1, [r0, #44]	; 0x2c
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 8006464:	60c4      	str	r4, [r0, #12]
  p->prev       = qp->prev;
 8006466:	6b5c      	ldr	r4, [r3, #52]	; 0x34
  lp->next = lp;
 8006468:	6387      	str	r7, [r0, #56]	; 0x38
  tp->epending          = (eventmask_t)0;
 800646a:	e9c0 1111 	strd	r1, r1, [r0, #68]	; 0x44
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 800646e:	e942 6509 	strd	r6, r5, [r2, #-36]	; 0x24
 8006472:	4d07      	ldr	r5, [pc, #28]	; (8006490 <chThdSpawnSuspendedI+0x68>)

  /* Registry-related fields.*/
#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(tp->owner, tp);
 8006474:	f100 0124 	add.w	r1, r0, #36	; 0x24
  PORT_SETUP_CONTEXT(tp, tp->wabase, tp->waend, tdp->funcp, tdp->arg);
 8006478:	f842 5c04 	str.w	r5, [r2, #-4]
  REG_INSERT(tp->owner, tp);
 800647c:	f103 0230 	add.w	r2, r3, #48	; 0x30
  p->next       = qp;
 8006480:	e9c0 2409 	strd	r2, r4, [r0, #36]	; 0x24
  p->prev->next = p;
 8006484:	6021      	str	r1, [r4, #0]
  qp->prev      = p;
 8006486:	6359      	str	r1, [r3, #52]	; 0x34
#endif

  return tp;
}
 8006488:	bcf0      	pop	{r4, r5, r6, r7}
 800648a:	4770      	bx	lr
    tp->owner           = currcore;
 800648c:	4b01      	ldr	r3, [pc, #4]	; (8006494 <chThdSpawnSuspendedI+0x6c>)
 800648e:	e7d6      	b.n	800643e <chThdSpawnSuspendedI+0x16>
 8006490:	0800043d 	.word	0x0800043d
 8006494:	24000c20 	.word	0x24000c20

08006498 <chThdSpawnRunningI>:
 * @param[in] tdp       pointer to a @p thread_descriptor_t object
 * @return              Reference to the @p thread_t object.
 *
 * @iclass
 */
thread_t *chThdSpawnRunningI(thread_t *tp, const thread_descriptor_t *tdp) {
 8006498:	b508      	push	{r3, lr}

  return chSchReadyI(chThdSpawnSuspendedI(tp, tdp));
 800649a:	f7ff ffc5 	bl	8006428 <chThdSpawnSuspendedI>
}
 800649e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return chSchReadyI(chThdSpawnSuspendedI(tp, tdp));
 80064a2:	f7ff be2b 	b.w	80060fc <chSchReadyI>
 80064a6:	bf00      	nop

080064a8 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(stkline_t *wbase, size_t wsize,
                            tprio_t prio, tfunc_t func, void *arg) {
 80064a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  chDbgAssert(chRegFindThreadByWorkingArea(wbase) == NULL,
              "working area in use");
#endif

  /* Working area end address.*/
  wend = (uint8_t *)wbase + wsize;
 80064aa:	1844      	adds	r4, r0, r1
  tp->state             = CH_STATE_WTSTART;
 80064ac:	2102      	movs	r1, #2
                            tprio_t prio, tfunc_t func, void *arg) {
 80064ae:	b083      	sub	sp, #12
  tp->state             = CH_STATE_WTSTART;
 80064b0:	f804 1c44 	strb.w	r1, [r4, #-68]
  ch_list_init(&tp->waiting);
 80064b4:	f1a4 0128 	sub.w	r1, r4, #40	; 0x28
                            tprio_t prio, tfunc_t func, void *arg) {
 80064b8:	9d08      	ldr	r5, [sp, #32]
  tp->wabase = (void *)tdp->wbase;
 80064ba:	f844 0c4c 	str.w	r0, [r4, #-76]
  /* Initializing the thread_t structure using the passed parameters.*/
  THD_DESC_DECL(desc, "noname", wbase, wend, prio, func, arg, currcore, NULL);
  tp = chThdObjectInit(threadref(stktop), &desc);

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wbase, tp, func, arg);
 80064be:	f844 3c84 	str.w	r3, [r4, #-132]
 80064c2:	4820      	ldr	r0, [pc, #128]	; (8006544 <chThdCreateStatic+0x9c>)
    tp->owner           = tdp->owner;
 80064c4:	4b20      	ldr	r3, [pc, #128]	; (8006548 <chThdCreateStatic+0xa0>)
  lp->next = lp;
 80064c6:	f844 1c28 	str.w	r1, [r4, #-40]
  tp->refs              = (trefs_t)1;
 80064ca:	2101      	movs	r1, #1
  PORT_SETUP_CONTEXT(tp, wbase, tp, func, arg);
 80064cc:	f844 5c80 	str.w	r5, [r4, #-128]
  tp->flags             = (tmode_t)0;
 80064d0:	2500      	movs	r5, #0
  PORT_SETUP_CONTEXT(tp, wbase, tp, func, arg);
 80064d2:	f844 0c64 	str.w	r0, [r4, #-100]
 80064d6:	f1a4 00c4 	sub.w	r0, r4, #196	; 0xc4
    tp->owner           = tdp->owner;
 80064da:	f844 3c50 	str.w	r3, [r4, #-80]
  ch_queue_init(&tp->msgqueue);
 80064de:	f1a4 0324 	sub.w	r3, r4, #36	; 0x24
  tp->refs              = (trefs_t)1;
 80064e2:	f804 1c42 	strb.w	r1, [r4, #-66]
  tp->name              = tdp->name;
 80064e6:	4919      	ldr	r1, [pc, #100]	; (800654c <chThdCreateStatic+0xa4>)
  PORT_SETUP_CONTEXT(tp, wbase, tp, func, arg);
 80064e8:	f844 0c54 	str.w	r0, [r4, #-84]
  stktop  = wend - MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN);
 80064ec:	f1a4 0060 	sub.w	r0, r4, #96	; 0x60
  tp->waend  = (void *)tdp->wend;
 80064f0:	f844 4c48 	str.w	r4, [r4, #-72]
  tp->hdr.pqueue.prio   = tdp->prio;
 80064f4:	f844 2c58 	str.w	r2, [r4, #-88]
  tp->flags             = (tmode_t)0;
 80064f8:	f804 5c43 	strb.w	r5, [r4, #-67]
  tp->epending          = (eventmask_t)0;
 80064fc:	f844 5c1c 	str.w	r5, [r4, #-28]
  tp->name              = tdp->name;
 8006500:	f844 1c40 	str.w	r1, [r4, #-64]
  qp->prev = qp;
 8006504:	e944 3309 	strd	r3, r3, [r4, #-36]	; 0x24
  tp->object            = NULL;
 8006508:	e944 550d 	strd	r5, r5, [r4, #-52]	; 0x34
 800650c:	2330      	movs	r3, #48	; 0x30
  tp->mtxlist           = NULL;
 800650e:	e944 5206 	strd	r5, r2, [r4, #-24]
 8006512:	f383 8811 	msr	BASEPRI, r3

  chSysLock();

#if CH_CFG_USE_REGISTRY == TRUE
  REG_INSERT(tp->owner, tp);
 8006516:	f854 3c50 	ldr.w	r3, [r4, #-80]
 800651a:	f1a4 023c 	sub.w	r2, r4, #60	; 0x3c
#endif

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 800651e:	4629      	mov	r1, r5
 8006520:	9001      	str	r0, [sp, #4]
  p->prev       = qp->prev;
 8006522:	6b5e      	ldr	r6, [r3, #52]	; 0x34
  REG_INSERT(tp->owner, tp);
 8006524:	f103 0730 	add.w	r7, r3, #48	; 0x30
 8006528:	f844 6c38 	str.w	r6, [r4, #-56]
  p->next       = qp;
 800652c:	f844 7c3c 	str.w	r7, [r4, #-60]
  p->prev->next = p;
 8006530:	6032      	str	r2, [r6, #0]
  qp->prev      = p;
 8006532:	635a      	str	r2, [r3, #52]	; 0x34
  chSchWakeupS(tp, MSG_OK);
 8006534:	f7ff fe4e 	bl	80061d4 <chSchWakeupS>
 8006538:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 800653c:	9801      	ldr	r0, [sp, #4]
 800653e:	b003      	add	sp, #12
 8006540:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006542:	bf00      	nop
 8006544:	0800043d 	.word	0x0800043d
 8006548:	24000c20 	.word	0x24000c20
 800654c:	08014eb8 	.word	0x08014eb8

08006550 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8006550:	b538      	push	{r3, r4, r5, lr}
 8006552:	2330      	movs	r3, #48	; 0x30
 8006554:	f383 8811 	msr	BASEPRI, r3
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8006558:	4b10      	ldr	r3, [pc, #64]	; (800659c <chThdExit+0x4c>)
 800655a:	68dc      	ldr	r4, [r3, #12]
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 800655c:	f104 0538 	add.w	r5, r4, #56	; 0x38
  return (bool)(lp->next != lp);
 8006560:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  currtp->u.exitcode = msg;
 8006562:	6360      	str	r0, [r4, #52]	; 0x34
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8006564:	429d      	cmp	r5, r3
 8006566:	d106      	bne.n	8006576 <chThdExit+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8006568:	7fa3      	ldrb	r3, [r4, #30]
 800656a:	b17b      	cbz	r3, 800658c <chThdExit+0x3c>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800656c:	200f      	movs	r0, #15
}
 800656e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8006572:	f7ff bdd7 	b.w	8006124 <chSchGoSleepS>
  lp->next = p->next;
 8006576:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8006578:	4618      	mov	r0, r3
 800657a:	63a2      	str	r2, [r4, #56]	; 0x38
 800657c:	f7ff fdbe 	bl	80060fc <chSchReadyI>
  return (bool)(lp->next != lp);
 8006580:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8006582:	42ab      	cmp	r3, r5
 8006584:	d1f7      	bne.n	8006576 <chThdExit+0x26>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8006586:	7fa3      	ldrb	r3, [r4, #30]
 8006588:	2b00      	cmp	r3, #0
 800658a:	d1ef      	bne.n	800656c <chThdExit+0x1c>
    if (currtp->dispose == NULL) {
 800658c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800658e:	2b00      	cmp	r3, #0
 8006590:	d1ec      	bne.n	800656c <chThdExit+0x1c>
  p->prev->next = p->next;
 8006592:	e9d4 3209 	ldrd	r3, r2, [r4, #36]	; 0x24
 8006596:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8006598:	605a      	str	r2, [r3, #4]
  return p;
 800659a:	e7e7      	b.n	800656c <chThdExit+0x1c>
 800659c:	24000c20 	.word	0x24000c20

080065a0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 80065a0:	b538      	push	{r3, r4, r5, lr}
 80065a2:	4b17      	ldr	r3, [pc, #92]	; (8006600 <chThdWait+0x60>)
 80065a4:	2230      	movs	r2, #48	; 0x30
 80065a6:	4604      	mov	r4, r0
 80065a8:	68db      	ldr	r3, [r3, #12]
 80065aa:	f382 8811 	msr	BASEPRI, r2
  chDbgAssert(tp != currtp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (likely(tp->state != CH_STATE_FINAL)) {
 80065ae:	7f02      	ldrb	r2, [r0, #28]
 80065b0:	2a0f      	cmp	r2, #15
 80065b2:	d005      	beq.n	80065c0 <chThdWait+0x20>
  p->next = lp->next;
 80065b4:	6b82      	ldr	r2, [r0, #56]	; 0x38
    ch_list_link(&tp->waiting, &currtp->hdr.list);
    chSchGoSleepS(CH_STATE_WTEXIT);
 80065b6:	2009      	movs	r0, #9
 80065b8:	601a      	str	r2, [r3, #0]
  lp->next = p;
 80065ba:	63a3      	str	r3, [r4, #56]	; 0x38
 80065bc:	f7ff fdb2 	bl	8006124 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 80065c0:	6b65      	ldr	r5, [r4, #52]	; 0x34
 80065c2:	2200      	movs	r2, #0
 80065c4:	f382 8811 	msr	BASEPRI, r2
 80065c8:	2330      	movs	r3, #48	; 0x30
 80065ca:	f383 8811 	msr	BASEPRI, r3
  tp->refs--;
 80065ce:	7fa3      	ldrb	r3, [r4, #30]
 80065d0:	3b01      	subs	r3, #1
 80065d2:	77a3      	strb	r3, [r4, #30]
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80065d4:	69e3      	ldr	r3, [r4, #28]
 80065d6:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 80065da:	2b0f      	cmp	r3, #15
 80065dc:	d003      	beq.n	80065e6 <chThdWait+0x46>
 80065de:	f382 8811 	msr	BASEPRI, r2
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
#endif

  return msg;
}
 80065e2:	4628      	mov	r0, r5
 80065e4:	bd38      	pop	{r3, r4, r5, pc}
  p->prev->next = p->next;
 80065e6:	e9d4 3109 	ldrd	r3, r1, [r4, #36]	; 0x24
 80065ea:	600b      	str	r3, [r1, #0]
  p->next->prev = p->prev;
 80065ec:	6059      	str	r1, [r3, #4]
 80065ee:	f382 8811 	msr	BASEPRI, r2
    if (tp->dispose != NULL) {
 80065f2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80065f4:	2b00      	cmp	r3, #0
 80065f6:	d0f4      	beq.n	80065e2 <chThdWait+0x42>
      tp->dispose(tp);
 80065f8:	4620      	mov	r0, r4
 80065fa:	4798      	blx	r3
}
 80065fc:	4628      	mov	r0, r5
 80065fe:	bd38      	pop	{r3, r4, r5, pc}
 8006600:	24000c20 	.word	0x24000c20

08006604 <chThdSleep>:
 *                        state.
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8006604:	b508      	push	{r3, lr}
 8006606:	4601      	mov	r1, r0
 8006608:	2330      	movs	r3, #48	; 0x30
 800660a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800660e:	2008      	movs	r0, #8
 8006610:	f7ff fda4 	bl	800615c <chSchGoSleepTimeoutS>
 8006614:	2300      	movs	r3, #0
 8006616:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 800661a:	bd08      	pop	{r3, pc}

0800661c <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 800661c:	b508      	push	{r3, lr}
 800661e:	2330      	movs	r3, #48	; 0x30
 8006620:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chSchDoYieldS();
 8006624:	f7ff fe50 	bl	80062c8 <chSchDoYieldS>
 8006628:	2300      	movs	r3, #0
 800662a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 800662e:	bd08      	pop	{r3, pc}

08006630 <chThdSuspendTimeoutS>:
  return __sch_get_currthread();
 8006630:	4a05      	ldr	r2, [pc, #20]	; (8006648 <chThdSuspendTimeoutS+0x18>)
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8006632:	4603      	mov	r3, r0
 8006634:	68d2      	ldr	r2, [r2, #12]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8006636:	b121      	cbz	r1, 8006642 <chThdSuspendTimeoutS+0x12>
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8006638:	6002      	str	r2, [r0, #0]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800663a:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 800663c:	6353      	str	r3, [r2, #52]	; 0x34
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800663e:	f7ff bd8d 	b.w	800615c <chSchGoSleepTimeoutS>
}
 8006642:	f04f 30ff 	mov.w	r0, #4294967295
 8006646:	4770      	bx	lr
 8006648:	24000c20 	.word	0x24000c20

0800664c <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 800664c:	4603      	mov	r3, r0

  if (*trp != NULL) {
 800664e:	6800      	ldr	r0, [r0, #0]
 8006650:	b120      	cbz	r0, 800665c <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8006652:	2200      	movs	r2, #0
 8006654:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8006656:	6341      	str	r1, [r0, #52]	; 0x34
    (void) chSchReadyI(tp);
 8006658:	f7ff bd50 	b.w	80060fc <chSchReadyI>
  }
}
 800665c:	4770      	bx	lr
 800665e:	bf00      	nop

08006660 <chThdQueueObjectInit>:
  qp->prev = qp;
 8006660:	e9c0 0000 	strd	r0, r0, [r0]
void chThdQueueObjectInit(threads_queue_t *tqp) {

  chDbgCheck(tqp);

  ch_queue_init(&tqp->queue);
}
 8006664:	4770      	bx	lr
 8006666:	bf00      	nop

08006668 <chThdEnqueueTimeoutS>:
 8006668:	4a08      	ldr	r2, [pc, #32]	; (800668c <chThdEnqueueTimeoutS+0x24>)
 800666a:	68d2      	ldr	r2, [r2, #12]
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 800666c:	b159      	cbz	r1, 8006686 <chThdEnqueueTimeoutS+0x1e>
 800666e:	4603      	mov	r3, r0
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8006670:	b410      	push	{r4}
  p->prev       = qp->prev;
 8006672:	6844      	ldr	r4, [r0, #4]
  p->next       = qp;
 8006674:	6010      	str	r0, [r2, #0]
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8006676:	2004      	movs	r0, #4
  p->prev       = qp->prev;
 8006678:	6054      	str	r4, [r2, #4]
  p->prev->next = p;
 800667a:	6022      	str	r2, [r4, #0]
}
 800667c:	f85d 4b04 	ldr.w	r4, [sp], #4
  qp->prev      = p;
 8006680:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8006682:	f7ff bd6b 	b.w	800615c <chSchGoSleepTimeoutS>
}
 8006686:	f04f 30ff 	mov.w	r0, #4294967295
 800668a:	4770      	bx	lr
 800668c:	24000c20 	.word	0x24000c20

08006690 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8006690:	4603      	mov	r3, r0
  return (bool)(qp->next != qp);
 8006692:	6800      	ldr	r0, [r0, #0]

  if (ch_queue_notempty(&tqp->queue)) {
 8006694:	4283      	cmp	r3, r0
 8006696:	d005      	beq.n	80066a4 <chThdDequeueNextI+0x14>
  qp->next       = p->next;
 8006698:	6802      	ldr	r2, [r0, #0]
 800669a:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 800669c:	6053      	str	r3, [r2, #4]

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 800669e:	6341      	str	r1, [r0, #52]	; 0x34
  (void) chSchReadyI(tp);
 80066a0:	f7ff bd2c 	b.w	80060fc <chSchReadyI>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80066a4:	4770      	bx	lr
 80066a6:	bf00      	nop

080066a8 <chTMObjectInit>:

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80066a8:	ed9f 7b05 	vldr	d7, [pc, #20]	; 80066c0 <chTMObjectInit+0x18>
  tmp->worst      = (rtcnt_t)0;
 80066ac:	2300      	movs	r3, #0
  tmp->best       = (rtcnt_t)-1;
 80066ae:	f04f 32ff 	mov.w	r2, #4294967295
  tmp->n          = (ucnt_t)0;
 80066b2:	e9c0 3302 	strd	r3, r3, [r0, #8]
  tmp->worst      = (rtcnt_t)0;
 80066b6:	e9c0 2300 	strd	r2, r3, [r0]
  tmp->cumulative = (rttime_t)0;
 80066ba:	ed80 7b04 	vstr	d7, [r0, #16]
}
 80066be:	4770      	bx	lr
	...

080066c8 <chTMStartMeasurementX>:
 80066c8:	4b01      	ldr	r3, [pc, #4]	; (80066d0 <chTMStartMeasurementX+0x8>)
 80066ca:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80066cc:	6083      	str	r3, [r0, #8]
}
 80066ce:	4770      	bx	lr
 80066d0:	e0001000 	.word	0xe0001000

080066d4 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 80066d4:	4a0e      	ldr	r2, [pc, #56]	; (8006710 <chTMStopMeasurementX+0x3c>)
 80066d6:	4b0f      	ldr	r3, [pc, #60]	; (8006714 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
 80066d8:	6881      	ldr	r1, [r0, #8]
 80066da:	685b      	ldr	r3, [r3, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80066dc:	b410      	push	{r4}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 80066de:	6894      	ldr	r4, [r2, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80066e0:	6902      	ldr	r2, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 80066e2:	1b1b      	subs	r3, r3, r4
  tmp->n++;
 80066e4:	68c4      	ldr	r4, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 80066e6:	1a5b      	subs	r3, r3, r1
  tmp->cumulative += (rttime_t)tmp->last;
 80066e8:	6941      	ldr	r1, [r0, #20]
  tmp->n++;
 80066ea:	3401      	adds	r4, #1
  tmp->cumulative += (rttime_t)tmp->last;
 80066ec:	18d2      	adds	r2, r2, r3
 80066ee:	6102      	str	r2, [r0, #16]
 80066f0:	f141 0100 	adc.w	r1, r1, #0
  if (tmp->last > tmp->worst) {
 80066f4:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
 80066f6:	6141      	str	r1, [r0, #20]
  if (tmp->last > tmp->worst) {
 80066f8:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 80066fa:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 80066fc:	bf88      	it	hi
 80066fe:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 8006700:	4293      	cmp	r3, r2
  tmp->n++;
 8006702:	e9c0 3402 	strd	r3, r4, [r0, #8]
    tmp->best = tmp->last;
 8006706:	bf38      	it	cc
 8006708:	6003      	strcc	r3, [r0, #0]
}
 800670a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800670e:	4770      	bx	lr
 8006710:	240016e0 	.word	0x240016e0
 8006714:	e0001000 	.word	0xe0001000

08006718 <chSemObjectInit>:
  qp->prev = qp;
 8006718:	e9c0 0000 	strd	r0, r0, [r0]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  ch_queue_init(&sp->queue);
  sp->cnt = n;
 800671c:	6081      	str	r1, [r0, #8]
}
 800671e:	4770      	bx	lr

08006720 <chSemWait>:
 8006720:	2230      	movs	r2, #48	; 0x30
 8006722:	f382 8811 	msr	BASEPRI, r2
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8006726:	6882      	ldr	r2, [r0, #8]
 8006728:	3a01      	subs	r2, #1
 800672a:	2a00      	cmp	r2, #0
 800672c:	6082      	str	r2, [r0, #8]
 800672e:	db04      	blt.n	800673a <chSemWait+0x1a>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currtp->u.rdymsg;
  }

  return MSG_OK;
 8006730:	2000      	movs	r0, #0
 8006732:	2300      	movs	r3, #0
 8006734:	f383 8811 	msr	BASEPRI, r3
}
 8006738:	4770      	bx	lr
  return __sch_get_currthread();
 800673a:	4909      	ldr	r1, [pc, #36]	; (8006760 <chSemWait+0x40>)
 800673c:	4603      	mov	r3, r0
  p->prev       = qp->prev;
 800673e:	6842      	ldr	r2, [r0, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 8006740:	2005      	movs	r0, #5
msg_t chSemWait(semaphore_t *sp) {
 8006742:	b510      	push	{r4, lr}
 8006744:	68cc      	ldr	r4, [r1, #12]
    currtp->u.wtsemp = sp;
 8006746:	6363      	str	r3, [r4, #52]	; 0x34
 8006748:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 800674c:	6014      	str	r4, [r2, #0]
  qp->prev      = p;
 800674e:	605c      	str	r4, [r3, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 8006750:	f7ff fce8 	bl	8006124 <chSchGoSleepS>
    return currtp->u.rdymsg;
 8006754:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8006756:	2300      	movs	r3, #0
 8006758:	f383 8811 	msr	BASEPRI, r3
}
 800675c:	bd10      	pop	{r4, pc}
 800675e:	bf00      	nop
 8006760:	24000c20 	.word	0x24000c20

08006764 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
 8006764:	b510      	push	{r4, lr}
 8006766:	4603      	mov	r3, r0
 8006768:	2430      	movs	r4, #48	; 0x30
 800676a:	f384 8811 	msr	BASEPRI, r4
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 800676e:	6884      	ldr	r4, [r0, #8]
 8006770:	1e60      	subs	r0, r4, #1
 8006772:	2800      	cmp	r0, #0
 8006774:	6098      	str	r0, [r3, #8]
 8006776:	db04      	blt.n	8006782 <chSemWaitTimeout+0x1e>
    sem_insert(&sp->queue, currtp);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
  }

  return MSG_OK;
 8006778:	2000      	movs	r0, #0
 800677a:	2300      	movs	r3, #0
 800677c:	f383 8811 	msr	BASEPRI, r3
}
 8006780:	bd10      	pop	{r4, pc}
    if (unlikely(TIME_IMMEDIATE == timeout)) {
 8006782:	b171      	cbz	r1, 80067a2 <chSemWaitTimeout+0x3e>
 8006784:	4a09      	ldr	r2, [pc, #36]	; (80067ac <chSemWaitTimeout+0x48>)
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8006786:	2005      	movs	r0, #5
  p->prev       = qp->prev;
 8006788:	685c      	ldr	r4, [r3, #4]
 800678a:	68d2      	ldr	r2, [r2, #12]
    currtp->u.wtsemp = sp;
 800678c:	6353      	str	r3, [r2, #52]	; 0x34
 800678e:	e9c2 3400 	strd	r3, r4, [r2]
  p->prev->next = p;
 8006792:	6022      	str	r2, [r4, #0]
  qp->prev      = p;
 8006794:	605a      	str	r2, [r3, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8006796:	f7ff fce1 	bl	800615c <chSchGoSleepTimeoutS>
 800679a:	2300      	movs	r3, #0
 800679c:	f383 8811 	msr	BASEPRI, r3
}
 80067a0:	bd10      	pop	{r4, pc}
      return MSG_TIMEOUT;
 80067a2:	f04f 30ff 	mov.w	r0, #4294967295
      sp->cnt++;
 80067a6:	609c      	str	r4, [r3, #8]
      return MSG_TIMEOUT;
 80067a8:	e7e7      	b.n	800677a <chSemWaitTimeout+0x16>
 80067aa:	bf00      	nop
 80067ac:	24000c20 	.word	0x24000c20

080067b0 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 80067b0:	6882      	ldr	r2, [r0, #8]
void chSemSignalI(semaphore_t *sp) {
 80067b2:	4603      	mov	r3, r0
  if (++sp->cnt <= (cnt_t)0) {
 80067b4:	3201      	adds	r2, #1
 80067b6:	2a00      	cmp	r2, #0
 80067b8:	6082      	str	r2, [r0, #8]
 80067ba:	dd00      	ble.n	80067be <chSemSignalI+0xe>
             chSchReadyI().*/
    thread_t *tp = threadref(ch_queue_fifo_remove(&sp->queue));
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 80067bc:	4770      	bx	lr
  ch_queue_t *p = qp->next;
 80067be:	6800      	ldr	r0, [r0, #0]
    tp->u.rdymsg = MSG_OK;
 80067c0:	2100      	movs	r1, #0
  qp->next       = p->next;
 80067c2:	6802      	ldr	r2, [r0, #0]
 80067c4:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 80067c6:	6053      	str	r3, [r2, #4]
 80067c8:	6341      	str	r1, [r0, #52]	; 0x34
    (void) chSchReadyI(tp);
 80067ca:	f7ff bc97 	b.w	80060fc <chSchReadyI>
 80067ce:	bf00      	nop

080067d0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
 80067d0:	2300      	movs	r3, #0
  qp->prev = qp;
 80067d2:	e9c0 0000 	strd	r0, r0, [r0]
 80067d6:	6083      	str	r3, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80067d8:	4770      	bx	lr
 80067da:	bf00      	nop

080067dc <chMtxLockS>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80067dc:	b570      	push	{r4, r5, r6, lr}
 80067de:	4b2e      	ldr	r3, [pc, #184]	; (8006898 <chMtxLockS+0xbc>)
 80067e0:	4604      	mov	r4, r0

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80067e2:	6880      	ldr	r0, [r0, #8]
 80067e4:	68dd      	ldr	r5, [r3, #12]
 80067e6:	b328      	cbz	r0, 8006834 <chMtxLockS+0x58>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 80067e8:	68aa      	ldr	r2, [r5, #8]
 80067ea:	6883      	ldr	r3, [r0, #8]
 80067ec:	4293      	cmp	r3, r2
 80067ee:	d206      	bcs.n	80067fe <chMtxLockS+0x22>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80067f0:	7f03      	ldrb	r3, [r0, #28]
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 80067f2:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 80067f4:	2b06      	cmp	r3, #6
 80067f6:	d036      	beq.n	8006866 <chMtxLockS+0x8a>
 80067f8:	2b07      	cmp	r3, #7
 80067fa:	d020      	beq.n	800683e <chMtxLockS+0x62>
 80067fc:	b19b      	cbz	r3, 8006826 <chMtxLockS+0x4a>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
 80067fe:	4623      	mov	r3, r4
 8006800:	e003      	b.n	800680a <chMtxLockS+0x2e>
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 8006802:	6899      	ldr	r1, [r3, #8]
 8006804:	68aa      	ldr	r2, [r5, #8]
 8006806:	4291      	cmp	r1, r2
 8006808:	d302      	bcc.n	8006810 <chMtxLockS+0x34>
    cp = cp->next;
 800680a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != qp) &&
 800680c:	429c      	cmp	r4, r3
 800680e:	d1f8      	bne.n	8006802 <chMtxLockS+0x26>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
  tp->next       = cp;
  tp->prev       = cp->prev;
 8006810:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
      currtp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8006812:	2006      	movs	r0, #6
  tp->next       = cp;
 8006814:	602b      	str	r3, [r5, #0]
  tp->prev       = cp->prev;
 8006816:	606a      	str	r2, [r5, #4]
  tp->prev->next = tp;
 8006818:	6015      	str	r5, [r2, #0]
  cp->prev       = tp;
 800681a:	605d      	str	r5, [r3, #4]
      currtp->u.wtmtxp = mp;
 800681c:	636c      	str	r4, [r5, #52]	; 0x34
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 800681e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      chSchGoSleepS(CH_STATE_WTMTX);
 8006822:	f7ff bc7f 	b.w	8006124 <chSchGoSleepS>
  p->prev->next = p->next;
 8006826:	e9d0 3200 	ldrd	r3, r2, [r0]
 800682a:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 800682c:	605a      	str	r2, [r3, #4]
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 800682e:	f7ff fc65 	bl	80060fc <chSchReadyI>
          break;
 8006832:	e7e4      	b.n	80067fe <chMtxLockS+0x22>
    mp->next = currtp->mtxlist;
 8006834:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8006836:	e9c4 5302 	strd	r5, r3, [r4, #8]
    currtp->mtxlist = mp;
 800683a:	64ac      	str	r4, [r5, #72]	; 0x48
}
 800683c:	bd70      	pop	{r4, r5, r6, pc}
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 800683e:	6b46      	ldr	r6, [r0, #52]	; 0x34
  p->prev->next = p->next;
 8006840:	e9d0 3200 	ldrd	r3, r2, [r0]
 8006844:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8006846:	605a      	str	r2, [r3, #4]
  ch_queue_t *cp = qp;
 8006848:	4633      	mov	r3, r6
 800684a:	e003      	b.n	8006854 <chMtxLockS+0x78>
  } while ((cp != qp) &&
 800684c:	6899      	ldr	r1, [r3, #8]
 800684e:	6882      	ldr	r2, [r0, #8]
 8006850:	4291      	cmp	r1, r2
 8006852:	d302      	bcc.n	800685a <chMtxLockS+0x7e>
    cp = cp->next;
 8006854:	681b      	ldr	r3, [r3, #0]
  } while ((cp != qp) &&
 8006856:	429e      	cmp	r6, r3
 8006858:	d1f8      	bne.n	800684c <chMtxLockS+0x70>
  tp->prev       = cp->prev;
 800685a:	685a      	ldr	r2, [r3, #4]
 800685c:	e9c0 3200 	strd	r3, r2, [r0]
  tp->prev->next = tp;
 8006860:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 8006862:	6058      	str	r0, [r3, #4]
}
 8006864:	e7cb      	b.n	80067fe <chMtxLockS+0x22>
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8006866:	6b46      	ldr	r6, [r0, #52]	; 0x34
  p->prev->next = p->next;
 8006868:	e9d0 3200 	ldrd	r3, r2, [r0]
 800686c:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 800686e:	605a      	str	r2, [r3, #4]
  ch_queue_t *cp = qp;
 8006870:	4633      	mov	r3, r6
 8006872:	e003      	b.n	800687c <chMtxLockS+0xa0>
  } while ((cp != qp) &&
 8006874:	6899      	ldr	r1, [r3, #8]
 8006876:	6882      	ldr	r2, [r0, #8]
 8006878:	4291      	cmp	r1, r2
 800687a:	d302      	bcc.n	8006882 <chMtxLockS+0xa6>
    cp = cp->next;
 800687c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != qp) &&
 800687e:	429e      	cmp	r6, r3
 8006880:	d1f8      	bne.n	8006874 <chMtxLockS+0x98>
  tp->prev       = cp->prev;
 8006882:	685a      	ldr	r2, [r3, #4]
  tp->next       = cp;
 8006884:	6003      	str	r3, [r0, #0]
  tp->prev       = cp->prev;
 8006886:	6042      	str	r2, [r0, #4]
  tp->prev->next = tp;
 8006888:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 800688a:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800688c:	68b0      	ldr	r0, [r6, #8]
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 800688e:	68aa      	ldr	r2, [r5, #8]
 8006890:	6883      	ldr	r3, [r0, #8]
 8006892:	4293      	cmp	r3, r2
 8006894:	d3ac      	bcc.n	80067f0 <chMtxLockS+0x14>
 8006896:	e7b2      	b.n	80067fe <chMtxLockS+0x22>
 8006898:	24000c20 	.word	0x24000c20

0800689c <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 800689c:	b508      	push	{r3, lr}
 800689e:	2330      	movs	r3, #48	; 0x30
 80068a0:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 80068a4:	f7ff ff9a 	bl	80067dc <chMtxLockS>
 80068a8:	2300      	movs	r3, #0
 80068aa:	f383 8811 	msr	BASEPRI, r3
}
 80068ae:	bd08      	pop	{r3, pc}

080068b0 <chMtxUnlock>:
 80068b0:	4a17      	ldr	r2, [pc, #92]	; (8006910 <chMtxUnlock+0x60>)
 80068b2:	2330      	movs	r3, #48	; 0x30
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80068b4:	b510      	push	{r4, lr}
 80068b6:	68d4      	ldr	r4, [r2, #12]
 80068b8:	f383 8811 	msr	BASEPRI, r3
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80068bc:	6802      	ldr	r2, [r0, #0]
    currtp->mtxlist = mp->next;
 80068be:	68c3      	ldr	r3, [r0, #12]
    if (chMtxQueueNotEmptyS(mp)) {
 80068c0:	4282      	cmp	r2, r0
    currtp->mtxlist = mp->next;
 80068c2:	64a3      	str	r3, [r4, #72]	; 0x48
    if (chMtxQueueNotEmptyS(mp)) {
 80068c4:	d01d      	beq.n	8006902 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 80068c6:	4601      	mov	r1, r0
 80068c8:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
 80068ca:	b14b      	cbz	r3, 80068e0 <chMtxUnlock+0x30>
  return (bool)(qp->next != qp);
 80068cc:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80068ce:	4293      	cmp	r3, r2
 80068d0:	d003      	beq.n	80068da <chMtxUnlock+0x2a>
 80068d2:	6892      	ldr	r2, [r2, #8]
 80068d4:	4290      	cmp	r0, r2
 80068d6:	bf38      	it	cc
 80068d8:	4610      	movcc	r0, r2
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
 80068da:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 80068dc:	2b00      	cmp	r3, #0
 80068de:	d1f5      	bne.n	80068cc <chMtxUnlock+0x1c>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 80068e0:	60a0      	str	r0, [r4, #8]
  ch_queue_t *p = qp->next;
 80068e2:	6808      	ldr	r0, [r1, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80068e4:	6c82      	ldr	r2, [r0, #72]	; 0x48
  qp->next       = p->next;
 80068e6:	6803      	ldr	r3, [r0, #0]
 80068e8:	600b      	str	r3, [r1, #0]
  qp->next->prev = qp;
 80068ea:	6059      	str	r1, [r3, #4]
 80068ec:	e9c1 0202 	strd	r0, r2, [r1, #8]
      tp->mtxlist = mp;
 80068f0:	6481      	str	r1, [r0, #72]	; 0x48

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80068f2:	f7ff fc03 	bl	80060fc <chSchReadyI>
      chSchRescheduleS();
 80068f6:	f7ff fcdb 	bl	80062b0 <chSchRescheduleS>
 80068fa:	2300      	movs	r3, #0
 80068fc:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8006900:	bd10      	pop	{r4, pc}
      mp->owner = NULL;
 8006902:	2300      	movs	r3, #0
 8006904:	6093      	str	r3, [r2, #8]
 8006906:	2300      	movs	r3, #0
 8006908:	f383 8811 	msr	BASEPRI, r3
}
 800690c:	bd10      	pop	{r4, pc}
 800690e:	bf00      	nop
 8006910:	24000c20 	.word	0x24000c20

08006914 <chEvtObjectInit>:
 */
void chEvtObjectInit(event_source_t *esp) {

  chDbgCheck(esp != NULL);

  esp->next = (event_listener_t *)esp;
 8006914:	6000      	str	r0, [r0, #0]
}
 8006916:	4770      	bx	lr

08006918 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to an @p event_source_t object
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8006918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 800691a:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800691c:	42a0      	cmp	r0, r4
 800691e:	d020      	beq.n	8006962 <chEvtBroadcastFlagsI+0x4a>
 8006920:	4607      	mov	r7, r0
 8006922:	460d      	mov	r5, r1
    tp->u.rdymsg = MSG_OK;
 8006924:	2600      	movs	r6, #0
 8006926:	e004      	b.n	8006932 <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8006928:	290b      	cmp	r1, #11
 800692a:	d01b      	beq.n	8006964 <chEvtBroadcastFlagsI+0x4c>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 800692c:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 800692e:	42a7      	cmp	r7, r4
 8006930:	d017      	beq.n	8006962 <chEvtBroadcastFlagsI+0x4a>
    elp->flags |= flags;
 8006932:	68e3      	ldr	r3, [r4, #12]
 8006934:	432b      	orrs	r3, r5
 8006936:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8006938:	b115      	cbz	r5, 8006940 <chEvtBroadcastFlagsI+0x28>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 800693a:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 800693c:	421d      	tst	r5, r3
 800693e:	d0f5      	beq.n	800692c <chEvtBroadcastFlagsI+0x14>
  tp->epending |= events;
 8006940:	e9d4 0201 	ldrd	r0, r2, [r4, #4]
 8006944:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if (((tp->state == CH_STATE_WTOREVT) &&
 8006946:	7f01      	ldrb	r1, [r0, #28]
  tp->epending |= events;
 8006948:	431a      	orrs	r2, r3
  if (((tp->state == CH_STATE_WTOREVT) &&
 800694a:	290a      	cmp	r1, #10
  tp->epending |= events;
 800694c:	6442      	str	r2, [r0, #68]	; 0x44
  if (((tp->state == CH_STATE_WTOREVT) &&
 800694e:	d1eb      	bne.n	8006928 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8006950:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8006952:	420a      	tst	r2, r1
 8006954:	d0ea      	beq.n	800692c <chEvtBroadcastFlagsI+0x14>
    tp->u.rdymsg = MSG_OK;
 8006956:	6346      	str	r6, [r0, #52]	; 0x34
    (void) chSchReadyI(tp);
 8006958:	f7ff fbd0 	bl	80060fc <chSchReadyI>
    elp = elp->next;
 800695c:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 800695e:	42a7      	cmp	r7, r4
 8006960:	d1e7      	bne.n	8006932 <chEvtBroadcastFlagsI+0x1a>
  }
}
 8006962:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8006964:	6b41      	ldr	r1, [r0, #52]	; 0x34
      ((tp->state == CH_STATE_WTANDEVT) &&
 8006966:	4391      	bics	r1, r2
 8006968:	d1e0      	bne.n	800692c <chEvtBroadcastFlagsI+0x14>
 800696a:	e7f4      	b.n	8006956 <chEvtBroadcastFlagsI+0x3e>

0800696c <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {
 800696c:	b510      	push	{r4, lr}

  mbp->buffer = buf;
  mbp->top    = &buf[n];
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->cnt    = (size_t)0;
 800696e:	2300      	movs	r3, #0
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {
 8006970:	4604      	mov	r4, r0
  mbp->top    = &buf[n];
 8006972:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  mbp->reset  = false;
  chThdQueueObjectInit(&mbp->qw);
 8006976:	3018      	adds	r0, #24
  mbp->buffer = buf;
 8006978:	6021      	str	r1, [r4, #0]
  mbp->rdptr  = buf;
 800697a:	60e1      	str	r1, [r4, #12]
  mbp->cnt    = (size_t)0;
 800697c:	6123      	str	r3, [r4, #16]
  mbp->reset  = false;
 800697e:	7523      	strb	r3, [r4, #20]
  mbp->wrptr  = buf;
 8006980:	e9c4 2101 	strd	r2, r1, [r4, #4]
  chThdQueueObjectInit(&mbp->qw);
 8006984:	f7ff fe6c 	bl	8006660 <chThdQueueObjectInit>
  chThdQueueObjectInit(&mbp->qr);
 8006988:	f104 0020 	add.w	r0, r4, #32
}
 800698c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdQueueObjectInit(&mbp->qr);
 8006990:	f7ff be66 	b.w	8006660 <chThdQueueObjectInit>

08006994 <chMBPostTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8006994:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006998:	4604      	mov	r4, r0
 800699a:	460f      	mov	r7, r1
 800699c:	4690      	mov	r8, r2

      return MSG_OK;
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 800699e:	f100 0918 	add.w	r9, r0, #24
 80069a2:	e009      	b.n	80069b8 <chMBPostTimeoutS+0x24>
 */
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(mbp->top - mbp->buffer);
 80069a4:	e9d4 5600 	ldrd	r5, r6, [r4]
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return mbp->cnt;
 80069a8:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 80069aa:	1b72      	subs	r2, r6, r5
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 80069ac:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
 80069b0:	d10b      	bne.n	80069ca <chMBPostTimeoutS+0x36>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80069b2:	f7ff fe59 	bl	8006668 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 80069b6:	b930      	cbnz	r0, 80069c6 <chMBPostTimeoutS+0x32>
    if (mbp->reset) {
 80069b8:	7d23      	ldrb	r3, [r4, #20]
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80069ba:	4641      	mov	r1, r8
 80069bc:	4648      	mov	r0, r9
    if (mbp->reset) {
 80069be:	2b00      	cmp	r3, #0
 80069c0:	d0f0      	beq.n	80069a4 <chMBPostTimeoutS+0x10>
      return MSG_RESET;
 80069c2:	f06f 0001 	mvn.w	r0, #1

  return rdymsg;
}
 80069c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *mbp->wrptr++ = msg;
 80069ca:	68a1      	ldr	r1, [r4, #8]
      mbp->cnt++;
 80069cc:	3301      	adds	r3, #1
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80069ce:	f104 0020 	add.w	r0, r4, #32
      *mbp->wrptr++ = msg;
 80069d2:	1d0a      	adds	r2, r1, #4
      if (mbp->wrptr >= mbp->top) {
 80069d4:	42b2      	cmp	r2, r6
      *mbp->wrptr++ = msg;
 80069d6:	60a2      	str	r2, [r4, #8]
 80069d8:	600f      	str	r7, [r1, #0]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80069da:	f04f 0100 	mov.w	r1, #0
        mbp->wrptr = mbp->buffer;
 80069de:	bf38      	it	cc
 80069e0:	68a5      	ldrcc	r5, [r4, #8]
      mbp->cnt++;
 80069e2:	6123      	str	r3, [r4, #16]
 80069e4:	60a5      	str	r5, [r4, #8]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80069e6:	f7ff fe53 	bl	8006690 <chThdDequeueNextI>
      chSchRescheduleS();
 80069ea:	f7ff fc61 	bl	80062b0 <chSchRescheduleS>
      return MSG_OK;
 80069ee:	2000      	movs	r0, #0
}
 80069f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080069f4 <chMBPostTimeout>:
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 80069f4:	b508      	push	{r3, lr}
 80069f6:	2330      	movs	r3, #48	; 0x30
 80069f8:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBPostTimeoutS(mbp, msg, timeout);
 80069fc:	f7ff ffca 	bl	8006994 <chMBPostTimeoutS>
 8006a00:	2300      	movs	r3, #0
 8006a02:	f383 8811 	msr	BASEPRI, r3
}
 8006a06:	bd08      	pop	{r3, pc}

08006a08 <chMBPostI>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8006a08:	7d02      	ldrb	r2, [r0, #20]
 8006a0a:	b9e2      	cbnz	r2, 8006a46 <chMBPostI+0x3e>
 8006a0c:	4603      	mov	r3, r0
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8006a0e:	b570      	push	{r4, r5, r6, lr}
 8006a10:	e9d0 4000 	ldrd	r4, r0, [r0]
  return mbp->cnt;
 8006a14:	691a      	ldr	r2, [r3, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8006a16:	1b05      	subs	r5, r0, r4
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8006a18:	ebb2 0fa5 	cmp.w	r2, r5, asr #2
 8006a1c:	d010      	beq.n	8006a40 <chMBPostI+0x38>
    *mbp->wrptr++ = msg;
 8006a1e:	689e      	ldr	r6, [r3, #8]
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
 8006a20:	3201      	adds	r2, #1
    *mbp->wrptr++ = msg;
 8006a22:	1d35      	adds	r5, r6, #4
    if (mbp->wrptr >= mbp->top) {
 8006a24:	4285      	cmp	r5, r0
    *mbp->wrptr++ = msg;
 8006a26:	609d      	str	r5, [r3, #8]
 8006a28:	6031      	str	r1, [r6, #0]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8006a2a:	f103 0020 	add.w	r0, r3, #32
      mbp->wrptr = mbp->buffer;
 8006a2e:	bf38      	it	cc
 8006a30:	689c      	ldrcc	r4, [r3, #8]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8006a32:	2100      	movs	r1, #0
    mbp->cnt++;
 8006a34:	611a      	str	r2, [r3, #16]
 8006a36:	609c      	str	r4, [r3, #8]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8006a38:	f7ff fe2a 	bl	8006690 <chThdDequeueNextI>

    return MSG_OK;
 8006a3c:	2000      	movs	r0, #0
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
}
 8006a3e:	bd70      	pop	{r4, r5, r6, pc}
  return MSG_TIMEOUT;
 8006a40:	f04f 30ff 	mov.w	r0, #4294967295
}
 8006a44:	bd70      	pop	{r4, r5, r6, pc}
    return MSG_RESET;
 8006a46:	f06f 0001 	mvn.w	r0, #1
}
 8006a4a:	4770      	bx	lr

08006a4c <chMBFetchTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8006a4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006a4e:	4604      	mov	r4, r0
 8006a50:	460e      	mov	r6, r1
 8006a52:	4615      	mov	r5, r2

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8006a54:	f100 0720 	add.w	r7, r0, #32
 8006a58:	e004      	b.n	8006a64 <chMBFetchTimeoutS+0x18>
  return mbp->cnt;
 8006a5a:	6923      	ldr	r3, [r4, #16]
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8006a5c:	b953      	cbnz	r3, 8006a74 <chMBFetchTimeoutS+0x28>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8006a5e:	f7ff fe03 	bl	8006668 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8006a62:	b930      	cbnz	r0, 8006a72 <chMBFetchTimeoutS+0x26>
    if (mbp->reset) {
 8006a64:	7d23      	ldrb	r3, [r4, #20]
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8006a66:	4629      	mov	r1, r5
 8006a68:	4638      	mov	r0, r7
    if (mbp->reset) {
 8006a6a:	2b00      	cmp	r3, #0
 8006a6c:	d0f5      	beq.n	8006a5a <chMBFetchTimeoutS+0xe>
      return MSG_RESET;
 8006a6e:	f06f 0001 	mvn.w	r0, #1

  return rdymsg;
}
 8006a72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      *msgp = *mbp->rdptr++;
 8006a74:	68e1      	ldr	r1, [r4, #12]
 8006a76:	1d0a      	adds	r2, r1, #4
 8006a78:	6809      	ldr	r1, [r1, #0]
 8006a7a:	60e2      	str	r2, [r4, #12]
 8006a7c:	6031      	str	r1, [r6, #0]
      if (mbp->rdptr >= mbp->top) {
 8006a7e:	6861      	ldr	r1, [r4, #4]
 8006a80:	428a      	cmp	r2, r1
 8006a82:	d301      	bcc.n	8006a88 <chMBFetchTimeoutS+0x3c>
        mbp->rdptr = mbp->buffer;
 8006a84:	6822      	ldr	r2, [r4, #0]
 8006a86:	60e2      	str	r2, [r4, #12]
      mbp->cnt--;
 8006a88:	3b01      	subs	r3, #1
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8006a8a:	f104 0018 	add.w	r0, r4, #24
 8006a8e:	2100      	movs	r1, #0
      mbp->cnt--;
 8006a90:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8006a92:	f7ff fdfd 	bl	8006690 <chThdDequeueNextI>
      chSchRescheduleS();
 8006a96:	f7ff fc0b 	bl	80062b0 <chSchRescheduleS>
      return MSG_OK;
 8006a9a:	2000      	movs	r0, #0
}
 8006a9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006a9e:	bf00      	nop

08006aa0 <chMBFetchTimeout>:
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8006aa0:	b508      	push	{r3, lr}
 8006aa2:	2330      	movs	r3, #48	; 0x30
 8006aa4:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
 8006aa8:	f7ff ffd0 	bl	8006a4c <chMBFetchTimeoutS>
 8006aac:	2300      	movs	r3, #0
 8006aae:	f383 8811 	msr	BASEPRI, r3
}
 8006ab2:	bd08      	pop	{r3, pc}

08006ab4 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8006ab4:	4b02      	ldr	r3, [pc, #8]	; (8006ac0 <__core_init+0xc>)
 8006ab6:	4903      	ldr	r1, [pc, #12]	; (8006ac4 <__core_init+0x10>)
  ch_memcore.topmem  = __heap_end__;
 8006ab8:	4a03      	ldr	r2, [pc, #12]	; (8006ac8 <__core_init+0x14>)
 8006aba:	e9c3 1200 	strd	r1, r2, [r3]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8006abe:	4770      	bx	lr
 8006ac0:	240016ec 	.word	0x240016ec
 8006ac4:	240061c0 	.word	0x240061c0
 8006ac8:	24080000 	.word	0x24080000

08006acc <chCoreAllocFromTopI>:
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8006acc:	4b09      	ldr	r3, [pc, #36]	; (8006af4 <chCoreAllocFromTopI+0x28>)
 8006ace:	4249      	negs	r1, r1
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8006ad0:	b410      	push	{r4}
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8006ad2:	685c      	ldr	r4, [r3, #4]
 8006ad4:	1a20      	subs	r0, r4, r0
 8006ad6:	4008      	ands	r0, r1
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8006ad8:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
 8006ada:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8006adc:	428a      	cmp	r2, r1
 8006ade:	d305      	bcc.n	8006aec <chCoreAllocFromTopI+0x20>
 8006ae0:	42a2      	cmp	r2, r4
 8006ae2:	d803      	bhi.n	8006aec <chCoreAllocFromTopI+0x20>
  }

  ch_memcore.topmem = prev;

  return p;
}
 8006ae4:	f85d 4b04 	ldr.w	r4, [sp], #4
  ch_memcore.topmem = prev;
 8006ae8:	605a      	str	r2, [r3, #4]
}
 8006aea:	4770      	bx	lr
    return NULL;
 8006aec:	2000      	movs	r0, #0
}
 8006aee:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006af2:	4770      	bx	lr
 8006af4:	240016ec 	.word	0x240016ec

08006af8 <chCoreAllocFromTop>:
 8006af8:	2330      	movs	r3, #48	; 0x30
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8006afa:	b410      	push	{r4}
 8006afc:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8006b00:	4b0c      	ldr	r3, [pc, #48]	; (8006b34 <chCoreAllocFromTop+0x3c>)
 8006b02:	4249      	negs	r1, r1
 8006b04:	685c      	ldr	r4, [r3, #4]
 8006b06:	1a20      	subs	r0, r4, r0
 8006b08:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8006b0a:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
 8006b0c:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8006b0e:	428a      	cmp	r2, r1
 8006b10:	d308      	bcc.n	8006b24 <chCoreAllocFromTop+0x2c>
 8006b12:	4294      	cmp	r4, r2
 8006b14:	d306      	bcc.n	8006b24 <chCoreAllocFromTop+0x2c>
  ch_memcore.topmem = prev;
 8006b16:	605a      	str	r2, [r3, #4]
 8006b18:	2300      	movs	r3, #0
 8006b1a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 8006b1e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006b22:	4770      	bx	lr
    return NULL;
 8006b24:	2000      	movs	r0, #0
 8006b26:	2300      	movs	r3, #0
 8006b28:	f383 8811 	msr	BASEPRI, r3
}
 8006b2c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006b30:	4770      	bx	lr
 8006b32:	bf00      	nop
 8006b34:	240016ec 	.word	0x240016ec

08006b38 <chCoreGetStatusX>:
 *
 * @xclass
 */
void chCoreGetStatusX(memory_area_t *map) {

  map->base = ch_memcore.basemem;
 8006b38:	4b03      	ldr	r3, [pc, #12]	; (8006b48 <chCoreGetStatusX+0x10>)
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
 8006b3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006b3e:	1a9b      	subs	r3, r3, r2
 8006b40:	e9c0 2300 	strd	r2, r3, [r0]
  /*lint -restore*/
}
 8006b44:	4770      	bx	lr
 8006b46:	bf00      	nop
 8006b48:	240016ec 	.word	0x240016ec

08006b4c <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8006b4c:	b510      	push	{r4, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8006b4e:	4c08      	ldr	r4, [pc, #32]	; (8006b70 <__heap_init+0x24>)
 8006b50:	4b08      	ldr	r3, [pc, #32]	; (8006b74 <__heap_init+0x28>)
 8006b52:	4620      	mov	r0, r4
 8006b54:	f840 3b04 	str.w	r3, [r0], #4
  chCoreGetStatusX(&default_heap.area);
 8006b58:	f7ff ffee 	bl	8006b38 <chCoreGetStatusX>
  H_FREE_NEXT(&default_heap.header) = NULL;
 8006b5c:	2300      	movs	r3, #0
  H_FREE_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8006b5e:	f104 0014 	add.w	r0, r4, #20
  H_FREE_PAGES(&default_heap.header) = 0;
 8006b62:	e9c4 3303 	strd	r3, r3, [r4, #12]
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8006b66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMtxObjectInit(&default_heap.mtx);
 8006b6a:	f7ff be31 	b.w	80067d0 <chMtxObjectInit>
 8006b6e:	bf00      	nop
 8006b70:	240016f4 	.word	0x240016f4
 8006b74:	08006af9 	.word	0x08006af9

08006b78 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8006b78:	b410      	push	{r4}
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8006b7a:	2400      	movs	r4, #0
  mp->object_size = size;
  mp->align = align;
  mp->provider = provider;
 8006b7c:	e9c0 2302 	strd	r2, r3, [r0, #8]
  mp->next = NULL;
 8006b80:	e9c0 4100 	strd	r4, r1, [r0]
}
 8006b84:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006b88:	4770      	bx	lr
 8006b8a:	bf00      	nop

08006b8c <chCoreAllocAlignedI>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8006b8c:	2200      	movs	r2, #0
 8006b8e:	f7ff bf9d 	b.w	8006acc <chCoreAllocFromTopI>
 8006b92:	bf00      	nop

08006b94 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8006b94:	b510      	push	{r4, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8006b96:	4c12      	ldr	r4, [pc, #72]	; (8006be0 <__factory_init+0x4c>)
 8006b98:	4620      	mov	r0, r4
 8006b9a:	f7ff fe19 	bl	80067d0 <chMtxObjectInit>
  dlp->next = (dyn_element_t *)dlp;
 8006b9e:	f104 0110 	add.w	r1, r4, #16
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8006ba2:	4b10      	ldr	r3, [pc, #64]	; (8006be4 <__factory_init+0x50>)
 8006ba4:	2204      	movs	r2, #4
 8006ba6:	6121      	str	r1, [r4, #16]
 8006ba8:	2114      	movs	r1, #20
 8006baa:	1860      	adds	r0, r4, r1
 8006bac:	f7ff ffe4 	bl	8006b78 <chPoolObjectInitAligned>
 8006bb0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006bb4:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8006bb8:	4b0a      	ldr	r3, [pc, #40]	; (8006be4 <__factory_init+0x50>)
 8006bba:	2204      	movs	r2, #4
 8006bbc:	e9c4 0109 	strd	r0, r1, [r4, #36]	; 0x24
 8006bc0:	211c      	movs	r1, #28
 8006bc2:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8006bc6:	f7ff ffd7 	bl	8006b78 <chPoolObjectInitAligned>
 8006bca:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 8006bce:	f104 0240 	add.w	r2, r4, #64	; 0x40
 8006bd2:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8006bd6:	e9c4 120f 	strd	r1, r2, [r4, #60]	; 0x3c
 8006bda:	6463      	str	r3, [r4, #68]	; 0x44
  dyn_list_init(&ch_factory.fifo_list);
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
#endif
}
 8006bdc:	bd10      	pop	{r4, pc}
 8006bde:	bf00      	nop
 8006be0:	24001718 	.word	0x24001718
 8006be4:	08006b8d 	.word	0x08006b8d

08006be8 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8006be8:	f3ef 8309 	mrs	r3, PSP
     positioning the stack to point to the real one.*/
  psp += sizeof (struct port_extctx);

#if CORTEX_USE_FPU == TRUE
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8006bec:	4905      	ldr	r1, [pc, #20]	; (8006c04 <SVC_Handler+0x1c>)
  psp += sizeof (struct port_extctx);
 8006bee:	3368      	adds	r3, #104	; 0x68
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8006bf0:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 8006bf2:	f022 0201 	bic.w	r2, r2, #1
 8006bf6:	634a      	str	r2, [r1, #52]	; 0x34
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8006bf8:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006bfc:	2300      	movs	r3, #0
 8006bfe:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP(psp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 8006c02:	4770      	bx	lr
 8006c04:	e000ef00 	.word	0xe000ef00

08006c08 <port_init>:
 8006c08:	f04f 0c30 	mov.w	ip, #48	; 0x30
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8006c0c:	b500      	push	{lr}
 8006c0e:	f38c 8811 	msr	BASEPRI, ip
  __ASM volatile ("cpsie i" : : : "memory");
 8006c12:	b662      	cpsie	i
  port_suspend();

#if CORTEX_USE_FPU == TRUE
  /* Making sure to use the correct settings for FPU-related exception
     handling, better do not rely on startup settings.*/
  FPU->FPCCR  = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
 8006c14:	4a15      	ldr	r2, [pc, #84]	; (8006c6c <port_init+0x64>)
 8006c16:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
  FPU->FPDSCR = 0U;
 8006c1a:	2300      	movs	r3, #0
  FPU->FPCCR  = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
 8006c1c:	6351      	str	r1, [r2, #52]	; 0x34
  FPU->FPDSCR = 0U;
 8006c1e:	63d3      	str	r3, [r2, #60]	; 0x3c
  __builtin_arm_set_fpscr(fpscr);
 8006c20:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 8006c24:	2306      	movs	r3, #6
 8006c26:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
 8006c2a:	f3bf 8f6f 	isb	sy
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8006c2e:	4b10      	ldr	r3, [pc, #64]	; (8006c70 <port_init+0x68>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8006c30:	f64f 0eff 	movw	lr, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 8006c34:	490f      	ldr	r1, [pc, #60]	; (8006c74 <port_init+0x6c>)
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
 8006c36:	f5a2 425f 	sub.w	r2, r2, #57088	; 0xdf00
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8006c3a:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8006c3c:	ea00 000e 	and.w	r0, r0, lr
  reg_value  =  (reg_value                                   |
 8006c40:	4301      	orrs	r1, r0
 8006c42:	480d      	ldr	r0, [pc, #52]	; (8006c78 <port_init+0x70>)
  SCB->AIRCR =  reg_value;
 8006c44:	60d9      	str	r1, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8006c46:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
 8006c4a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8006c4e:	f8c3 10fc 	str.w	r1, [r3, #252]	; 0xfc
  DWT->LAR = 0xC5ACCE55U;
 8006c52:	f8c2 0fb0 	str.w	r0, [r2, #4016]	; 0xfb0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006c56:	2020      	movs	r0, #32
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8006c58:	6811      	ldr	r1, [r2, #0]
 8006c5a:	f041 0101 	orr.w	r1, r1, #1
 8006c5e:	6011      	str	r1, [r2, #0]
 8006c60:	77d8      	strb	r0, [r3, #31]
 8006c62:	f883 c022 	strb.w	ip, [r3, #34]	; 0x22

#if (PORT_MPU_INITIALIZE == TRUE) || (PORT_ENABLE_GUARD_PAGES == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8006c66:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c6a:	bf00      	nop
 8006c6c:	e000ef00 	.word	0xe000ef00
 8006c70:	e000ed00 	.word	0xe000ed00
 8006c74:	05fa0300 	.word	0x05fa0300
 8006c78:	c5acce55 	.word	0xc5acce55

08006c7c <__port_irq_epilogue>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006c7c:	2330      	movs	r3, #48	; 0x30
 8006c7e:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8006c82:	4b0f      	ldr	r3, [pc, #60]	; (8006cc0 <__port_irq_epilogue+0x44>)
 8006c84:	685b      	ldr	r3, [r3, #4]
 8006c86:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8006c8a:	d102      	bne.n	8006c92 <__port_irq_epilogue+0x16>
 8006c8c:	f383 8811 	msr	BASEPRI, r3
 8006c90:	4770      	bx	lr
void __port_irq_epilogue(void) {
 8006c92:	b510      	push	{r4, lr}
  return __builtin_arm_get_fpscr();
 8006c94:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8006c98:	f3ef 8409 	mrs	r4, PSP

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)psp;

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8006c9c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ectxp->fpscr = FPU->FPDSCR;
 8006ca0:	4b08      	ldr	r3, [pc, #32]	; (8006cc4 <__port_irq_epilogue+0x48>)
    psp -= sizeof (struct port_extctx);
 8006ca2:	3c68      	subs	r4, #104	; 0x68
    ectxp->xpsr = 0x01000000U;
 8006ca4:	61e2      	str	r2, [r4, #28]
    ectxp->fpscr = FPU->FPDSCR;
 8006ca6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006ca8:	6623      	str	r3, [r4, #96]	; 0x60
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8006caa:	f384 8809 	msr	PSP, r4
    /* Writing back the modified S-PSP value.*/
    __set_PSP(psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8006cae:	f7ff facb 	bl	8006248 <chSchIsPreemptionRequired>
 8006cb2:	b110      	cbz	r0, 8006cba <__port_irq_epilogue+0x3e>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8006cb4:	4b04      	ldr	r3, [pc, #16]	; (8006cc8 <__port_irq_epilogue+0x4c>)
 8006cb6:	61a3      	str	r3, [r4, #24]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8006cb8:	bd10      	pop	{r4, pc}
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8006cba:	4b04      	ldr	r3, [pc, #16]	; (8006ccc <__port_irq_epilogue+0x50>)
 8006cbc:	61a3      	str	r3, [r4, #24]
}
 8006cbe:	bd10      	pop	{r4, pc}
 8006cc0:	e000ed00 	.word	0xe000ed00
 8006cc4:	e000ef00 	.word	0xe000ef00
 8006cc8:	0800044f 	.word	0x0800044f
 8006ccc:	08000452 	.word	0x08000452

08006cd0 <main>:
#include "ch.h"
#include "hal.h"
#include "drivers.h"      // qui inclut drv_display.h
#include "system_init.h"

int main(void) {
 8006cd0:	b508      	push	{r3, lr}
  halInit();
 8006cd2:	f7f9 ff75 	bl	8000bc0 <halInit>
  chSysInit();
 8006cd6:	f7fe ff93 	bl	8005c00 <chSysInit>

  if (system_init_early() != SYS_OK) {
 8006cda:	f000 f871 	bl	8006dc0 <system_init_early>
 8006cde:	b998      	cbnz	r0, 8006d08 <main+0x38>
    chSysHalt("SYS EARLY FAIL");
  }

  if (system_init_drivers() != SYS_OK) {
 8006ce0:	f000 f8e4 	bl	8006eac <system_init_drivers>
 8006ce4:	b9c0      	cbnz	r0, 8006d18 <main+0x48>
    chSysHalt("SYS DRIVERS FAIL");
  }

  if (system_init_late() != SYS_OK) {
 8006ce6:	f000 f8f3 	bl	8006ed0 <system_init_late>
 8006cea:	b988      	cbnz	r0, 8006d10 <main+0x40>
    chSysHalt("SYS LATE FAIL");
  }

  drv_display_clear();
 8006cec:	f000 fc6e 	bl	80075cc <drv_display_clear>
  drv_display_draw_text(0, 0, "HELLO H743");
 8006cf0:	2100      	movs	r1, #0
 8006cf2:	4a0b      	ldr	r2, [pc, #44]	; (8006d20 <main+0x50>)
 8006cf4:	4608      	mov	r0, r1
 8006cf6:	f000 fdaf 	bl	8007858 <drv_display_draw_text>
  drv_display_update();   // si tu n’utilises pas le thread
 8006cfa:	f000 fc6f 	bl	80075dc <drv_display_update>

  while (true) {
    chThdSleepMilliseconds(1000);
 8006cfe:	f242 7010 	movw	r0, #10000	; 0x2710
 8006d02:	f7ff fc7f 	bl	8006604 <chThdSleep>
  while (true) {
 8006d06:	e7fa      	b.n	8006cfe <main+0x2e>
    chSysHalt("SYS EARLY FAIL");
 8006d08:	4806      	ldr	r0, [pc, #24]	; (8006d24 <main+0x54>)
 8006d0a:	f7fe ffa5 	bl	8005c58 <chSysHalt>
 8006d0e:	e7e7      	b.n	8006ce0 <main+0x10>
    chSysHalt("SYS LATE FAIL");
 8006d10:	4805      	ldr	r0, [pc, #20]	; (8006d28 <main+0x58>)
 8006d12:	f7fe ffa1 	bl	8005c58 <chSysHalt>
 8006d16:	e7e9      	b.n	8006cec <main+0x1c>
    chSysHalt("SYS DRIVERS FAIL");
 8006d18:	4804      	ldr	r0, [pc, #16]	; (8006d2c <main+0x5c>)
 8006d1a:	f7fe ff9d 	bl	8005c58 <chSysHalt>
 8006d1e:	e7e2      	b.n	8006ce6 <main+0x16>
 8006d20:	08014ef4 	.word	0x08014ef4
 8006d24:	08014ec0 	.word	0x08014ec0
 8006d28:	08014ee4 	.word	0x08014ee4
 8006d2c:	08014ed0 	.word	0x08014ed0

08006d30 <_write>:
#include <errno.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/types.h>

__attribute__((weak)) int _write(int file, const char *ptr, int len) {
 8006d30:	b508      	push	{r3, lr}
    (void)file;
    (void)ptr;
    (void)len;
    errno = ENOSYS;
 8006d32:	f007 fe41 	bl	800e9b8 <__errno>
 8006d36:	2258      	movs	r2, #88	; 0x58
 8006d38:	4603      	mov	r3, r0
    return -1;
}
 8006d3a:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOSYS;
 8006d3e:	601a      	str	r2, [r3, #0]
}
 8006d40:	bd08      	pop	{r3, pc}
 8006d42:	bf00      	nop

08006d44 <_read>:
 8006d44:	b508      	push	{r3, lr}
 8006d46:	f007 fe37 	bl	800e9b8 <__errno>
 8006d4a:	2258      	movs	r2, #88	; 0x58
 8006d4c:	4603      	mov	r3, r0
 8006d4e:	f04f 30ff 	mov.w	r0, #4294967295
 8006d52:	601a      	str	r2, [r3, #0]
 8006d54:	bd08      	pop	{r3, pc}
 8006d56:	bf00      	nop

08006d58 <_close>:
    (void)len;
    errno = ENOSYS;
    return -1;
}

__attribute__((weak)) int _close(int file) {
 8006d58:	b508      	push	{r3, lr}
    (void)file;
    errno = ENOSYS;
 8006d5a:	f007 fe2d 	bl	800e9b8 <__errno>
 8006d5e:	2258      	movs	r2, #88	; 0x58
 8006d60:	4603      	mov	r3, r0
    return -1;
}
 8006d62:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOSYS;
 8006d66:	601a      	str	r2, [r3, #0]
}
 8006d68:	bd08      	pop	{r3, pc}
 8006d6a:	bf00      	nop

08006d6c <_lseek>:

__attribute__((weak)) int _lseek(int file, int ptr, int dir) {
 8006d6c:	b508      	push	{r3, lr}
    (void)file;
    (void)ptr;
    (void)dir;
    errno = ENOSYS;
 8006d6e:	f007 fe23 	bl	800e9b8 <__errno>
 8006d72:	2258      	movs	r2, #88	; 0x58
 8006d74:	4603      	mov	r3, r0
    return -1;
}
 8006d76:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOSYS;
 8006d7a:	601a      	str	r2, [r3, #0]
}
 8006d7c:	bd08      	pop	{r3, pc}
 8006d7e:	bf00      	nop

08006d80 <_fstat>:

__attribute__((weak)) int _fstat(int file, struct stat *st) {
    (void)file;
    if (st != NULL) {
 8006d80:	b111      	cbz	r1, 8006d88 <_fstat+0x8>
        st->st_mode = S_IFCHR;
 8006d82:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006d86:	604b      	str	r3, [r1, #4]
    }
    return 0;
}
 8006d88:	2000      	movs	r0, #0
 8006d8a:	4770      	bx	lr

08006d8c <_isatty>:

__attribute__((weak)) int _isatty(int file) {
    (void)file;
    return 1;
}
 8006d8c:	2001      	movs	r0, #1
 8006d8e:	4770      	bx	lr

08006d90 <_kill>:

__attribute__((weak)) int _kill(int pid, int sig) {
 8006d90:	b508      	push	{r3, lr}
    (void)pid;
    (void)sig;
    errno = ENOSYS;
 8006d92:	f007 fe11 	bl	800e9b8 <__errno>
 8006d96:	2258      	movs	r2, #88	; 0x58
 8006d98:	4603      	mov	r3, r0
    return -1;
}
 8006d9a:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOSYS;
 8006d9e:	601a      	str	r2, [r3, #0]
}
 8006da0:	bd08      	pop	{r3, pc}
 8006da2:	bf00      	nop

08006da4 <_getpid>:

__attribute__((weak)) int _getpid(void) {
    return 1;
}
 8006da4:	2001      	movs	r0, #1
 8006da6:	4770      	bx	lr

08006da8 <_exit>:

__attribute__((weak)) void _exit(int status) {
    (void)status;
    while (1) {
 8006da8:	e7fe      	b.n	8006da8 <_exit>
 8006daa:	bf00      	nop

08006dac <_sbrk>:
    }
}

__attribute__((weak)) caddr_t _sbrk(int incr) {
 8006dac:	b508      	push	{r3, lr}
    (void)incr;
    errno = ENOMEM;
 8006dae:	f007 fe03 	bl	800e9b8 <__errno>
 8006db2:	220c      	movs	r2, #12
 8006db4:	4603      	mov	r3, r0
    return (caddr_t)-1;
}
 8006db6:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOMEM;
 8006dba:	601a      	str	r2, [r3, #0]
}
 8006dbc:	bd08      	pop	{r3, pc}
 8006dbe:	bf00      	nop

08006dc0 <system_init_early>:
  SCB_EnableICache();
  SCB_EnableDCache();
  caches_enabled = true;
}

sys_status_t system_init_early(void) {
 8006dc0:	b570      	push	{r4, r5, r6, lr}
  if (early_done) {
 8006dc2:	4c36      	ldr	r4, [pc, #216]	; (8006e9c <system_init_early+0xdc>)
 8006dc4:	7823      	ldrb	r3, [r4, #0]
 8006dc6:	b113      	cbz	r3, 8006dce <system_init_early+0xe>
    return last_error;
 8006dc8:	4b35      	ldr	r3, [pc, #212]	; (8006ea0 <system_init_early+0xe0>)
 8006dca:	7818      	ldrb	r0, [r3, #0]
    return last_error;
  }

  early_done = true;
  return last_error;
}
 8006dcc:	bd70      	pop	{r4, r5, r6, pc}
  if (!mpu_config_init_once()) {
 8006dce:	f001 f833 	bl	8007e38 <mpu_config_init_once>
 8006dd2:	b938      	cbnz	r0, 8006de4 <system_init_early+0x24>
  if (last_error == SYS_OK) {
 8006dd4:	4b32      	ldr	r3, [pc, #200]	; (8006ea0 <system_init_early+0xe0>)
 8006dd6:	7818      	ldrb	r0, [r3, #0]
 8006dd8:	2800      	cmp	r0, #0
 8006dda:	d1f7      	bne.n	8006dcc <system_init_early+0xc>
    last_error = err;
 8006ddc:	2201      	movs	r2, #1
 8006dde:	4610      	mov	r0, r2
 8006de0:	701a      	strb	r2, [r3, #0]
}
 8006de2:	bd70      	pop	{r4, r5, r6, pc}
  if (caches_enabled) {
 8006de4:	4e2f      	ldr	r6, [pc, #188]	; (8006ea4 <system_init_early+0xe4>)
 8006de6:	7833      	ldrb	r3, [r6, #0]
 8006de8:	b19b      	cbz	r3, 8006e12 <system_init_early+0x52>
  sdram_init(true);
 8006dea:	2001      	movs	r0, #1
 8006dec:	f001 fcd6 	bl	800879c <sdram_init>
  const sdram_state_t sdram_state = sdram_status();
 8006df0:	f001 fd44 	bl	800887c <sdram_status>
  if (sdram_state != SDRAM_READY) {
 8006df4:	2802      	cmp	r0, #2
 8006df6:	d007      	beq.n	8006e08 <system_init_early+0x48>
  if (last_error == SYS_OK) {
 8006df8:	4b29      	ldr	r3, [pc, #164]	; (8006ea0 <system_init_early+0xe0>)
 8006dfa:	7818      	ldrb	r0, [r3, #0]
 8006dfc:	2800      	cmp	r0, #0
 8006dfe:	d1e5      	bne.n	8006dcc <system_init_early+0xc>
    last_error = err;
 8006e00:	2202      	movs	r2, #2
 8006e02:	4610      	mov	r0, r2
 8006e04:	701a      	strb	r2, [r3, #0]
}
 8006e06:	bd70      	pop	{r4, r5, r6, pc}
  return last_error;
 8006e08:	4a25      	ldr	r2, [pc, #148]	; (8006ea0 <system_init_early+0xe0>)
  early_done = true;
 8006e0a:	2301      	movs	r3, #1
  return last_error;
 8006e0c:	7810      	ldrb	r0, [r2, #0]
  early_done = true;
 8006e0e:	7023      	strb	r3, [r4, #0]
}
 8006e10:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("dsb 0xF":::"memory");
 8006e12:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006e16:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8006e1a:	4823      	ldr	r0, [pc, #140]	; (8006ea8 <system_init_early+0xe8>)
 8006e1c:	f8c0 3250 	str.w	r3, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8006e20:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006e24:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8006e28:	6942      	ldr	r2, [r0, #20]
 8006e2a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8006e2e:	6142      	str	r2, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8006e30:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006e34:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8006e38:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8006e3c:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 8006e40:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8006e44:	f643 7ee0 	movw	lr, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8006e48:	f3c3 05c9 	ubfx	r5, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8006e4c:	f3c3 334e 	ubfx	r3, r3, #13, #15
 8006e50:	ea4f 1c43 	mov.w	ip, r3, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8006e54:	ea0c 010e 	and.w	r1, ip, lr
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8006e58:	462b      	mov	r3, r5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8006e5a:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
      } while (ways-- != 0U);
 8006e5e:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8006e60:	f8c0 2260 	str.w	r2, [r0, #608]	; 0x260
      } while (ways-- != 0U);
 8006e64:	1c5a      	adds	r2, r3, #1
 8006e66:	d1f8      	bne.n	8006e5a <system_init_early+0x9a>
    } while(sets-- != 0U);
 8006e68:	f1ac 0c20 	sub.w	ip, ip, #32
 8006e6c:	f11c 0f20 	cmn.w	ip, #32
 8006e70:	d1f0      	bne.n	8006e54 <system_init_early+0x94>
 8006e72:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8006e76:	6943      	ldr	r3, [r0, #20]
 8006e78:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006e7c:	6143      	str	r3, [r0, #20]
 8006e7e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006e82:	f3bf 8f6f 	isb	sy
  caches_enabled = true;
 8006e86:	2301      	movs	r3, #1
  sdram_init(true);
 8006e88:	2001      	movs	r0, #1
  caches_enabled = true;
 8006e8a:	7033      	strb	r3, [r6, #0]
  sdram_init(true);
 8006e8c:	f001 fc86 	bl	800879c <sdram_init>
  const sdram_state_t sdram_state = sdram_status();
 8006e90:	f001 fcf4 	bl	800887c <sdram_status>
  if (sdram_state != SDRAM_READY) {
 8006e94:	2802      	cmp	r0, #2
 8006e96:	d0b7      	beq.n	8006e08 <system_init_early+0x48>
 8006e98:	e7ae      	b.n	8006df8 <system_init_early+0x38>
 8006e9a:	bf00      	nop
 8006e9c:	24001763 	.word	0x24001763
 8006ea0:	24001764 	.word	0x24001764
 8006ea4:	24001761 	.word	0x24001761
 8006ea8:	e000ed00 	.word	0xe000ed00

08006eac <system_init_drivers>:

sys_status_t system_init_drivers(void) {
 8006eac:	b538      	push	{r3, r4, r5, lr}
  if (last_error != SYS_OK) {
 8006eae:	4c06      	ldr	r4, [pc, #24]	; (8006ec8 <system_init_drivers+0x1c>)
 8006eb0:	7820      	ldrb	r0, [r4, #0]
 8006eb2:	b910      	cbnz	r0, 8006eba <system_init_drivers+0xe>
    return last_error;
  }

  if (drivers_done) {
 8006eb4:	4d05      	ldr	r5, [pc, #20]	; (8006ecc <system_init_drivers+0x20>)
 8006eb6:	782b      	ldrb	r3, [r5, #0]
 8006eb8:	b103      	cbz	r3, 8006ebc <system_init_drivers+0x10>

  drivers_init_all();

  drivers_done = true;
  return last_error;
}
 8006eba:	bd38      	pop	{r3, r4, r5, pc}
  drivers_init_all();
 8006ebc:	f000 f834 	bl	8006f28 <drivers_init_all>
  drivers_done = true;
 8006ec0:	2301      	movs	r3, #1
  return last_error;
 8006ec2:	7820      	ldrb	r0, [r4, #0]
  drivers_done = true;
 8006ec4:	702b      	strb	r3, [r5, #0]
}
 8006ec6:	bd38      	pop	{r3, r4, r5, pc}
 8006ec8:	24001764 	.word	0x24001764
 8006ecc:	24001762 	.word	0x24001762

08006ed0 <system_init_late>:

sys_status_t system_init_late(void) {
 8006ed0:	b570      	push	{r4, r5, r6, lr}
  if (last_error != SYS_OK) {
 8006ed2:	4c12      	ldr	r4, [pc, #72]	; (8006f1c <system_init_late+0x4c>)
 8006ed4:	7820      	ldrb	r0, [r4, #0]
 8006ed6:	b910      	cbnz	r0, 8006ede <system_init_late+0xe>
    return last_error;
  }

  if (late_done) {
 8006ed8:	4d11      	ldr	r5, [pc, #68]	; (8006f20 <system_init_late+0x50>)
 8006eda:	782b      	ldrb	r3, [r5, #0]
 8006edc:	b103      	cbz	r3, 8006ee0 <system_init_late+0x10>
    audio_started = true;
  }

  late_done = true;
  return last_error;
}
 8006ede:	bd70      	pop	{r4, r5, r6, pc}
  usb_device_start();
 8006ee0:	f001 fdb0 	bl	8008a44 <usb_device_start>
  usb_host_midi_init();
 8006ee4:	f004 fe34 	bl	800bb50 <usb_host_midi_init>
  midi_init();
 8006ee8:	f001 fa76 	bl	80083d8 <midi_init>
  const sd_error_t sd_init_res = drv_sd_init();
 8006eec:	f001 fea0 	bl	8008c30 <drv_sd_init>
  } else if (sd_init_res != SD_ERR_NO_CARD) {
 8006ef0:	2801      	cmp	r0, #1
 8006ef2:	d80b      	bhi.n	8006f0c <system_init_late+0x3c>
  if (!audio_initialized) {
 8006ef4:	4e0b      	ldr	r6, [pc, #44]	; (8006f24 <system_init_late+0x54>)
 8006ef6:	7833      	ldrb	r3, [r6, #0]
 8006ef8:	b11b      	cbz	r3, 8006f02 <system_init_late+0x32>
  late_done = true;
 8006efa:	2301      	movs	r3, #1
  return last_error;
 8006efc:	7820      	ldrb	r0, [r4, #0]
  late_done = true;
 8006efe:	702b      	strb	r3, [r5, #0]
}
 8006f00:	bd70      	pop	{r4, r5, r6, pc}
    drv_audio_init();
 8006f02:	f001 f893 	bl	800802c <drv_audio_init>
    audio_initialized = true;
 8006f06:	2301      	movs	r3, #1
 8006f08:	7033      	strb	r3, [r6, #0]
 8006f0a:	e7f6      	b.n	8006efa <system_init_late+0x2a>
  if (last_error == SYS_OK) {
 8006f0c:	7820      	ldrb	r0, [r4, #0]
 8006f0e:	2800      	cmp	r0, #0
 8006f10:	d1e5      	bne.n	8006ede <system_init_late+0xe>
    last_error = err;
 8006f12:	2303      	movs	r3, #3
 8006f14:	4618      	mov	r0, r3
 8006f16:	7023      	strb	r3, [r4, #0]
}
 8006f18:	bd70      	pop	{r4, r5, r6, pc}
 8006f1a:	bf00      	nop
 8006f1c:	24001764 	.word	0x24001764
 8006f20:	24001765 	.word	0x24001765
 8006f24:	24001760 	.word	0x24001760

08006f28 <drivers_init_all>:

#include "drivers.h"

mutex_t spi5_mutex;

void drivers_init_all(void) {
 8006f28:	b508      	push	{r3, lr}
    chMtxObjectInit(&spi5_mutex);
 8006f2a:	4808      	ldr	r0, [pc, #32]	; (8006f4c <drivers_init_all+0x24>)
 8006f2c:	f7ff fc50 	bl	80067d0 <chMtxObjectInit>
       - drv_display   : init + start (thread de rafraîchissement)
       - drv_leds_addr : init uniquement (rendu déclenché côté UI)
       - drv_buttons   : start = init + thread de scan
       - drv_encoders  : start = init + thread de scan
       - drv_pots      : start = init + thread de scan */
    drv_display_init();
 8006f30:	f000 f89c 	bl	800706c <drv_display_init>
    drv_display_start();
 8006f34:	f000 fcae 	bl	8007894 <drv_display_start>
    drv_leds_addr_init();
 8006f38:	f000 fe3a 	bl	8007bb0 <drv_leds_addr_init>
    drv_buttons_start();
 8006f3c:	f000 f86c 	bl	8007018 <drv_buttons_start>
    drv_encoders_start();
 8006f40:	f000 fcca 	bl	80078d8 <drv_encoders_start>
    drv_pots_start();
}
 8006f44:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    drv_pots_start();
 8006f48:	f000 bf4c 	b.w	8007de4 <drv_pots_start>
 8006f4c:	24001768 	.word	0x24001768

08006f50 <buttonThread>:
/*                             THREAD                                      */
/* ====================================================================== */

static THD_WORKING_AREA(waButtons, 256);

static THD_FUNCTION(buttonThread, arg) {
 8006f50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8006f54:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 800700c <buttonThread+0xbc>
 8006f58:	b083      	sub	sp, #12
 8006f5a:	4926      	ldr	r1, [pc, #152]	; (8006ff4 <buttonThread+0xa4>)
 8006f5c:	f8d9 300c 	ldr.w	r3, [r9, #12]
    (void)arg;
    chRegSetThreadName("buttons");

    while (!chThdShouldTerminateX()) {
 8006f60:	f993 201d 	ldrsb.w	r2, [r3, #29]
 8006f64:	6219      	str	r1, [r3, #32]
 8006f66:	2a00      	cmp	r2, #0
 8006f68:	db3d      	blt.n	8006fe6 <buttonThread+0x96>
 8006f6a:	4b23      	ldr	r3, [pc, #140]	; (8006ff8 <buttonThread+0xa8>)
 8006f6c:	4c23      	ldr	r4, [pc, #140]	; (8006ffc <buttonThread+0xac>)
 8006f6e:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 8007010 <buttonThread+0xc0>
    uint8_t rx[3] = {0};
 8006f72:	881f      	ldrh	r7, [r3, #0]
    chMtxLock(&spi5_mutex);
 8006f74:	4e22      	ldr	r6, [pc, #136]	; (8007000 <buttonThread+0xb0>)
    spiStart(&SPID5, &spicfg_buttons);
 8006f76:	4d23      	ldr	r5, [pc, #140]	; (8007004 <buttonThread+0xb4>)
    uint8_t rx[3] = {0};
 8006f78:	2300      	movs	r3, #0
    chMtxLock(&spi5_mutex);
 8006f7a:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_SR);
 8006f7c:	f8df a094 	ldr.w	sl, [pc, #148]	; 8007014 <buttonThread+0xc4>
 8006f80:	f04f 0b08 	mov.w	fp, #8
    uint8_t rx[3] = {0};
 8006f84:	f88d 3006 	strb.w	r3, [sp, #6]
 8006f88:	f8ad 7004 	strh.w	r7, [sp, #4]
    chMtxLock(&spi5_mutex);
 8006f8c:	f7ff fc86 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg_buttons);
 8006f90:	491d      	ldr	r1, [pc, #116]	; (8007008 <buttonThread+0xb8>)
 8006f92:	4628      	mov	r0, r5
 8006f94:	f7fa fb86 	bl	80016a4 <spiStart>
    spiReceive(&SPID5, 3, rx);
 8006f98:	aa01      	add	r2, sp, #4
 8006f9a:	2103      	movs	r1, #3
 8006f9c:	4628      	mov	r0, r5
    palClearLine(LINE_SPI5_CS_SR);
 8006f9e:	f8aa b01a 	strh.w	fp, [sl, #26]
    spiReceive(&SPID5, 3, rx);
 8006fa2:	f7fa fbad 	bl	8001700 <spiReceive>
    chMtxUnlock(&spi5_mutex);
 8006fa6:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_SR);
 8006fa8:	f8aa b018 	strh.w	fp, [sl, #24]
    chMtxUnlock(&spi5_mutex);
 8006fac:	f7ff fc80 	bl	80068b0 <chMtxUnlock>
    buttons_raw[2] = rx[2];
 8006fb0:	f89d 1006 	ldrb.w	r1, [sp, #6]
    buttons_raw[1] = rx[1];
 8006fb4:	f89d c005 	ldrb.w	ip, [sp, #5]
        buttons_read_shiftreg();
        chThdSleepMilliseconds(2);  /* 500 Hz */
 8006fb8:	2014      	movs	r0, #20
         ((uint32_t)rx[2] << 16);
 8006fba:	040b      	lsls	r3, r1, #16
    buttons_raw[0] = rx[0];
 8006fbc:	f89d 2004 	ldrb.w	r2, [sp, #4]
    uint32_t m =
 8006fc0:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
    buttons_raw[0] = rx[0];
 8006fc4:	7022      	strb	r2, [r4, #0]
    buttons_raw[1] = rx[1];
 8006fc6:	f884 c001 	strb.w	ip, [r4, #1]
    uint32_t m =
 8006fca:	4313      	orrs	r3, r2
    buttons_raw[2] = rx[2];
 8006fcc:	70a1      	strb	r1, [r4, #2]
    buttons_mask = (m & 0x000FFFFF);   /* 20 bits utiles */
 8006fce:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8006fd2:	f8c8 3000 	str.w	r3, [r8]
        chThdSleepMilliseconds(2);  /* 500 Hz */
 8006fd6:	f7ff fb15 	bl	8006604 <chThdSleep>
  return (bool)((chThdGetSelfX()->flags & CH_FLAGS_TERMINATE) != (tmode_t)0);
 8006fda:	f8d9 300c 	ldr.w	r3, [r9, #12]
    while (!chThdShouldTerminateX()) {
 8006fde:	f993 301d 	ldrsb.w	r3, [r3, #29]
 8006fe2:	2b00      	cmp	r3, #0
 8006fe4:	dac8      	bge.n	8006f78 <buttonThread+0x28>
    }

    chThdExit(MSG_OK);
 8006fe6:	2000      	movs	r0, #0
}
 8006fe8:	b003      	add	sp, #12
 8006fea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    chThdExit(MSG_OK);
 8006fee:	f7ff baaf 	b.w	8006550 <chThdExit>
 8006ff2:	bf00      	nop
 8006ff4:	08014f00 	.word	0x08014f00
 8006ff8:	080149b8 	.word	0x080149b8
 8006ffc:	2400177c 	.word	0x2400177c
 8007000:	24001768 	.word	0x24001768
 8007004:	24000b04 	.word	0x24000b04
 8007008:	08014f08 	.word	0x08014f08
 800700c:	24000c20 	.word	0x24000c20
 8007010:	24001778 	.word	0x24001778
 8007014:	58020000 	.word	0x58020000

08007018 <drv_buttons_start>:
    /* CS shift-register */
    palSetLineMode(LINE_SPI5_CS_SR, PAL_MODE_OUTPUT_PUSHPULL);
    palSetLine(LINE_SPI5_CS_SR);   /* repos = haut */
}

void drv_buttons_start(void) {
 8007018:	b530      	push	{r4, r5, lr}
    if (buttons_tp != NULL) {
 800701a:	4c10      	ldr	r4, [pc, #64]	; (800705c <drv_buttons_start+0x44>)
void drv_buttons_start(void) {
 800701c:	b083      	sub	sp, #12
    if (buttons_tp != NULL) {
 800701e:	6820      	ldr	r0, [r4, #0]
 8007020:	b140      	cbz	r0, 8007034 <drv_buttons_start+0x1c>
        if (chThdTerminatedX(buttons_tp)) {
 8007022:	7f03      	ldrb	r3, [r0, #28]
 8007024:	2b0f      	cmp	r3, #15
 8007026:	d001      	beq.n	800702c <drv_buttons_start+0x14>

    drv_buttons_init();

    buttons_tp = chThdCreateStatic(waButtons, sizeof(waButtons),
                                   NORMALPRIO, buttonThread, NULL);
}
 8007028:	b003      	add	sp, #12
 800702a:	bd30      	pop	{r4, r5, pc}
            chThdWait(buttons_tp);
 800702c:	f7ff fab8 	bl	80065a0 <chThdWait>
            buttons_tp = NULL;
 8007030:	2300      	movs	r3, #0
 8007032:	6023      	str	r3, [r4, #0]
    palSetLineMode(LINE_SPI5_CS_SR, PAL_MODE_OUTPUT_PUSHPULL);
 8007034:	4d0a      	ldr	r5, [pc, #40]	; (8007060 <drv_buttons_start+0x48>)
 8007036:	2201      	movs	r2, #1
 8007038:	2108      	movs	r1, #8
 800703a:	4628      	mov	r0, r5
 800703c:	f7fc f80c 	bl	8003058 <_pal_lld_setgroupmode>
    palSetLine(LINE_SPI5_CS_SR);   /* repos = haut */
 8007040:	2108      	movs	r1, #8
    buttons_tp = chThdCreateStatic(waButtons, sizeof(waButtons),
 8007042:	2200      	movs	r2, #0
 8007044:	4b07      	ldr	r3, [pc, #28]	; (8007064 <drv_buttons_start+0x4c>)
    palSetLine(LINE_SPI5_CS_SR);   /* repos = haut */
 8007046:	8329      	strh	r1, [r5, #24]
    buttons_tp = chThdCreateStatic(waButtons, sizeof(waButtons),
 8007048:	f44f 7138 	mov.w	r1, #736	; 0x2e0
 800704c:	9200      	str	r2, [sp, #0]
 800704e:	2280      	movs	r2, #128	; 0x80
 8007050:	4805      	ldr	r0, [pc, #20]	; (8007068 <drv_buttons_start+0x50>)
 8007052:	f7ff fa29 	bl	80064a8 <chThdCreateStatic>
 8007056:	6020      	str	r0, [r4, #0]
}
 8007058:	b003      	add	sp, #12
 800705a:	bd30      	pop	{r4, r5, pc}
 800705c:	24001780 	.word	0x24001780
 8007060:	58020000 	.word	0x58020000
 8007064:	08006f51 	.word	0x08006f51
 8007068:	240017a0 	.word	0x240017a0

0800706c <drv_display_init>:

/* ====================================================================== */
/*                      INITIALISATION OLED                               */
/* ====================================================================== */

void drv_display_init(void) {
 800706c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /* Reset OLED */
    palClearLine(LINE_SPI5_RES_OLED);
 8007070:	4ce7      	ldr	r4, [pc, #924]	; (8007410 <drv_display_init+0x3a4>)
 8007072:	2510      	movs	r5, #16
void drv_display_init(void) {
 8007074:	b083      	sub	sp, #12
    chThdSleepMilliseconds(10);
 8007076:	2064      	movs	r0, #100	; 0x64
    palClearLine(LINE_SPI5_RES_OLED);
 8007078:	8365      	strh	r5, [r4, #26]
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800707a:	f04f 0820 	mov.w	r8, #32
    chMtxLock(&spi5_mutex);
 800707e:	4ee5      	ldr	r6, [pc, #916]	; (8007414 <drv_display_init+0x3a8>)
    chThdSleepMilliseconds(10);
 8007080:	f7ff fac0 	bl	8006604 <chThdSleep>
    palSetLine(LINE_SPI5_RES_OLED);
 8007084:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(10);
 8007086:	2064      	movs	r0, #100	; 0x64
    spiStart(&SPID5, &spicfg);
 8007088:	4fe3      	ldr	r7, [pc, #908]	; (8007418 <drv_display_init+0x3ac>)
    chThdSleepMilliseconds(10);
 800708a:	f7ff fabb 	bl	8006604 <chThdSleep>
    spiStart(&SPID5, &spicfg);
 800708e:	f8df 938c 	ldr.w	r9, [pc, #908]	; 800741c <drv_display_init+0x3b0>
 8007092:	23ae      	movs	r3, #174	; 0xae
    palClearLine(LINE_SPI5_CS_OLED);
 8007094:	2540      	movs	r5, #64	; 0x40
    chMtxLock(&spi5_mutex);
 8007096:	4630      	mov	r0, r6
 8007098:	f88d 3007 	strb.w	r3, [sp, #7]
 800709c:	f7ff fbfe 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80070a0:	4649      	mov	r1, r9
 80070a2:	4638      	mov	r0, r7
 80070a4:	f7fa fafe 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80070a8:	f10d 0207 	add.w	r2, sp, #7
 80070ac:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80070ae:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80070b2:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80070b4:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80070b6:	f7fa fb07 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80070ba:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80070bc:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80070be:	f04f 0a00 	mov.w	sl, #0
 80070c2:	f7ff fbf5 	bl	80068b0 <chMtxUnlock>

    /* Séquence init SSD1309 / SSD1306 */
    send_cmd(0xAE);
    send_cmd(0xD5); send_cmd(0x80);
 80070c6:	23d5      	movs	r3, #213	; 0xd5
    chMtxLock(&spi5_mutex);
 80070c8:	4630      	mov	r0, r6
 80070ca:	f04f 0b7f 	mov.w	fp, #127	; 0x7f
 80070ce:	f88d 3007 	strb.w	r3, [sp, #7]
 80070d2:	f7ff fbe3 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80070d6:	4649      	mov	r1, r9
 80070d8:	4638      	mov	r0, r7
 80070da:	f7fa fae3 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80070de:	f10d 0207 	add.w	r2, sp, #7
 80070e2:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80070e4:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80070e8:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80070ea:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80070ec:	f7fa faec 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80070f0:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80070f2:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80070f4:	f7ff fbdc 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xD5); send_cmd(0x80);
 80070f8:	2380      	movs	r3, #128	; 0x80
    chMtxLock(&spi5_mutex);
 80070fa:	4630      	mov	r0, r6
 80070fc:	f88d 3007 	strb.w	r3, [sp, #7]
 8007100:	f7ff fbcc 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007104:	4649      	mov	r1, r9
 8007106:	4638      	mov	r0, r7
 8007108:	f7fa facc 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800710c:	f10d 0207 	add.w	r2, sp, #7
 8007110:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007112:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007116:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007118:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800711a:	f7fa fad5 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800711e:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007120:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007122:	f7ff fbc5 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xA8); send_cmd(0x3F);
 8007126:	23a8      	movs	r3, #168	; 0xa8
    chMtxLock(&spi5_mutex);
 8007128:	4630      	mov	r0, r6
 800712a:	f88d 3007 	strb.w	r3, [sp, #7]
 800712e:	f7ff fbb5 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007132:	4649      	mov	r1, r9
 8007134:	4638      	mov	r0, r7
 8007136:	f7fa fab5 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800713a:	f10d 0207 	add.w	r2, sp, #7
 800713e:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007140:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007144:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007146:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007148:	f7fa fabe 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800714c:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 800714e:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007150:	f7ff fbae 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xA8); send_cmd(0x3F);
 8007154:	233f      	movs	r3, #63	; 0x3f
    chMtxLock(&spi5_mutex);
 8007156:	4630      	mov	r0, r6
 8007158:	f88d 3007 	strb.w	r3, [sp, #7]
 800715c:	f7ff fb9e 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007160:	4649      	mov	r1, r9
 8007162:	4638      	mov	r0, r7
 8007164:	f7fa fa9e 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007168:	f10d 0207 	add.w	r2, sp, #7
 800716c:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800716e:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007172:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007174:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007176:	f7fa faa7 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800717a:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 800717c:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 800717e:	f7ff fb97 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xD3); send_cmd(0x00);
 8007182:	23d3      	movs	r3, #211	; 0xd3
    chMtxLock(&spi5_mutex);
 8007184:	4630      	mov	r0, r6
 8007186:	f88d 3007 	strb.w	r3, [sp, #7]
 800718a:	f7ff fb87 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 800718e:	4649      	mov	r1, r9
 8007190:	4638      	mov	r0, r7
 8007192:	f7fa fa87 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007196:	f10d 0207 	add.w	r2, sp, #7
 800719a:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800719c:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80071a0:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80071a2:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80071a4:	f7fa fa90 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80071a8:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80071aa:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80071ac:	f7ff fb80 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 80071b0:	4630      	mov	r0, r6
 80071b2:	f88d a007 	strb.w	sl, [sp, #7]
 80071b6:	f7ff fb71 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80071ba:	4649      	mov	r1, r9
 80071bc:	4638      	mov	r0, r7
 80071be:	f7fa fa71 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80071c2:	f10d 0207 	add.w	r2, sp, #7
 80071c6:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80071c8:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80071cc:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80071ce:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80071d0:	f7fa fa7a 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80071d4:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80071d6:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80071d8:	f7ff fb6a 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 80071dc:	4630      	mov	r0, r6
 80071de:	f88d 5007 	strb.w	r5, [sp, #7]
 80071e2:	f7ff fb5b 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80071e6:	4649      	mov	r1, r9
 80071e8:	4638      	mov	r0, r7
 80071ea:	f7fa fa5b 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80071ee:	f10d 0207 	add.w	r2, sp, #7
 80071f2:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80071f4:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80071f8:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80071fa:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80071fc:	f7fa fa64 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007200:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007202:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007204:	f7ff fb54 	bl	80068b0 <chMtxUnlock>
    send_cmd(0x40);
    send_cmd(0x8D); send_cmd(0x14);
 8007208:	238d      	movs	r3, #141	; 0x8d
    chMtxLock(&spi5_mutex);
 800720a:	4630      	mov	r0, r6
 800720c:	f88d 3007 	strb.w	r3, [sp, #7]
 8007210:	f7ff fb44 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007214:	4649      	mov	r1, r9
 8007216:	4638      	mov	r0, r7
 8007218:	f7fa fa44 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800721c:	f10d 0207 	add.w	r2, sp, #7
 8007220:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007222:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007226:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007228:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800722a:	f7fa fa4d 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800722e:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007230:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007232:	f7ff fb3d 	bl	80068b0 <chMtxUnlock>
    send_cmd(0x8D); send_cmd(0x14);
 8007236:	2314      	movs	r3, #20
    chMtxLock(&spi5_mutex);
 8007238:	4630      	mov	r0, r6
 800723a:	f88d 3007 	strb.w	r3, [sp, #7]
 800723e:	f7ff fb2d 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007242:	4649      	mov	r1, r9
 8007244:	4638      	mov	r0, r7
 8007246:	f7fa fa2d 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800724a:	f10d 0207 	add.w	r2, sp, #7
 800724e:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007250:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007254:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007256:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007258:	f7fa fa36 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800725c:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 800725e:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007260:	f7ff fb26 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 8007264:	4630      	mov	r0, r6
 8007266:	f88d 8007 	strb.w	r8, [sp, #7]
 800726a:	f7ff fb17 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 800726e:	4649      	mov	r1, r9
 8007270:	4638      	mov	r0, r7
 8007272:	f7fa fa17 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007276:	f10d 0207 	add.w	r2, sp, #7
 800727a:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800727c:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007280:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007282:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007284:	f7fa fa20 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007288:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 800728a:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 800728c:	f7ff fb10 	bl	80068b0 <chMtxUnlock>
    send_cmd(0x20); send_cmd(0x02);
 8007290:	2302      	movs	r3, #2
    chMtxLock(&spi5_mutex);
 8007292:	4630      	mov	r0, r6
 8007294:	f88d 3007 	strb.w	r3, [sp, #7]
 8007298:	f7ff fb00 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 800729c:	4649      	mov	r1, r9
 800729e:	4638      	mov	r0, r7
 80072a0:	f7fa fa00 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80072a4:	f10d 0207 	add.w	r2, sp, #7
 80072a8:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80072aa:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80072ae:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80072b0:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80072b2:	f7fa fa09 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80072b6:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80072b8:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80072ba:	f7ff faf9 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xA1);
 80072be:	23a1      	movs	r3, #161	; 0xa1
    chMtxLock(&spi5_mutex);
 80072c0:	4630      	mov	r0, r6
 80072c2:	f88d 3007 	strb.w	r3, [sp, #7]
 80072c6:	f7ff fae9 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80072ca:	4649      	mov	r1, r9
 80072cc:	4638      	mov	r0, r7
 80072ce:	f7fa f9e9 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80072d2:	f10d 0207 	add.w	r2, sp, #7
 80072d6:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80072d8:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80072dc:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80072de:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80072e0:	f7fa f9f2 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80072e4:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80072e6:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80072e8:	f7ff fae2 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xC8);
 80072ec:	23c8      	movs	r3, #200	; 0xc8
    chMtxLock(&spi5_mutex);
 80072ee:	4630      	mov	r0, r6
 80072f0:	f88d 3007 	strb.w	r3, [sp, #7]
 80072f4:	f7ff fad2 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80072f8:	4649      	mov	r1, r9
 80072fa:	4638      	mov	r0, r7
 80072fc:	f7fa f9d2 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007300:	f10d 0207 	add.w	r2, sp, #7
 8007304:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007306:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800730a:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 800730c:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800730e:	f7fa f9db 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007312:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007314:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007316:	f7ff facb 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xDA); send_cmd(0x12);
 800731a:	23da      	movs	r3, #218	; 0xda
    chMtxLock(&spi5_mutex);
 800731c:	4630      	mov	r0, r6
 800731e:	f88d 3007 	strb.w	r3, [sp, #7]
 8007322:	f7ff fabb 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007326:	4649      	mov	r1, r9
 8007328:	4638      	mov	r0, r7
 800732a:	f7fa f9bb 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800732e:	f10d 0207 	add.w	r2, sp, #7
 8007332:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007334:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007338:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 800733a:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800733c:	f7fa f9c4 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007340:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007342:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007344:	f7ff fab4 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xDA); send_cmd(0x12);
 8007348:	2312      	movs	r3, #18
    chMtxLock(&spi5_mutex);
 800734a:	4630      	mov	r0, r6
 800734c:	f88d 3007 	strb.w	r3, [sp, #7]
 8007350:	f7ff faa4 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007354:	4649      	mov	r1, r9
 8007356:	4638      	mov	r0, r7
 8007358:	f7fa f9a4 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800735c:	f10d 0207 	add.w	r2, sp, #7
 8007360:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007362:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007366:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007368:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800736a:	f7fa f9ad 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800736e:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007370:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007372:	f7ff fa9d 	bl	80068b0 <chMtxUnlock>
    send_cmd(0x81); send_cmd(0x7F);
 8007376:	2381      	movs	r3, #129	; 0x81
    chMtxLock(&spi5_mutex);
 8007378:	4630      	mov	r0, r6
 800737a:	f88d 3007 	strb.w	r3, [sp, #7]
 800737e:	f7ff fa8d 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007382:	4649      	mov	r1, r9
 8007384:	4638      	mov	r0, r7
 8007386:	f7fa f98d 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800738a:	f10d 0207 	add.w	r2, sp, #7
 800738e:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007390:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007394:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007396:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007398:	f7fa f996 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800739c:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 800739e:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80073a0:	f7ff fa86 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 80073a4:	4630      	mov	r0, r6
 80073a6:	f88d b007 	strb.w	fp, [sp, #7]
 80073aa:	f7ff fa77 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80073ae:	4649      	mov	r1, r9
 80073b0:	4638      	mov	r0, r7
 80073b2:	f7fa f977 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80073b6:	f10d 0207 	add.w	r2, sp, #7
 80073ba:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80073bc:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80073c0:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80073c2:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80073c4:	f7fa f980 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80073c8:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80073ca:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80073cc:	f7ff fa70 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xD9); send_cmd(0xF1);
 80073d0:	23d9      	movs	r3, #217	; 0xd9
    chMtxLock(&spi5_mutex);
 80073d2:	4630      	mov	r0, r6
 80073d4:	f88d 3007 	strb.w	r3, [sp, #7]
 80073d8:	f7ff fa60 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80073dc:	4649      	mov	r1, r9
 80073de:	4638      	mov	r0, r7
 80073e0:	f7fa f960 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80073e4:	f10d 0207 	add.w	r2, sp, #7
 80073e8:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80073ea:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80073ee:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80073f0:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80073f2:	f7fa f969 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80073f6:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80073f8:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80073fa:	f7ff fa59 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xD9); send_cmd(0xF1);
 80073fe:	23f1      	movs	r3, #241	; 0xf1
    chMtxLock(&spi5_mutex);
 8007400:	4630      	mov	r0, r6
 8007402:	f88d 3007 	strb.w	r3, [sp, #7]
 8007406:	f7ff fa49 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 800740a:	4649      	mov	r1, r9
 800740c:	4638      	mov	r0, r7
 800740e:	e007      	b.n	8007420 <drv_display_init+0x3b4>
 8007410:	58022000 	.word	0x58022000
 8007414:	24001768 	.word	0x24001768
 8007418:	24000b04 	.word	0x24000b04
 800741c:	08014f2c 	.word	0x08014f2c
 8007420:	f7fa f940 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007424:	f10d 0207 	add.w	r2, sp, #7
 8007428:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800742a:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800742e:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007430:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007432:	f7fa f949 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007436:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007438:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 800743a:	f7ff fa39 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xDB); send_cmd(0x40);
 800743e:	23db      	movs	r3, #219	; 0xdb
    chMtxLock(&spi5_mutex);
 8007440:	4630      	mov	r0, r6
 8007442:	f88d 3007 	strb.w	r3, [sp, #7]
 8007446:	f7ff fa29 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 800744a:	4649      	mov	r1, r9
 800744c:	4638      	mov	r0, r7
 800744e:	f7fa f929 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007452:	f10d 0207 	add.w	r2, sp, #7
 8007456:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007458:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800745c:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 800745e:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007460:	f7fa f932 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007464:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007466:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007468:	f7ff fa22 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 800746c:	4630      	mov	r0, r6
 800746e:	f88d 5007 	strb.w	r5, [sp, #7]
 8007472:	f7ff fa13 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007476:	4649      	mov	r1, r9
 8007478:	4638      	mov	r0, r7
 800747a:	f7fa f913 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800747e:	f10d 0207 	add.w	r2, sp, #7
 8007482:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007484:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007488:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 800748a:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800748c:	f7fa f91c 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007490:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007492:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007494:	f7ff fa0c 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xA4);
 8007498:	23a4      	movs	r3, #164	; 0xa4
    chMtxLock(&spi5_mutex);
 800749a:	4630      	mov	r0, r6
 800749c:	f88d 3007 	strb.w	r3, [sp, #7]
 80074a0:	f7ff f9fc 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80074a4:	4649      	mov	r1, r9
 80074a6:	4638      	mov	r0, r7
 80074a8:	f7fa f8fc 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80074ac:	f10d 0207 	add.w	r2, sp, #7
 80074b0:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80074b2:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80074b6:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80074b8:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80074ba:	f7fa f905 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80074be:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80074c0:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80074c2:	f7ff f9f5 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xA6);
 80074c6:	23a6      	movs	r3, #166	; 0xa6
    chMtxLock(&spi5_mutex);
 80074c8:	4630      	mov	r0, r6
 80074ca:	f88d 3007 	strb.w	r3, [sp, #7]
 80074ce:	f7ff f9e5 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80074d2:	4649      	mov	r1, r9
 80074d4:	4638      	mov	r0, r7
 80074d6:	f7fa f8e5 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80074da:	f10d 0207 	add.w	r2, sp, #7
 80074de:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80074e0:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80074e4:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 80074e6:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80074e8:	f7fa f8ee 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80074ec:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80074ee:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80074f0:	f7ff f9de 	bl	80068b0 <chMtxUnlock>
    send_cmd(0x21); send_cmd(0x00); send_cmd(0x7F);
 80074f4:	2321      	movs	r3, #33	; 0x21
    chMtxLock(&spi5_mutex);
 80074f6:	4630      	mov	r0, r6
 80074f8:	f88d 3007 	strb.w	r3, [sp, #7]
 80074fc:	f7ff f9ce 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007500:	4649      	mov	r1, r9
 8007502:	4638      	mov	r0, r7
 8007504:	f7fa f8ce 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007508:	f10d 0207 	add.w	r2, sp, #7
 800750c:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800750e:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007512:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007514:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007516:	f7fa f8d7 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800751a:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 800751c:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 800751e:	f7ff f9c7 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 8007522:	4630      	mov	r0, r6
 8007524:	f88d a007 	strb.w	sl, [sp, #7]
 8007528:	f7ff f9b8 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 800752c:	4649      	mov	r1, r9
 800752e:	4638      	mov	r0, r7
 8007530:	f7fa f8b8 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007534:	f10d 0207 	add.w	r2, sp, #7
 8007538:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800753a:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800753e:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 8007540:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007542:	f7fa f8c1 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007546:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007548:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 800754a:	f7ff f9b1 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 800754e:	4630      	mov	r0, r6
 8007550:	f88d b007 	strb.w	fp, [sp, #7]
 8007554:	f7ff f9a2 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007558:	4649      	mov	r1, r9
 800755a:	4638      	mov	r0, r7
 800755c:	f7fa f8a2 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007560:	f10d 0207 	add.w	r2, sp, #7
 8007564:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007566:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800756a:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 800756c:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800756e:	f7fa f8ab 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007572:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 8007574:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007576:	f7ff f99b 	bl	80068b0 <chMtxUnlock>
    send_cmd(0xAF);
 800757a:	23af      	movs	r3, #175	; 0xaf
    chMtxLock(&spi5_mutex);
 800757c:	4630      	mov	r0, r6
 800757e:	f88d 3007 	strb.w	r3, [sp, #7]
 8007582:	f7ff f98b 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007586:	4649      	mov	r1, r9
 8007588:	4638      	mov	r0, r7
 800758a:	f7fa f88b 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800758e:	f10d 0207 	add.w	r2, sp, #7
 8007592:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007594:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007598:	4638      	mov	r0, r7
    palClearLine(LINE_SPI5_CS_OLED);
 800759a:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800759c:	f7fa f894 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80075a0:	4630      	mov	r0, r6
    palSetLine(LINE_SPI5_CS_OLED);
 80075a2:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80075a4:	f7ff f984 	bl	80068b0 <chMtxUnlock>
/* ====================================================================== */
/*                               CLEAR                                    */
/* ====================================================================== */

void drv_display_clear(void) {
    memset(buffer, 0x00, sizeof(buffer));
 80075a8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80075ac:	4651      	mov	r1, sl
 80075ae:	4804      	ldr	r0, [pc, #16]	; (80075c0 <drv_display_init+0x554>)
 80075b0:	f007 f918 	bl	800e7e4 <memset>
    current_font = &FONT_5X7;
 80075b4:	4b03      	ldr	r3, [pc, #12]	; (80075c4 <drv_display_init+0x558>)
 80075b6:	4a04      	ldr	r2, [pc, #16]	; (80075c8 <drv_display_init+0x55c>)
 80075b8:	601a      	str	r2, [r3, #0]
}
 80075ba:	b003      	add	sp, #12
 80075bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80075c0:	24001a80 	.word	0x24001a80
 80075c4:	24001e80 	.word	0x24001e80
 80075c8:	08014fe8 	.word	0x08014fe8

080075cc <drv_display_clear>:
    memset(buffer, 0x00, sizeof(buffer));
 80075cc:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80075d0:	2100      	movs	r1, #0
 80075d2:	4801      	ldr	r0, [pc, #4]	; (80075d8 <drv_display_clear+0xc>)
 80075d4:	f007 b906 	b.w	800e7e4 <memset>
 80075d8:	24001a80 	.word	0x24001a80

080075dc <drv_display_update>:

/* ====================================================================== */
/*                               UPDATE                                   */
/* ====================================================================== */

void drv_display_update(void) {
 80075dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80075e0:	23b0      	movs	r3, #176	; 0xb0
 80075e2:	b085      	sub	sp, #20
 80075e4:	f8df a16c 	ldr.w	sl, [pc, #364]	; 8007754 <drv_display_update+0x178>
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80075e8:	f04f 0820 	mov.w	r8, #32
    chMtxLock(&spi5_mutex);
 80075ec:	4f56      	ldr	r7, [pc, #344]	; (8007748 <drv_display_update+0x16c>)
    spiStart(&SPID5, &spicfg);
 80075ee:	f8df 9168 	ldr.w	r9, [pc, #360]	; 8007758 <drv_display_update+0x17c>
 80075f2:	4e56      	ldr	r6, [pc, #344]	; (800774c <drv_display_update+0x170>)
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80075f4:	4c56      	ldr	r4, [pc, #344]	; (8007750 <drv_display_update+0x174>)
    palClearLine(LINE_SPI5_CS_OLED);
 80075f6:	2540      	movs	r5, #64	; 0x40
    chMtxLock(&spi5_mutex);
 80075f8:	4638      	mov	r0, r7
 80075fa:	f88d 300f 	strb.w	r3, [sp, #15]
 80075fe:	f04f 0b00 	mov.w	fp, #0
 8007602:	9301      	str	r3, [sp, #4]
 8007604:	f7ff f94a 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007608:	4649      	mov	r1, r9
 800760a:	4630      	mov	r0, r6
 800760c:	f7fa f84a 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007610:	f10d 020f 	add.w	r2, sp, #15
 8007614:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007616:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800761a:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_OLED);
 800761c:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800761e:	f7fa f853 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007622:	4638      	mov	r0, r7
    palSetLine(LINE_SPI5_CS_OLED);
 8007624:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007626:	f7ff f943 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 800762a:	4638      	mov	r0, r7
 800762c:	f88d b00f 	strb.w	fp, [sp, #15]
 8007630:	f7ff f934 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007634:	4649      	mov	r1, r9
 8007636:	4630      	mov	r0, r6
 8007638:	f7fa f834 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800763c:	2101      	movs	r1, #1
 800763e:	f10d 020f 	add.w	r2, sp, #15
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007642:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007646:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_OLED);
 8007648:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 800764a:	f7fa f83d 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800764e:	4638      	mov	r0, r7
    palSetLine(LINE_SPI5_CS_OLED);
 8007650:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007652:	f7ff f92d 	bl	80068b0 <chMtxUnlock>

    for (uint8_t page = 0; page < 8; page++) {
        send_cmd(0xB0 + page);
        send_cmd(0x00);
        send_cmd(0x10);
 8007656:	2210      	movs	r2, #16
    chMtxLock(&spi5_mutex);
 8007658:	4638      	mov	r0, r7
 800765a:	f88d 200f 	strb.w	r2, [sp, #15]
 800765e:	f7ff f91d 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007662:	4649      	mov	r1, r9
 8007664:	4630      	mov	r0, r6
 8007666:	f7fa f81d 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 800766a:	2101      	movs	r1, #1
 800766c:	f10d 020f 	add.w	r2, sp, #15
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 8007670:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007674:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_OLED);
 8007676:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007678:	f7fa f826 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800767c:	4638      	mov	r0, r7
    palSetLine(LINE_SPI5_CS_OLED);
 800767e:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007680:	f7ff f916 	bl	80068b0 <chMtxUnlock>
        send_cmd(0x21); send_cmd(0x00); send_cmd(0x7F);
 8007684:	2221      	movs	r2, #33	; 0x21
    chMtxLock(&spi5_mutex);
 8007686:	4638      	mov	r0, r7
 8007688:	f88d 200f 	strb.w	r2, [sp, #15]
 800768c:	f7ff f906 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007690:	4649      	mov	r1, r9
 8007692:	4630      	mov	r0, r6
 8007694:	f7fa f806 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 8007698:	f10d 020f 	add.w	r2, sp, #15
 800769c:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 800769e:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80076a2:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_OLED);
 80076a4:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80076a6:	f7fa f80f 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80076aa:	4638      	mov	r0, r7
    palSetLine(LINE_SPI5_CS_OLED);
 80076ac:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80076ae:	f7ff f8ff 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 80076b2:	4638      	mov	r0, r7
 80076b4:	f88d b00f 	strb.w	fp, [sp, #15]
 80076b8:	f7ff f8f0 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80076bc:	4649      	mov	r1, r9
 80076be:	4630      	mov	r0, r6
 80076c0:	f7f9 fff0 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80076c4:	2101      	movs	r1, #1
 80076c6:	f10d 020f 	add.w	r2, sp, #15
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80076ca:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80076ce:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_OLED);
 80076d0:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80076d2:	f7f9 fff9 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 80076d6:	4638      	mov	r0, r7
    palSetLine(LINE_SPI5_CS_OLED);
 80076d8:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 80076da:	f7ff f8e9 	bl	80068b0 <chMtxUnlock>
        send_cmd(0x21); send_cmd(0x00); send_cmd(0x7F);
 80076de:	227f      	movs	r2, #127	; 0x7f
    chMtxLock(&spi5_mutex);
 80076e0:	4638      	mov	r0, r7
 80076e2:	f88d 200f 	strb.w	r2, [sp, #15]
 80076e6:	f7ff f8d9 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 80076ea:	4649      	mov	r1, r9
 80076ec:	4630      	mov	r0, r6
 80076ee:	f7f9 ffd9 	bl	80016a4 <spiStart>
    spiSend(&SPID5, 1, &cmd);
 80076f2:	f10d 020f 	add.w	r2, sp, #15
 80076f6:	2101      	movs	r1, #1
static inline void dc_cmd(void)  { palClearLine(LINE_SPI5_DC_OLED); }
 80076f8:	f8a4 801a 	strh.w	r8, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 80076fc:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_OLED);
 80076fe:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, 1, &cmd);
 8007700:	f7f9 ffe2 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 8007704:	4638      	mov	r0, r7
    palSetLine(LINE_SPI5_CS_OLED);
 8007706:	8325      	strh	r5, [r4, #24]
    chMtxUnlock(&spi5_mutex);
 8007708:	f7ff f8d2 	bl	80068b0 <chMtxUnlock>
    chMtxLock(&spi5_mutex);
 800770c:	4638      	mov	r0, r7
 800770e:	f7ff f8c5 	bl	800689c <chMtxLock>
    spiStart(&SPID5, &spicfg);
 8007712:	4649      	mov	r1, r9
 8007714:	4630      	mov	r0, r6
 8007716:	f7f9 ffc5 	bl	80016a4 <spiStart>
    spiSend(&SPID5, len, data);
 800771a:	4652      	mov	r2, sl
 800771c:	2180      	movs	r1, #128	; 0x80
static inline void dc_data(void) { palSetLine  (LINE_SPI5_DC_OLED); }
 800771e:	f8a4 8018 	strh.w	r8, [r4, #24]
    spiSend(&SPID5, len, data);
 8007722:	4630      	mov	r0, r6
    palClearLine(LINE_SPI5_CS_OLED);
 8007724:	8365      	strh	r5, [r4, #26]
    spiSend(&SPID5, len, data);
 8007726:	f7f9 ffcf 	bl	80016c8 <spiSend>
    chMtxUnlock(&spi5_mutex);
 800772a:	4638      	mov	r0, r7
    palSetLine(LINE_SPI5_CS_OLED);
 800772c:	8325      	strh	r5, [r4, #24]
    for (uint8_t page = 0; page < 8; page++) {
 800772e:	f10a 0a80 	add.w	sl, sl, #128	; 0x80
    chMtxUnlock(&spi5_mutex);
 8007732:	f7ff f8bd 	bl	80068b0 <chMtxUnlock>
    for (uint8_t page = 0; page < 8; page++) {
 8007736:	9b01      	ldr	r3, [sp, #4]
 8007738:	3301      	adds	r3, #1
 800773a:	b2db      	uxtb	r3, r3
 800773c:	2bb8      	cmp	r3, #184	; 0xb8
 800773e:	f47f af5a 	bne.w	80075f6 <drv_display_update+0x1a>
        send_data(&buffer[page * BRICK_OLED_WIDTH], BRICK_OLED_WIDTH);
    }
}
 8007742:	b005      	add	sp, #20
 8007744:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007748:	24001768 	.word	0x24001768
 800774c:	24000b04 	.word	0x24000b04
 8007750:	58022000 	.word	0x58022000
 8007754:	24001a80 	.word	0x24001a80
 8007758:	08014f2c 	.word	0x08014f2c

0800775c <displayThread>:
/*                         THREAD DE RAFRAÎCHISSEMENT                      */
/* ====================================================================== */

static THD_WORKING_AREA(waDisplay, 512);

static THD_FUNCTION(displayThread, arg) {
 800775c:	b510      	push	{r4, lr}
 800775e:	4c0c      	ldr	r4, [pc, #48]	; (8007790 <displayThread+0x34>)
 8007760:	490c      	ldr	r1, [pc, #48]	; (8007794 <displayThread+0x38>)
 8007762:	68e3      	ldr	r3, [r4, #12]
    (void)arg;
    chRegSetThreadName("Display");

    while (!chThdShouldTerminateX()) {
 8007764:	f993 201d 	ldrsb.w	r2, [r3, #29]
 8007768:	6219      	str	r1, [r3, #32]
 800776a:	2a00      	cmp	r2, #0
 800776c:	db0a      	blt.n	8007784 <displayThread+0x28>
        drv_display_update();
 800776e:	f7ff ff35 	bl	80075dc <drv_display_update>
        chThdSleepMilliseconds(33);
 8007772:	f44f 70a5 	mov.w	r0, #330	; 0x14a
 8007776:	f7fe ff45 	bl	8006604 <chThdSleep>
 800777a:	68e3      	ldr	r3, [r4, #12]
    while (!chThdShouldTerminateX()) {
 800777c:	f993 301d 	ldrsb.w	r3, [r3, #29]
 8007780:	2b00      	cmp	r3, #0
 8007782:	daf4      	bge.n	800776e <displayThread+0x12>
    }

    chThdExit(MSG_OK);
 8007784:	2000      	movs	r0, #0
}
 8007786:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chThdExit(MSG_OK);
 800778a:	f7fe bee1 	b.w	8006550 <chThdExit>
 800778e:	bf00      	nop
 8007790:	24000c20 	.word	0x24000c20
 8007794:	08014f24 	.word	0x08014f24

08007798 <drv_display_draw_char>:
void drv_display_draw_char(uint8_t x, uint8_t y, char c) {
 8007798:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!current_font) return;
 800779c:	4b2c      	ldr	r3, [pc, #176]	; (8007850 <drv_display_draw_char+0xb8>)
 800779e:	f8d3 b000 	ldr.w	fp, [r3]
 80077a2:	f1bb 0f00 	cmp.w	fp, #0
 80077a6:	d04d      	beq.n	8007844 <drv_display_draw_char+0xac>
    if ((uint8_t)c < current_font->first || (uint8_t)c > current_font->last)
 80077a8:	f89b 3006 	ldrb.w	r3, [fp, #6]
 80077ac:	460e      	mov	r6, r1
 80077ae:	4692      	mov	sl, r2
 80077b0:	4293      	cmp	r3, r2
 80077b2:	d849      	bhi.n	8007848 <drv_display_draw_char+0xb0>
 80077b4:	f89b 3007 	ldrb.w	r3, [fp, #7]
        c = '?';
 80077b8:	4293      	cmp	r3, r2
 80077ba:	bf38      	it	cc
 80077bc:	f04f 0a3f 	movcc.w	sl, #63	; 0x3f
    for (uint8_t col = 0; col < current_font->width; col++) {
 80077c0:	f89b 3004 	ldrb.w	r3, [fp, #4]
 80077c4:	2b00      	cmp	r3, #0
 80077c6:	d03d      	beq.n	8007844 <drv_display_draw_char+0xac>
 80077c8:	2500      	movs	r5, #0
 80077ca:	46b0      	mov	r8, r6
    if (on) buffer[index] |=  mask;
 80077cc:	4f21      	ldr	r7, [pc, #132]	; (8007854 <drv_display_draw_char+0xbc>)
    const uint8_t mask = (uint8_t)(1U << (y & 7));
 80077ce:	f04f 0901 	mov.w	r9, #1
 80077d2:	462c      	mov	r4, r5
 80077d4:	462e      	mov	r6, r5
 80077d6:	4605      	mov	r5, r0
        uint8_t bits = current_font->get_col(c, col);
 80077d8:	f8db 300c 	ldr.w	r3, [fp, #12]
 80077dc:	4621      	mov	r1, r4
 80077de:	4650      	mov	r0, sl
 80077e0:	4798      	blx	r3
        for (uint8_t row = 0; row < current_font->height; row++) {
 80077e2:	4b1b      	ldr	r3, [pc, #108]	; (8007850 <drv_display_draw_char+0xb8>)
 80077e4:	f8d3 b000 	ldr.w	fp, [r3]
 80077e8:	f89b c005 	ldrb.w	ip, [fp, #5]
 80077ec:	f1bc 0f00 	cmp.w	ip, #0
 80077f0:	d022      	beq.n	8007838 <drv_display_draw_char+0xa0>
            if (bits & (1U << row))
 80077f2:	2200      	movs	r2, #0
                set_pixel(x + col, y + row, true);
 80077f4:	1961      	adds	r1, r4, r5
 80077f6:	4613      	mov	r3, r2
 80077f8:	e002      	b.n	8007800 <drv_display_draw_char+0x68>
        for (uint8_t row = 0; row < current_font->height; row++) {
 80077fa:	b2d3      	uxtb	r3, r2
 80077fc:	459c      	cmp	ip, r3
 80077fe:	d91b      	bls.n	8007838 <drv_display_draw_char+0xa0>
            if (bits & (1U << row))
 8007800:	fa20 f403 	lsr.w	r4, r0, r3
        for (uint8_t row = 0; row < current_font->height; row++) {
 8007804:	3201      	adds	r2, #1
            if (bits & (1U << row))
 8007806:	07e4      	lsls	r4, r4, #31
 8007808:	d5f7      	bpl.n	80077fa <drv_display_draw_char+0x62>
                set_pixel(x + col, y + row, true);
 800780a:	4443      	add	r3, r8
    if (x < 0 || x >= BRICK_OLED_WIDTH || y < 0 || y >= BRICK_OLED_HEIGHT) return;
 800780c:	297f      	cmp	r1, #127	; 0x7f
    const int index = x + (y >> 3) * BRICK_OLED_WIDTH;
 800780e:	ea4f 0ee3 	mov.w	lr, r3, asr #3
    const uint8_t mask = (uint8_t)(1U << (y & 7));
 8007812:	f003 0407 	and.w	r4, r3, #7
    if (x < 0 || x >= BRICK_OLED_WIDTH || y < 0 || y >= BRICK_OLED_HEIGHT) return;
 8007816:	d8f0      	bhi.n	80077fa <drv_display_draw_char+0x62>
 8007818:	2b3f      	cmp	r3, #63	; 0x3f
    const int index = x + (y >> 3) * BRICK_OLED_WIDTH;
 800781a:	eb01 1ece 	add.w	lr, r1, lr, lsl #7
    const uint8_t mask = (uint8_t)(1U << (y & 7));
 800781e:	fa09 f404 	lsl.w	r4, r9, r4
    if (x < 0 || x >= BRICK_OLED_WIDTH || y < 0 || y >= BRICK_OLED_HEIGHT) return;
 8007822:	dcea      	bgt.n	80077fa <drv_display_draw_char+0x62>
    if (on) buffer[index] |=  mask;
 8007824:	f817 300e 	ldrb.w	r3, [r7, lr]
 8007828:	431c      	orrs	r4, r3
        for (uint8_t row = 0; row < current_font->height; row++) {
 800782a:	b2d3      	uxtb	r3, r2
    if (on) buffer[index] |=  mask;
 800782c:	f807 400e 	strb.w	r4, [r7, lr]
 8007830:	f89b c005 	ldrb.w	ip, [fp, #5]
        for (uint8_t row = 0; row < current_font->height; row++) {
 8007834:	459c      	cmp	ip, r3
 8007836:	d8e3      	bhi.n	8007800 <drv_display_draw_char+0x68>
    for (uint8_t col = 0; col < current_font->width; col++) {
 8007838:	3601      	adds	r6, #1
 800783a:	f89b 3004 	ldrb.w	r3, [fp, #4]
 800783e:	b2f4      	uxtb	r4, r6
 8007840:	42a3      	cmp	r3, r4
 8007842:	d8c9      	bhi.n	80077d8 <drv_display_draw_char+0x40>
}
 8007844:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        c = '?';
 8007848:	f04f 0a3f 	mov.w	sl, #63	; 0x3f
 800784c:	e7b8      	b.n	80077c0 <drv_display_draw_char+0x28>
 800784e:	bf00      	nop
 8007850:	24001e80 	.word	0x24001e80
 8007854:	24001a80 	.word	0x24001a80

08007858 <drv_display_draw_text>:
void drv_display_draw_text(uint8_t x, uint8_t y, const char *txt) {
 8007858:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (!current_font || !txt) return;
 800785a:	4b0d      	ldr	r3, [pc, #52]	; (8007890 <drv_display_draw_text+0x38>)
 800785c:	681b      	ldr	r3, [r3, #0]
 800785e:	b1aa      	cbz	r2, 800788c <drv_display_draw_text+0x34>
 8007860:	b1a3      	cbz	r3, 800788c <drv_display_draw_text+0x34>
    return (uint8_t)(f->width + f->spacing);
 8007862:	791e      	ldrb	r6, [r3, #4]
 8007864:	4615      	mov	r5, r2
 8007866:	7a1b      	ldrb	r3, [r3, #8]
    while (*txt && x < BRICK_OLED_WIDTH) {
 8007868:	7812      	ldrb	r2, [r2, #0]
    return (uint8_t)(f->width + f->spacing);
 800786a:	441e      	add	r6, r3
 800786c:	b2f6      	uxtb	r6, r6
    while (*txt && x < BRICK_OLED_WIDTH) {
 800786e:	b16a      	cbz	r2, 800788c <drv_display_draw_text+0x34>
 8007870:	4604      	mov	r4, r0
 8007872:	460f      	mov	r7, r1
 8007874:	e008      	b.n	8007888 <drv_display_draw_text+0x30>
        drv_display_draw_char(x, y, *txt++);
 8007876:	4620      	mov	r0, r4
 8007878:	4639      	mov	r1, r7
        x = (uint8_t)(x + adv);
 800787a:	4434      	add	r4, r6
        drv_display_draw_char(x, y, *txt++);
 800787c:	f7ff ff8c 	bl	8007798 <drv_display_draw_char>
    while (*txt && x < BRICK_OLED_WIDTH) {
 8007880:	f815 2f01 	ldrb.w	r2, [r5, #1]!
        x = (uint8_t)(x + adv);
 8007884:	b2e4      	uxtb	r4, r4
    while (*txt && x < BRICK_OLED_WIDTH) {
 8007886:	b10a      	cbz	r2, 800788c <drv_display_draw_text+0x34>
 8007888:	0623      	lsls	r3, r4, #24
 800788a:	d5f4      	bpl.n	8007876 <drv_display_draw_text+0x1e>
}
 800788c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800788e:	bf00      	nop
 8007890:	24001e80 	.word	0x24001e80

08007894 <drv_display_start>:

void drv_display_start(void) {
 8007894:	b510      	push	{r4, lr}
    if (display_tp != NULL) {
 8007896:	4c0d      	ldr	r4, [pc, #52]	; (80078cc <drv_display_start+0x38>)
void drv_display_start(void) {
 8007898:	b082      	sub	sp, #8
    if (display_tp != NULL) {
 800789a:	6820      	ldr	r0, [r4, #0]
 800789c:	b140      	cbz	r0, 80078b0 <drv_display_start+0x1c>
        if (chThdTerminatedX(display_tp)) {
 800789e:	7f03      	ldrb	r3, [r0, #28]
 80078a0:	2b0f      	cmp	r3, #15
 80078a2:	d001      	beq.n	80078a8 <drv_display_start+0x14>

    drv_display_init();

    display_tp = chThdCreateStatic(waDisplay, sizeof(waDisplay),
                                   NORMALPRIO, displayThread, NULL);
}
 80078a4:	b002      	add	sp, #8
 80078a6:	bd10      	pop	{r4, pc}
            chThdWait(display_tp);
 80078a8:	f7fe fe7a 	bl	80065a0 <chThdWait>
            display_tp = NULL;
 80078ac:	2300      	movs	r3, #0
 80078ae:	6023      	str	r3, [r4, #0]
    drv_display_init();
 80078b0:	f7ff fbdc 	bl	800706c <drv_display_init>
    display_tp = chThdCreateStatic(waDisplay, sizeof(waDisplay),
 80078b4:	2000      	movs	r0, #0
 80078b6:	4b06      	ldr	r3, [pc, #24]	; (80078d0 <drv_display_start+0x3c>)
 80078b8:	2280      	movs	r2, #128	; 0x80
 80078ba:	f44f 7178 	mov.w	r1, #992	; 0x3e0
 80078be:	9000      	str	r0, [sp, #0]
 80078c0:	4804      	ldr	r0, [pc, #16]	; (80078d4 <drv_display_start+0x40>)
 80078c2:	f7fe fdf1 	bl	80064a8 <chThdCreateStatic>
 80078c6:	6020      	str	r0, [r4, #0]
}
 80078c8:	b002      	add	sp, #8
 80078ca:	bd10      	pop	{r4, pc}
 80078cc:	24001e84 	.word	0x24001e84
 80078d0:	0800775d 	.word	0x0800775d
 80078d4:	24001ea0 	.word	0x24001ea0

080078d8 <drv_encoders_start>:
/*                          API PUBLIQUE                                 */
/* --------------------------------------------------------------------- */

void drv_encoders_start(void) {

    if (encoders_started)
 80078d8:	4844      	ldr	r0, [pc, #272]	; (80079ec <drv_encoders_start+0x114>)
 80078da:	7803      	ldrb	r3, [r0, #0]
 80078dc:	b103      	cbz	r3, 80078e0 <drv_encoders_start+0x8>
 80078de:	4770      	bx	lr
  RCC_C1->APB1LENR |= mask;
 80078e0:	4a43      	ldr	r2, [pc, #268]	; (80079f0 <drv_encoders_start+0x118>)
    tim->CR1 = 0;
 80078e2:	4944      	ldr	r1, [pc, #272]	; (80079f4 <drv_encoders_start+0x11c>)
void drv_encoders_start(void) {
 80078e4:	b470      	push	{r4, r5, r6}
 80078e6:	f8d2 40e8 	ldr.w	r4, [r2, #232]	; 0xe8
    tim->ARR = 0xFFFF;
 80078ea:	f64f 76ff 	movw	r6, #65535	; 0xffff
    tim->CCMR1 =
 80078ee:	f240 1501 	movw	r5, #257	; 0x101
 80078f2:	f044 0401 	orr.w	r4, r4, #1
 80078f6:	f8c2 40e8 	str.w	r4, [r2, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 80078fa:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
 80078fe:	f044 0401 	orr.w	r4, r4, #1
 8007902:	f8c2 4110 	str.w	r4, [r2, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 8007906:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
  RCC_C1->APB1LENR |= mask;
 800790a:	f8d2 40e8 	ldr.w	r4, [r2, #232]	; 0xe8
 800790e:	f044 0402 	orr.w	r4, r4, #2
 8007912:	f8c2 40e8 	str.w	r4, [r2, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 8007916:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
 800791a:	f044 0402 	orr.w	r4, r4, #2
 800791e:	f8c2 4110 	str.w	r4, [r2, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 8007922:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
  RCC_C1->APB1LENR |= mask;
 8007926:	f8d2 40e8 	ldr.w	r4, [r2, #232]	; 0xe8
 800792a:	f044 0404 	orr.w	r4, r4, #4
 800792e:	f8c2 40e8 	str.w	r4, [r2, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 8007932:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
 8007936:	f044 0404 	orr.w	r4, r4, #4
 800793a:	f8c2 4110 	str.w	r4, [r2, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 800793e:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
  RCC_C1->APB1LENR |= mask;
 8007942:	f8d2 40e8 	ldr.w	r4, [r2, #232]	; 0xe8
 8007946:	f044 0408 	orr.w	r4, r4, #8
 800794a:	f8c2 40e8 	str.w	r4, [r2, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 800794e:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
 8007952:	f044 0408 	orr.w	r4, r4, #8
 8007956:	f8c2 4110 	str.w	r4, [r2, #272]	; 0x110
    tim->SMCR = (3U << TIM_SMCR_SMS_Pos);
 800795a:	2403      	movs	r4, #3
  (void)RCC_C1->APB1LLPENR;
 800795c:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
    tim->CR1 = 0;
 8007960:	600b      	str	r3, [r1, #0]
    tim->CNT = 0;
 8007962:	624b      	str	r3, [r1, #36]	; 0x24
    tim->PSC = 0;
 8007964:	628b      	str	r3, [r1, #40]	; 0x28
    tim->ARR = 0xFFFF;
 8007966:	62ce      	str	r6, [r1, #44]	; 0x2c
    tim->CCMR1 =
 8007968:	618d      	str	r5, [r1, #24]
    tim->CCER = 0;
 800796a:	620b      	str	r3, [r1, #32]
    tim->SMCR = (3U << TIM_SMCR_SMS_Pos);
 800796c:	608c      	str	r4, [r1, #8]
    tim->SR = 0;
 800796e:	610b      	str	r3, [r1, #16]
    tim->CR1 |= TIM_CR1_CEN;
 8007970:	680a      	ldr	r2, [r1, #0]
 8007972:	f042 0201 	orr.w	r2, r2, #1
 8007976:	600a      	str	r2, [r1, #0]
    tim->CR1 = 0;
 8007978:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800797c:	6013      	str	r3, [r2, #0]
    tim->CNT = 0;
 800797e:	6253      	str	r3, [r2, #36]	; 0x24
    tim->PSC = 0;
 8007980:	6293      	str	r3, [r2, #40]	; 0x28
    tim->ARR = 0xFFFF;
 8007982:	62d6      	str	r6, [r2, #44]	; 0x2c
    tim->CCMR1 =
 8007984:	6195      	str	r5, [r2, #24]
    tim->CCER = 0;
 8007986:	6213      	str	r3, [r2, #32]
    tim->SMCR = (3U << TIM_SMCR_SMS_Pos);
 8007988:	6094      	str	r4, [r2, #8]
    tim->SR = 0;
 800798a:	6113      	str	r3, [r2, #16]
    tim->CR1 |= TIM_CR1_CEN;
 800798c:	6811      	ldr	r1, [r2, #0]
 800798e:	f041 0101 	orr.w	r1, r1, #1
 8007992:	6011      	str	r1, [r2, #0]
    tim->CR1 = 0;
 8007994:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8007998:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
    tim->CNT = 0;
 800799c:	f8c2 3424 	str.w	r3, [r2, #1060]	; 0x424
    tim->PSC = 0;
 80079a0:	f8c2 3428 	str.w	r3, [r2, #1064]	; 0x428
    tim->ARR = 0xFFFF;
 80079a4:	f8c2 642c 	str.w	r6, [r2, #1068]	; 0x42c
    tim->CCMR1 =
 80079a8:	f8c2 5418 	str.w	r5, [r2, #1048]	; 0x418
    tim->CCER = 0;
 80079ac:	f8c2 3420 	str.w	r3, [r2, #1056]	; 0x420
    tim->SMCR = (3U << TIM_SMCR_SMS_Pos);
 80079b0:	f8c2 4408 	str.w	r4, [r2, #1032]	; 0x408
    tim->SR = 0;
 80079b4:	f8c2 3410 	str.w	r3, [r2, #1040]	; 0x410
    tim->CR1 |= TIM_CR1_CEN;
 80079b8:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
 80079bc:	f041 0101 	orr.w	r1, r1, #1
 80079c0:	f8c2 1400 	str.w	r1, [r2, #1024]	; 0x400
    tim->CR1 = 0;
 80079c4:	6013      	str	r3, [r2, #0]
    tim->CNT = 0;
 80079c6:	6253      	str	r3, [r2, #36]	; 0x24
    tim->PSC = 0;
 80079c8:	6293      	str	r3, [r2, #40]	; 0x28
    tim->ARR = 0xFFFF;
 80079ca:	62d6      	str	r6, [r2, #44]	; 0x2c
    tim->CCMR1 =
 80079cc:	6195      	str	r5, [r2, #24]
    tim->CCER = 0;
 80079ce:	6213      	str	r3, [r2, #32]
    tim->SMCR = (3U << TIM_SMCR_SMS_Pos);
 80079d0:	6094      	str	r4, [r2, #8]
    tim->SR = 0;
 80079d2:	6113      	str	r3, [r2, #16]
    tim->CR1 |= TIM_CR1_CEN;
 80079d4:	6811      	ldr	r1, [r2, #0]
    encoder_tim_init(TIM2);
    encoder_tim_init(TIM5);
    encoder_tim_init(TIM4);

    for (int i = 0; i < ENCODER_COUNT; i++)
        last_val[i] = 0;
 80079d6:	4c08      	ldr	r4, [pc, #32]	; (80079f8 <drv_encoders_start+0x120>)
    tim->CR1 |= TIM_CR1_CEN;
 80079d8:	f041 0101 	orr.w	r1, r1, #1
        last_val[i] = 0;
 80079dc:	6063      	str	r3, [r4, #4]
    tim->CR1 |= TIM_CR1_CEN;
 80079de:	6011      	str	r1, [r2, #0]

    encoders_started = true;
 80079e0:	2201      	movs	r2, #1
        last_val[i] = 0;
 80079e2:	6023      	str	r3, [r4, #0]
    encoders_started = true;
 80079e4:	7002      	strb	r2, [r0, #0]
}
 80079e6:	bc70      	pop	{r4, r5, r6}
 80079e8:	4770      	bx	lr
 80079ea:	bf00      	nop
 80079ec:	24002280 	.word	0x24002280
 80079f0:	58024400 	.word	0x58024400
 80079f4:	40000400 	.word	0x40000400
 80079f8:	24002284 	.word	0x24002284

080079fc <ws_dma_callback>:

    const uint32_t error_flags = STM32_DMA_ISR_TEIF |
                                 STM32_DMA_ISR_DMEIF |
                                 STM32_DMA_ISR_FEIF;

    if ((flags & error_flags) != 0U) {
 80079fc:	f011 030d 	ands.w	r3, r1, #13
static void ws_dma_callback(void *p, uint32_t flags) {
 8007a00:	b510      	push	{r4, lr}
    if ((flags & error_flags) != 0U) {
 8007a02:	d111      	bne.n	8007a28 <ws_dma_callback+0x2c>
        chBSemSignalI(&led_dma_sem);
        chSysUnlockFromISR();
        return;
    }

    if ((flags & STM32_DMA_ISR_TCIF) != 0U) {
 8007a04:	068a      	lsls	r2, r1, #26
 8007a06:	d50e      	bpl.n	8007a26 <ws_dma_callback+0x2a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007a08:	2230      	movs	r2, #48	; 0x30
 8007a0a:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8007a0e:	4811      	ldr	r0, [pc, #68]	; (8007a54 <ws_dma_callback+0x58>)
        chSysLockFromISR();
        led_dma_busy = false;
        led_dma_tc_pending = true;
 8007a10:	2101      	movs	r1, #1
        led_dma_busy = false;
 8007a12:	4c11      	ldr	r4, [pc, #68]	; (8007a58 <ws_dma_callback+0x5c>)
        led_dma_tc_pending = true;
 8007a14:	4a11      	ldr	r2, [pc, #68]	; (8007a5c <ws_dma_callback+0x60>)
        led_dma_busy = false;
 8007a16:	7023      	strb	r3, [r4, #0]
 8007a18:	6883      	ldr	r3, [r0, #8]
        led_dma_tc_pending = true;
 8007a1a:	7011      	strb	r1, [r2, #0]
 8007a1c:	2b00      	cmp	r3, #0
 8007a1e:	dd16      	ble.n	8007a4e <ws_dma_callback+0x52>
 8007a20:	2300      	movs	r3, #0
 8007a22:	f383 8811 	msr	BASEPRI, r3
        chBSemSignalI(&led_dma_sem);
        chSysUnlockFromISR();
    }
}
 8007a26:	bd10      	pop	{r4, pc}
 8007a28:	2330      	movs	r3, #48	; 0x30
 8007a2a:	f383 8811 	msr	BASEPRI, r3
        led_dma_errors++;
 8007a2e:	4a0c      	ldr	r2, [pc, #48]	; (8007a60 <ws_dma_callback+0x64>)
        led_dma_busy = false;
 8007a30:	f04f 0c00 	mov.w	ip, #0
 8007a34:	4807      	ldr	r0, [pc, #28]	; (8007a54 <ws_dma_callback+0x58>)
        led_dma_errors++;
 8007a36:	6813      	ldr	r3, [r2, #0]
        led_dma_busy = false;
 8007a38:	4907      	ldr	r1, [pc, #28]	; (8007a58 <ws_dma_callback+0x5c>)
        led_dma_errors++;
 8007a3a:	3301      	adds	r3, #1
 8007a3c:	6013      	str	r3, [r2, #0]
        led_dma_error_pending = true;
 8007a3e:	2201      	movs	r2, #1
 8007a40:	4b08      	ldr	r3, [pc, #32]	; (8007a64 <ws_dma_callback+0x68>)
        led_dma_busy = false;
 8007a42:	f881 c000 	strb.w	ip, [r1]
        led_dma_error_pending = true;
 8007a46:	701a      	strb	r2, [r3, #0]
 8007a48:	6883      	ldr	r3, [r0, #8]
 8007a4a:	4563      	cmp	r3, ip
 8007a4c:	dce8      	bgt.n	8007a20 <ws_dma_callback+0x24>
    chSemSignalI(&bsp->sem);
 8007a4e:	f7fe feaf 	bl	80067b0 <chSemSignalI>
 8007a52:	e7e5      	b.n	8007a20 <ws_dma_callback+0x24>
 8007a54:	240022f0 	.word	0x240022f0
 8007a58:	240022df 	.word	0x240022df
 8007a5c:	240022fc 	.word	0x240022fc
 8007a60:	240022e8 	.word	0x240022e8
 8007a64:	240022e4 	.word	0x240022e4

08007a68 <led_dma_thread>:
 8007a68:	4b40      	ldr	r3, [pc, #256]	; (8007b6c <led_dma_thread+0x104>)
 8007a6a:	4a41      	ldr	r2, [pc, #260]	; (8007b70 <led_dma_thread+0x108>)
 8007a6c:	68db      	ldr	r3, [r3, #12]
static THD_FUNCTION(led_dma_thread, arg) {
 8007a6e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007a72:	4f40      	ldr	r7, [pc, #256]	; (8007b74 <led_dma_thread+0x10c>)
 8007a74:	b083      	sub	sp, #12
 8007a76:	4e40      	ldr	r6, [pc, #256]	; (8007b78 <led_dma_thread+0x110>)
 8007a78:	f8df b128 	ldr.w	fp, [pc, #296]	; 8007ba4 <led_dma_thread+0x13c>
 8007a7c:	f8df a128 	ldr.w	sl, [pc, #296]	; 8007ba8 <led_dma_thread+0x140>
 8007a80:	621a      	str	r2, [r3, #32]
  return chSemWait(&bsp->sem);
 8007a82:	f8df 9128 	ldr.w	r9, [pc, #296]	; 8007bac <led_dma_thread+0x144>
 8007a86:	f04f 0830 	mov.w	r8, #48	; 0x30
 8007a8a:	4648      	mov	r0, r9
 8007a8c:	f7fe fe48 	bl	8006720 <chSemWait>
 8007a90:	f388 8811 	msr	BASEPRI, r8
        led_dma_error_pending = false;
 8007a94:	2400      	movs	r4, #0
        error_pending = led_dma_error_pending;
 8007a96:	783d      	ldrb	r5, [r7, #0]
        tc_pending = led_dma_tc_pending;
 8007a98:	7833      	ldrb	r3, [r6, #0]
        error_pending = led_dma_error_pending;
 8007a9a:	b2ed      	uxtb	r5, r5
        led_dma_error_pending = false;
 8007a9c:	703c      	strb	r4, [r7, #0]
        tc_pending = led_dma_tc_pending;
 8007a9e:	b2db      	uxtb	r3, r3
        led_dma_tc_pending = false;
 8007aa0:	7034      	strb	r4, [r6, #0]
        frame_start_snapshot = last_frame_start;
 8007aa2:	f8db 2000 	ldr.w	r2, [fp]
 8007aa6:	f384 8811 	msr	BASEPRI, r4
    if (tc_pending) {
 8007aaa:	b983      	cbnz	r3, 8007ace <led_dma_thread+0x66>
    if (error_pending) {
 8007aac:	2d00      	cmp	r5, #0
 8007aae:	d0ec      	beq.n	8007a8a <led_dma_thread+0x22>
        led_dma_consecutive_errors++;
 8007ab0:	f8da 3000 	ldr.w	r3, [sl]
 8007ab4:	3301      	adds	r3, #1
        if (led_dma_consecutive_errors > LED_DMA_MAX_RETRIES) {
 8007ab6:	2b02      	cmp	r3, #2
        led_dma_consecutive_errors++;
 8007ab8:	f8ca 3000 	str.w	r3, [sl]
        if (led_dma_consecutive_errors > LED_DMA_MAX_RETRIES) {
 8007abc:	d91d      	bls.n	8007afa <led_dma_thread+0x92>
            led_dma_enabled = false;
 8007abe:	2300      	movs	r3, #0
 8007ac0:	4a2e      	ldr	r2, [pc, #184]	; (8007b7c <led_dma_thread+0x114>)
 8007ac2:	7013      	strb	r3, [r2, #0]
            led_dma_retry_exhausted++;
 8007ac4:	4a2e      	ldr	r2, [pc, #184]	; (8007b80 <led_dma_thread+0x118>)
 8007ac6:	6813      	ldr	r3, [r2, #0]
 8007ac8:	3301      	adds	r3, #1
 8007aca:	6013      	str	r3, [r2, #0]
            return;
 8007acc:	e7d9      	b.n	8007a82 <led_dma_thread+0x1a>
 8007ace:	9201      	str	r2, [sp, #4]
 8007ad0:	f7f9 f894 	bl	8000bfc <stGetCounter>
        last_frame_time_us = TIME_I2US(chVTTimeElapsedSinceX(frame_start_snapshot));
 8007ad4:	f242 710f 	movw	r1, #9999	; 0x270f
 8007ad8:	9a01      	ldr	r2, [sp, #4]
 8007ada:	1a83      	subs	r3, r0, r2
 8007adc:	4608      	mov	r0, r1
 8007ade:	4a29      	ldr	r2, [pc, #164]	; (8007b84 <led_dma_thread+0x11c>)
 8007ae0:	4621      	mov	r1, r4
 8007ae2:	fbe3 0102 	umlal	r0, r1, r3, r2
 8007ae6:	2300      	movs	r3, #0
 8007ae8:	f242 7210 	movw	r2, #10000	; 0x2710
 8007aec:	f7f8 fcb4 	bl	8000458 <__aeabi_uldivmod>
 8007af0:	4b25      	ldr	r3, [pc, #148]	; (8007b88 <led_dma_thread+0x120>)
        led_dma_consecutive_errors = 0;
 8007af2:	f8ca 4000 	str.w	r4, [sl]
        last_frame_time_us = TIME_I2US(chVTTimeElapsedSinceX(frame_start_snapshot));
 8007af6:	6018      	str	r0, [r3, #0]
        led_dma_consecutive_errors = 0;
 8007af8:	e7d8      	b.n	8007aac <led_dma_thread+0x44>
        chMtxLock(&leds_mutex);
 8007afa:	4824      	ldr	r0, [pc, #144]	; (8007b8c <led_dma_thread+0x124>)
 8007afc:	f7fe fece 	bl	800689c <chMtxLock>
        if (!led_dma_busy && led_dma_enabled) {
 8007b00:	4b23      	ldr	r3, [pc, #140]	; (8007b90 <led_dma_thread+0x128>)
 8007b02:	781b      	ldrb	r3, [r3, #0]
 8007b04:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8007b08:	b913      	cbnz	r3, 8007b10 <led_dma_thread+0xa8>
 8007b0a:	4b1c      	ldr	r3, [pc, #112]	; (8007b7c <led_dma_thread+0x114>)
 8007b0c:	781b      	ldrb	r3, [r3, #0]
 8007b0e:	b91b      	cbnz	r3, 8007b18 <led_dma_thread+0xb0>
        chMtxUnlock(&leds_mutex);
 8007b10:	481e      	ldr	r0, [pc, #120]	; (8007b8c <led_dma_thread+0x124>)
 8007b12:	f7fe fecd 	bl	80068b0 <chMtxUnlock>
 8007b16:	e7b4      	b.n	8007a82 <led_dma_thread+0x1a>
    TIM_WS->EGR = TIM_EGR_UG;
 8007b18:	491e      	ldr	r1, [pc, #120]	; (8007b94 <led_dma_thread+0x12c>)
 8007b1a:	2301      	movs	r3, #1
 8007b1c:	614b      	str	r3, [r1, #20]
    dmaStreamDisable(ws_dma_stream);
 8007b1e:	4b1e      	ldr	r3, [pc, #120]	; (8007b98 <led_dma_thread+0x130>)
    TIM_WS->CNT = 0;
 8007b20:	624a      	str	r2, [r1, #36]	; 0x24
    dmaStreamDisable(ws_dma_stream);
 8007b22:	6819      	ldr	r1, [r3, #0]
 8007b24:	680a      	ldr	r2, [r1, #0]
 8007b26:	6813      	ldr	r3, [r2, #0]
 8007b28:	f023 031f 	bic.w	r3, r3, #31
 8007b2c:	6013      	str	r3, [r2, #0]
 8007b2e:	6813      	ldr	r3, [r2, #0]
 8007b30:	07db      	lsls	r3, r3, #31
 8007b32:	d4fc      	bmi.n	8007b2e <led_dma_thread+0xc6>
 8007b34:	7b08      	ldrb	r0, [r1, #12]
 8007b36:	233d      	movs	r3, #61	; 0x3d
 8007b38:	6849      	ldr	r1, [r1, #4]
 8007b3a:	4083      	lsls	r3, r0
 8007b3c:	600b      	str	r3, [r1, #0]
    dmaStreamSetTransactionSize(ws_dma_stream, LED_TOTAL_SLOTS);
 8007b3e:	f44f 712a 	mov.w	r1, #680	; 0x2a8
    dmaStreamSetMemory0(ws_dma_stream, pwm_buffer);
 8007b42:	4b16      	ldr	r3, [pc, #88]	; (8007b9c <led_dma_thread+0x134>)
 8007b44:	60d3      	str	r3, [r2, #12]
    dmaStreamSetMode(ws_dma_stream, ws_dma_mode);
 8007b46:	4b16      	ldr	r3, [pc, #88]	; (8007ba0 <led_dma_thread+0x138>)
    dmaStreamSetTransactionSize(ws_dma_stream, LED_TOTAL_SLOTS);
 8007b48:	6051      	str	r1, [r2, #4]
    dmaStreamSetMode(ws_dma_stream, ws_dma_mode);
 8007b4a:	681b      	ldr	r3, [r3, #0]
 8007b4c:	6013      	str	r3, [r2, #0]
    led_dma_busy = true;
 8007b4e:	2301      	movs	r3, #1
 8007b50:	4a0f      	ldr	r2, [pc, #60]	; (8007b90 <led_dma_thread+0x128>)
 8007b52:	7013      	strb	r3, [r2, #0]
 8007b54:	f7f9 f852 	bl	8000bfc <stGetCounter>
    dmaStreamEnable(ws_dma_stream);
 8007b58:	4b0f      	ldr	r3, [pc, #60]	; (8007b98 <led_dma_thread+0x130>)
    last_frame_start = chVTGetSystemTimeX();
 8007b5a:	f8cb 0000 	str.w	r0, [fp]
    dmaStreamEnable(ws_dma_stream);
 8007b5e:	681b      	ldr	r3, [r3, #0]
 8007b60:	681a      	ldr	r2, [r3, #0]
 8007b62:	6813      	ldr	r3, [r2, #0]
 8007b64:	f043 0301 	orr.w	r3, r3, #1
 8007b68:	6013      	str	r3, [r2, #0]
}
 8007b6a:	e7d1      	b.n	8007b10 <led_dma_thread+0xa8>
 8007b6c:	24000c20 	.word	0x24000c20
 8007b70:	08014f48 	.word	0x08014f48
 8007b74:	240022e4 	.word	0x240022e4
 8007b78:	240022fc 	.word	0x240022fc
 8007b7c:	24000000 	.word	0x24000000
 8007b80:	240022ec 	.word	0x240022ec
 8007b84:	000f4240 	.word	0x000f4240
 8007b88:	24002290 	.word	0x24002290
 8007b8c:	240027c0 	.word	0x240027c0
 8007b90:	240022df 	.word	0x240022df
 8007b94:	40010400 	.word	0x40010400
 8007b98:	240027d4 	.word	0x240027d4
 8007b9c:	30000000 	.word	0x30000000
 8007ba0:	240027d0 	.word	0x240027d0
 8007ba4:	2400228c 	.word	0x2400228c
 8007ba8:	240022e0 	.word	0x240022e0
 8007bac:	240022f0 	.word	0x240022f0

08007bb0 <drv_leds_addr_init>:
void drv_leds_addr_init(void) {
 8007bb0:	b530      	push	{r4, r5, lr}
    chMtxObjectInit(&leds_mutex);
 8007bb2:	4839      	ldr	r0, [pc, #228]	; (8007c98 <drv_leds_addr_init+0xe8>)
void drv_leds_addr_init(void) {
 8007bb4:	b083      	sub	sp, #12
    chMtxObjectInit(&leds_mutex);
 8007bb6:	f7fe fe0b 	bl	80067d0 <chMtxObjectInit>
    led_dma_busy = false;
 8007bba:	2400      	movs	r4, #0
 8007bbc:	4937      	ldr	r1, [pc, #220]	; (8007c9c <drv_leds_addr_init+0xec>)
    led_dma_errors = 0;
 8007bbe:	4b38      	ldr	r3, [pc, #224]	; (8007ca0 <drv_leds_addr_init+0xf0>)
    led_dma_busy = false;
 8007bc0:	700c      	strb	r4, [r1, #0]
    led_dma_retry_exhausted = 0;
 8007bc2:	4838      	ldr	r0, [pc, #224]	; (8007ca4 <drv_leds_addr_init+0xf4>)
    last_frame_time_us = 0;
 8007bc4:	4a38      	ldr	r2, [pc, #224]	; (8007ca8 <drv_leds_addr_init+0xf8>)
    last_frame_start = 0;
 8007bc6:	4939      	ldr	r1, [pc, #228]	; (8007cac <drv_leds_addr_init+0xfc>)
    led_dma_errors = 0;
 8007bc8:	601c      	str	r4, [r3, #0]
    led_dma_tc_pending = false;
 8007bca:	4b39      	ldr	r3, [pc, #228]	; (8007cb0 <drv_leds_addr_init+0x100>)
    led_dma_retry_exhausted = 0;
 8007bcc:	6004      	str	r4, [r0, #0]
    last_frame_time_us = 0;
 8007bce:	6014      	str	r4, [r2, #0]
    led_dma_error_pending = false;
 8007bd0:	4838      	ldr	r0, [pc, #224]	; (8007cb4 <drv_leds_addr_init+0x104>)
    last_frame_start = 0;
 8007bd2:	600c      	str	r4, [r1, #0]
    led_dma_enabled = true;
 8007bd4:	2101      	movs	r1, #1
 8007bd6:	4a38      	ldr	r2, [pc, #224]	; (8007cb8 <drv_leds_addr_init+0x108>)
    led_dma_tc_pending = false;
 8007bd8:	701c      	strb	r4, [r3, #0]
    led_dma_consecutive_errors = 0;
 8007bda:	4b38      	ldr	r3, [pc, #224]	; (8007cbc <drv_leds_addr_init+0x10c>)
    led_dma_error_pending = false;
 8007bdc:	7004      	strb	r4, [r0, #0]
    led_dma_enabled = true;
 8007bde:	7011      	strb	r1, [r2, #0]
  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8007be0:	4621      	mov	r1, r4
 8007be2:	4837      	ldr	r0, [pc, #220]	; (8007cc0 <drv_leds_addr_init+0x110>)
    led_dma_consecutive_errors = 0;
 8007be4:	601c      	str	r4, [r3, #0]
 8007be6:	f7fe fd97 	bl	8006718 <chSemObjectInit>
  RCC_C1->APB2ENR |= mask;
 8007bea:	4b36      	ldr	r3, [pc, #216]	; (8007cc4 <drv_leds_addr_init+0x114>)
    TIM_WS->ARR = PERIOD_TICKS - 1;
 8007bec:	2077      	movs	r0, #119	; 0x77
    TIM_WS->PSC = 0;
 8007bee:	4936      	ldr	r1, [pc, #216]	; (8007cc8 <drv_leds_addr_init+0x118>)
 8007bf0:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
    ws_dma_stream = dmaStreamAlloc(WS_DMA_STREAM_ID,
 8007bf4:	4d35      	ldr	r5, [pc, #212]	; (8007ccc <drv_leds_addr_init+0x11c>)
 8007bf6:	f042 0202 	orr.w	r2, r2, #2
 8007bfa:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    RCC_C1->APB2LPENR |= mask;
 8007bfe:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8007c02:	f042 0202 	orr.w	r2, r2, #2
 8007c06:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
  (void)RCC_C1->APB2LPENR;
 8007c0a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8007c0e:	4623      	mov	r3, r4
    TIM_WS->PSC = 0;
 8007c10:	628c      	str	r4, [r1, #40]	; 0x28
    TIM_WS->ARR = PERIOD_TICKS - 1;
 8007c12:	62c8      	str	r0, [r1, #44]	; 0x2c
    TIM_WS->CCR2 = 0;
 8007c14:	638c      	str	r4, [r1, #56]	; 0x38
    TIM_WS->CCMR1 |= (6 << 12);      /* PWM mode 1 CH2 */
 8007c16:	6988      	ldr	r0, [r1, #24]
    ws_dma_stream = dmaStreamAlloc(WS_DMA_STREAM_ID,
 8007c18:	4a2d      	ldr	r2, [pc, #180]	; (8007cd0 <drv_leds_addr_init+0x120>)
    TIM_WS->CCMR1 |= (6 << 12);      /* PWM mode 1 CH2 */
 8007c1a:	f440 40c0 	orr.w	r0, r0, #24576	; 0x6000
 8007c1e:	6188      	str	r0, [r1, #24]
    TIM_WS->CCER  |= TIM_CCER_CC2E;
 8007c20:	6a08      	ldr	r0, [r1, #32]
 8007c22:	f040 0010 	orr.w	r0, r0, #16
 8007c26:	6208      	str	r0, [r1, #32]
    TIM_WS->BDTR  |= TIM_BDTR_MOE;
 8007c28:	6c48      	ldr	r0, [r1, #68]	; 0x44
 8007c2a:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 8007c2e:	6448      	str	r0, [r1, #68]	; 0x44
    TIM_WS->DIER |= TIM_DIER_CC2DE; /* DMA request on CH2 */
 8007c30:	68c8      	ldr	r0, [r1, #12]
 8007c32:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
 8007c36:	60c8      	str	r0, [r1, #12]
    TIM_WS->CR1 |= TIM_CR1_CEN;
 8007c38:	6808      	ldr	r0, [r1, #0]
 8007c3a:	f040 0001 	orr.w	r0, r0, #1
 8007c3e:	6008      	str	r0, [r1, #0]
    ws_dma_stream = dmaStreamAlloc(WS_DMA_STREAM_ID,
 8007c40:	210d      	movs	r1, #13
 8007c42:	2009      	movs	r0, #9
 8007c44:	f7fb f9c0 	bl	8002fc8 <dmaStreamAlloc>
    dmaSetRequestSource(ws_dma_stream, STM32_DMAMUX1_TIM8_CH2);
 8007c48:	2130      	movs	r1, #48	; 0x30
    ws_dma_stream = dmaStreamAlloc(WS_DMA_STREAM_ID,
 8007c4a:	6028      	str	r0, [r5, #0]
    dmaSetRequestSource(ws_dma_stream, STM32_DMAMUX1_TIM8_CH2);
 8007c4c:	f7fb f9fe 	bl	800304c <dmaSetRequestSource>
    dmaStreamSetPeripheral(ws_dma_stream, &TIM_WS->CCR2);
 8007c50:	682b      	ldr	r3, [r5, #0]
    ws_dma_mode = STM32_DMA_CR_MINC |
 8007c52:	f642 4056 	movw	r0, #11350	; 0x2c56
    dmaStreamSetPeripheral(ws_dma_stream, &TIM_WS->CCR2);
 8007c56:	4a1f      	ldr	r2, [pc, #124]	; (8007cd4 <drv_leds_addr_init+0x124>)
 8007c58:	681b      	ldr	r3, [r3, #0]
    ws_dma_mode = STM32_DMA_CR_MINC |
 8007c5a:	491f      	ldr	r1, [pc, #124]	; (8007cd8 <drv_leds_addr_init+0x128>)
    dmaStreamSetPeripheral(ws_dma_stream, &TIM_WS->CCR2);
 8007c5c:	609a      	str	r2, [r3, #8]
    ws_dma_mode = STM32_DMA_CR_MINC |
 8007c5e:	6008      	str	r0, [r1, #0]
    chMtxLock(&leds_mutex);
 8007c60:	480d      	ldr	r0, [pc, #52]	; (8007c98 <drv_leds_addr_init+0xe8>)
 8007c62:	f7fe fe1b 	bl	800689c <chMtxLock>
    for (int i = 0; i < NUM_ADRESS_LEDS; i++)
 8007c66:	4b1d      	ldr	r3, [pc, #116]	; (8007cdc <drv_leds_addr_init+0x12c>)
 8007c68:	f103 024b 	add.w	r2, r3, #75	; 0x4b
        led_buffer[i] = (led_color_t){0, 0, 0};
 8007c6c:	701c      	strb	r4, [r3, #0]
    for (int i = 0; i < NUM_ADRESS_LEDS; i++)
 8007c6e:	3303      	adds	r3, #3
        led_buffer[i] = (led_color_t){0, 0, 0};
 8007c70:	f803 4c02 	strb.w	r4, [r3, #-2]
 8007c74:	f803 4c01 	strb.w	r4, [r3, #-1]
    for (int i = 0; i < NUM_ADRESS_LEDS; i++)
 8007c78:	4293      	cmp	r3, r2
 8007c7a:	d1f7      	bne.n	8007c6c <drv_leds_addr_init+0xbc>
    chMtxUnlock(&leds_mutex);
 8007c7c:	4806      	ldr	r0, [pc, #24]	; (8007c98 <drv_leds_addr_init+0xe8>)
 8007c7e:	f7fe fe17 	bl	80068b0 <chMtxUnlock>
    chThdCreateStatic(led_dma_thread_wa,
 8007c82:	4b17      	ldr	r3, [pc, #92]	; (8007ce0 <drv_leds_addr_init+0x130>)
 8007c84:	2280      	movs	r2, #128	; 0x80
 8007c86:	f44f 7138 	mov.w	r1, #736	; 0x2e0
 8007c8a:	9400      	str	r4, [sp, #0]
 8007c8c:	4815      	ldr	r0, [pc, #84]	; (8007ce4 <drv_leds_addr_init+0x134>)
 8007c8e:	f7fe fc0b 	bl	80064a8 <chThdCreateStatic>
}
 8007c92:	b003      	add	sp, #12
 8007c94:	bd30      	pop	{r4, r5, pc}
 8007c96:	bf00      	nop
 8007c98:	240027c0 	.word	0x240027c0
 8007c9c:	240022df 	.word	0x240022df
 8007ca0:	240022e8 	.word	0x240022e8
 8007ca4:	240022ec 	.word	0x240022ec
 8007ca8:	24002290 	.word	0x24002290
 8007cac:	2400228c 	.word	0x2400228c
 8007cb0:	240022fc 	.word	0x240022fc
 8007cb4:	240022e4 	.word	0x240022e4
 8007cb8:	24000000 	.word	0x24000000
 8007cbc:	240022e0 	.word	0x240022e0
 8007cc0:	240022f0 	.word	0x240022f0
 8007cc4:	58024400 	.word	0x58024400
 8007cc8:	40010400 	.word	0x40010400
 8007ccc:	240027d4 	.word	0x240027d4
 8007cd0:	080079fd 	.word	0x080079fd
 8007cd4:	40010438 	.word	0x40010438
 8007cd8:	240027d0 	.word	0x240027d0
 8007cdc:	24002294 	.word	0x24002294
 8007ce0:	08007a69 	.word	0x08007a69
 8007ce4:	24002300 	.word	0x24002300

08007ce8 <potReaderThread>:
/*                         THREAD DE LECTURE                              */
/* ====================================================================== */

static THD_WORKING_AREA(waPotReader, 512);

static THD_FUNCTION(potReaderThread, arg) {
 8007ce8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    (void)arg;

    adcStart(&ADCD1, NULL);

    while (!stop_requested) {
 8007cec:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 8007da0 <potReaderThread+0xb8>
    adcStart(&ADCD1, NULL);
 8007cf0:	2100      	movs	r1, #0
 8007cf2:	4823      	ldr	r0, [pc, #140]	; (8007d80 <potReaderThread+0x98>)
 8007cf4:	f7f9 f980 	bl	8000ff8 <adcStart>
    while (!stop_requested) {
 8007cf8:	f898 3000 	ldrb.w	r3, [r8]
 8007cfc:	bb5b      	cbnz	r3, 8007d56 <potReaderThread+0x6e>
 8007cfe:	4e21      	ldr	r6, [pc, #132]	; (8007d84 <potReaderThread+0x9c>)
    palWriteLine(LINE_MUX_POT_S0, (index >> 0) & 1U);
 8007d00:	f44f 2580 	mov.w	r5, #262144	; 0x40000
 8007d04:	4c20      	ldr	r4, [pc, #128]	; (8007d88 <potReaderThread+0xa0>)
    palWriteLine(LINE_MUX_POT_S1, (index >> 1) & 1U);
 8007d06:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    palWriteLine(LINE_MUX_POT_S2, (index >> 2) & 1U);
 8007d0a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    palWriteLine(LINE_MUX_POT_S0, (index >> 0) & 1U);
 8007d0e:	61a5      	str	r5, [r4, #24]

        for (uint8_t i = 0; i < BRICK_POT_MUX_COUNT; i++) {

            mux_select(i);
            chThdSleepMicroseconds(8);   /* Stabilisation MUX */
 8007d10:	2001      	movs	r0, #1
    palWriteLine(LINE_MUX_POT_S1, (index >> 1) & 1U);
 8007d12:	61a2      	str	r2, [r4, #24]
    palWriteLine(LINE_MUX_POT_S2, (index >> 2) & 1U);
 8007d14:	61a3      	str	r3, [r4, #24]
            chThdSleepMicroseconds(8);   /* Stabilisation MUX */
 8007d16:	f7fe fc75 	bl	8006604 <chThdSleep>

            msg_t ret = adcConvert(&ADCD1, &adcgrpcfg, &adc_sample, 1);
 8007d1a:	491c      	ldr	r1, [pc, #112]	; (8007d8c <potReaderThread+0xa4>)
 8007d1c:	2301      	movs	r3, #1
 8007d1e:	4a19      	ldr	r2, [pc, #100]	; (8007d84 <potReaderThread+0x9c>)
 8007d20:	4817      	ldr	r0, [pc, #92]	; (8007d80 <potReaderThread+0x98>)
 8007d22:	f7f9 f989 	bl	8001038 <adcConvert>
                continue;
            }

            int32_t delta     = (int32_t)adc_sample - (int32_t)pots_filt[i];
            pots_filt[i]      = (uint16_t)(pots_filt[i] + (delta >> 3));
            pots_raw[i]       = pots_filt[i];
 8007d26:	4f1a      	ldr	r7, [pc, #104]	; (8007d90 <potReaderThread+0xa8>)
            int32_t delta     = (int32_t)adc_sample - (int32_t)pots_filt[i];
 8007d28:	491a      	ldr	r1, [pc, #104]	; (8007d94 <potReaderThread+0xac>)
            if (ret != MSG_OK) {
 8007d2a:	bb00      	cbnz	r0, 8007d6e <potReaderThread+0x86>
            int32_t delta     = (int32_t)adc_sample - (int32_t)pots_filt[i];
 8007d2c:	880b      	ldrh	r3, [r1, #0]
 8007d2e:	8832      	ldrh	r2, [r6, #0]
 8007d30:	1ad2      	subs	r2, r2, r3
            pots_filt[i]      = (uint16_t)(pots_filt[i] + (delta >> 3));
 8007d32:	eb03 03e2 	add.w	r3, r3, r2, asr #3
 8007d36:	b29b      	uxth	r3, r3
 8007d38:	800b      	strh	r3, [r1, #0]
            pots_raw[i]       = pots_filt[i];
 8007d3a:	803b      	strh	r3, [r7, #0]
        }

        palClearLine(LINE_MUX_POT_S0);
        palClearLine(LINE_MUX_POT_S1);
        palClearLine(LINE_MUX_POT_S2);
 8007d3c:	2310      	movs	r3, #16
        palClearLine(LINE_MUX_POT_S0);
 8007d3e:	2104      	movs	r1, #4
        palClearLine(LINE_MUX_POT_S1);
 8007d40:	2208      	movs	r2, #8

        chThdSleepMilliseconds(5);
 8007d42:	2032      	movs	r0, #50	; 0x32
        palClearLine(LINE_MUX_POT_S0);
 8007d44:	8361      	strh	r1, [r4, #26]
        palClearLine(LINE_MUX_POT_S1);
 8007d46:	8362      	strh	r2, [r4, #26]
        palClearLine(LINE_MUX_POT_S2);
 8007d48:	8363      	strh	r3, [r4, #26]
        chThdSleepMilliseconds(5);
 8007d4a:	f7fe fc5b 	bl	8006604 <chThdSleep>
    while (!stop_requested) {
 8007d4e:	f898 3000 	ldrb.w	r3, [r8]
 8007d52:	2b00      	cmp	r3, #0
 8007d54:	d0d7      	beq.n	8007d06 <potReaderThread+0x1e>
    }

    palClearLine(LINE_MUX_POT_S0);
 8007d56:	4b0c      	ldr	r3, [pc, #48]	; (8007d88 <potReaderThread+0xa0>)
 8007d58:	2004      	movs	r0, #4
    palClearLine(LINE_MUX_POT_S1);
 8007d5a:	2108      	movs	r1, #8
    palClearLine(LINE_MUX_POT_S2);
 8007d5c:	2210      	movs	r2, #16
    palClearLine(LINE_MUX_POT_S0);
 8007d5e:	8358      	strh	r0, [r3, #26]
    palClearLine(LINE_MUX_POT_S1);
 8007d60:	8359      	strh	r1, [r3, #26]

    adcStop(&ADCD1);
 8007d62:	4807      	ldr	r0, [pc, #28]	; (8007d80 <potReaderThread+0x98>)
    palClearLine(LINE_MUX_POT_S2);
 8007d64:	835a      	strh	r2, [r3, #26]
}
 8007d66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    adcStop(&ADCD1);
 8007d6a:	f7f9 b957 	b.w	800101c <adcStop>
                adc_error_count++;
 8007d6e:	4a0a      	ldr	r2, [pc, #40]	; (8007d98 <potReaderThread+0xb0>)
                pots_state = POTS_FAULT;
 8007d70:	2002      	movs	r0, #2
 8007d72:	490a      	ldr	r1, [pc, #40]	; (8007d9c <potReaderThread+0xb4>)
                adc_error_count++;
 8007d74:	6813      	ldr	r3, [r2, #0]
                pots_state = POTS_FAULT;
 8007d76:	7008      	strb	r0, [r1, #0]
                adc_error_count++;
 8007d78:	3301      	adds	r3, #1
 8007d7a:	6013      	str	r3, [r2, #0]
        for (uint8_t i = 0; i < BRICK_POT_MUX_COUNT; i++) {
 8007d7c:	e7de      	b.n	8007d3c <potReaderThread+0x54>
 8007d7e:	bf00      	nop
 8007d80:	24000700 	.word	0x24000700
 8007d84:	240027dc 	.word	0x240027dc
 8007d88:	58021c00 	.word	0x58021c00
 8007d8c:	08014f50 	.word	0x08014f50
 8007d90:	240027e4 	.word	0x240027e4
 8007d94:	240027e0 	.word	0x240027e0
 8007d98:	240027d8 	.word	0x240027d8
 8007d9c:	240027e6 	.word	0x240027e6
 8007da0:	240027ec 	.word	0x240027ec

08007da4 <drv_pots_init>:

/* ====================================================================== */
/*                           INITIALISATION                               */
/* ====================================================================== */

void drv_pots_init(void) {
 8007da4:	b510      	push	{r4, lr}

    /* Entrée ADC */
    palSetLineMode(LINE_MUX_POT_ADC, PAL_MODE_INPUT_ANALOG);
 8007da6:	4c0e      	ldr	r4, [pc, #56]	; (8007de0 <drv_pots_init+0x3c>)
 8007da8:	2203      	movs	r2, #3
 8007daa:	2120      	movs	r1, #32
 8007dac:	4620      	mov	r0, r4
 8007dae:	f7fb f953 	bl	8003058 <_pal_lld_setgroupmode>

    /* Lignes de sélection MUX */
    palSetLineMode(LINE_MUX_POT_S0, PAL_MODE_OUTPUT_PUSHPULL);
 8007db2:	2201      	movs	r2, #1
 8007db4:	2104      	movs	r1, #4
 8007db6:	4620      	mov	r0, r4
 8007db8:	f7fb f94e 	bl	8003058 <_pal_lld_setgroupmode>
    palSetLineMode(LINE_MUX_POT_S1, PAL_MODE_OUTPUT_PUSHPULL);
 8007dbc:	2201      	movs	r2, #1
 8007dbe:	2108      	movs	r1, #8
 8007dc0:	4620      	mov	r0, r4
 8007dc2:	f7fb f949 	bl	8003058 <_pal_lld_setgroupmode>
    palSetLineMode(LINE_MUX_POT_S2, PAL_MODE_OUTPUT_PUSHPULL);
 8007dc6:	2201      	movs	r2, #1
 8007dc8:	2110      	movs	r1, #16
 8007dca:	4620      	mov	r0, r4
 8007dcc:	f7fb f944 	bl	8003058 <_pal_lld_setgroupmode>

    palClearLine(LINE_MUX_POT_S0);
 8007dd0:	2104      	movs	r1, #4
    palClearLine(LINE_MUX_POT_S1);
 8007dd2:	2208      	movs	r2, #8
    palClearLine(LINE_MUX_POT_S2);
 8007dd4:	2310      	movs	r3, #16
    palClearLine(LINE_MUX_POT_S0);
 8007dd6:	8361      	strh	r1, [r4, #26]
    palClearLine(LINE_MUX_POT_S1);
 8007dd8:	8362      	strh	r2, [r4, #26]
    palClearLine(LINE_MUX_POT_S2);
 8007dda:	8363      	strh	r3, [r4, #26]
}
 8007ddc:	bd10      	pop	{r4, pc}
 8007dde:	bf00      	nop
 8007de0:	58021c00 	.word	0x58021c00

08007de4 <drv_pots_start>:

void drv_pots_start(void) {
 8007de4:	b570      	push	{r4, r5, r6, lr}
    if (pots_state == POTS_RUNNING ||
 8007de6:	4c0f      	ldr	r4, [pc, #60]	; (8007e24 <drv_pots_start+0x40>)
void drv_pots_start(void) {
 8007de8:	b082      	sub	sp, #8
    if (pots_state == POTS_RUNNING ||
 8007dea:	7823      	ldrb	r3, [r4, #0]
 8007dec:	2b01      	cmp	r3, #1
 8007dee:	d016      	beq.n	8007e1e <drv_pots_start+0x3a>
        (pots_thread != NULL && chThdTerminatedX(pots_thread) == false)) {
 8007df0:	4d0d      	ldr	r5, [pc, #52]	; (8007e28 <drv_pots_start+0x44>)
 8007df2:	682b      	ldr	r3, [r5, #0]
    if (pots_state == POTS_RUNNING ||
 8007df4:	b113      	cbz	r3, 8007dfc <drv_pots_start+0x18>
        (pots_thread != NULL && chThdTerminatedX(pots_thread) == false)) {
 8007df6:	7f1b      	ldrb	r3, [r3, #28]
 8007df8:	2b0f      	cmp	r3, #15
 8007dfa:	d110      	bne.n	8007e1e <drv_pots_start+0x3a>
        return;
    }

    stop_requested = false;
 8007dfc:	4b0b      	ldr	r3, [pc, #44]	; (8007e2c <drv_pots_start+0x48>)
 8007dfe:	2600      	movs	r6, #0
 8007e00:	701e      	strb	r6, [r3, #0]
    drv_pots_init();
 8007e02:	f7ff ffcf 	bl	8007da4 <drv_pots_init>

    pots_thread = chThdCreateStatic(waPotReader, sizeof(waPotReader),
 8007e06:	4b0a      	ldr	r3, [pc, #40]	; (8007e30 <drv_pots_start+0x4c>)
 8007e08:	2280      	movs	r2, #128	; 0x80
 8007e0a:	f44f 7178 	mov.w	r1, #992	; 0x3e0
 8007e0e:	4809      	ldr	r0, [pc, #36]	; (8007e34 <drv_pots_start+0x50>)
 8007e10:	9600      	str	r6, [sp, #0]
 8007e12:	f7fe fb49 	bl	80064a8 <chThdCreateStatic>
 8007e16:	6028      	str	r0, [r5, #0]
                                    NORMALPRIO, potReaderThread, NULL);
    if (pots_thread != NULL) {
 8007e18:	b108      	cbz	r0, 8007e1e <drv_pots_start+0x3a>
        pots_state = POTS_RUNNING;
 8007e1a:	2301      	movs	r3, #1
 8007e1c:	7023      	strb	r3, [r4, #0]
    }
}
 8007e1e:	b002      	add	sp, #8
 8007e20:	bd70      	pop	{r4, r5, r6, pc}
 8007e22:	bf00      	nop
 8007e24:	240027e6 	.word	0x240027e6
 8007e28:	240027e8 	.word	0x240027e8
 8007e2c:	240027ec 	.word	0x240027ec
 8007e30:	08007ce9 	.word	0x08007ce9
 8007e34:	24002800 	.word	0x24002800

08007e38 <mpu_config_init_once>:
    *encoded_size = rasr_size;
    *region_bytes = candidate_bytes;
    return true;
}

bool mpu_config_init_once(void) {
 8007e38:	b530      	push	{r4, r5, lr}
    const uintptr_t ram_d2_end  = (uintptr_t)&__ram_d2_end__;
    const uintptr_t ram_d2_size = ram_d2_end - ram_d2_base;
    uint32_t region_size_encoding = 0U;
    uintptr_t region_size_bytes = 0U;

    if (initialized) {
 8007e3a:	4d42      	ldr	r5, [pc, #264]	; (8007f44 <mpu_config_init_once+0x10c>)
 8007e3c:	7828      	ldrb	r0, [r5, #0]
 8007e3e:	b978      	cbnz	r0, 8007e60 <mpu_config_init_once+0x28>
    const uintptr_t ram_d2_base = (uintptr_t)&__ram_d2_start__;
 8007e40:	4c41      	ldr	r4, [pc, #260]	; (8007f48 <mpu_config_init_once+0x110>)
    const uintptr_t ram_d2_end  = (uintptr_t)&__ram_d2_end__;
 8007e42:	4a42      	ldr	r2, [pc, #264]	; (8007f4c <mpu_config_init_once+0x114>)
        return true;
    }

    if (((ram_d2_base & 0x1FU) != 0U) || (ram_d2_size == 0U)) {
 8007e44:	f014 031f 	ands.w	r3, r4, #31
 8007e48:	bf18      	it	ne
 8007e4a:	2301      	movne	r3, #1
    if ((size == 0U) || (encoded_size == NULL) || (region_bytes == NULL)) {
 8007e4c:	ebb2 0c04 	subs.w	ip, r2, r4
 8007e50:	bf08      	it	eq
 8007e52:	f043 0301 	orreq.w	r3, r3, #1
 8007e56:	4294      	cmp	r4, r2
 8007e58:	bf08      	it	eq
 8007e5a:	f043 0301 	orreq.w	r3, r3, #1
 8007e5e:	b103      	cbz	r3, 8007e62 <mpu_config_init_once+0x2a>
    __DSB();
    __ISB();

    initialized = true;
    return true;
}
 8007e60:	bd30      	pop	{r4, r5, pc}
    while ((candidate_bytes < size) && (rasr_size < ARM_MPU_REGION_SIZE_4GB)) {
 8007e62:	f1bc 0f20 	cmp.w	ip, #32
 8007e66:	d969      	bls.n	8007f3c <mpu_config_init_once+0x104>
    uint32_t rasr_size = ARM_MPU_REGION_SIZE_32B;
 8007e68:	2104      	movs	r1, #4
    uintptr_t candidate_bytes = 32U;
 8007e6a:	2220      	movs	r2, #32
        candidate_bytes <<= 1;
 8007e6c:	0052      	lsls	r2, r2, #1
        rasr_size++;
 8007e6e:	3101      	adds	r1, #1
    while ((candidate_bytes < size) && (rasr_size < ARM_MPU_REGION_SIZE_4GB)) {
 8007e70:	4594      	cmp	ip, r2
 8007e72:	bf94      	ite	ls
 8007e74:	2300      	movls	r3, #0
 8007e76:	2301      	movhi	r3, #1
 8007e78:	291e      	cmp	r1, #30
 8007e7a:	d801      	bhi.n	8007e80 <mpu_config_init_once+0x48>
 8007e7c:	2b00      	cmp	r3, #0
 8007e7e:	d1f5      	bne.n	8007e6c <mpu_config_init_once+0x34>
    if ((candidate_bytes & (candidate_bytes - 1U)) != 0U) {
 8007e80:	1e51      	subs	r1, r2, #1
    if ((base & (candidate_bytes - 1U)) != 0U) {
 8007e82:	4322      	orrs	r2, r4
    if (ram_d2_size > region_size_bytes) {
 8007e84:	420a      	tst	r2, r1
 8007e86:	d100      	bne.n	8007e8a <mpu_config_init_once+0x52>
 8007e88:	b10b      	cbz	r3, 8007e8e <mpu_config_init_once+0x56>
        return false;
 8007e8a:	2000      	movs	r0, #0
}
 8007e8c:	bd30      	pop	{r4, r5, pc}
  __ASM volatile ("dsb 0xF":::"memory");
 8007e8e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007e92:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void ARM_MPU_Disable(void)
{
  __DSB();
  __ISB();
#ifdef SCB_SHCSR_MEMFAULTENA_Msk
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8007e96:	492e      	ldr	r1, [pc, #184]	; (8007f50 <mpu_config_init_once+0x118>)
 8007e98:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8007e9a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8007e9e:	624a      	str	r2, [r1, #36]	; 0x24
#endif
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 8007ea0:	f8d1 2094 	ldr.w	r2, [r1, #148]	; 0x94
 8007ea4:	f022 0201 	bic.w	r2, r2, #1
 8007ea8:	f8c1 2094 	str.w	r2, [r1, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
 8007eac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007eb0:	f3bf 8f6f 	isb	sy
    ARM_MPU_SetRegion(ARM_MPU_RBAR(MPU_REGION_D2_NOCACHE, ram_d2_base),
 8007eb4:	f024 021f 	bic.w	r2, r4, #31
* \param rsar Value for RSAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
{
  MPU->RBAR = rbar;
  MPU->RASR = rasr;
 8007eb8:	f04f 7043 	mov.w	r0, #51118080	; 0x30c0000
 8007ebc:	f042 0213 	orr.w	r2, r2, #19
  MPU->RBAR = rbar;
 8007ec0:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  MPU->RASR = rasr;
 8007ec4:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
  __ASM volatile ("dsb 0xF":::"memory");
 8007ec8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007ecc:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8007ed0:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8007ed4:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 8007ed8:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8007edc:	f643 7ee0 	movw	lr, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8007ee0:	f3c3 344e 	ubfx	r4, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8007ee4:	f3c3 0cc9 	ubfx	ip, r3, #3, #10
 8007ee8:	0164      	lsls	r4, r4, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8007eea:	ea04 000e 	and.w	r0, r4, lr
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8007eee:	4663      	mov	r3, ip
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8007ef0:	ea40 7283 	orr.w	r2, r0, r3, lsl #30
      } while (ways-- != 0U);
 8007ef4:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8007ef6:	f8c1 2260 	str.w	r2, [r1, #608]	; 0x260
      } while (ways-- != 0U);
 8007efa:	1c5a      	adds	r2, r3, #1
 8007efc:	d1f8      	bne.n	8007ef0 <mpu_config_init_once+0xb8>
    } while(sets-- != 0U);
 8007efe:	3c20      	subs	r4, #32
 8007f00:	f114 0f20 	cmn.w	r4, #32
 8007f04:	d1f1      	bne.n	8007eea <mpu_config_init_once+0xb2>
 8007f06:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007f0a:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 8007f0e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007f12:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 8007f16:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007f1a:	f3bf 8f6f 	isb	sy
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8007f1e:	2305      	movs	r3, #5
 8007f20:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8007f24:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8007f26:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8007f2a:	624b      	str	r3, [r1, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8007f2c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007f30:	f3bf 8f6f 	isb	sy
    initialized = true;
 8007f34:	2301      	movs	r3, #1
    return true;
 8007f36:	4618      	mov	r0, r3
    initialized = true;
 8007f38:	702b      	strb	r3, [r5, #0]
}
 8007f3a:	bd30      	pop	{r4, r5, pc}
    while ((candidate_bytes < size) && (rasr_size < ARM_MPU_REGION_SIZE_4GB)) {
 8007f3c:	211f      	movs	r1, #31
    uintptr_t candidate_bytes = 32U;
 8007f3e:	2220      	movs	r2, #32
 8007f40:	e79f      	b.n	8007e82 <mpu_config_init_once+0x4a>
 8007f42:	bf00      	nop
 8007f44:	24002be0 	.word	0x24002be0
 8007f48:	30000000 	.word	0x30000000
 8007f4c:	30011360 	.word	0x30011360
 8007f50:	e000ed00 	.word	0xe000ed00

08007f54 <adau1979_init>:
/* -------------------------------------------------------------------------- */
/* API publique                                                               */
/* -------------------------------------------------------------------------- */

msg_t adau1979_init(void) {
    if (audio_i2c->state == I2C_STOP) {
 8007f54:	481d      	ldr	r0, [pc, #116]	; (8007fcc <adau1979_init+0x78>)
msg_t adau1979_init(void) {
 8007f56:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (audio_i2c->state == I2C_STOP) {
 8007f58:	7803      	ldrb	r3, [r0, #0]
msg_t adau1979_init(void) {
 8007f5a:	b087      	sub	sp, #28
    if (audio_i2c->state == I2C_STOP) {
 8007f5c:	2b01      	cmp	r3, #1
 8007f5e:	d02d      	beq.n	8007fbc <adau1979_init+0x68>
    return i2cMasterTransmitTimeout(audio_i2c, addr, &reg, 1, value, 1, TIME_MS2I(10));
 8007f60:	2401      	movs	r4, #1
        uint8_t devid = 0U;
 8007f62:	2300      	movs	r3, #0
    return i2cMasterTransmitTimeout(audio_i2c, addr, &reg, 1, value, 1, TIME_MS2I(10));
 8007f64:	2764      	movs	r7, #100	; 0x64
 8007f66:	f10d 0516 	add.w	r5, sp, #22
 8007f6a:	26f0      	movs	r6, #240	; 0xf0
        uint8_t devid = 0U;
 8007f6c:	f88d 3016 	strb.w	r3, [sp, #22]
    return i2cMasterTransmitTimeout(audio_i2c, addr, &reg, 1, value, 1, TIME_MS2I(10));
 8007f70:	f10d 0217 	add.w	r2, sp, #23
 8007f74:	4623      	mov	r3, r4
 8007f76:	2111      	movs	r1, #17
 8007f78:	4814      	ldr	r0, [pc, #80]	; (8007fcc <adau1979_init+0x78>)
 8007f7a:	9500      	str	r5, [sp, #0]
 8007f7c:	f88d 6017 	strb.w	r6, [sp, #23]
 8007f80:	e9cd 4701 	strd	r4, r7, [sp, #4]
 8007f84:	f7f9 f886 	bl	8001094 <i2cMasterTransmitTimeout>
        if (st != HAL_RET_SUCCESS) {
 8007f88:	b9b0      	cbnz	r0, 8007fb8 <adau1979_init+0x64>
        if (devid != ADAU1979_DEVID0_EXPECTED) {
 8007f8a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007f8e:	2b79      	cmp	r3, #121	; 0x79
 8007f90:	d118      	bne.n	8007fc4 <adau1979_init+0x70>
        uint8_t devid = 0U;
 8007f92:	f88d 0016 	strb.w	r0, [sp, #22]
    return i2cMasterTransmitTimeout(audio_i2c, addr, &reg, 1, value, 1, TIME_MS2I(10));
 8007f96:	4623      	mov	r3, r4
 8007f98:	f10d 0217 	add.w	r2, sp, #23
 8007f9c:	2112      	movs	r1, #18
 8007f9e:	480b      	ldr	r0, [pc, #44]	; (8007fcc <adau1979_init+0x78>)
 8007fa0:	9702      	str	r7, [sp, #8]
 8007fa2:	f88d 6017 	strb.w	r6, [sp, #23]
 8007fa6:	e9cd 5400 	strd	r5, r4, [sp]
 8007faa:	f7f9 f873 	bl	8001094 <i2cMasterTransmitTimeout>
        if (st != HAL_RET_SUCCESS) {
 8007fae:	b918      	cbnz	r0, 8007fb8 <adau1979_init+0x64>
        if (devid != ADAU1979_DEVID0_EXPECTED) {
 8007fb0:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007fb4:	2b79      	cmp	r3, #121	; 0x79
 8007fb6:	d105      	bne.n	8007fc4 <adau1979_init+0x70>
        i2cStart(audio_i2c, &adau1979_default_i2c_cfg);
    }
    return adau1979_verify_devid();
}
 8007fb8:	b007      	add	sp, #28
 8007fba:	bdf0      	pop	{r4, r5, r6, r7, pc}
        i2cStart(audio_i2c, &adau1979_default_i2c_cfg);
 8007fbc:	4904      	ldr	r1, [pc, #16]	; (8007fd0 <adau1979_init+0x7c>)
 8007fbe:	f7f9 f85b 	bl	8001078 <i2cStart>
 8007fc2:	e7cd      	b.n	8007f60 <adau1979_init+0xc>
            return MSG_RESET;
 8007fc4:	f06f 0001 	mvn.w	r0, #1
 8007fc8:	e7f6      	b.n	8007fb8 <adau1979_init+0x64>
 8007fca:	bf00      	nop
 8007fcc:	24000838 	.word	0x24000838
 8007fd0:	08014fa8 	.word	0x08014fa8

08007fd4 <audio_codec_pcm4104_init>:
    /* Si un jour une broche MUTE est ajoutée en hardware,
       elle sera configurée ici automatiquement. */
    palSetLineMode(AUDIO_HP_MUTE_LINE, PAL_MODE_OUTPUT_PUSHPULL);
    palClearLine(AUDIO_HP_MUTE_LINE); /* Mute par défaut au boot. */
#endif
}
 8007fd4:	4770      	bx	lr
 8007fd6:	bf00      	nop

08007fd8 <audio_routes_reset_defaults>:
    audio_control.state.routes[track].gain_main = clamp_0_1(gain_main);
    audio_control.state.routes[track].gain_cue = clamp_0_1(gain_cue);
    chMtxUnlock(&audio_control.lock);
}

static void audio_routes_reset_defaults(void) {
 8007fd8:	b570      	push	{r4, r5, r6, lr}
    chMtxLock(&audio_control.lock);
 8007fda:	4e11      	ldr	r6, [pc, #68]	; (8008020 <audio_routes_reset_defaults+0x48>)
    audio_control.state.master_volume = 1.0f;
    for (uint8_t t = 0U; t < 4U; ++t) {
        audio_control.state.routes[t].gain_main = 1.0f;
        audio_control.state.routes[t].gain_cue = 1.0f;
        audio_control.state.routes[t].to_main = true;
 8007fdc:	2501      	movs	r5, #1
    chMtxLock(&audio_control.lock);
 8007fde:	4630      	mov	r0, r6
 8007fe0:	f106 0430 	add.w	r4, r6, #48	; 0x30
 8007fe4:	f7fe fc5a 	bl	800689c <chMtxLock>
    audio_control.state.master_volume = 1.0f;
 8007fe8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8007fec:	4633      	mov	r3, r6
        audio_control.state.routes[t].to_cue = false;
 8007fee:	2100      	movs	r1, #0
    audio_control.state.master_volume = 1.0f;
 8007ff0:	6132      	str	r2, [r6, #16]
        audio_control.state.routes[t].gain_main = 1.0f;
 8007ff2:	615a      	str	r2, [r3, #20]
    for (uint8_t t = 0U; t < 4U; ++t) {
 8007ff4:	330c      	adds	r3, #12
        audio_control.state.routes[t].gain_cue = 1.0f;
 8007ff6:	60da      	str	r2, [r3, #12]
        audio_control.state.routes[t].to_main = true;
 8007ff8:	741d      	strb	r5, [r3, #16]
        audio_control.state.routes[t].to_cue = false;
 8007ffa:	7459      	strb	r1, [r3, #17]
    for (uint8_t t = 0U; t < 4U; ++t) {
 8007ffc:	42a3      	cmp	r3, r4
 8007ffe:	d1f8      	bne.n	8007ff2 <audio_routes_reset_defaults+0x1a>
    }
    audio_control_cached = audio_control.state;
 8008000:	4d08      	ldr	r5, [pc, #32]	; (8008024 <audio_routes_reset_defaults+0x4c>)
 8008002:	4c09      	ldr	r4, [pc, #36]	; (8008028 <audio_routes_reset_defaults+0x50>)
 8008004:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8008006:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8008008:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800800a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800800c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800800e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8008010:	4628      	mov	r0, r5
 8008012:	f850 3940 	ldr.w	r3, [r0], #-64
 8008016:	6023      	str	r3, [r4, #0]
    chMtxUnlock(&audio_control.lock);
}
 8008018:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chMtxUnlock(&audio_control.lock);
 800801c:	f7fe bc48 	b.w	80068b0 <chMtxUnlock>
 8008020:	24002be4 	.word	0x24002be4
 8008024:	24002bf4 	.word	0x24002bf4
 8008028:	24002c28 	.word	0x24002c28

0800802c <drv_audio_init>:
void drv_audio_init(void) {
 800802c:	b538      	push	{r3, r4, r5, lr}
    if (audio_initialized) {
 800802e:	4c21      	ldr	r4, [pc, #132]	; (80080b4 <drv_audio_init+0x88>)
 8008030:	7823      	ldrb	r3, [r4, #0]
 8008032:	b103      	cbz	r3, 8008036 <drv_audio_init+0xa>
}
 8008034:	bd38      	pop	{r3, r4, r5, pc}
    if (!mpu_config_init_once()) {
 8008036:	f7ff feff 	bl	8007e38 <mpu_config_init_once>
 800803a:	b160      	cbz	r0, 8008056 <drv_audio_init+0x2a>
 800803c:	2101      	movs	r1, #1
 800803e:	481e      	ldr	r0, [pc, #120]	; (80080b8 <drv_audio_init+0x8c>)
 8008040:	f7fe fb6a 	bl	8006718 <chSemObjectInit>
    chMtxObjectInit(&audio_control.lock);
 8008044:	481d      	ldr	r0, [pc, #116]	; (80080bc <drv_audio_init+0x90>)
 8008046:	f7fe fbc3 	bl	80067d0 <chMtxObjectInit>
    audio_routes_reset_defaults();
 800804a:	f7ff ffc5 	bl	8007fd8 <audio_routes_reset_defaults>
    msg_t codec_status = adau1979_init();
 800804e:	f7ff ff81 	bl	8007f54 <adau1979_init>
    if (codec_status != HAL_RET_SUCCESS) {
 8008052:	4605      	mov	r5, r0
 8008054:	b118      	cbz	r0, 800805e <drv_audio_init+0x32>
        audio_state = AUDIO_FAULT;
 8008056:	4b1a      	ldr	r3, [pc, #104]	; (80080c0 <drv_audio_init+0x94>)
 8008058:	2203      	movs	r2, #3
 800805a:	701a      	strb	r2, [r3, #0]
}
 800805c:	bd38      	pop	{r3, r4, r5, pc}
    audio_codec_pcm4104_init();
 800805e:	f7ff ffb9 	bl	8007fd4 <audio_codec_pcm4104_init>
    audio_in_ready_index = 0xFFU;
 8008062:	23ff      	movs	r3, #255	; 0xff
 8008064:	4917      	ldr	r1, [pc, #92]	; (80080c4 <drv_audio_init+0x98>)
    audio_out_ready_index = 0xFFU;
 8008066:	4a18      	ldr	r2, [pc, #96]	; (80080c8 <drv_audio_init+0x9c>)
    audio_in_ready_index = 0xFFU;
 8008068:	700b      	strb	r3, [r1, #0]
    audio_out_ready_index = 0xFFU;
 800806a:	7013      	strb	r3, [r2, #0]
    audio_sync_mask = 0U;
 800806c:	4917      	ldr	r1, [pc, #92]	; (80080cc <drv_audio_init+0xa0>)
    audio_sync_half = 0xFFU;
 800806e:	4a18      	ldr	r2, [pc, #96]	; (80080d0 <drv_audio_init+0xa4>)
    audio_sync_mask = 0U;
 8008070:	700d      	strb	r5, [r1, #0]
    memset((void *)audio_in_buffers, 0, sizeof(audio_in_buffers));
 8008072:	4629      	mov	r1, r5
    audio_sync_half = 0xFFU;
 8008074:	7013      	strb	r3, [r2, #0]
    memset((void *)audio_in_buffers, 0, sizeof(audio_in_buffers));
 8008076:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800807a:	4816      	ldr	r0, [pc, #88]	; (80080d4 <drv_audio_init+0xa8>)
 800807c:	f006 fbb2 	bl	800e7e4 <memset>
    memset((void *)audio_out_buffers, 0, sizeof(audio_out_buffers));
 8008080:	f44f 7200 	mov.w	r2, #512	; 0x200
 8008084:	4629      	mov	r1, r5
 8008086:	4814      	ldr	r0, [pc, #80]	; (80080d8 <drv_audio_init+0xac>)
 8008088:	f006 fbac 	bl	800e7e4 <memset>
    memset((void *)spi_in_buffers, 0, sizeof(spi_in_buffers));
 800808c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8008090:	4629      	mov	r1, r5
 8008092:	4812      	ldr	r0, [pc, #72]	; (80080dc <drv_audio_init+0xb0>)
 8008094:	f006 fba6 	bl	800e7e4 <memset>
    memset((void *)spi_out_buffers, 0, sizeof(spi_out_buffers));
 8008098:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800809c:	4629      	mov	r1, r5
 800809e:	4810      	ldr	r0, [pc, #64]	; (80080e0 <drv_audio_init+0xb4>)
 80080a0:	f006 fba0 	bl	800e7e4 <memset>
    audio_routes_reset_defaults();
 80080a4:	f7ff ff98 	bl	8007fd8 <audio_routes_reset_defaults>
    audio_state = AUDIO_READY;
 80080a8:	2301      	movs	r3, #1
 80080aa:	4a05      	ldr	r2, [pc, #20]	; (80080c0 <drv_audio_init+0x94>)
    audio_initialized = true;
 80080ac:	7023      	strb	r3, [r4, #0]
    audio_state = AUDIO_READY;
 80080ae:	7013      	strb	r3, [r2, #0]
}
 80080b0:	bd38      	pop	{r3, r4, r5, pc}
 80080b2:	bf00      	nop
 80080b4:	24002c68 	.word	0x24002c68
 80080b8:	24002c5c 	.word	0x24002c5c
 80080bc:	24002be4 	.word	0x24002be4
 80080c0:	24002c69 	.word	0x24002c69
 80080c4:	24000001 	.word	0x24000001
 80080c8:	24000002 	.word	0x24000002
 80080cc:	24002c6a 	.word	0x24002c6a
 80080d0:	24000003 	.word	0x24000003
 80080d4:	30000560 	.word	0x30000560
 80080d8:	30000960 	.word	0x30000960
 80080dc:	30000b60 	.word	0x30000b60
 80080e0:	30000f60 	.word	0x30000f60

080080e4 <midi_internal_receive>:
#endif

/* Callback faible pour injection dans le moteur MIDI interne. */
__attribute__((weak)) void midi_internal_receive(const uint8_t *msg, size_t len) {
  (void)msg; (void)len;
}
 80080e4:	4770      	bx	lr
 80080e6:	bf00      	nop

080080e8 <thdMidiUsbTx>:
 80080e8:	4b83      	ldr	r3, [pc, #524]	; (80082f8 <thdMidiUsbTx+0x210>)
 80080ea:	4a84      	ldr	r2, [pc, #528]	; (80082fc <thdMidiUsbTx+0x214>)
 80080ec:	68db      	ldr	r3, [r3, #12]
 * - Si le sémaphore n’est pas obtenu dans @ref MIDI_USB_TX_WAIT_MS ms,
 *   le lot courant est **abandonné** (drop contrôlé) pour éviter tout blocage.
 *
 * @param arg Argument inutilisé.
 */
static THD_FUNCTION(thdMidiUsbTx, arg) {
 80080ee:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  (void)arg;
#if CH_CFG_USE_REGISTRY
  chRegSetThreadName("MIDI_USB_TX");
#endif
  uint8_t buf[64];
  size_t n = 0;
 80080f2:	f04f 0900 	mov.w	r9, #0
static THD_FUNCTION(thdMidiUsbTx, arg) {
 80080f6:	b093      	sub	sp, #76	; 0x4c
 80080f8:	4e81      	ldr	r6, [pc, #516]	; (8008300 <thdMidiUsbTx+0x218>)
 80080fa:	f8df a22c 	ldr.w	sl, [pc, #556]	; 8008328 <thdMidiUsbTx+0x240>
 80080fe:	4d81      	ldr	r5, [pc, #516]	; (8008304 <thdMidiUsbTx+0x21c>)
  const uint32_t max_burst = 16U;
  uint32_t processed = 0U;
  msg_t raw;

  while ((processed < max_burst) &&
         (chMBFetchTimeout(&midi_usb_rx_mb, &raw, TIME_IMMEDIATE) == MSG_OK)) {
 8008100:	f8df 8228 	ldr.w	r8, [pc, #552]	; 800832c <thdMidiUsbTx+0x244>
 8008104:	621a      	str	r2, [r3, #32]
      out->data[2] = pkt[3];
 8008106:	2410      	movs	r4, #16
         (chMBFetchTimeout(&midi_usb_rx_mb, &raw, TIME_IMMEDIATE) == MSG_OK)) {
 8008108:	2700      	movs	r7, #0
 800810a:	e00d      	b.n	8008128 <thdMidiUsbTx+0x40>
  switch (cin) {
 800810c:	f243 0304 	movw	r3, #12292	; 0x3004
 8008110:	421a      	tst	r2, r3
 8008112:	f040 808c 	bne.w	800822e <thdMidiUsbTx+0x146>
 8008116:	280f      	cmp	r0, #15
 8008118:	f000 8091 	beq.w	800823e <thdMidiUsbTx+0x156>
    midi_msg_t msg;
    if (usb_midi_decode_packet(pkt, &msg)) {
      midi_dispatch_rx_message(&msg);
      midi_rx_stats.usb_rx_decoded++;
    } else {
      midi_rx_stats.usb_rx_ignored++;
 800811c:	68eb      	ldr	r3, [r5, #12]
  while ((processed < max_burst) &&
 800811e:	3c01      	subs	r4, #1
      midi_rx_stats.usb_rx_ignored++;
 8008120:	f103 0301 	add.w	r3, r3, #1
 8008124:	60eb      	str	r3, [r5, #12]
  while ((processed < max_burst) &&
 8008126:	d035      	beq.n	8008194 <thdMidiUsbTx+0xac>
         (chMBFetchTimeout(&midi_usb_rx_mb, &raw, TIME_IMMEDIATE) == MSG_OK)) {
 8008128:	2200      	movs	r2, #0
 800812a:	4669      	mov	r1, sp
 800812c:	4640      	mov	r0, r8
 800812e:	f7fe fcb7 	bl	8006aa0 <chMBFetchTimeout>
  while ((processed < max_burst) &&
 8008132:	bb78      	cbnz	r0, 8008194 <thdMidiUsbTx+0xac>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008134:	2330      	movs	r3, #48	; 0x30
 8008136:	f383 8811 	msr	BASEPRI, r3
  if (midi_usb_rx_queue_fill > 0U) {
 800813a:	8833      	ldrh	r3, [r6, #0]
 800813c:	b10b      	cbz	r3, 8008142 <thdMidiUsbTx+0x5a>
    midi_usb_rx_queue_fill--;
 800813e:	3b01      	subs	r3, #1
 8008140:	8033      	strh	r3, [r6, #0]
 8008142:	f387 8811 	msr	BASEPRI, r7
    pkt[0] = (uint8_t)((raw >> 24) & 0xFF);
 8008146:	9b00      	ldr	r3, [sp, #0]
    pkt[1] = (uint8_t)((raw >> 16) & 0xFF);
 8008148:	2101      	movs	r1, #1
  switch (cin) {
 800814a:	f644 7c08 	movw	ip, #20232	; 0x4f08
  const uint8_t cin = (uint8_t)(pkt[0] & 0x0F);
 800814e:	f3c3 6003 	ubfx	r0, r3, #24, #4
    pkt[1] = (uint8_t)((raw >> 16) & 0xFF);
 8008152:	f3c3 4e07 	ubfx	lr, r3, #16, #8
    pkt[2] = (uint8_t)((raw >> 8)  & 0xFF);
 8008156:	f3c3 2b07 	ubfx	fp, r3, #8, #8
  switch (cin) {
 800815a:	fa01 f200 	lsl.w	r2, r1, r0
 800815e:	ea12 0f0c 	tst.w	r2, ip
 8008162:	d0d3      	beq.n	800810c <thdMidiUsbTx+0x24>
      out->len = 3U;
 8008164:	2103      	movs	r1, #3
      out->data[0] = pkt[1];
 8008166:	f88d e004 	strb.w	lr, [sp, #4]
      out->data[1] = pkt[2];
 800816a:	f88d b005 	strb.w	fp, [sp, #5]
    pkt[3] = (uint8_t)( raw        & 0xFF);
 800816e:	f88d 3006 	strb.w	r3, [sp, #6]
      out->len = 3U;
 8008172:	f88d 1007 	strb.w	r1, [sp, #7]
  midi_internal_receive(msg->data, msg->len);
 8008176:	a801      	add	r0, sp, #4
 8008178:	f7ff ffb4 	bl	80080e4 <midi_internal_receive>
  if ((midi_rx_dest == MIDI_DEST_UART) || (midi_rx_dest == MIDI_DEST_BOTH)) {
 800817c:	f89a 3000 	ldrb.w	r3, [sl]
 8008180:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 8008184:	2b01      	cmp	r3, #1
 8008186:	d06b      	beq.n	8008260 <thdMidiUsbTx+0x178>
      midi_rx_stats.usb_rx_decoded++;
 8008188:	68ab      	ldr	r3, [r5, #8]
  while ((processed < max_burst) &&
 800818a:	3c01      	subs	r4, #1
      midi_rx_stats.usb_rx_decoded++;
 800818c:	f103 0301 	add.w	r3, r3, #1
 8008190:	60ab      	str	r3, [r5, #8]
  while ((processed < max_burst) &&
 8008192:	d1c9      	bne.n	8008128 <thdMidiUsbTx+0x40>
    msg_t res = chMBFetchTimeout(&midi_usb_mb, &msg, TIME_MS2I(1));
 8008194:	220a      	movs	r2, #10
 8008196:	a901      	add	r1, sp, #4
 8008198:	485b      	ldr	r0, [pc, #364]	; (8008308 <thdMidiUsbTx+0x220>)
 800819a:	f7fe fc81 	bl	8006aa0 <chMBFetchTimeout>
    if (res == MSG_OK) {
 800819e:	2800      	cmp	r0, #0
 80081a0:	d167      	bne.n	8008272 <thdMidiUsbTx+0x18a>
 80081a2:	2330      	movs	r3, #48	; 0x30
 80081a4:	f383 8811 	msr	BASEPRI, r3
  if (midi_usb_queue_fill > 0U) {
 80081a8:	4a58      	ldr	r2, [pc, #352]	; (800830c <thdMidiUsbTx+0x224>)
 80081aa:	8813      	ldrh	r3, [r2, #0]
 80081ac:	b10b      	cbz	r3, 80081b2 <thdMidiUsbTx+0xca>
    midi_usb_queue_fill--;
 80081ae:	3b01      	subs	r3, #1
 80081b0:	8013      	strh	r3, [r2, #0]
 80081b2:	2400      	movs	r4, #0
 80081b4:	f384 8811 	msr	BASEPRI, r4
      buf[n++] = (uint8_t)((msg >> 24) & 0xFF);
 80081b8:	9b01      	ldr	r3, [sp, #4]
 80081ba:	f109 0148 	add.w	r1, r9, #72	; 0x48
      buf[n++] = (uint8_t)( msg        & 0xFF);
 80081be:	f109 024b 	add.w	r2, r9, #75	; 0x4b
 80081c2:	f109 0904 	add.w	r9, r9, #4
      buf[n++] = (uint8_t)((msg >> 24) & 0xFF);
 80081c6:	4469      	add	r1, sp
 80081c8:	1618      	asrs	r0, r3, #24
      buf[n++] = (uint8_t)( msg        & 0xFF);
 80081ca:	446a      	add	r2, sp
      if (n == sizeof(buf)) {
 80081cc:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
      buf[n++] = (uint8_t)((msg >> 24) & 0xFF);
 80081d0:	f801 0c40 	strb.w	r0, [r1, #-64]
      buf[n++] = (uint8_t)((msg >> 16) & 0xFF);
 80081d4:	ea4f 4023 	mov.w	r0, r3, asr #16
 80081d8:	f801 0c3f 	strb.w	r0, [r1, #-63]
      buf[n++] = (uint8_t)((msg >> 8)  & 0xFF);
 80081dc:	ea4f 2023 	mov.w	r0, r3, asr #8
 80081e0:	f801 0c3e 	strb.w	r0, [r1, #-62]
      buf[n++] = (uint8_t)( msg        & 0xFF);
 80081e4:	f802 3c40 	strb.w	r3, [r2, #-64]
      if (n == sizeof(buf)) {
 80081e8:	d18d      	bne.n	8008106 <thdMidiUsbTx+0x1e>
 80081ea:	f04f 0b30 	mov.w	fp, #48	; 0x30
 80081ee:	f38b 8811 	msr	BASEPRI, fp
  ready = usb_midi_tx_ready;
 80081f2:	4b47      	ldr	r3, [pc, #284]	; (8008310 <thdMidiUsbTx+0x228>)
 80081f4:	781b      	ldrb	r3, [r3, #0]
 80081f6:	b2db      	uxtb	r3, r3
 80081f8:	f384 8811 	msr	BASEPRI, r4
        if (ready) {
 80081fc:	2b00      	cmp	r3, #0
 80081fe:	d051      	beq.n	80082a4 <thdMidiUsbTx+0x1bc>
  return chSemWaitTimeout(&bsp->sem, timeout);
 8008200:	2114      	movs	r1, #20
 8008202:	4844      	ldr	r0, [pc, #272]	; (8008314 <thdMidiUsbTx+0x22c>)
 8008204:	f7fe faae 	bl	8006764 <chSemWaitTimeout>
          if (chBSemWaitTimeout(&tx_sem, tw) == MSG_OK) {
 8008208:	4607      	mov	r7, r0
 800820a:	2800      	cmp	r0, #0
 800820c:	d15d      	bne.n	80082ca <thdMidiUsbTx+0x1e2>
 800820e:	f38b 8811 	msr	BASEPRI, fp
  usbStartTransmitI(&USBD1, MIDI_EP_IN, buffer, len);
 8008212:	2102      	movs	r1, #2
 8008214:	464b      	mov	r3, r9
 8008216:	aa02      	add	r2, sp, #8
 8008218:	483f      	ldr	r0, [pc, #252]	; (8008318 <thdMidiUsbTx+0x230>)
 800821a:	f7f9 fae3 	bl	80017e4 <usbStartTransmitI>
 800821e:	f387 8811 	msr	BASEPRI, r7
            midi_tx_stats.tx_sent_batched++;
 8008222:	4a3e      	ldr	r2, [pc, #248]	; (800831c <thdMidiUsbTx+0x234>)
        n = 0;
 8008224:	46b9      	mov	r9, r7
            midi_tx_stats.tx_sent_batched++;
 8008226:	6853      	ldr	r3, [r2, #4]
 8008228:	3301      	adds	r3, #1
 800822a:	6053      	str	r3, [r2, #4]
 800822c:	e76b      	b.n	8008106 <thdMidiUsbTx+0x1e>
      out->len = 2U;
 800822e:	2102      	movs	r1, #2
      out->data[0] = pkt[1];
 8008230:	f88d e004 	strb.w	lr, [sp, #4]
      out->data[1] = pkt[2];
 8008234:	f88d b005 	strb.w	fp, [sp, #5]
      out->len = 2U;
 8008238:	f88d 1007 	strb.w	r1, [sp, #7]
      return true;
 800823c:	e79b      	b.n	8008176 <thdMidiUsbTx+0x8e>
      switch (pkt[1]) {
 800823e:	f10e 0308 	add.w	r3, lr, #8
 8008242:	b2db      	uxtb	r3, r3
 8008244:	2b07      	cmp	r3, #7
 8008246:	f63f af69 	bhi.w	800811c <thdMidiUsbTx+0x34>
 800824a:	22dd      	movs	r2, #221	; 0xdd
 800824c:	fa22 f303 	lsr.w	r3, r2, r3
 8008250:	07db      	lsls	r3, r3, #31
 8008252:	f57f af63 	bpl.w	800811c <thdMidiUsbTx+0x34>
          out->data[0] = pkt[1];
 8008256:	f88d e004 	strb.w	lr, [sp, #4]
          out->len = 1U;
 800825a:	f88d 1007 	strb.w	r1, [sp, #7]
          return true;
 800825e:	e78a      	b.n	8008176 <thdMidiUsbTx+0x8e>
static void send_uart(const uint8_t *msg, size_t len) { sdWrite(MIDI_UART, msg, len); }
 8008260:	f04f 33ff 	mov.w	r3, #4294967295
 8008264:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8008268:	a901      	add	r1, sp, #4
 800826a:	482d      	ldr	r0, [pc, #180]	; (8008320 <thdMidiUsbTx+0x238>)
 800826c:	f7f8 fe28 	bl	8000ec0 <oqWriteTimeout>
 8008270:	e78a      	b.n	8008188 <thdMidiUsbTx+0xa0>
    } else if (n > 0U) {
 8008272:	f1b9 0f00 	cmp.w	r9, #0
 8008276:	f43f af46 	beq.w	8008106 <thdMidiUsbTx+0x1e>
 800827a:	210a      	movs	r1, #10
 800827c:	4829      	ldr	r0, [pc, #164]	; (8008324 <thdMidiUsbTx+0x23c>)
 800827e:	f7fe fa71 	bl	8006764 <chSemWaitTimeout>
 8008282:	2730      	movs	r7, #48	; 0x30
 8008284:	f387 8811 	msr	BASEPRI, r7
  ready = usb_midi_tx_ready;
 8008288:	4b21      	ldr	r3, [pc, #132]	; (8008310 <thdMidiUsbTx+0x228>)
 800828a:	2400      	movs	r4, #0
 800828c:	781b      	ldrb	r3, [r3, #0]
 800828e:	b2db      	uxtb	r3, r3
 8008290:	f384 8811 	msr	BASEPRI, r4
      if (ready) {
 8008294:	b963      	cbnz	r3, 80082b0 <thdMidiUsbTx+0x1c8>
        midi_tx_stats.usb_not_ready_drops += n / 4;
 8008296:	4921      	ldr	r1, [pc, #132]	; (800831c <thdMidiUsbTx+0x234>)
 8008298:	698a      	ldr	r2, [r1, #24]
 800829a:	eb02 0299 	add.w	r2, r2, r9, lsr #2
      n = 0;
 800829e:	4699      	mov	r9, r3
        midi_tx_stats.usb_not_ready_drops += n / 4;
 80082a0:	618a      	str	r2, [r1, #24]
  while (true) {
 80082a2:	e730      	b.n	8008106 <thdMidiUsbTx+0x1e>
          midi_tx_stats.usb_not_ready_drops += n / 4;
 80082a4:	4a1d      	ldr	r2, [pc, #116]	; (800831c <thdMidiUsbTx+0x234>)
        n = 0;
 80082a6:	4699      	mov	r9, r3
          midi_tx_stats.usb_not_ready_drops += n / 4;
 80082a8:	6993      	ldr	r3, [r2, #24]
 80082aa:	3310      	adds	r3, #16
 80082ac:	6193      	str	r3, [r2, #24]
 80082ae:	e72a      	b.n	8008106 <thdMidiUsbTx+0x1e>
 80082b0:	2114      	movs	r1, #20
 80082b2:	4818      	ldr	r0, [pc, #96]	; (8008314 <thdMidiUsbTx+0x22c>)
 80082b4:	f7fe fa56 	bl	8006764 <chSemWaitTimeout>
        if (chBSemWaitTimeout(&tx_sem, tw) == MSG_OK) {
 80082b8:	4683      	mov	fp, r0
 80082ba:	b160      	cbz	r0, 80082d6 <thdMidiUsbTx+0x1ee>
          midi_tx_stats.usb_not_ready_drops += n / 4;
 80082bc:	4a17      	ldr	r2, [pc, #92]	; (800831c <thdMidiUsbTx+0x234>)
 80082be:	6993      	ldr	r3, [r2, #24]
 80082c0:	eb03 0399 	add.w	r3, r3, r9, lsr #2
      n = 0;
 80082c4:	46a1      	mov	r9, r4
          midi_tx_stats.usb_not_ready_drops += n / 4;
 80082c6:	6193      	str	r3, [r2, #24]
 80082c8:	e71d      	b.n	8008106 <thdMidiUsbTx+0x1e>
            midi_tx_stats.usb_not_ready_drops += n / 4;
 80082ca:	4a14      	ldr	r2, [pc, #80]	; (800831c <thdMidiUsbTx+0x234>)
        n = 0;
 80082cc:	46a1      	mov	r9, r4
            midi_tx_stats.usb_not_ready_drops += n / 4;
 80082ce:	6993      	ldr	r3, [r2, #24]
 80082d0:	3310      	adds	r3, #16
 80082d2:	6193      	str	r3, [r2, #24]
 80082d4:	e717      	b.n	8008106 <thdMidiUsbTx+0x1e>
 80082d6:	f387 8811 	msr	BASEPRI, r7
  usbStartTransmitI(&USBD1, MIDI_EP_IN, buffer, len);
 80082da:	2102      	movs	r1, #2
 80082dc:	464b      	mov	r3, r9
 80082de:	aa02      	add	r2, sp, #8
 80082e0:	480d      	ldr	r0, [pc, #52]	; (8008318 <thdMidiUsbTx+0x230>)
 80082e2:	f7f9 fa7f 	bl	80017e4 <usbStartTransmitI>
 80082e6:	f38b 8811 	msr	BASEPRI, fp
          midi_tx_stats.tx_sent_batched++;
 80082ea:	4a0c      	ldr	r2, [pc, #48]	; (800831c <thdMidiUsbTx+0x234>)
      n = 0;
 80082ec:	46d9      	mov	r9, fp
          midi_tx_stats.tx_sent_batched++;
 80082ee:	6853      	ldr	r3, [r2, #4]
 80082f0:	3301      	adds	r3, #1
 80082f2:	6053      	str	r3, [r2, #4]
 80082f4:	e707      	b.n	8008106 <thdMidiUsbTx+0x1e>
 80082f6:	bf00      	nop
 80082f8:	24000c20 	.word	0x24000c20
 80082fc:	08014fb4 	.word	0x08014fb4
 8008300:	240032f0 	.word	0x240032f0
 8008304:	24002c6c 	.word	0x24002c6c
 8008308:	24002c98 	.word	0x24002c98
 800830c:	240030c0 	.word	0x240030c0
 8008310:	240037a4 	.word	0x240037a4
 8008314:	24003300 	.word	0x24003300
 8008318:	24000874 	.word	0x24000874
 800831c:	24002c7c 	.word	0x24002c7c
 8008320:	24000bcc 	.word	0x24000bcc
 8008324:	240032f4 	.word	0x240032f4
 8008328:	24000004 	.word	0x24000004
 800832c:	240030c8 	.word	0x240030c8

08008330 <midi_usb_rx_submit_from_isr>:
  if ((packet == NULL) || (len < 4U)) {
 8008330:	2800      	cmp	r0, #0
 8008332:	d045      	beq.n	80083c0 <midi_usb_rx_submit_from_isr+0x90>
 8008334:	2903      	cmp	r1, #3
 8008336:	d943      	bls.n	80083c0 <midi_usb_rx_submit_from_isr+0x90>
  const size_t packets = len / 4U;
 8008338:	0889      	lsrs	r1, r1, #2
 800833a:	2330      	movs	r3, #48	; 0x30
void midi_usb_rx_submit_from_isr(const uint8_t *packet, size_t len) {
 800833c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008340:	f383 8811 	msr	BASEPRI, r3
  if (midi_usb_rx_mb.buffer == NULL) {
 8008344:	f8df a084 	ldr.w	sl, [pc, #132]	; 80083cc <midi_usb_rx_submit_from_isr+0x9c>
 8008348:	f8da 3000 	ldr.w	r3, [sl]
 800834c:	b3a3      	cbz	r3, 80083b8 <midi_usb_rx_submit_from_isr+0x88>
 800834e:	4604      	mov	r4, r0
 8008350:	eb00 0581 	add.w	r5, r0, r1, lsl #2
 8008354:	f8df 9078 	ldr.w	r9, [pc, #120]	; 80083d0 <midi_usb_rx_submit_from_isr+0xa0>
 8008358:	4e1a      	ldr	r6, [pc, #104]	; (80083c4 <midi_usb_rx_submit_from_isr+0x94>)
        midi_usb_rx_drops++;
 800835a:	4f1b      	ldr	r7, [pc, #108]	; (80083c8 <midi_usb_rx_submit_from_isr+0x98>)
    if (midi_usb_rx_queue_fill > midi_usb_rx_queue_high_water) {
 800835c:	f8df 8074 	ldr.w	r8, [pc, #116]	; 80083d4 <midi_usb_rx_submit_from_isr+0xa4>
 8008360:	e009      	b.n	8008376 <midi_usb_rx_submit_from_isr+0x46>
        midi_usb_rx_drops++;
 8008362:	683b      	ldr	r3, [r7, #0]
    packet += 4U;
 8008364:	3404      	adds	r4, #4
        midi_usb_rx_drops++;
 8008366:	3301      	adds	r3, #1
  for (size_t i = 0; i < packets; i++) {
 8008368:	42a5      	cmp	r5, r4
        midi_usb_rx_drops++;
 800836a:	603b      	str	r3, [r7, #0]
        midi_rx_stats.usb_rx_drops++;
 800836c:	6873      	ldr	r3, [r6, #4]
 800836e:	f103 0301 	add.w	r3, r3, #1
 8008372:	6073      	str	r3, [r6, #4]
  for (size_t i = 0; i < packets; i++) {
 8008374:	d01f      	beq.n	80083b6 <midi_usb_rx_submit_from_isr+0x86>
    if (midi_usb_rx_queue_fill >= MIDI_USB_RX_QUEUE_LEN) {
 8008376:	f8b9 3000 	ldrh.w	r3, [r9]
 800837a:	2b7f      	cmp	r3, #127	; 0x7f
 800837c:	d8f1      	bhi.n	8008362 <midi_usb_rx_submit_from_isr+0x32>
      if (chMBPostI(&midi_usb_rx_mb, m) == MSG_OK) {
 800837e:	6821      	ldr	r1, [r4, #0]
 8008380:	4650      	mov	r0, sl
 8008382:	ba09      	rev	r1, r1
 8008384:	f7fe fb40 	bl	8006a08 <chMBPostI>
 8008388:	2800      	cmp	r0, #0
 800838a:	d1ea      	bne.n	8008362 <midi_usb_rx_submit_from_isr+0x32>
  if (midi_usb_rx_queue_fill < MIDI_USB_RX_QUEUE_LEN) {
 800838c:	f8b9 3000 	ldrh.w	r3, [r9]
 8008390:	2b7f      	cmp	r3, #127	; 0x7f
    midi_usb_rx_queue_fill++;
 8008392:	f103 0301 	add.w	r3, r3, #1
 8008396:	b29b      	uxth	r3, r3
  if (midi_usb_rx_queue_fill < MIDI_USB_RX_QUEUE_LEN) {
 8008398:	d807      	bhi.n	80083aa <midi_usb_rx_submit_from_isr+0x7a>
    if (midi_usb_rx_queue_fill > midi_usb_rx_queue_high_water) {
 800839a:	f8b8 2000 	ldrh.w	r2, [r8]
    midi_usb_rx_queue_fill++;
 800839e:	f8a9 3000 	strh.w	r3, [r9]
    if (midi_usb_rx_queue_fill > midi_usb_rx_queue_high_water) {
 80083a2:	429a      	cmp	r2, r3
      midi_usb_rx_queue_high_water = midi_usb_rx_queue_fill;
 80083a4:	bf38      	it	cc
 80083a6:	f8a8 3000 	strhcc.w	r3, [r8]
        midi_rx_stats.usb_rx_enqueued++;
 80083aa:	6833      	ldr	r3, [r6, #0]
    packet += 4U;
 80083ac:	3404      	adds	r4, #4
        midi_rx_stats.usb_rx_enqueued++;
 80083ae:	3301      	adds	r3, #1
  for (size_t i = 0; i < packets; i++) {
 80083b0:	42a5      	cmp	r5, r4
        midi_rx_stats.usb_rx_enqueued++;
 80083b2:	6033      	str	r3, [r6, #0]
  for (size_t i = 0; i < packets; i++) {
 80083b4:	d1df      	bne.n	8008376 <midi_usb_rx_submit_from_isr+0x46>
 80083b6:	2300      	movs	r3, #0
 80083b8:	f383 8811 	msr	BASEPRI, r3
}
 80083bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80083c0:	4770      	bx	lr
 80083c2:	bf00      	nop
 80083c4:	24002c6c 	.word	0x24002c6c
 80083c8:	240030c4 	.word	0x240030c4
 80083cc:	240030c8 	.word	0x240030c8
 80083d0:	240032f0 	.word	0x240032f0
 80083d4:	240032f2 	.word	0x240032f2

080083d8 <midi_init>:
void midi_init(void) {
 80083d8:	b510      	push	{r4, lr}
 80083da:	2330      	movs	r3, #48	; 0x30
 80083dc:	b082      	sub	sp, #8
 80083de:	f383 8811 	msr	BASEPRI, r3
  if (midi_initialized) {
 80083e2:	4b1b      	ldr	r3, [pc, #108]	; (8008450 <midi_init+0x78>)
 80083e4:	781c      	ldrb	r4, [r3, #0]
 80083e6:	b124      	cbz	r4, 80083f2 <midi_init+0x1a>
 80083e8:	2300      	movs	r3, #0
 80083ea:	f383 8811 	msr	BASEPRI, r3
}
 80083ee:	b002      	add	sp, #8
 80083f0:	bd10      	pop	{r4, pc}
  midi_initialized = true;
 80083f2:	2201      	movs	r2, #1
 80083f4:	701a      	strb	r2, [r3, #0]
 80083f6:	f384 8811 	msr	BASEPRI, r4
  sdStart(MIDI_UART, &uart_cfg);
 80083fa:	4916      	ldr	r1, [pc, #88]	; (8008454 <midi_init+0x7c>)
 80083fc:	4816      	ldr	r0, [pc, #88]	; (8008458 <midi_init+0x80>)
 80083fe:	f7f9 f915 	bl	800162c <sdStart>
  midi_usb_queue_high_water = 0;
 8008402:	4b16      	ldr	r3, [pc, #88]	; (800845c <midi_init+0x84>)
  midi_usb_queue_fill = 0;
 8008404:	4a16      	ldr	r2, [pc, #88]	; (8008460 <midi_init+0x88>)
  midi_usb_rx_queue_fill = 0;
 8008406:	4817      	ldr	r0, [pc, #92]	; (8008464 <midi_init+0x8c>)
  midi_usb_rx_queue_high_water = 0;
 8008408:	4917      	ldr	r1, [pc, #92]	; (8008468 <midi_init+0x90>)
  midi_usb_queue_high_water = 0;
 800840a:	801c      	strh	r4, [r3, #0]
  midi_usb_rx_drops = 0;
 800840c:	4b17      	ldr	r3, [pc, #92]	; (800846c <midi_init+0x94>)
  midi_usb_queue_fill = 0;
 800840e:	8014      	strh	r4, [r2, #0]
  chMBObjectInit(&midi_usb_mb, midi_usb_queue, MIDI_USB_QUEUE_LEN);
 8008410:	f44f 7280 	mov.w	r2, #256	; 0x100
  midi_usb_rx_queue_fill = 0;
 8008414:	8004      	strh	r4, [r0, #0]
  midi_usb_rx_queue_high_water = 0;
 8008416:	800c      	strh	r4, [r1, #0]
  chMBObjectInit(&midi_usb_mb, midi_usb_queue, MIDI_USB_QUEUE_LEN);
 8008418:	4815      	ldr	r0, [pc, #84]	; (8008470 <midi_init+0x98>)
 800841a:	4916      	ldr	r1, [pc, #88]	; (8008474 <midi_init+0x9c>)
  midi_usb_rx_drops = 0;
 800841c:	601c      	str	r4, [r3, #0]
  chMBObjectInit(&midi_usb_mb, midi_usb_queue, MIDI_USB_QUEUE_LEN);
 800841e:	f7fe faa5 	bl	800696c <chMBObjectInit>
  chMBObjectInit(&midi_usb_rx_mb, midi_usb_rx_queue, MIDI_USB_RX_QUEUE_LEN);
 8008422:	2280      	movs	r2, #128	; 0x80
 8008424:	4814      	ldr	r0, [pc, #80]	; (8008478 <midi_init+0xa0>)
 8008426:	4915      	ldr	r1, [pc, #84]	; (800847c <midi_init+0xa4>)
 8008428:	f7fe faa0 	bl	800696c <chMBObjectInit>
  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 800842c:	4621      	mov	r1, r4
 800842e:	4814      	ldr	r0, [pc, #80]	; (8008480 <midi_init+0xa8>)
 8008430:	f7fe f972 	bl	8006718 <chSemObjectInit>
 8008434:	4621      	mov	r1, r4
 8008436:	4813      	ldr	r0, [pc, #76]	; (8008484 <midi_init+0xac>)
 8008438:	f7fe f96e 	bl	8006718 <chSemObjectInit>
  chThdCreateStatic(waMidiUsbTx, sizeof(waMidiUsbTx),
 800843c:	4b12      	ldr	r3, [pc, #72]	; (8008488 <midi_init+0xb0>)
 800843e:	2281      	movs	r2, #129	; 0x81
 8008440:	f44f 7178 	mov.w	r1, #992	; 0x3e0
 8008444:	9400      	str	r4, [sp, #0]
 8008446:	4811      	ldr	r0, [pc, #68]	; (800848c <midi_init+0xb4>)
 8008448:	f7fe f82e 	bl	80064a8 <chThdCreateStatic>
}
 800844c:	b002      	add	sp, #8
 800844e:	bd10      	pop	{r4, pc}
 8008450:	24002c6b 	.word	0x24002c6b
 8008454:	08014fc0 	.word	0x08014fc0
 8008458:	24000b9c 	.word	0x24000b9c
 800845c:	240030c2 	.word	0x240030c2
 8008460:	240030c0 	.word	0x240030c0
 8008464:	240032f0 	.word	0x240032f0
 8008468:	240032f2 	.word	0x240032f2
 800846c:	240030c4 	.word	0x240030c4
 8008470:	24002c98 	.word	0x24002c98
 8008474:	24002cc0 	.word	0x24002cc0
 8008478:	240030c8 	.word	0x240030c8
 800847c:	240030f0 	.word	0x240030f0
 8008480:	24003300 	.word	0x24003300
 8008484:	240032f4 	.word	0x240032f4
 8008488:	080080e9 	.word	0x080080e9
 800848c:	24003320 	.word	0x24003320

08008490 <bist_run_stress_sequential_offset.constprop.0>:

static void bist_run_stress_sequential_offset(volatile uint16_t *base,
                                              uint32_t offset_words,
                                              uint32_t words,
                                              sdram_bist_context_t *ctx) {
  volatile uint16_t *const target = base + offset_words;
 8008490:	0040      	lsls	r0, r0, #1
  for (uint32_t i = 0; i < words; ++i) {
 8008492:	2300      	movs	r3, #0
  volatile uint16_t *const target = base + offset_words;
 8008494:	f100 4040 	add.w	r0, r0, #3221225472	; 0xc0000000
 8008498:	4602      	mov	r2, r0
static void bist_run_stress_sequential_offset(volatile uint16_t *base,
 800849a:	b510      	push	{r4, lr}
    target[i] = (uint16_t)(i & 0xFFFFu);
 800849c:	fa1f fc83 	uxth.w	ip, r3
  for (uint32_t i = 0; i < words; ++i) {
 80084a0:	3301      	adds	r3, #1
 80084a2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    target[i] = (uint16_t)(i & 0xFFFFu);
 80084a6:	f822 cb02 	strh.w	ip, [r2], #2
  for (uint32_t i = 0; i < words; ++i) {
 80084aa:	d1f7      	bne.n	800849c <bist_run_stress_sequential_offset.constprop.0+0xc>
  }

  for (uint32_t i = 0; i < words; ++i) {
 80084ac:	2300      	movs	r3, #0
    res->first_error = classification;
 80084ae:	f04f 0e01 	mov.w	lr, #1
    const uint16_t expected = (uint16_t)(i & 0xFFFFu);
    const uint16_t read_back = target[i];
 80084b2:	8802      	ldrh	r2, [r0, #0]
 80084b4:	fa1f fc83 	uxth.w	ip, r3
  for (uint32_t i = 0; i < words; ++i) {
 80084b8:	3301      	adds	r3, #1
    const uint16_t read_back = target[i];
 80084ba:	b292      	uxth	r2, r2
    if (read_back != expected) {
 80084bc:	4562      	cmp	r2, ip
 80084be:	d00c      	beq.n	80084da <bist_run_stress_sequential_offset.constprop.0+0x4a>
  res->error_count++;
 80084c0:	698a      	ldr	r2, [r1, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 80084c2:	f891 4020 	ldrb.w	r4, [r1, #32]
  res->error_count++;
 80084c6:	3201      	adds	r2, #1
 80084c8:	618a      	str	r2, [r1, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 80084ca:	b934      	cbnz	r4, 80084da <bist_run_stress_sequential_offset.constprop.0+0x4a>
    res->first_error_address = addr;
 80084cc:	61c8      	str	r0, [r1, #28]
    res->first_error_pattern = expected;
 80084ce:	f8a1 c022 	strh.w	ip, [r1, #34]	; 0x22
    res->first_error = classification;
 80084d2:	f881 e020 	strb.w	lr, [r1, #32]
    res->status = SDRAM_BIST_FAIL;
 80084d6:	f881 e00c 	strb.w	lr, [r1, #12]
  for (uint32_t i = 0; i < words; ++i) {
 80084da:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80084de:	f100 0002 	add.w	r0, r0, #2
 80084e2:	d1e6      	bne.n	80084b2 <bist_run_stress_sequential_offset.constprop.0+0x22>
      bist_record_error(&ctx->result, (uintptr_t)(&target[i]), expected, read_back, SDRAM_BIST_ERR_DATA_MISMATCH);
    }
  }

  ctx->patterns_executed++;
 80084e4:	684a      	ldr	r2, [r1, #4]
  ctx->result.words_tested += words;
 80084e6:	690b      	ldr	r3, [r1, #16]
  ctx->patterns_executed++;
 80084e8:	3201      	adds	r2, #1
  ctx->result.words_tested += words;
 80084ea:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
  ctx->patterns_executed++;
 80084ee:	604a      	str	r2, [r1, #4]
  ctx->result.words_tested += words;
 80084f0:	610b      	str	r3, [r1, #16]
}
 80084f2:	bd10      	pop	{r4, pc}

080084f4 <bist_run_constant_pattern.constprop.0>:
static void bist_run_constant_pattern(volatile uint16_t *base, uint32_t words, uint16_t pattern, sdram_bist_context_t *ctx) {
 80084f4:	b570      	push	{r4, r5, r6, lr}
 80084f6:	f100 4ec0 	add.w	lr, r0, #1610612736	; 0x60000000
 80084fa:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 80084fe:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    base[i] = pattern;
 8008502:	f823 1b02 	strh.w	r1, [r3], #2
  for (uint32_t i = 0; i < words; ++i) {
 8008506:	4573      	cmp	r3, lr
 8008508:	d1fb      	bne.n	8008502 <bist_run_constant_pattern.constprop.0+0xe>
 800850a:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    res->first_error = classification;
 800850e:	2601      	movs	r6, #1
    uint16_t read_back = base[i];
 8008510:	f8b3 c000 	ldrh.w	ip, [r3]
 8008514:	fa1f fc8c 	uxth.w	ip, ip
    if (read_back != pattern) {
 8008518:	4561      	cmp	r1, ip
 800851a:	d00a      	beq.n	8008532 <bist_run_constant_pattern.constprop.0+0x3e>
  res->error_count++;
 800851c:	6994      	ldr	r4, [r2, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 800851e:	f892 5020 	ldrb.w	r5, [r2, #32]
  res->error_count++;
 8008522:	3401      	adds	r4, #1
 8008524:	6194      	str	r4, [r2, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 8008526:	b925      	cbnz	r5, 8008532 <bist_run_constant_pattern.constprop.0+0x3e>
    res->first_error_address = addr;
 8008528:	61d3      	str	r3, [r2, #28]
    res->first_error_pattern = expected;
 800852a:	8451      	strh	r1, [r2, #34]	; 0x22
    res->first_error = classification;
 800852c:	f882 6020 	strb.w	r6, [r2, #32]
    res->status = SDRAM_BIST_FAIL;
 8008530:	7316      	strb	r6, [r2, #12]
  for (uint32_t i = 0; i < words; ++i) {
 8008532:	3302      	adds	r3, #2
 8008534:	4573      	cmp	r3, lr
 8008536:	d1eb      	bne.n	8008510 <bist_run_constant_pattern.constprop.0+0x1c>
  ctx->patterns_executed++;
 8008538:	6851      	ldr	r1, [r2, #4]
  ctx->result.words_tested += words;
 800853a:	6913      	ldr	r3, [r2, #16]
  ctx->patterns_executed++;
 800853c:	3101      	adds	r1, #1
  ctx->result.words_tested += words;
 800853e:	4403      	add	r3, r0
  ctx->patterns_executed++;
 8008540:	6051      	str	r1, [r2, #4]
  ctx->result.words_tested += words;
 8008542:	6113      	str	r3, [r2, #16]
}
 8008544:	bd70      	pop	{r4, r5, r6, pc}
 8008546:	bf00      	nop

08008548 <bist_run_walking.constprop.0>:
static void bist_run_walking(volatile uint16_t *base, uint32_t words, bool walking_one, sdram_bist_context_t *ctx) {
 8008548:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ctx->patterns_executed++;
 800854c:	6853      	ldr	r3, [r2, #4]
 800854e:	f100 44c0 	add.w	r4, r0, #1610612736	; 0x60000000
 8008552:	6917      	ldr	r7, [r2, #16]
static void bist_run_walking(volatile uint16_t *base, uint32_t words, bool walking_one, sdram_bist_context_t *ctx) {
 8008554:	4682      	mov	sl, r0
 8008556:	4689      	mov	r9, r1
 8008558:	f103 0801 	add.w	r8, r3, #1
 800855c:	4407      	add	r7, r0
 800855e:	0064      	lsls	r4, r4, #1
  for (uint32_t bit = 0; bit < 16u; ++bit) {
 8008560:	2600      	movs	r6, #0
    uint16_t pattern = walking_one ? ((uint16_t)1u << bit) : (uint16_t)(~((uint16_t)1u << bit));
 8008562:	2501      	movs	r5, #1
 8008564:	fa05 fe06 	lsl.w	lr, r5, r6
 8008568:	f1b9 0f00 	cmp.w	r9, #0
 800856c:	d101      	bne.n	8008572 <bist_run_walking.constprop.0+0x2a>
 800856e:	ea6f 0e0e 	mvn.w	lr, lr
 8008572:	fa1f fe8e 	uxth.w	lr, lr
  for (uint32_t bit = 0; bit < 16u; ++bit) {
 8008576:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    base[i] = pattern;
 800857a:	f823 eb02 	strh.w	lr, [r3], #2
  for (uint32_t i = 0; i < words; ++i) {
 800857e:	42a3      	cmp	r3, r4
 8008580:	d1fb      	bne.n	800857a <bist_run_walking.constprop.0+0x32>
 8008582:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    uint16_t read_back = base[i];
 8008586:	f8b3 c000 	ldrh.w	ip, [r3]
 800858a:	fa1f fc8c 	uxth.w	ip, ip
    if (read_back != pattern) {
 800858e:	45e6      	cmp	lr, ip
 8008590:	d00d      	beq.n	80085ae <bist_run_walking.constprop.0+0x66>
  res->error_count++;
 8008592:	6990      	ldr	r0, [r2, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 8008594:	f892 1020 	ldrb.w	r1, [r2, #32]
  res->error_count++;
 8008598:	f100 0c01 	add.w	ip, r0, #1
 800859c:	f8c2 c018 	str.w	ip, [r2, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 80085a0:	b929      	cbnz	r1, 80085ae <bist_run_walking.constprop.0+0x66>
    res->first_error_address = addr;
 80085a2:	61d3      	str	r3, [r2, #28]
    res->first_error_pattern = expected;
 80085a4:	f8a2 e022 	strh.w	lr, [r2, #34]	; 0x22
    res->first_error = classification;
 80085a8:	f882 5020 	strb.w	r5, [r2, #32]
    res->status = SDRAM_BIST_FAIL;
 80085ac:	7315      	strb	r5, [r2, #12]
  for (uint32_t i = 0; i < words; ++i) {
 80085ae:	3302      	adds	r3, #2
 80085b0:	42a3      	cmp	r3, r4
 80085b2:	d1e8      	bne.n	8008586 <bist_run_walking.constprop.0+0x3e>
    ctx->patterns_executed++;
 80085b4:	eb08 0306 	add.w	r3, r8, r6
  for (uint32_t bit = 0; bit < 16u; ++bit) {
 80085b8:	3601      	adds	r6, #1
    ctx->result.words_tested += words;
 80085ba:	6117      	str	r7, [r2, #16]
  for (uint32_t bit = 0; bit < 16u; ++bit) {
 80085bc:	4457      	add	r7, sl
 80085be:	2e10      	cmp	r6, #16
    ctx->patterns_executed++;
 80085c0:	6053      	str	r3, [r2, #4]
  for (uint32_t bit = 0; bit < 16u; ++bit) {
 80085c2:	d1cf      	bne.n	8008564 <bist_run_walking.constprop.0+0x1c>
}
 80085c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080085c8 <sdram_bist_start>:

bool sdram_bist_start(sdram_bist_context_t *ctx) {
 80085c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (ctx == NULL) {
 80085cc:	4605      	mov	r5, r0
 80085ce:	b110      	cbz	r0, 80085d6 <sdram_bist_start+0xe>
    return false;
  }

  if ((ctx->mode != SDRAM_BIST_MODE_QUICK) && (ctx->mode != SDRAM_BIST_MODE_FULL)) {
 80085d0:	7803      	ldrb	r3, [r0, #0]
 80085d2:	2b01      	cmp	r3, #1
 80085d4:	d902      	bls.n	80085dc <sdram_bist_start+0x14>
    return false;
 80085d6:	2000      	movs	r0, #0
    chThdYield();
  }

  bist_finalize_result(&ctx->result);
  return true;
}
 80085d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  res->status = SDRAM_BIST_PASS;
 80085dc:	2700      	movs	r7, #0
 80085de:	7307      	strb	r7, [r0, #12]
  res->first_error = SDRAM_BIST_ERR_NONE;
 80085e0:	f880 7020 	strb.w	r7, [r0, #32]
  res->first_error_pattern = 0u;
 80085e4:	8447      	strh	r7, [r0, #34]	; 0x22
  res->words_covered_unique = 0u;
 80085e6:	e9c0 7704 	strd	r7, r7, [r0, #16]
  res->first_error_address = 0u;
 80085ea:	e9c0 7706 	strd	r7, r7, [r0, #24]
 80085ee:	f7f8 fb05 	bl	8000bfc <stGetCounter>
  const uint32_t coverage_bytes = (ctx->mode == SDRAM_BIST_MODE_FULL) ? SDRAM_FULL_BYTES : SDRAM_QUICK_BYTES;
 80085f2:	782b      	ldrb	r3, [r5, #0]
  bist_run_constant_pattern(base, coverage_words, 0x0000u, ctx);
 80085f4:	462a      	mov	r2, r5
 80085f6:	4639      	mov	r1, r7
  const uint32_t coverage_bytes = (ctx->mode == SDRAM_BIST_MODE_FULL) ? SDRAM_FULL_BYTES : SDRAM_QUICK_BYTES;
 80085f8:	2b01      	cmp	r3, #1
  ctx->patterns_executed = 0u;
 80085fa:	606f      	str	r7, [r5, #4]
  const uint32_t coverage_bytes = (ctx->mode == SDRAM_BIST_MODE_FULL) ? SDRAM_FULL_BYTES : SDRAM_QUICK_BYTES;
 80085fc:	bf0b      	itete	eq
 80085fe:	f04f 7680 	moveq.w	r6, #16777216	; 0x1000000
 8008602:	f44f 2600 	movne.w	r6, #524288	; 0x80000
 8008606:	f04f 7400 	moveq.w	r4, #33554432	; 0x2000000
 800860a:	f44f 1480 	movne.w	r4, #1048576	; 0x100000
  ctx->words_target = coverage_words;
 800860e:	60ae      	str	r6, [r5, #8]
  ctx->result.words_covered_unique = coverage_words;
 8008610:	616e      	str	r6, [r5, #20]
  res->timestamp_end = res->timestamp_start;
 8008612:	e9c5 0009 	strd	r0, r0, [r5, #36]	; 0x24
  bist_run_constant_pattern(base, coverage_words, 0x0000u, ctx);
 8008616:	4630      	mov	r0, r6
 8008618:	f7ff ff6c 	bl	80084f4 <bist_run_constant_pattern.constprop.0>
  bist_run_constant_pattern(base, coverage_words, 0xFFFFu, ctx);
 800861c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008620:	f7ff ff68 	bl	80084f4 <bist_run_constant_pattern.constprop.0>
  bist_run_constant_pattern(base, coverage_words, 0xAAAAu, ctx);
 8008624:	f64a 21aa 	movw	r1, #43690	; 0xaaaa
 8008628:	f7ff ff64 	bl	80084f4 <bist_run_constant_pattern.constprop.0>
  bist_run_constant_pattern(base, coverage_words, 0x5555u, ctx);
 800862c:	f245 5155 	movw	r1, #21845	; 0x5555
 8008630:	f7ff ff60 	bl	80084f4 <bist_run_constant_pattern.constprop.0>
  bist_run_walking(base, coverage_words, true, ctx);
 8008634:	2101      	movs	r1, #1
 8008636:	f7ff ff87 	bl	8008548 <bist_run_walking.constprop.0>
  bist_run_walking(base, coverage_words, false, ctx);
 800863a:	4639      	mov	r1, r7
 800863c:	4630      	mov	r0, r6
 800863e:	f7ff ff83 	bl	8008548 <bist_run_walking.constprop.0>
  for (uint32_t i = 0; i < words; ++i) {
 8008642:	f106 42c0 	add.w	r2, r6, #1610612736	; 0x60000000
  bist_run_walking(base, coverage_words, false, ctx);
 8008646:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
  uint16_t lfsr = 0xACE1u;
 800864a:	f64a 41e1 	movw	r1, #44257	; 0xace1
 800864e:	0052      	lsls	r2, r2, #1
    uint16_t bit = (uint16_t)(((lfsr >> 0u) ^ (lfsr >> 2u) ^ (lfsr >> 3u) ^ (lfsr >> 5u)) & 1u);
 8008650:	08cb      	lsrs	r3, r1, #3
 8008652:	ea83 0391 	eor.w	r3, r3, r1, lsr #2
 8008656:	404b      	eors	r3, r1
 8008658:	ea83 1351 	eor.w	r3, r3, r1, lsr #5
    lfsr = (uint16_t)((lfsr >> 1u) | (bit << 15));
 800865c:	f003 0301 	and.w	r3, r3, #1
 8008660:	03db      	lsls	r3, r3, #15
 8008662:	ea43 0151 	orr.w	r1, r3, r1, lsr #1
    base[i] = lfsr;
 8008666:	f820 1b02 	strh.w	r1, [r0], #2
  for (uint32_t i = 0; i < words; ++i) {
 800866a:	4282      	cmp	r2, r0
 800866c:	d1f0      	bne.n	8008650 <sdram_bist_start+0x88>
 800866e:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
  lfsr = 0xACE1u;
 8008672:	f64a 41e1 	movw	r1, #44257	; 0xace1
    res->first_error = classification;
 8008676:	f04f 0e01 	mov.w	lr, #1
    uint16_t bit = (uint16_t)(((lfsr >> 0u) ^ (lfsr >> 2u) ^ (lfsr >> 3u) ^ (lfsr >> 5u)) & 1u);
 800867a:	08cb      	lsrs	r3, r1, #3
    uint16_t read_back = base[i];
 800867c:	f8b0 c000 	ldrh.w	ip, [r0]
    uint16_t bit = (uint16_t)(((lfsr >> 0u) ^ (lfsr >> 2u) ^ (lfsr >> 3u) ^ (lfsr >> 5u)) & 1u);
 8008680:	ea83 0391 	eor.w	r3, r3, r1, lsr #2
    uint16_t read_back = base[i];
 8008684:	fa1f fc8c 	uxth.w	ip, ip
    uint16_t bit = (uint16_t)(((lfsr >> 0u) ^ (lfsr >> 2u) ^ (lfsr >> 3u) ^ (lfsr >> 5u)) & 1u);
 8008688:	404b      	eors	r3, r1
 800868a:	ea83 1351 	eor.w	r3, r3, r1, lsr #5
    lfsr = (uint16_t)((lfsr >> 1u) | (bit << 15));
 800868e:	f003 0301 	and.w	r3, r3, #1
 8008692:	03db      	lsls	r3, r3, #15
 8008694:	ea43 0151 	orr.w	r1, r3, r1, lsr #1
    if (read_back != expected) {
 8008698:	4561      	cmp	r1, ip
 800869a:	d00b      	beq.n	80086b4 <sdram_bist_start+0xec>
  res->error_count++;
 800869c:	69ab      	ldr	r3, [r5, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 800869e:	f895 7020 	ldrb.w	r7, [r5, #32]
  res->error_count++;
 80086a2:	3301      	adds	r3, #1
 80086a4:	61ab      	str	r3, [r5, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 80086a6:	b92f      	cbnz	r7, 80086b4 <sdram_bist_start+0xec>
    res->first_error_address = addr;
 80086a8:	61e8      	str	r0, [r5, #28]
    res->first_error_pattern = expected;
 80086aa:	8469      	strh	r1, [r5, #34]	; 0x22
    res->first_error = classification;
 80086ac:	f885 e020 	strb.w	lr, [r5, #32]
    res->status = SDRAM_BIST_FAIL;
 80086b0:	f885 e00c 	strb.w	lr, [r5, #12]
  for (uint32_t i = 0; i < words; ++i) {
 80086b4:	3002      	adds	r0, #2
 80086b6:	4282      	cmp	r2, r0
 80086b8:	d1df      	bne.n	800867a <sdram_bist_start+0xb2>
  ctx->patterns_executed++;
 80086ba:	686a      	ldr	r2, [r5, #4]
  if (ctx->mode == SDRAM_BIST_MODE_FULL) {
 80086bc:	7829      	ldrb	r1, [r5, #0]
  ctx->patterns_executed++;
 80086be:	1c53      	adds	r3, r2, #1
  if (ctx->mode == SDRAM_BIST_MODE_FULL) {
 80086c0:	2901      	cmp	r1, #1
  ctx->patterns_executed++;
 80086c2:	606b      	str	r3, [r5, #4]
  ctx->result.words_tested += words;
 80086c4:	692b      	ldr	r3, [r5, #16]
 80086c6:	4433      	add	r3, r6
 80086c8:	612b      	str	r3, [r5, #16]
  if (ctx->mode == SDRAM_BIST_MODE_FULL) {
 80086ca:	d00c      	beq.n	80086e6 <sdram_bist_start+0x11e>
  if (res->error_count > 0u && res->status == SDRAM_BIST_PASS) {
 80086cc:	69ab      	ldr	r3, [r5, #24]
 80086ce:	b11b      	cbz	r3, 80086d8 <sdram_bist_start+0x110>
 80086d0:	7b2b      	ldrb	r3, [r5, #12]
 80086d2:	b90b      	cbnz	r3, 80086d8 <sdram_bist_start+0x110>
    res->status = SDRAM_BIST_FAIL;
 80086d4:	2301      	movs	r3, #1
 80086d6:	732b      	strb	r3, [r5, #12]
 80086d8:	f7f8 fa90 	bl	8000bfc <stGetCounter>
 80086dc:	4603      	mov	r3, r0
  return true;
 80086de:	2001      	movs	r0, #1
  res->timestamp_end = chVTGetSystemTimeX();
 80086e0:	62ab      	str	r3, [r5, #40]	; 0x28
}
 80086e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  volatile uint16_t *addr_b = base + (words / 2u);
 80086e6:	f106 4e40 	add.w	lr, r6, #3221225472	; 0xc0000000
  addr_a[0] = ALIAS_PATTERN_A;
 80086ea:	f04f 4c40 	mov.w	ip, #3221225472	; 0xc0000000
  addr_b[0] = ALIAS_PATTERN_B;
 80086ee:	f645 20a5 	movw	r0, #23205	; 0x5aa5
  addr_a[0] = ALIAS_PATTERN_A;
 80086f2:	f24a 585a 	movw	r8, #42330	; 0xa55a
    const uint32_t mid_offset = (max_start > stress_words) ? ((coverage_words / 2u) - (stress_words / 2u)) : 0u;
 80086f6:	08a4      	lsrs	r4, r4, #2
    const uint32_t max_start = (coverage_words > stress_words) ? (coverage_words - stress_words) : 0u;
 80086f8:	f5a6 3600 	sub.w	r6, r6, #131072	; 0x20000
  addr_a[0] = ALIAS_PATTERN_A;
 80086fc:	f8ac 8000 	strh.w	r8, [ip]
  addr_b[0] = ALIAS_PATTERN_B;
 8008700:	f8ae 0000 	strh.w	r0, [lr]
    const uint32_t mid_offset = (max_start > stress_words) ? ((coverage_words / 2u) - (stress_words / 2u)) : 0u;
 8008704:	f5a4 3480 	sub.w	r4, r4, #65536	; 0x10000
  const uint16_t observed_a = addr_a[0];
 8008708:	f8bc 7000 	ldrh.w	r7, [ip]
  const uint16_t observed_b = addr_b[0];
 800870c:	f8be 0000 	ldrh.w	r0, [lr]
  const uint16_t observed_a = addr_a[0];
 8008710:	b2bf      	uxth	r7, r7
  const uint16_t observed_b = addr_b[0];
 8008712:	b280      	uxth	r0, r0
  if ((observed_a == observed_b) && (ALIAS_PATTERN_A != ALIAS_PATTERN_B)) {
 8008714:	4287      	cmp	r7, r0
 8008716:	d030      	beq.n	800877a <sdram_bist_start+0x1b2>
    if (observed_a != ALIAS_PATTERN_A) {
 8008718:	4547      	cmp	r7, r8
 800871a:	d00c      	beq.n	8008736 <sdram_bist_start+0x16e>
  res->error_count++;
 800871c:	69af      	ldr	r7, [r5, #24]
 800871e:	3701      	adds	r7, #1
 8008720:	61af      	str	r7, [r5, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 8008722:	f895 7020 	ldrb.w	r7, [r5, #32]
 8008726:	b937      	cbnz	r7, 8008736 <sdram_bist_start+0x16e>
    res->first_error_address = addr;
 8008728:	f8c5 c01c 	str.w	ip, [r5, #28]
    res->first_error_pattern = expected;
 800872c:	f8a5 8022 	strh.w	r8, [r5, #34]	; 0x22
    res->first_error = classification;
 8008730:	f885 1020 	strb.w	r1, [r5, #32]
    res->status = SDRAM_BIST_FAIL;
 8008734:	7329      	strb	r1, [r5, #12]
    if (observed_b != ALIAS_PATTERN_B) {
 8008736:	f645 27a5 	movw	r7, #23205	; 0x5aa5
 800873a:	42b8      	cmp	r0, r7
 800873c:	d00c      	beq.n	8008758 <sdram_bist_start+0x190>
  res->error_count++;
 800873e:	69a9      	ldr	r1, [r5, #24]
 8008740:	3101      	adds	r1, #1
 8008742:	61a9      	str	r1, [r5, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 8008744:	f895 1020 	ldrb.w	r1, [r5, #32]
 8008748:	b931      	cbnz	r1, 8008758 <sdram_bist_start+0x190>
    res->first_error = classification;
 800874a:	2101      	movs	r1, #1
    res->first_error_address = addr;
 800874c:	f8c5 e01c 	str.w	lr, [r5, #28]
    res->first_error_pattern = expected;
 8008750:	846f      	strh	r7, [r5, #34]	; 0x22
    res->first_error = classification;
 8008752:	f885 1020 	strb.w	r1, [r5, #32]
    res->status = SDRAM_BIST_FAIL;
 8008756:	7329      	strb	r1, [r5, #12]
  ctx->patterns_executed++;
 8008758:	3202      	adds	r2, #2
  ctx->result.words_tested += 2u;
 800875a:	3302      	adds	r3, #2
    bist_run_stress_sequential_offset(base, 0u, stress_words, ctx);
 800875c:	4629      	mov	r1, r5
 800875e:	2000      	movs	r0, #0
  ctx->patterns_executed++;
 8008760:	606a      	str	r2, [r5, #4]
  ctx->result.words_tested += 2u;
 8008762:	612b      	str	r3, [r5, #16]
    bist_run_stress_sequential_offset(base, 0u, stress_words, ctx);
 8008764:	f7ff fe94 	bl	8008490 <bist_run_stress_sequential_offset.constprop.0>
    bist_run_stress_sequential_offset(base, mid_offset, stress_words, ctx);
 8008768:	4620      	mov	r0, r4
 800876a:	f7ff fe91 	bl	8008490 <bist_run_stress_sequential_offset.constprop.0>
    bist_run_stress_sequential_offset(base, end_offset, stress_words, ctx);
 800876e:	4630      	mov	r0, r6
 8008770:	f7ff fe8e 	bl	8008490 <bist_run_stress_sequential_offset.constprop.0>
    chThdYield();
 8008774:	f7fd ff52 	bl	800661c <chThdYield>
 8008778:	e7a8      	b.n	80086cc <sdram_bist_start+0x104>
  res->error_count++;
 800877a:	69a8      	ldr	r0, [r5, #24]
 800877c:	3001      	adds	r0, #1
 800877e:	61a8      	str	r0, [r5, #24]
  if (res->first_error == SDRAM_BIST_ERR_NONE) {
 8008780:	f895 0020 	ldrb.w	r0, [r5, #32]
 8008784:	2800      	cmp	r0, #0
 8008786:	d1e7      	bne.n	8008758 <sdram_bist_start+0x190>
    res->status = SDRAM_BIST_FAIL;
 8008788:	7329      	strb	r1, [r5, #12]
    res->first_error = classification;
 800878a:	2102      	movs	r1, #2
    res->first_error_address = addr;
 800878c:	f8c5 c01c 	str.w	ip, [r5, #28]
    res->first_error_pattern = expected;
 8008790:	f8a5 8022 	strh.w	r8, [r5, #34]	; 0x22
    res->first_error = classification;
 8008794:	f885 1020 	strb.w	r1, [r5, #32]
    res->status = SDRAM_BIST_FAIL;
 8008798:	e7de      	b.n	8008758 <sdram_bist_start+0x190>
 800879a:	bf00      	nop

0800879c <sdram_init>:
  info->size_bytes = 0u;
  info->flags = 0u;
  info->alignment_bytes = 0u;
}

void sdram_init(bool run_quick_bist) {
 800879c:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Ensure single initialization sequence.
  chMtxLock(&sdram_ctx_mtx);
  if (sdram_ctx.state != SDRAM_NOT_INITIALIZED) {
 800879e:	4c35      	ldr	r4, [pc, #212]	; (8008874 <sdram_init+0xd8>)
void sdram_init(bool run_quick_bist) {
 80087a0:	b08d      	sub	sp, #52	; 0x34
 80087a2:	4605      	mov	r5, r0
  chMtxLock(&sdram_ctx_mtx);
 80087a4:	4834      	ldr	r0, [pc, #208]	; (8008878 <sdram_init+0xdc>)
 80087a6:	f7fe f879 	bl	800689c <chMtxLock>
  if (sdram_ctx.state != SDRAM_NOT_INITIALIZED) {
 80087aa:	7826      	ldrb	r6, [r4, #0]
 80087ac:	2e00      	cmp	r6, #0
 80087ae:	d142      	bne.n	8008836 <sdram_init+0x9a>
    chMtxUnlock(&sdram_ctx_mtx);
    return;
  }

  sdram_ctx.state = SDRAM_INITIALIZING;
 80087b0:	2701      	movs	r7, #1
  sdram_ctx.last_error = SDRAM_ERR_NONE;
  sdram_ctx.bist_running = false;
  chMtxUnlock(&sdram_ctx_mtx);
 80087b2:	4831      	ldr	r0, [pc, #196]	; (8008878 <sdram_init+0xdc>)
  sdram_ctx.bist_running = false;
 80087b4:	70a6      	strb	r6, [r4, #2]
  sdram_ctx.state = SDRAM_INITIALIZING;
 80087b6:	8027      	strh	r7, [r4, #0]
  chMtxUnlock(&sdram_ctx_mtx);
 80087b8:	f7fe f87a 	bl	80068b0 <chMtxUnlock>

  // Hardware/FMC initialization sequence.
  if (!sdram_hw_init_sequence()) {
 80087bc:	f000 f86e 	bl	800889c <sdram_hw_init_sequence>
 80087c0:	b368      	cbz	r0, 800881e <sdram_init+0x82>
    chMtxUnlock(&sdram_ctx_mtx);
    return;
  }

  // MPU region configuration for cache attributes.
  if (!sdram_configure_mpu_regions()) {
 80087c2:	f000 f8d5 	bl	8008970 <sdram_configure_mpu_regions>
 80087c6:	2800      	cmp	r0, #0
 80087c8:	d04c      	beq.n	8008864 <sdram_init+0xc8>
    sdram_set_fault_locked(SDRAM_ERR_PARAM);
    chMtxUnlock(&sdram_ctx_mtx);
    return;
  }

  if (!run_quick_bist) {
 80087ca:	2d00      	cmp	r5, #0
 80087cc:	d03f      	beq.n	800884e <sdram_init+0xb2>
    chMtxUnlock(&sdram_ctx_mtx);
    return;
  }

  // Quick BIST at boot (synchronous or quasi-synchronous).
  sdram_bist_context_t bist_ctx = {0};
 80087ce:	222c      	movs	r2, #44	; 0x2c
 80087d0:	4631      	mov	r1, r6
 80087d2:	a801      	add	r0, sp, #4

  bool bist_ok = sdram_bist_start(&bist_ctx);

  chMtxLock(&sdram_ctx_mtx);
  sdram_ctx.bist_running = false;
  sdram_ctx.last_bist_result = bist_ctx.result;
 80087d4:	1d25      	adds	r5, r4, #4
  sdram_bist_context_t bist_ctx = {0};
 80087d6:	f006 f805 	bl	800e7e4 <memset>
  chMtxLock(&sdram_ctx_mtx);
 80087da:	4827      	ldr	r0, [pc, #156]	; (8008878 <sdram_init+0xdc>)
 80087dc:	f7fe f85e 	bl	800689c <chMtxLock>
  chMtxUnlock(&sdram_ctx_mtx);
 80087e0:	4825      	ldr	r0, [pc, #148]	; (8008878 <sdram_init+0xdc>)
  sdram_ctx.bist_running = true;
 80087e2:	70a7      	strb	r7, [r4, #2]
  chMtxUnlock(&sdram_ctx_mtx);
 80087e4:	f7fe f864 	bl	80068b0 <chMtxUnlock>
  bool bist_ok = sdram_bist_start(&bist_ctx);
 80087e8:	a801      	add	r0, sp, #4
 80087ea:	f7ff feed 	bl	80085c8 <sdram_bist_start>
 80087ee:	4607      	mov	r7, r0
  chMtxLock(&sdram_ctx_mtx);
 80087f0:	4821      	ldr	r0, [pc, #132]	; (8008878 <sdram_init+0xdc>)
 80087f2:	f7fe f853 	bl	800689c <chMtxLock>
  sdram_ctx.last_bist_result = bist_ctx.result;
 80087f6:	f10d 0c10 	add.w	ip, sp, #16
  sdram_ctx.bist_running = false;
 80087fa:	70a6      	strb	r6, [r4, #2]
  sdram_ctx.last_bist_result = bist_ctx.result;
 80087fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8008800:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8008802:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 8008806:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

  if (!bist_ok || bist_ctx.result.status != SDRAM_BIST_PASS) {
 800880a:	b9d7      	cbnz	r7, 8008842 <sdram_init+0xa6>
 800880c:	2203      	movs	r2, #3
 800880e:	2304      	movs	r3, #4
  } else {
    sdram_ctx.state = SDRAM_READY;
    sdram_ctx.last_error = SDRAM_ERR_NONE;
  }

  chMtxUnlock(&sdram_ctx_mtx);
 8008810:	4819      	ldr	r0, [pc, #100]	; (8008878 <sdram_init+0xdc>)
    sdram_ctx.state = SDRAM_DEGRADED;
 8008812:	7022      	strb	r2, [r4, #0]
    sdram_ctx.last_error = SDRAM_ERR_BIST_FAIL;
 8008814:	7063      	strb	r3, [r4, #1]
  chMtxUnlock(&sdram_ctx_mtx);
 8008816:	f7fe f84b 	bl	80068b0 <chMtxUnlock>
}
 800881a:	b00d      	add	sp, #52	; 0x34
 800881c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    chMtxLock(&sdram_ctx_mtx);
 800881e:	4816      	ldr	r0, [pc, #88]	; (8008878 <sdram_init+0xdc>)
 8008820:	f7fe f83c 	bl	800689c <chMtxLock>
  sdram_ctx.state = SDRAM_FAULT;
 8008824:	f44f 7382 	mov.w	r3, #260	; 0x104
    chMtxUnlock(&sdram_ctx_mtx);
 8008828:	4813      	ldr	r0, [pc, #76]	; (8008878 <sdram_init+0xdc>)
  sdram_ctx.state = SDRAM_FAULT;
 800882a:	8023      	strh	r3, [r4, #0]
}
 800882c:	b00d      	add	sp, #52	; 0x34
 800882e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    chMtxUnlock(&sdram_ctx_mtx);
 8008832:	f7fe b83d 	b.w	80068b0 <chMtxUnlock>
    chMtxUnlock(&sdram_ctx_mtx);
 8008836:	4810      	ldr	r0, [pc, #64]	; (8008878 <sdram_init+0xdc>)
}
 8008838:	b00d      	add	sp, #52	; 0x34
 800883a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    chMtxUnlock(&sdram_ctx_mtx);
 800883e:	f7fe b837 	b.w	80068b0 <chMtxUnlock>
  if (!bist_ok || bist_ctx.result.status != SDRAM_BIST_PASS) {
 8008842:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8008846:	2b00      	cmp	r3, #0
 8008848:	d1e0      	bne.n	800880c <sdram_init+0x70>
 800884a:	2202      	movs	r2, #2
 800884c:	e7e0      	b.n	8008810 <sdram_init+0x74>
    chMtxLock(&sdram_ctx_mtx);
 800884e:	480a      	ldr	r0, [pc, #40]	; (8008878 <sdram_init+0xdc>)
 8008850:	f7fe f824 	bl	800689c <chMtxLock>
    sdram_ctx.state = SDRAM_READY;
 8008854:	2302      	movs	r3, #2
    chMtxUnlock(&sdram_ctx_mtx);
 8008856:	4808      	ldr	r0, [pc, #32]	; (8008878 <sdram_init+0xdc>)
    sdram_ctx.state = SDRAM_READY;
 8008858:	7023      	strb	r3, [r4, #0]
}
 800885a:	b00d      	add	sp, #52	; 0x34
 800885c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    chMtxUnlock(&sdram_ctx_mtx);
 8008860:	f7fe b826 	b.w	80068b0 <chMtxUnlock>
    chMtxLock(&sdram_ctx_mtx);
 8008864:	4804      	ldr	r0, [pc, #16]	; (8008878 <sdram_init+0xdc>)
 8008866:	f7fe f819 	bl	800689c <chMtxLock>
  sdram_ctx.state = SDRAM_FAULT;
 800886a:	f240 5304 	movw	r3, #1284	; 0x504
    chMtxUnlock(&sdram_ctx_mtx);
 800886e:	4802      	ldr	r0, [pc, #8]	; (8008878 <sdram_init+0xdc>)
  sdram_ctx.state = SDRAM_FAULT;
 8008870:	8023      	strh	r3, [r4, #0]
    chMtxUnlock(&sdram_ctx_mtx);
 8008872:	e7db      	b.n	800882c <sdram_init+0x90>
 8008874:	24003700 	.word	0x24003700
 8008878:	24000008 	.word	0x24000008

0800887c <sdram_status>:

sdram_state_t sdram_status(void) {
 800887c:	b510      	push	{r4, lr}
  chMtxLock(&sdram_ctx_mtx);
 800887e:	4805      	ldr	r0, [pc, #20]	; (8008894 <sdram_status+0x18>)
 8008880:	f7fe f80c 	bl	800689c <chMtxLock>
  sdram_state_t state = sdram_ctx.state;
 8008884:	4b04      	ldr	r3, [pc, #16]	; (8008898 <sdram_status+0x1c>)
  chMtxUnlock(&sdram_ctx_mtx);
 8008886:	4803      	ldr	r0, [pc, #12]	; (8008894 <sdram_status+0x18>)
  sdram_state_t state = sdram_ctx.state;
 8008888:	781c      	ldrb	r4, [r3, #0]
  chMtxUnlock(&sdram_ctx_mtx);
 800888a:	f7fe f811 	bl	80068b0 <chMtxUnlock>
  return state;
}
 800888e:	4620      	mov	r0, r4
 8008890:	bd10      	pop	{r4, pc}
 8008892:	bf00      	nop
 8008894:	24000008 	.word	0x24000008
 8008898:	24003700 	.word	0x24003700

0800889c <sdram_hw_init_sequence>:
  return (FMC_Bank5_6_R->SDSR & FMC_SDSR_MODES1_Msk) >> FMC_SDSR_MODES1_Pos;
}

bool sdram_hw_init_sequence(void)
{
  if ((RCC->AHB3ENR & RCC_AHB3ENR_FMCEN) == 0u) {
 800889c:	4b30      	ldr	r3, [pc, #192]	; (8008960 <sdram_hw_init_sequence+0xc4>)
 800889e:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 80088a2:	04d0      	lsls	r0, r2, #19
{
 80088a4:	b510      	push	{r4, lr}
  if ((RCC->AHB3ENR & RCC_AHB3ENR_FMCEN) == 0u) {
 80088a6:	d407      	bmi.n	80088b8 <sdram_hw_init_sequence+0x1c>
    RCC->AHB3ENR |= RCC_AHB3ENR_FMCEN;
 80088a8:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 80088ac:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80088b0:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
    (void)RCC->AHB3ENR;
 80088b4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
                        ((6u - 1u) << FMC_SDTRx_TRC_Pos) |   /* tRC  */
                        ((3u - 1u) << FMC_SDTRx_TWR_Pos) |   /* tWR  */
                        ((3u - 1u) << FMC_SDTRx_TRP_Pos) |   /* tRP  */
                        ((3u - 1u) << FMC_SDTRx_TRCD_Pos);   /* tRCD */

  FMC_Bank5_6_R->SDCR[0] = sdcr;
 80088b8:	4c2a      	ldr	r4, [pc, #168]	; (8008964 <sdram_hw_init_sequence+0xc8>)
 80088ba:	f641 1259 	movw	r2, #6489	; 0x1959
  FMC_Bank5_6_R->SDTR[0] = sdtr;
 80088be:	4b2a      	ldr	r3, [pc, #168]	; (8008968 <sdram_hw_init_sequence+0xcc>)

  chThdSleepMicroseconds(200u);
 80088c0:	2002      	movs	r0, #2
  FMC_Bank5_6_R->SDCR[0] = sdcr;
 80088c2:	6422      	str	r2, [r4, #64]	; 0x40
  FMC_Bank5_6_R->SDTR[0] = sdtr;
 80088c4:	64a3      	str	r3, [r4, #72]	; 0x48
  chThdSleepMicroseconds(200u);
 80088c6:	f7fd fe9d 	bl	8006604 <chThdSleep>
  FMC_Bank5_6_R->SDCMR = command;
 80088ca:	2211      	movs	r2, #17
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 80088cc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  FMC_Bank5_6_R->SDCMR = command;
 80088d0:	6522      	str	r2, [r4, #80]	; 0x50
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 80088d2:	e001      	b.n	80088d8 <sdram_hw_init_sequence+0x3c>
    if (timeout-- == 0u) {
 80088d4:	3b01      	subs	r3, #1
 80088d6:	d041      	beq.n	800895c <sdram_hw_init_sequence+0xc0>
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 80088d8:	6da2      	ldr	r2, [r4, #88]	; 0x58
 80088da:	0691      	lsls	r1, r2, #26
 80088dc:	d4fa      	bmi.n	80088d4 <sdram_hw_init_sequence+0x38>

  if (!fmc_issue_command(SDRAM_CMD_CLK_ENABLE, 1u, 0u)) {
    return false;
  }

  chThdSleepMilliseconds(1);
 80088de:	200a      	movs	r0, #10
 80088e0:	f7fd fe90 	bl	8006604 <chThdSleep>
  FMC_Bank5_6_R->SDCMR = command;
 80088e4:	2212      	movs	r2, #18
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 80088e6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80088ea:	491e      	ldr	r1, [pc, #120]	; (8008964 <sdram_hw_init_sequence+0xc8>)
  FMC_Bank5_6_R->SDCMR = command;
 80088ec:	6522      	str	r2, [r4, #80]	; 0x50
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 80088ee:	e001      	b.n	80088f4 <sdram_hw_init_sequence+0x58>
    if (timeout-- == 0u) {
 80088f0:	3b01      	subs	r3, #1
 80088f2:	d033      	beq.n	800895c <sdram_hw_init_sequence+0xc0>
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 80088f4:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 80088f6:	0692      	lsls	r2, r2, #26
 80088f8:	d4fa      	bmi.n	80088f0 <sdram_hw_init_sequence+0x54>
  FMC_Bank5_6_R->SDCMR = command;
 80088fa:	22f3      	movs	r2, #243	; 0xf3
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 80088fc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008900:	4818      	ldr	r0, [pc, #96]	; (8008964 <sdram_hw_init_sequence+0xc8>)
  FMC_Bank5_6_R->SDCMR = command;
 8008902:	650a      	str	r2, [r1, #80]	; 0x50
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 8008904:	e001      	b.n	800890a <sdram_hw_init_sequence+0x6e>
    if (timeout-- == 0u) {
 8008906:	3b01      	subs	r3, #1
 8008908:	d028      	beq.n	800895c <sdram_hw_init_sequence+0xc0>
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 800890a:	6d82      	ldr	r2, [r0, #88]	; 0x58
 800890c:	0694      	lsls	r4, r2, #26
 800890e:	d4fa      	bmi.n	8008906 <sdram_hw_init_sequence+0x6a>
  FMC_Bank5_6_R->SDCMR = command;
 8008910:	f246 4214 	movw	r2, #25620	; 0x6414
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 8008914:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8008918:	4912      	ldr	r1, [pc, #72]	; (8008964 <sdram_hw_init_sequence+0xc8>)
  FMC_Bank5_6_R->SDCMR = command;
 800891a:	6502      	str	r2, [r0, #80]	; 0x50
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 800891c:	e001      	b.n	8008922 <sdram_hw_init_sequence+0x86>
    if (timeout-- == 0u) {
 800891e:	3b01      	subs	r3, #1
 8008920:	d01c      	beq.n	800895c <sdram_hw_init_sequence+0xc0>
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 8008922:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 8008924:	0690      	lsls	r0, r2, #26
 8008926:	d4fa      	bmi.n	800891e <sdram_hw_init_sequence+0x82>

  if (!fmc_issue_command(SDRAM_CMD_LOAD_MODE, 1u, SDRAM_MODE_REGISTER_VALUE)) {
    return false;
  }

  uint32_t sdrtr = FMC_Bank5_6_R->SDRTR;
 8008928:	6d4c      	ldr	r4, [r1, #84]	; 0x54
  sdrtr &= ~FMC_SDRTR_COUNT_Msk;
  sdrtr |= (SDRAM_REFRESH_COUNT << FMC_SDRTR_COUNT_Pos);
 800892a:	f240 52f2 	movw	r2, #1522	; 0x5f2
  sdrtr &= ~FMC_SDRTR_COUNT_Msk;
 800892e:	480f      	ldr	r0, [pc, #60]	; (800896c <sdram_hw_init_sequence+0xd0>)
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 8008930:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  sdrtr &= ~FMC_SDRTR_COUNT_Msk;
 8008934:	4020      	ands	r0, r4
  sdrtr |= (SDRAM_REFRESH_COUNT << FMC_SDRTR_COUNT_Pos);
 8008936:	4302      	orrs	r2, r0
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 8008938:	480a      	ldr	r0, [pc, #40]	; (8008964 <sdram_hw_init_sequence+0xc8>)
  FMC_Bank5_6_R->SDRTR = sdrtr;
 800893a:	654a      	str	r2, [r1, #84]	; 0x54
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 800893c:	e001      	b.n	8008942 <sdram_hw_init_sequence+0xa6>
    if (timeout-- == 0u) {
 800893e:	3b01      	subs	r3, #1
 8008940:	d00c      	beq.n	800895c <sdram_hw_init_sequence+0xc0>
  while ((FMC_Bank5_6_R->SDSR & SDRAM_SDSR_BUSY) != 0u) {
 8008942:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8008944:	0692      	lsls	r2, r2, #26
 8008946:	d4fa      	bmi.n	800893e <sdram_hw_init_sequence+0xa2>

  if (!fmc_wait_while_busy(SDRAM_TIMEOUT_CYCLES)) {
    return false;
  }

  const uint32_t status = FMC_Bank5_6_R->SDSR;
 8008948:	6d83      	ldr	r3, [r0, #88]	; 0x58
  if ((status & FMC_SDSR_RE) != 0u) {
 800894a:	07db      	lsls	r3, r3, #31
 800894c:	d406      	bmi.n	800895c <sdram_hw_init_sequence+0xc0>
  return (FMC_Bank5_6_R->SDSR & FMC_SDSR_MODES1_Msk) >> FMC_SDSR_MODES1_Pos;
 800894e:	6d83      	ldr	r3, [r0, #88]	; 0x58
    return false;
  }

  const uint32_t mode = fmc_current_mode();
  if (mode != 0u) {
 8008950:	f013 0f06 	tst.w	r3, #6
 8008954:	bf0c      	ite	eq
 8008956:	2001      	moveq	r0, #1
 8008958:	2000      	movne	r0, #0
    return false;
  }

  return true;
}
 800895a:	bd10      	pop	{r4, pc}
    return false;
 800895c:	2000      	movs	r0, #0
}
 800895e:	bd10      	pop	{r4, pc}
 8008960:	58024400 	.word	0x58024400
 8008964:	52004100 	.word	0x52004100
 8008968:	02225571 	.word	0x02225571
 800896c:	ffffc001 	.word	0xffffc001

08008970 <sdram_configure_mpu_regions>:

bool sdram_configure_mpu_regions(void)
{
 8008970:	b510      	push	{r4, lr}
  __ASM volatile ("dsb 0xF":::"memory");
 8008972:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8008976:	f3bf 8f6f 	isb	sy
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800897a:	4928      	ldr	r1, [pc, #160]	; (8008a1c <sdram_configure_mpu_regions+0xac>)
 800897c:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 800897e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008982:	624b      	str	r3, [r1, #36]	; 0x24
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 8008984:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
 8008988:	f023 0301 	bic.w	r3, r3, #1
 800898c:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
 8008990:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8008994:	f3bf 8f6f 	isb	sy
  MPU->RBAR = rbar;
 8008998:	4a21      	ldr	r2, [pc, #132]	; (8008a20 <sdram_configure_mpu_regions+0xb0>)
  MPU->RASR = rasr;
 800899a:	f04f 7343 	mov.w	r3, #51118080	; 0x30c0000
  MPU->RBAR = rbar;
 800899e:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  MPU->RASR = rasr;
 80089a2:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
  __ASM volatile ("dsb 0xF":::"memory");
 80089a6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80089aa:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80089ae:	2300      	movs	r3, #0
 80089b0:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80089b4:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 80089b8:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80089bc:	f643 74e0 	movw	r4, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80089c0:	f3c3 3c4e 	ubfx	ip, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80089c4:	f3c3 0ec9 	ubfx	lr, r3, #3, #10
 80089c8:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80089cc:	ea0c 0004 	and.w	r0, ip, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80089d0:	4673      	mov	r3, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80089d2:	ea40 7283 	orr.w	r2, r0, r3, lsl #30
      } while (ways-- != 0U);
 80089d6:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80089d8:	f8c1 2260 	str.w	r2, [r1, #608]	; 0x260
      } while (ways-- != 0U);
 80089dc:	1c5a      	adds	r2, r3, #1
 80089de:	d1f8      	bne.n	80089d2 <sdram_configure_mpu_regions+0x62>
    } while(sets-- != 0U);
 80089e0:	f1ac 0c20 	sub.w	ip, ip, #32
 80089e4:	f11c 0f20 	cmn.w	ip, #32
 80089e8:	d1f0      	bne.n	80089cc <sdram_configure_mpu_regions+0x5c>
 80089ea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80089ee:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 80089f2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80089f6:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 80089fa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80089fe:	f3bf 8f6f 	isb	sy
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8008a02:	2305      	movs	r3, #5
 8008a04:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8008a08:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8008a0a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008a0e:	624b      	str	r3, [r1, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8008a10:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8008a14:	f3bf 8f6f 	isb	sy
  ARM_MPU_Enable(MPU_CTRL_PRIVDEFENA_Msk);
  __DSB();
  __ISB();

  return true;
}
 8008a18:	2001      	movs	r0, #1
 8008a1a:	bd10      	pop	{r4, pc}
 8008a1c:	e000ed00 	.word	0xe000ed00
 8008a20:	c0000011 	.word	0xc0000011

08008a24 <get_col_5x7>:
 * @param c   Caractère ASCII (32..126)
 * @param col Index de colonne (0..4)
 * @return Octet contenant les 7 bits verticaux du glyphe.
 */
static uint8_t get_col_5x7(char c, uint8_t col) {
    if (c < 32 || c > 126) return 0;
 8008a24:	3820      	subs	r0, #32
 8008a26:	b2c3      	uxtb	r3, r0
    if (col >= 5) return 0;
 8008a28:	2b5e      	cmp	r3, #94	; 0x5e
 8008a2a:	d807      	bhi.n	8008a3c <get_col_5x7+0x18>
 8008a2c:	2904      	cmp	r1, #4
 8008a2e:	d805      	bhi.n	8008a3c <get_col_5x7+0x18>
    return font5x7[(uint8_t)c - 32][col];
 8008a30:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8008a34:	4b02      	ldr	r3, [pc, #8]	; (8008a40 <get_col_5x7+0x1c>)
 8008a36:	4403      	add	r3, r0
 8008a38:	5c58      	ldrb	r0, [r3, r1]
 8008a3a:	4770      	bx	lr
    if (col >= 5) return 0;
 8008a3c:	2000      	movs	r0, #0
}
 8008a3e:	4770      	bx	lr
 8008a40:	08014ff8 	.word	0x08014ff8

08008a44 <usb_device_start>:
 * 5. Connexion du bus (activation du pull-up DP).
 *
 * @note Cette procédure est nécessaire sur certaines cartes Nucleo où
 *       la broche VBUS (PA9) n’est pas connectée au contrôleur OTG FS.
 */
void usb_device_start(void) {
 8008a44:	b510      	push	{r4, lr}
    /* 1. Déconnexion logique pour forcer une ré-énumération */
    usbDisconnectBus(&USBD1);
 8008a46:	4c0d      	ldr	r4, [pc, #52]	; (8008a7c <usb_device_start+0x38>)
    chThdSleepMilliseconds(1500);
 8008a48:	f643 2098 	movw	r0, #15000	; 0x3a98
    usbDisconnectBus(&USBD1);
 8008a4c:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8008a50:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 8008a54:	f043 0302 	orr.w	r3, r3, #2
 8008a58:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
    chThdSleepMilliseconds(1500);
 8008a5c:	f7fd fdd2 	bl	8006604 <chThdSleep>

    /* 2. Démarrage du driver avec la config USB du projet */
    usbStart(&USBD1, &usbcfg);
 8008a60:	4907      	ldr	r1, [pc, #28]	; (8008a80 <usb_device_start+0x3c>)
 8008a62:	4620      	mov	r0, r4
 8008a64:	f7f8 fe78 	bl	8001758 <usbStart>
        USBD1.otg->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
#endif
    }

    /* 4. Connexion logique sur le bus */
    usbConnectBus(&USBD1);
 8008a68:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8008a6c:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 8008a70:	f023 0302 	bic.w	r3, r3, #2
 8008a74:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
}
 8008a78:	bd10      	pop	{r4, pc}
 8008a7a:	bf00      	nop
 8008a7c:	24000874 	.word	0x24000874
 8008a80:	080152f4 	.word	0x080152f4

08008a84 <get_descriptor>:
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
  (void)usbp; (void)lang;
  switch (dtype) {
 8008a84:	2902      	cmp	r1, #2
 8008a86:	d006      	beq.n	8008a96 <get_descriptor+0x12>
 8008a88:	2903      	cmp	r1, #3
 8008a8a:	d006      	beq.n	8008a9a <get_descriptor+0x16>
    case USB_DESCRIPTOR_DEVICE:        return &device_descriptor;
 8008a8c:	2901      	cmp	r1, #1
 8008a8e:	4807      	ldr	r0, [pc, #28]	; (8008aac <get_descriptor+0x28>)
 8008a90:	bf18      	it	ne
 8008a92:	2000      	movne	r0, #0
 8008a94:	4770      	bx	lr
  switch (dtype) {
 8008a96:	4806      	ldr	r0, [pc, #24]	; (8008ab0 <get_descriptor+0x2c>)
 8008a98:	4770      	bx	lr
    case USB_DESCRIPTOR_CONFIGURATION: return &config_descriptor;
    case USB_DESCRIPTOR_STRING:
      if (dindex < 4) return &strings[dindex];
 8008a9a:	2a03      	cmp	r2, #3
 8008a9c:	d803      	bhi.n	8008aa6 <get_descriptor+0x22>
 8008a9e:	4805      	ldr	r0, [pc, #20]	; (8008ab4 <get_descriptor+0x30>)
 8008aa0:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 8008aa4:	4770      	bx	lr
      break;
    default:
      break;
  }
  return NULL;
 8008aa6:	2000      	movs	r0, #0
}
 8008aa8:	4770      	bx	lr
 8008aaa:	bf00      	nop
 8008aac:	08015230 	.word	0x08015230
 8008ab0:	080151d4 	.word	0x080151d4
 8008ab4:	080152d4 	.word	0x080152d4

08008ab8 <sof_handler>:
  if (bsp->sem.cnt < (cnt_t)1) {
 8008ab8:	4803      	ldr	r0, [pc, #12]	; (8008ac8 <sof_handler+0x10>)
 8008aba:	6883      	ldr	r3, [r0, #8]
 8008abc:	2b00      	cmp	r3, #0
 8008abe:	dd00      	ble.n	8008ac2 <sof_handler+0xa>
 * @brief Callback "Start Of Frame" (SOF). Inutilisé ici.
 */
static void sof_handler(USBDriver *usbp) {
  (void)usbp;
  chBSemSignalI(&sof_sem);
}
 8008ac0:	4770      	bx	lr
    chSemSignalI(&bsp->sem);
 8008ac2:	f7fd be75 	b.w	80067b0 <chSemSignalI>
 8008ac6:	bf00      	nop
 8008ac8:	240032f4 	.word	0x240032f4

08008acc <ep2_in_cb>:
  if (bsp->sem.cnt < (cnt_t)1) {
 8008acc:	4803      	ldr	r0, [pc, #12]	; (8008adc <ep2_in_cb+0x10>)
 8008ace:	6883      	ldr	r3, [r0, #8]
 8008ad0:	2b00      	cmp	r3, #0
 8008ad2:	dd00      	ble.n	8008ad6 <ep2_in_cb+0xa>
}
 8008ad4:	4770      	bx	lr
    chSemSignalI(&bsp->sem);
 8008ad6:	f7fd be6b 	b.w	80067b0 <chSemSignalI>
 8008ada:	bf00      	nop
 8008adc:	24003300 	.word	0x24003300

08008ae0 <usb_event>:
  switch (event) {
 8008ae0:	2902      	cmp	r1, #2
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8008ae2:	b538      	push	{r3, r4, r5, lr}
 8008ae4:	460c      	mov	r4, r1
  switch (event) {
 8008ae6:	d00f      	beq.n	8008b08 <usb_event+0x28>
 8008ae8:	d90b      	bls.n	8008b02 <usb_event+0x22>
 8008aea:	1ecc      	subs	r4, r1, #3
 8008aec:	2c01      	cmp	r4, #1
 8008aee:	d807      	bhi.n	8008b00 <usb_event+0x20>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008af0:	2330      	movs	r3, #48	; 0x30
 8008af2:	f383 8811 	msr	BASEPRI, r3
      usb_midi_tx_ready = false;
 8008af6:	4a15      	ldr	r2, [pc, #84]	; (8008b4c <usb_event+0x6c>)
 8008af8:	2300      	movs	r3, #0
 8008afa:	7013      	strb	r3, [r2, #0]
 8008afc:	f383 8811 	msr	BASEPRI, r3
}
 8008b00:	bd38      	pop	{r3, r4, r5, pc}
  switch (event) {
 8008b02:	2900      	cmp	r1, #0
 8008b04:	d0f4      	beq.n	8008af0 <usb_event+0x10>
}
 8008b06:	bd38      	pop	{r3, r4, r5, pc}
 8008b08:	4605      	mov	r5, r0
 8008b0a:	2330      	movs	r3, #48	; 0x30
 8008b0c:	f383 8811 	msr	BASEPRI, r3
      usbInitEndpointI(usbp, MIDI_EP_OUT, &ep1_out_cfg);
 8008b10:	4a0f      	ldr	r2, [pc, #60]	; (8008b50 <usb_event+0x70>)
 8008b12:	2101      	movs	r1, #1
 8008b14:	f7f8 fe36 	bl	8001784 <usbInitEndpointI>
      usbInitEndpointI(usbp, MIDI_EP_IN,  &ep2_in_cfg);
 8008b18:	4a0e      	ldr	r2, [pc, #56]	; (8008b54 <usb_event+0x74>)
 8008b1a:	4621      	mov	r1, r4
 8008b1c:	4628      	mov	r0, r5
 8008b1e:	f7f8 fe31 	bl	8001784 <usbInitEndpointI>
      usbStartReceiveI(usbp, MIDI_EP_OUT, rx_pkt, sizeof rx_pkt);
 8008b22:	2340      	movs	r3, #64	; 0x40
 8008b24:	4a0c      	ldr	r2, [pc, #48]	; (8008b58 <usb_event+0x78>)
 8008b26:	2101      	movs	r1, #1
 8008b28:	4628      	mov	r0, r5
 8008b2a:	f7f8 fe45 	bl	80017b8 <usbStartReceiveI>
  if (bsp->sem.cnt < (cnt_t)1) {
 8008b2e:	480b      	ldr	r0, [pc, #44]	; (8008b5c <usb_event+0x7c>)
      usb_midi_tx_ready = true;
 8008b30:	4a06      	ldr	r2, [pc, #24]	; (8008b4c <usb_event+0x6c>)
 8008b32:	2101      	movs	r1, #1
 8008b34:	6883      	ldr	r3, [r0, #8]
 8008b36:	7011      	strb	r1, [r2, #0]
 8008b38:	2b00      	cmp	r3, #0
 8008b3a:	dd03      	ble.n	8008b44 <usb_event+0x64>
 8008b3c:	2300      	movs	r3, #0
 8008b3e:	f383 8811 	msr	BASEPRI, r3
}
 8008b42:	bd38      	pop	{r3, r4, r5, pc}
    chSemSignalI(&bsp->sem);
 8008b44:	f7fd fe34 	bl	80067b0 <chSemSignalI>
 8008b48:	e7f8      	b.n	8008b3c <usb_event+0x5c>
 8008b4a:	bf00      	nop
 8008b4c:	240037a4 	.word	0x240037a4
 8008b50:	0801524c 	.word	0x0801524c
 8008b54:	08015270 	.word	0x08015270
 8008b58:	24003760 	.word	0x24003760
 8008b5c:	24003300 	.word	0x24003300

08008b60 <ep1_out_cb>:
  const size_t rx_size = ep1_out_state.rxsize;
 8008b60:	4b10      	ldr	r3, [pc, #64]	; (8008ba4 <ep1_out_cb+0x44>)
 8008b62:	6819      	ldr	r1, [r3, #0]
  if ((rx_size == 0U) || (rx_size > sizeof rx_pkt)) {
 8008b64:	1e4b      	subs	r3, r1, #1
 8008b66:	2b3f      	cmp	r3, #63	; 0x3f
static void ep1_out_cb(USBDriver *usbp, usbep_t ep) {
 8008b68:	b570      	push	{r4, r5, r6, lr}
  if ((rx_size == 0U) || (rx_size > sizeof rx_pkt)) {
 8008b6a:	d80b      	bhi.n	8008b84 <ep1_out_cb+0x24>
 8008b6c:	4604      	mov	r4, r0
  midi_usb_rx_submit_from_isr(rx_pkt, rx_size);
 8008b6e:	480e      	ldr	r0, [pc, #56]	; (8008ba8 <ep1_out_cb+0x48>)
 8008b70:	f7ff fbde 	bl	8008330 <midi_usb_rx_submit_from_isr>
  usbStartReceiveI(usbp, MIDI_EP_OUT, rx_pkt, sizeof rx_pkt);
 8008b74:	2340      	movs	r3, #64	; 0x40
 8008b76:	4620      	mov	r0, r4
 8008b78:	4a0b      	ldr	r2, [pc, #44]	; (8008ba8 <ep1_out_cb+0x48>)
 8008b7a:	2101      	movs	r1, #1
}
 8008b7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  usbStartReceiveI(usbp, MIDI_EP_OUT, rx_pkt, sizeof rx_pkt);
 8008b80:	f7f8 be1a 	b.w	80017b8 <usbStartReceiveI>
    usb_midi_rx_invalid_size++;
 8008b84:	4d09      	ldr	r5, [pc, #36]	; (8008bac <ep1_out_cb+0x4c>)
    usbStartReceiveI(usbp, MIDI_EP_OUT, rx_pkt, sizeof rx_pkt);
 8008b86:	2340      	movs	r3, #64	; 0x40
    midi_rx_stats.usb_rx_drops++;
 8008b88:	4c09      	ldr	r4, [pc, #36]	; (8008bb0 <ep1_out_cb+0x50>)
    usb_midi_rx_invalid_size++;
 8008b8a:	6829      	ldr	r1, [r5, #0]
    usbStartReceiveI(usbp, MIDI_EP_OUT, rx_pkt, sizeof rx_pkt);
 8008b8c:	4a06      	ldr	r2, [pc, #24]	; (8008ba8 <ep1_out_cb+0x48>)
    usb_midi_rx_invalid_size++;
 8008b8e:	3101      	adds	r1, #1
 8008b90:	6029      	str	r1, [r5, #0]
    midi_rx_stats.usb_rx_drops++;
 8008b92:	6861      	ldr	r1, [r4, #4]
 8008b94:	3101      	adds	r1, #1
 8008b96:	6061      	str	r1, [r4, #4]
    usbStartReceiveI(usbp, MIDI_EP_OUT, rx_pkt, sizeof rx_pkt);
 8008b98:	2101      	movs	r1, #1
}
 8008b9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    usbStartReceiveI(usbp, MIDI_EP_OUT, rx_pkt, sizeof rx_pkt);
 8008b9e:	f7f8 be0b 	b.w	80017b8 <usbStartReceiveI>
 8008ba2:	bf00      	nop
 8008ba4:	24003724 	.word	0x24003724
 8008ba8:	24003760 	.word	0x24003760
 8008bac:	240037a0 	.word	0x240037a0
 8008bb0:	24002c6c 	.word	0x24002c6c

08008bb4 <sd_submit_request>:
    case SD_ERR_BUSY: g_sd_stats.err_busy++; break;
    default: break;
    }
}

static sd_error_t sd_submit_request(sd_request_t *req) {
 8008bb4:	b538      	push	{r3, r4, r5, lr}
    if (!req) {
 8008bb6:	b1a0      	cbz	r0, 8008be2 <sd_submit_request+0x2e>
        sd_record_rejection(SD_ERR_BUSY);
        return SD_ERR_BUSY;
    }
    if (!drv_sd_thread_post(req)) {
 8008bb8:	4604      	mov	r4, r0
 8008bba:	f001 f8df 	bl	8009d7c <drv_sd_thread_post>
 8008bbe:	b168      	cbz	r0, 8008bdc <sd_submit_request+0x28>
  return chSemWaitTimeout(&bsp->sem, timeout);
 8008bc0:	1d25      	adds	r5, r4, #4
 8008bc2:	f644 6120 	movw	r1, #20000	; 0x4e20
 8008bc6:	4628      	mov	r0, r5
 8008bc8:	f7fd fdcc 	bl	8006764 <chSemWaitTimeout>
        drv_sd_thread_release(req);
        sd_record_rejection(SD_ERR_BUSY);
        return SD_ERR_BUSY;
    }
    msg_t wait = chBSemWaitTimeout(&req->done, TIME_MS2I(2000));
    if (wait == MSG_TIMEOUT) {
 8008bcc:	1c43      	adds	r3, r0, #1
 8008bce:	d017      	beq.n	8008c00 <sd_submit_request+0x4c>
            (void)chBSemWaitTimeout(&req->done, TIME_INFINITE);
        }
        return SD_ERR_TIMEOUT;
    }
    sd_error_t res = req->result;
    drv_sd_thread_release(req);
 8008bd0:	4620      	mov	r0, r4
    sd_error_t res = req->result;
 8008bd2:	7864      	ldrb	r4, [r4, #1]
    drv_sd_thread_release(req);
 8008bd4:	f001 f8ae 	bl	8009d34 <drv_sd_thread_release>
    return res;
}
 8008bd8:	4620      	mov	r0, r4
 8008bda:	bd38      	pop	{r3, r4, r5, pc}
        drv_sd_thread_release(req);
 8008bdc:	4620      	mov	r0, r4
 8008bde:	f001 f8a9 	bl	8009d34 <drv_sd_thread_release>
    g_sd_stats.ops_total++;
 8008be2:	4b11      	ldr	r3, [pc, #68]	; (8008c28 <sd_submit_request+0x74>)
    g_sd_last_error = err;
 8008be4:	2403      	movs	r4, #3
 8008be6:	4811      	ldr	r0, [pc, #68]	; (8008c2c <sd_submit_request+0x78>)
    g_sd_stats.ops_total++;
 8008be8:	6819      	ldr	r1, [r3, #0]
    g_sd_stats.ops_error++;
 8008bea:	689a      	ldr	r2, [r3, #8]
    g_sd_last_error = err;
 8008bec:	7004      	strb	r4, [r0, #0]
    g_sd_stats.ops_total++;
 8008bee:	1c48      	adds	r0, r1, #1
    g_sd_stats.ops_error++;
 8008bf0:	1c51      	adds	r1, r2, #1
    case SD_ERR_BUSY: g_sd_stats.err_busy++; break;
 8008bf2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    g_sd_stats.ops_total++;
 8008bf4:	6018      	str	r0, [r3, #0]
}
 8008bf6:	4620      	mov	r0, r4
    case SD_ERR_BUSY: g_sd_stats.err_busy++; break;
 8008bf8:	3201      	adds	r2, #1
    g_sd_stats.ops_error++;
 8008bfa:	6099      	str	r1, [r3, #8]
    case SD_ERR_BUSY: g_sd_stats.err_busy++; break;
 8008bfc:	631a      	str	r2, [r3, #48]	; 0x30
}
 8008bfe:	bd38      	pop	{r3, r4, r5, pc}
        req->result = SD_ERR_TIMEOUT;
 8008c00:	220b      	movs	r2, #11
        req->auto_release = true;
 8008c02:	f240 1301 	movw	r3, #257	; 0x101
        g_sd_last_error = SD_ERR_TIMEOUT;
 8008c06:	4909      	ldr	r1, [pc, #36]	; (8008c2c <sd_submit_request+0x78>)
        req->auto_release = true;
 8008c08:	8223      	strh	r3, [r4, #16]
        g_sd_last_error = SD_ERR_TIMEOUT;
 8008c0a:	700a      	strb	r2, [r1, #0]
    switch (req->type) {
 8008c0c:	7823      	ldrb	r3, [r4, #0]
        req->result = SD_ERR_TIMEOUT;
 8008c0e:	7062      	strb	r2, [r4, #1]
    switch (req->type) {
 8008c10:	3b03      	subs	r3, #3
 8008c12:	2b04      	cmp	r3, #4
 8008c14:	d805      	bhi.n	8008c22 <sd_submit_request+0x6e>
 8008c16:	4601      	mov	r1, r0
 8008c18:	4628      	mov	r0, r5
        return SD_ERR_TIMEOUT;
 8008c1a:	4614      	mov	r4, r2
 8008c1c:	f7fd fda2 	bl	8006764 <chSemWaitTimeout>
 8008c20:	e7da      	b.n	8008bd8 <sd_submit_request+0x24>
 8008c22:	4614      	mov	r4, r2
 8008c24:	e7d8      	b.n	8008bd8 <sd_submit_request+0x24>
 8008c26:	bf00      	nop
 8008c28:	240037a8 	.word	0x240037a8
 8008c2c:	240037a5 	.word	0x240037a5

08008c30 <drv_sd_init>:

sd_error_t drv_sd_init(void) {
 8008c30:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8008c32:	f3ef 8305 	mrs	r3, IPSR
    if (__get_IPSR() != 0U) {
 8008c36:	b9ab      	cbnz	r3, 8008c64 <drv_sd_init+0x34>
  return __sch_get_currthread();
 8008c38:	4b16      	ldr	r3, [pc, #88]	; (8008c94 <drv_sd_init+0x64>)
 *
 */
static inline const char *chRegGetThreadNameX(thread_t *tp) {

#if CH_CFG_USE_REGISTRY == TRUE
  return tp->name;
 8008c3a:	68db      	ldr	r3, [r3, #12]
 8008c3c:	6a18      	ldr	r0, [r3, #32]
    if (name != NULL && strcmp(name, "audioProcess") == 0) {
 8008c3e:	b118      	cbz	r0, 8008c48 <drv_sd_init+0x18>
 8008c40:	4915      	ldr	r1, [pc, #84]	; (8008c98 <drv_sd_init+0x68>)
 8008c42:	f7f7 fc31 	bl	80004a8 <strcmp>
 8008c46:	b168      	cbz	r0, 8008c64 <drv_sd_init+0x34>
    if (!sd_initialized) {
 8008c48:	4c14      	ldr	r4, [pc, #80]	; (8008c9c <drv_sd_init+0x6c>)
    if (sd_context_forbidden()) {
        sd_record_rejection(SD_ERR_CONTEXT);
        return SD_ERR_CONTEXT;
    }
    (void)mpu_config_init_once();
 8008c4a:	f7ff f8f5 	bl	8007e38 <mpu_config_init_once>
    if (!sd_initialized) {
 8008c4e:	7823      	ldrb	r3, [r4, #0]
 8008c50:	b1b3      	cbz	r3, 8008c80 <drv_sd_init+0x50>
    sd_ensure_thread_started();
    sd_request_t *req = drv_sd_thread_alloc();
 8008c52:	f001 f83d 	bl	8009cd0 <drv_sd_thread_alloc>
    if (req == NULL) {
 8008c56:	b1d0      	cbz	r0, 8008c8e <drv_sd_init+0x5e>
        return SD_ERR_BUSY;
    }
    req->type = SD_REQ_INIT;
 8008c58:	2200      	movs	r2, #0
 8008c5a:	7002      	strb	r2, [r0, #0]
    return sd_submit_request(req);
}
 8008c5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return sd_submit_request(req);
 8008c60:	f7ff bfa8 	b.w	8008bb4 <sd_submit_request>
    g_sd_stats.ops_total++;
 8008c64:	4b0e      	ldr	r3, [pc, #56]	; (8008ca0 <drv_sd_init+0x70>)
    g_sd_last_error = err;
 8008c66:	200c      	movs	r0, #12
 8008c68:	4c0e      	ldr	r4, [pc, #56]	; (8008ca4 <drv_sd_init+0x74>)
    g_sd_stats.ops_total++;
 8008c6a:	6819      	ldr	r1, [r3, #0]
    g_sd_stats.ops_error++;
 8008c6c:	689a      	ldr	r2, [r3, #8]
    g_sd_last_error = err;
 8008c6e:	7020      	strb	r0, [r4, #0]
    g_sd_stats.ops_total++;
 8008c70:	1c4c      	adds	r4, r1, #1
    g_sd_stats.ops_error++;
 8008c72:	1c51      	adds	r1, r2, #1
    case SD_ERR_CONTEXT: g_sd_stats.err_context++; break;
 8008c74:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    g_sd_stats.ops_total++;
 8008c76:	601c      	str	r4, [r3, #0]
    case SD_ERR_CONTEXT: g_sd_stats.err_context++; break;
 8008c78:	3201      	adds	r2, #1
    g_sd_stats.ops_error++;
 8008c7a:	6099      	str	r1, [r3, #8]
    case SD_ERR_CONTEXT: g_sd_stats.err_context++; break;
 8008c7c:	635a      	str	r2, [r3, #52]	; 0x34
}
 8008c7e:	bd10      	pop	{r4, pc}
        drv_sd_thread_start();
 8008c80:	f001 f802 	bl	8009c88 <drv_sd_thread_start>
        sd_initialized = true;
 8008c84:	2301      	movs	r3, #1
        g_sd_state = SD_STATE_UNMOUNTED;
 8008c86:	4a08      	ldr	r2, [pc, #32]	; (8008ca8 <drv_sd_init+0x78>)
        sd_initialized = true;
 8008c88:	7023      	strb	r3, [r4, #0]
        g_sd_state = SD_STATE_UNMOUNTED;
 8008c8a:	7013      	strb	r3, [r2, #0]
}
 8008c8c:	e7e1      	b.n	8008c52 <drv_sd_init+0x22>
        return SD_ERR_BUSY;
 8008c8e:	2003      	movs	r0, #3
}
 8008c90:	bd10      	pop	{r4, pc}
 8008c92:	bf00      	nop
 8008c94:	24000c20 	.word	0x24000c20
 8008c98:	08015304 	.word	0x08015304
 8008c9c:	240037f0 	.word	0x240037f0
 8008ca0:	240037a8 	.word	0x240037a8
 8008ca4:	240037a5 	.word	0x240037a5
 8008ca8:	240037a6 	.word	0x240037a6

08008cac <drv_sd_fs_map_result>:
static bool fs_mounted = false;
static bool fs_read_only = false;
static bool fs_write_protected_event = false;

static sd_error_t drv_sd_fs_map_result(FRESULT res) {
    switch (res) {
 8008cac:	280b      	cmp	r0, #11
 8008cae:	d807      	bhi.n	8008cc0 <drv_sd_fs_map_result+0x14>
 8008cb0:	e8df f000 	tbb	[pc, r0]
 8008cb4:	08080807 	.word	0x08080807
 8008cb8:	15060a0a 	.word	0x15060a0a
 8008cbc:	080e060c 	.word	0x080e060c
    case FR_WRITE_PROTECTED:
        fs_write_protected_event = true;
        fs_read_only = true;
        return SD_ERR_FS;
    default:
        return SD_ERR_FS;
 8008cc0:	2006      	movs	r0, #6
    }
}
 8008cc2:	4770      	bx	lr
        return SD_ERR_IO;
 8008cc4:	2004      	movs	r0, #4
 8008cc6:	4770      	bx	lr
    switch (res) {
 8008cc8:	2009      	movs	r0, #9
 8008cca:	4770      	bx	lr
        return SD_ERR_PARAM;
 8008ccc:	2007      	movs	r0, #7
 8008cce:	4770      	bx	lr
        fs_write_protected_event = true;
 8008cd0:	2301      	movs	r3, #1
 8008cd2:	4904      	ldr	r1, [pc, #16]	; (8008ce4 <drv_sd_fs_map_result+0x38>)
        fs_read_only = true;
 8008cd4:	4a04      	ldr	r2, [pc, #16]	; (8008ce8 <drv_sd_fs_map_result+0x3c>)
        return SD_ERR_FS;
 8008cd6:	2006      	movs	r0, #6
        fs_write_protected_event = true;
 8008cd8:	700b      	strb	r3, [r1, #0]
        fs_read_only = true;
 8008cda:	7013      	strb	r3, [r2, #0]
        return SD_ERR_FS;
 8008cdc:	4770      	bx	lr
        return SD_ERR_FULL;
 8008cde:	2008      	movs	r0, #8
 8008ce0:	4770      	bx	lr
 8008ce2:	bf00      	nop
 8008ce4:	240037f3 	.word	0x240037f3
 8008ce8:	240037f2 	.word	0x240037f2

08008cec <drv_sd_fs_mount>:

sd_error_t drv_sd_fs_mount(sd_fs_mode_t mode) {
 8008cec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008cf0:	b086      	sub	sp, #24
 8008cf2:	4605      	mov	r5, r0
    if (!drv_sd_hal_is_card_present()) {
 8008cf4:	f000 f99e 	bl	8009034 <drv_sd_hal_is_card_present>
 8008cf8:	b930      	cbnz	r0, 8008d08 <drv_sd_fs_mount+0x1c>
        fs_mounted = false;
 8008cfa:	4b35      	ldr	r3, [pc, #212]	; (8008dd0 <drv_sd_fs_mount+0xe4>)
        return SD_ERR_NO_CARD;
 8008cfc:	2401      	movs	r4, #1
        fs_mounted = false;
 8008cfe:	7018      	strb	r0, [r3, #0]
            drv_sd_fs_unmount();
            return SD_ERR_FS;
        }
    }
    return SD_OK;
}
 8008d00:	4620      	mov	r0, r4
 8008d02:	b006      	add	sp, #24
 8008d04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    sd_hal_status_t hal_status = drv_sd_hal_connect();
 8008d08:	f000 f99a 	bl	8009040 <drv_sd_hal_connect>
 8008d0c:	4604      	mov	r4, r0
 8008d0e:	4607      	mov	r7, r0
    if (hal_status != SD_HAL_OK) {
 8008d10:	b150      	cbz	r0, 8008d28 <drv_sd_fs_mount+0x3c>
        return hal_status == SD_HAL_NO_CARD ? SD_ERR_NO_CARD : SD_ERR_IO;
 8008d12:	2801      	cmp	r0, #1
        fs_mounted = false;
 8008d14:	4b2e      	ldr	r3, [pc, #184]	; (8008dd0 <drv_sd_fs_mount+0xe4>)
 8008d16:	f04f 0200 	mov.w	r2, #0
        return hal_status == SD_HAL_NO_CARD ? SD_ERR_NO_CARD : SD_ERR_IO;
 8008d1a:	bf18      	it	ne
 8008d1c:	2404      	movne	r4, #4
        fs_mounted = false;
 8008d1e:	701a      	strb	r2, [r3, #0]
}
 8008d20:	4620      	mov	r0, r4
 8008d22:	b006      	add	sp, #24
 8008d24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FRESULT res = f_mount(&sd_fs, "", 1);
 8008d28:	2201      	movs	r2, #1
 8008d2a:	492a      	ldr	r1, [pc, #168]	; (8008dd4 <drv_sd_fs_mount+0xe8>)
 8008d2c:	482a      	ldr	r0, [pc, #168]	; (8008dd8 <drv_sd_fs_mount+0xec>)
 8008d2e:	f001 ff6b 	bl	800ac08 <f_mount>
 8008d32:	4606      	mov	r6, r0
 8008d34:	4604      	mov	r4, r0
    if (res != FR_OK) {
 8008d36:	bb68      	cbnz	r0, 8008d94 <drv_sd_fs_mount+0xa8>
    fs_mounted = true;
 8008d38:	2301      	movs	r3, #1
    fs_read_only = (mode == SD_FS_RO);
 8008d3a:	2d01      	cmp	r5, #1
    fs_mounted = true;
 8008d3c:	4d24      	ldr	r5, [pc, #144]	; (8008dd0 <drv_sd_fs_mount+0xe4>)
        if (f_stat("/samples", &info) != FR_OK) {
 8008d3e:	4669      	mov	r1, sp
    fs_read_only = (mode == SD_FS_RO);
 8008d40:	4f26      	ldr	r7, [pc, #152]	; (8008ddc <drv_sd_fs_mount+0xf0>)
    fs_mounted = true;
 8008d42:	702b      	strb	r3, [r5, #0]
    fs_read_only = (mode == SD_FS_RO);
 8008d44:	bf18      	it	ne
 8008d46:	2300      	movne	r3, #0
        if (f_stat("/samples", &info) != FR_OK) {
 8008d48:	4825      	ldr	r0, [pc, #148]	; (8008de0 <drv_sd_fs_mount+0xf4>)
    fs_read_only = (mode == SD_FS_RO);
 8008d4a:	703b      	strb	r3, [r7, #0]
    if (!fs_read_only) {
 8008d4c:	d014      	beq.n	8008d78 <drv_sd_fs_mount+0x8c>
        if (f_stat("/samples", &info) != FR_OK) {
 8008d4e:	f002 fb2b 	bl	800b3a8 <f_stat>
 8008d52:	2800      	cmp	r0, #0
 8008d54:	d0d4      	beq.n	8008d00 <drv_sd_fs_mount+0x14>
            sd_error_t mkdir_res = drv_sd_fs_map_result(f_mkdir("/samples"));
 8008d56:	4822      	ldr	r0, [pc, #136]	; (8008de0 <drv_sd_fs_mount+0xf4>)
 8008d58:	f002 fba2 	bl	800b4a0 <f_mkdir>
 8008d5c:	f7ff ffa6 	bl	8008cac <drv_sd_fs_map_result>
            if (mkdir_res != SD_OK) {
 8008d60:	4680      	mov	r8, r0
 8008d62:	2800      	cmp	r0, #0
 8008d64:	d0cc      	beq.n	8008d00 <drv_sd_fs_mount+0x14>

void drv_sd_fs_unmount(void) {
    if (fs_mounted) {
 8008d66:	782b      	ldrb	r3, [r5, #0]
 8008d68:	bb43      	cbnz	r3, 8008dbc <drv_sd_fs_mount+0xd0>
        drv_sd_hal_sync();
        f_unmount("");
        drv_sd_hal_disconnect();
    }
    fs_mounted = false;
 8008d6a:	2300      	movs	r3, #0
    fs_read_only = false;
    fs_write_protected_event = false;
 8008d6c:	4a1d      	ldr	r2, [pc, #116]	; (8008de4 <drv_sd_fs_mount+0xf8>)
                return mkdir_res;
 8008d6e:	4644      	mov	r4, r8
    fs_mounted = false;
 8008d70:	702b      	strb	r3, [r5, #0]
    fs_read_only = false;
 8008d72:	703b      	strb	r3, [r7, #0]
    fs_write_protected_event = false;
 8008d74:	7013      	strb	r3, [r2, #0]
                return mkdir_res;
 8008d76:	e7c3      	b.n	8008d00 <drv_sd_fs_mount+0x14>
        if (f_stat("/samples", &info) != FR_OK) {
 8008d78:	f002 fb16 	bl	800b3a8 <f_stat>
 8008d7c:	4604      	mov	r4, r0
 8008d7e:	2800      	cmp	r0, #0
 8008d80:	d0be      	beq.n	8008d00 <drv_sd_fs_mount+0x14>
    if (fs_mounted) {
 8008d82:	782b      	ldrb	r3, [r5, #0]
 8008d84:	b983      	cbnz	r3, 8008da8 <drv_sd_fs_mount+0xbc>
    fs_mounted = false;
 8008d86:	2300      	movs	r3, #0
    fs_write_protected_event = false;
 8008d88:	4a16      	ldr	r2, [pc, #88]	; (8008de4 <drv_sd_fs_mount+0xf8>)
            return SD_ERR_FS;
 8008d8a:	2406      	movs	r4, #6
    fs_mounted = false;
 8008d8c:	702b      	strb	r3, [r5, #0]
    fs_read_only = false;
 8008d8e:	703b      	strb	r3, [r7, #0]
    fs_write_protected_event = false;
 8008d90:	7013      	strb	r3, [r2, #0]
            return SD_ERR_FS;
 8008d92:	e7b5      	b.n	8008d00 <drv_sd_fs_mount+0x14>
        fs_mounted = false;
 8008d94:	4b0e      	ldr	r3, [pc, #56]	; (8008dd0 <drv_sd_fs_mount+0xe4>)
 8008d96:	701f      	strb	r7, [r3, #0]
        drv_sd_hal_disconnect();
 8008d98:	f000 f96c 	bl	8009074 <drv_sd_hal_disconnect>
        return drv_sd_fs_map_result(res);
 8008d9c:	4630      	mov	r0, r6
}
 8008d9e:	b006      	add	sp, #24
 8008da0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        return drv_sd_fs_map_result(res);
 8008da4:	f7ff bf82 	b.w	8008cac <drv_sd_fs_map_result>
        drv_sd_hal_sync();
 8008da8:	f000 f9c0 	bl	800912c <drv_sd_hal_sync>
        f_unmount("");
 8008dac:	4632      	mov	r2, r6
 8008dae:	4909      	ldr	r1, [pc, #36]	; (8008dd4 <drv_sd_fs_mount+0xe8>)
 8008db0:	4630      	mov	r0, r6
 8008db2:	f001 ff29 	bl	800ac08 <f_mount>
        drv_sd_hal_disconnect();
 8008db6:	f000 f95d 	bl	8009074 <drv_sd_hal_disconnect>
 8008dba:	e7e4      	b.n	8008d86 <drv_sd_fs_mount+0x9a>
        drv_sd_hal_sync();
 8008dbc:	f000 f9b6 	bl	800912c <drv_sd_hal_sync>
        f_unmount("");
 8008dc0:	4632      	mov	r2, r6
 8008dc2:	4904      	ldr	r1, [pc, #16]	; (8008dd4 <drv_sd_fs_mount+0xe8>)
 8008dc4:	4630      	mov	r0, r6
 8008dc6:	f001 ff1f 	bl	800ac08 <f_mount>
        drv_sd_hal_disconnect();
 8008dca:	f000 f953 	bl	8009074 <drv_sd_hal_disconnect>
 8008dce:	e7cc      	b.n	8008d6a <drv_sd_fs_mount+0x7e>
 8008dd0:	240037f1 	.word	0x240037f1
 8008dd4:	08015378 	.word	0x08015378
 8008dd8:	240037f4 	.word	0x240037f4
 8008ddc:	240037f2 	.word	0x240037f2
 8008de0:	08015314 	.word	0x08015314
 8008de4:	240037f3 	.word	0x240037f3

08008de8 <drv_sd_fs_unmount>:
void drv_sd_fs_unmount(void) {
 8008de8:	b510      	push	{r4, lr}
    if (fs_mounted) {
 8008dea:	4c0a      	ldr	r4, [pc, #40]	; (8008e14 <drv_sd_fs_unmount+0x2c>)
 8008dec:	7823      	ldrb	r3, [r4, #0]
 8008dee:	b933      	cbnz	r3, 8008dfe <drv_sd_fs_unmount+0x16>
    fs_mounted = false;
 8008df0:	2300      	movs	r3, #0
    fs_read_only = false;
 8008df2:	4909      	ldr	r1, [pc, #36]	; (8008e18 <drv_sd_fs_unmount+0x30>)
    fs_write_protected_event = false;
 8008df4:	4a09      	ldr	r2, [pc, #36]	; (8008e1c <drv_sd_fs_unmount+0x34>)
    fs_mounted = false;
 8008df6:	7023      	strb	r3, [r4, #0]
    fs_read_only = false;
 8008df8:	700b      	strb	r3, [r1, #0]
    fs_write_protected_event = false;
 8008dfa:	7013      	strb	r3, [r2, #0]
}
 8008dfc:	bd10      	pop	{r4, pc}
        drv_sd_hal_sync();
 8008dfe:	f000 f995 	bl	800912c <drv_sd_hal_sync>
        f_unmount("");
 8008e02:	2200      	movs	r2, #0
 8008e04:	4906      	ldr	r1, [pc, #24]	; (8008e20 <drv_sd_fs_unmount+0x38>)
 8008e06:	4610      	mov	r0, r2
 8008e08:	f001 fefe 	bl	800ac08 <f_mount>
        drv_sd_hal_disconnect();
 8008e0c:	f000 f932 	bl	8009074 <drv_sd_hal_disconnect>
 8008e10:	e7ee      	b.n	8008df0 <drv_sd_fs_unmount+0x8>
 8008e12:	bf00      	nop
 8008e14:	240037f1 	.word	0x240037f1
 8008e18:	240037f2 	.word	0x240037f2
 8008e1c:	240037f3 	.word	0x240037f3
 8008e20:	08015378 	.word	0x08015378

08008e24 <drv_sd_fs_is_mounted>:

bool drv_sd_fs_is_mounted(void) {
    return fs_mounted;
 8008e24:	4b01      	ldr	r3, [pc, #4]	; (8008e2c <drv_sd_fs_is_mounted+0x8>)
}
 8008e26:	7818      	ldrb	r0, [r3, #0]
 8008e28:	4770      	bx	lr
 8008e2a:	bf00      	nop
 8008e2c:	240037f1 	.word	0x240037f1

08008e30 <drv_sd_fs_open>:

sd_error_t drv_sd_fs_open(sd_fs_file_t *handle, const char *path, BYTE mode) {
    if (!fs_mounted || handle == NULL || path == NULL) {
 8008e30:	4b0f      	ldr	r3, [pc, #60]	; (8008e70 <drv_sd_fs_open+0x40>)
 8008e32:	781b      	ldrb	r3, [r3, #0]
 8008e34:	b1ab      	cbz	r3, 8008e62 <drv_sd_fs_open+0x32>
sd_error_t drv_sd_fs_open(sd_fs_file_t *handle, const char *path, BYTE mode) {
 8008e36:	b510      	push	{r4, lr}
 8008e38:	4604      	mov	r4, r0
    if (!fs_mounted || handle == NULL || path == NULL) {
 8008e3a:	b1b0      	cbz	r0, 8008e6a <drv_sd_fs_open+0x3a>
 8008e3c:	b1a9      	cbz	r1, 8008e6a <drv_sd_fs_open+0x3a>
        return SD_ERR_PARAM;
    }
    if (fs_read_only && (mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND))) {
 8008e3e:	4b0d      	ldr	r3, [pc, #52]	; (8008e74 <drv_sd_fs_open+0x44>)
 8008e40:	781b      	ldrb	r3, [r3, #0]
 8008e42:	b113      	cbz	r3, 8008e4a <drv_sd_fs_open+0x1a>
 8008e44:	f012 0f3e 	tst.w	r2, #62	; 0x3e
 8008e48:	d10d      	bne.n	8008e66 <drv_sd_fs_open+0x36>
        return SD_ERR_FS;
    }
    FRESULT res = f_open(&handle->file, path, mode);
 8008e4a:	4620      	mov	r0, r4
 8008e4c:	f001 ff06 	bl	800ac5c <f_open>
    handle->open = (res == FR_OK);
 8008e50:	fab0 f380 	clz	r3, r0
 8008e54:	095b      	lsrs	r3, r3, #5
 8008e56:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    return drv_sd_fs_map_result(res);
}
 8008e5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return drv_sd_fs_map_result(res);
 8008e5e:	f7ff bf25 	b.w	8008cac <drv_sd_fs_map_result>
        return SD_ERR_PARAM;
 8008e62:	2007      	movs	r0, #7
}
 8008e64:	4770      	bx	lr
        return SD_ERR_FS;
 8008e66:	2006      	movs	r0, #6
}
 8008e68:	bd10      	pop	{r4, pc}
        return SD_ERR_PARAM;
 8008e6a:	2007      	movs	r0, #7
}
 8008e6c:	bd10      	pop	{r4, pc}
 8008e6e:	bf00      	nop
 8008e70:	240037f1 	.word	0x240037f1
 8008e74:	240037f2 	.word	0x240037f2

08008e78 <drv_sd_fs_close>:

void drv_sd_fs_close(sd_fs_file_t *handle) {
    if (handle != NULL && handle->open) {
 8008e78:	b158      	cbz	r0, 8008e92 <drv_sd_fs_close+0x1a>
 8008e7a:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
void drv_sd_fs_close(sd_fs_file_t *handle) {
 8008e7e:	b510      	push	{r4, lr}
 8008e80:	4604      	mov	r4, r0
    if (handle != NULL && handle->open) {
 8008e82:	b903      	cbnz	r3, 8008e86 <drv_sd_fs_close+0xe>
        (void)f_close(&handle->file);
        handle->open = false;
    }
}
 8008e84:	bd10      	pop	{r4, pc}
        (void)f_close(&handle->file);
 8008e86:	f002 f9f3 	bl	800b270 <f_close>
        handle->open = false;
 8008e8a:	2300      	movs	r3, #0
 8008e8c:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
}
 8008e90:	bd10      	pop	{r4, pc}
 8008e92:	4770      	bx	lr

08008e94 <drv_sd_fs_read>:

sd_error_t drv_sd_fs_read(sd_fs_file_t *handle, void *buffer, UINT btr, UINT *br) {
    if (!handle || !handle->open) {
 8008e94:	b158      	cbz	r0, 8008eae <drv_sd_fs_read+0x1a>
sd_error_t drv_sd_fs_read(sd_fs_file_t *handle, void *buffer, UINT btr, UINT *br) {
 8008e96:	b510      	push	{r4, lr}
    if (!handle || !handle->open) {
 8008e98:	f890 4228 	ldrb.w	r4, [r0, #552]	; 0x228
 8008e9c:	b12c      	cbz	r4, 8008eaa <drv_sd_fs_read+0x16>
        return SD_ERR_PARAM;
    }
    FRESULT res = f_read(&handle->file, buffer, btr, br);
 8008e9e:	f001 ffe5 	bl	800ae6c <f_read>
    return drv_sd_fs_map_result(res);
}
 8008ea2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return drv_sd_fs_map_result(res);
 8008ea6:	f7ff bf01 	b.w	8008cac <drv_sd_fs_map_result>
}
 8008eaa:	2007      	movs	r0, #7
 8008eac:	bd10      	pop	{r4, pc}
 8008eae:	2007      	movs	r0, #7
 8008eb0:	4770      	bx	lr
 8008eb2:	bf00      	nop

08008eb4 <drv_sd_fs_write>:

sd_error_t drv_sd_fs_write(sd_fs_file_t *handle, const void *buffer, UINT btw, UINT *bw) {
    if (!handle || !handle->open || fs_read_only) {
 8008eb4:	b170      	cbz	r0, 8008ed4 <drv_sd_fs_write+0x20>
sd_error_t drv_sd_fs_write(sd_fs_file_t *handle, const void *buffer, UINT btw, UINT *bw) {
 8008eb6:	b510      	push	{r4, lr}
    if (!handle || !handle->open || fs_read_only) {
 8008eb8:	f890 4228 	ldrb.w	r4, [r0, #552]	; 0x228
 8008ebc:	b144      	cbz	r4, 8008ed0 <drv_sd_fs_write+0x1c>
 8008ebe:	4c06      	ldr	r4, [pc, #24]	; (8008ed8 <drv_sd_fs_write+0x24>)
 8008ec0:	7824      	ldrb	r4, [r4, #0]
 8008ec2:	b92c      	cbnz	r4, 8008ed0 <drv_sd_fs_write+0x1c>
        return SD_ERR_PARAM;
    }
    FRESULT res = f_write(&handle->file, buffer, btw, bw);
 8008ec4:	f002 f896 	bl	800aff4 <f_write>
    return drv_sd_fs_map_result(res);
}
 8008ec8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return drv_sd_fs_map_result(res);
 8008ecc:	f7ff beee 	b.w	8008cac <drv_sd_fs_map_result>
}
 8008ed0:	2007      	movs	r0, #7
 8008ed2:	bd10      	pop	{r4, pc}
 8008ed4:	2007      	movs	r0, #7
 8008ed6:	4770      	bx	lr
 8008ed8:	240037f2 	.word	0x240037f2

08008edc <drv_sd_fs_sync>:

sd_error_t drv_sd_fs_sync(sd_fs_file_t *handle) {
    if (!handle || !handle->open || fs_read_only) {
 8008edc:	b190      	cbz	r0, 8008f04 <drv_sd_fs_sync+0x28>
 8008ede:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
 8008ee2:	b17b      	cbz	r3, 8008f04 <drv_sd_fs_sync+0x28>
 8008ee4:	4b08      	ldr	r3, [pc, #32]	; (8008f08 <drv_sd_fs_sync+0x2c>)
 8008ee6:	781b      	ldrb	r3, [r3, #0]
 8008ee8:	b963      	cbnz	r3, 8008f04 <drv_sd_fs_sync+0x28>
sd_error_t drv_sd_fs_sync(sd_fs_file_t *handle) {
 8008eea:	b500      	push	{lr}
 8008eec:	b083      	sub	sp, #12
        return SD_ERR_PARAM;
    }
    FRESULT res = f_sync(&handle->file);
 8008eee:	f002 f961 	bl	800b1b4 <f_sync>
 8008ef2:	9001      	str	r0, [sp, #4]
    drv_sd_hal_sync();
 8008ef4:	f000 f91a 	bl	800912c <drv_sd_hal_sync>
    return drv_sd_fs_map_result(res);
 8008ef8:	9801      	ldr	r0, [sp, #4]
}
 8008efa:	b003      	add	sp, #12
 8008efc:	f85d eb04 	ldr.w	lr, [sp], #4
    return drv_sd_fs_map_result(res);
 8008f00:	f7ff bed4 	b.w	8008cac <drv_sd_fs_map_result>
}
 8008f04:	2007      	movs	r0, #7
 8008f06:	4770      	bx	lr
 8008f08:	240037f2 	.word	0x240037f2

08008f0c <drv_sd_fs_rename>:
    }
    return drv_sd_fs_map_result(f_stat(path, info));
}

sd_error_t drv_sd_fs_rename(const char *oldp, const char *newp) {
    if (!fs_mounted || oldp == NULL || newp == NULL || fs_read_only) {
 8008f0c:	4b08      	ldr	r3, [pc, #32]	; (8008f30 <drv_sd_fs_rename+0x24>)
sd_error_t drv_sd_fs_rename(const char *oldp, const char *newp) {
 8008f0e:	b510      	push	{r4, lr}
    if (!fs_mounted || oldp == NULL || newp == NULL || fs_read_only) {
 8008f10:	781c      	ldrb	r4, [r3, #0]
 8008f12:	b154      	cbz	r4, 8008f2a <drv_sd_fs_rename+0x1e>
 8008f14:	b148      	cbz	r0, 8008f2a <drv_sd_fs_rename+0x1e>
 8008f16:	b141      	cbz	r1, 8008f2a <drv_sd_fs_rename+0x1e>
 8008f18:	4b06      	ldr	r3, [pc, #24]	; (8008f34 <drv_sd_fs_rename+0x28>)
 8008f1a:	781b      	ldrb	r3, [r3, #0]
 8008f1c:	b92b      	cbnz	r3, 8008f2a <drv_sd_fs_rename+0x1e>
        return SD_ERR_PARAM;
    }
    return drv_sd_fs_map_result(f_rename(oldp, newp));
 8008f1e:	f002 fbab 	bl	800b678 <f_rename>
}
 8008f22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return drv_sd_fs_map_result(f_rename(oldp, newp));
 8008f26:	f7ff bec1 	b.w	8008cac <drv_sd_fs_map_result>
}
 8008f2a:	2007      	movs	r0, #7
 8008f2c:	bd10      	pop	{r4, pc}
 8008f2e:	bf00      	nop
 8008f30:	240037f1 	.word	0x240037f1
 8008f34:	240037f2 	.word	0x240037f2

08008f38 <drv_sd_fs_delete>:

sd_error_t drv_sd_fs_delete(const char *path) {
 8008f38:	b508      	push	{r3, lr}
    if (!fs_mounted || path == NULL || fs_read_only) {
 8008f3a:	4b08      	ldr	r3, [pc, #32]	; (8008f5c <drv_sd_fs_delete+0x24>)
 8008f3c:	781a      	ldrb	r2, [r3, #0]
 8008f3e:	2a01      	cmp	r2, #1
 8008f40:	d109      	bne.n	8008f56 <drv_sd_fs_delete+0x1e>
 8008f42:	b140      	cbz	r0, 8008f56 <drv_sd_fs_delete+0x1e>
 8008f44:	4b06      	ldr	r3, [pc, #24]	; (8008f60 <drv_sd_fs_delete+0x28>)
 8008f46:	781b      	ldrb	r3, [r3, #0]
 8008f48:	b92b      	cbnz	r3, 8008f56 <drv_sd_fs_delete+0x1e>
        return SD_ERR_PARAM;
    }
    return drv_sd_fs_map_result(f_unlink(path));
 8008f4a:	f002 fa57 	bl	800b3fc <f_unlink>
}
 8008f4e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return drv_sd_fs_map_result(f_unlink(path));
 8008f52:	f7ff beab 	b.w	8008cac <drv_sd_fs_map_result>
}
 8008f56:	2007      	movs	r0, #7
 8008f58:	bd08      	pop	{r3, pc}
 8008f5a:	bf00      	nop
 8008f5c:	240037f1 	.word	0x240037f1
 8008f60:	240037f2 	.word	0x240037f2

08008f64 <drv_sd_fs_mkdir>:

sd_error_t drv_sd_fs_mkdir(const char *path) {
 8008f64:	b508      	push	{r3, lr}
    if (!fs_mounted || path == NULL || fs_read_only) {
 8008f66:	4b08      	ldr	r3, [pc, #32]	; (8008f88 <drv_sd_fs_mkdir+0x24>)
 8008f68:	781a      	ldrb	r2, [r3, #0]
 8008f6a:	2a01      	cmp	r2, #1
 8008f6c:	d109      	bne.n	8008f82 <drv_sd_fs_mkdir+0x1e>
 8008f6e:	b140      	cbz	r0, 8008f82 <drv_sd_fs_mkdir+0x1e>
 8008f70:	4b06      	ldr	r3, [pc, #24]	; (8008f8c <drv_sd_fs_mkdir+0x28>)
 8008f72:	781b      	ldrb	r3, [r3, #0]
 8008f74:	b92b      	cbnz	r3, 8008f82 <drv_sd_fs_mkdir+0x1e>
        return SD_ERR_PARAM;
    }
    return drv_sd_fs_map_result(f_mkdir(path));
 8008f76:	f002 fa93 	bl	800b4a0 <f_mkdir>
}
 8008f7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return drv_sd_fs_map_result(f_mkdir(path));
 8008f7e:	f7ff be95 	b.w	8008cac <drv_sd_fs_map_result>
}
 8008f82:	2007      	movs	r0, #7
 8008f84:	bd08      	pop	{r3, pc}
 8008f86:	bf00      	nop
 8008f88:	240037f1 	.word	0x240037f1
 8008f8c:	240037f2 	.word	0x240037f2

08008f90 <drv_sd_fs_list_dir>:

sd_error_t drv_sd_fs_list_dir(const char *path, FRESULT (*cb)(FILINFO *info, void *arg), void *arg) {
    if (!fs_mounted || path == NULL || cb == NULL) {
 8008f90:	4b15      	ldr	r3, [pc, #84]	; (8008fe8 <drv_sd_fs_list_dir+0x58>)
 8008f92:	781b      	ldrb	r3, [r3, #0]
 8008f94:	b313      	cbz	r3, 8008fdc <drv_sd_fs_list_dir+0x4c>
 8008f96:	b308      	cbz	r0, 8008fdc <drv_sd_fs_list_dir+0x4c>
sd_error_t drv_sd_fs_list_dir(const char *path, FRESULT (*cb)(FILINFO *info, void *arg), void *arg) {
 8008f98:	b570      	push	{r4, r5, r6, lr}
 8008f9a:	460d      	mov	r5, r1
 8008f9c:	b092      	sub	sp, #72	; 0x48
    if (!fs_mounted || path == NULL || cb == NULL) {
 8008f9e:	b1f9      	cbz	r1, 8008fe0 <drv_sd_fs_list_dir+0x50>
        return SD_ERR_PARAM;
    }
    DIR dir;
    FRESULT res = f_opendir(&dir, path);
 8008fa0:	4601      	mov	r1, r0
 8008fa2:	a807      	add	r0, sp, #28
 8008fa4:	4616      	mov	r6, r2
 8008fa6:	f002 f975 	bl	800b294 <f_opendir>
    if (res != FR_OK) {
 8008faa:	b148      	cbz	r0, 8008fc0 <drv_sd_fs_list_dir+0x30>
        if (res != FR_OK) {
            break;
        }
    }
    f_closedir(&dir);
    return drv_sd_fs_map_result(res);
 8008fac:	f7ff fe7e 	bl	8008cac <drv_sd_fs_map_result>
}
 8008fb0:	b012      	add	sp, #72	; 0x48
 8008fb2:	bd70      	pop	{r4, r5, r6, pc}
        if (res != FR_OK || fno.fname[0] == 0) {
 8008fb4:	f89d 400d 	ldrb.w	r4, [sp, #13]
 8008fb8:	b15c      	cbz	r4, 8008fd2 <drv_sd_fs_list_dir+0x42>
        res = cb(&fno, arg);
 8008fba:	47a8      	blx	r5
        if (res != FR_OK) {
 8008fbc:	4604      	mov	r4, r0
 8008fbe:	b940      	cbnz	r0, 8008fd2 <drv_sd_fs_list_dir+0x42>
        res = f_readdir(&dir, &fno);
 8008fc0:	a901      	add	r1, sp, #4
 8008fc2:	a807      	add	r0, sp, #28
 8008fc4:	f002 f9b8 	bl	800b338 <f_readdir>
 8008fc8:	4604      	mov	r4, r0
        res = cb(&fno, arg);
 8008fca:	4631      	mov	r1, r6
 8008fcc:	a801      	add	r0, sp, #4
        if (res != FR_OK || fno.fname[0] == 0) {
 8008fce:	2c00      	cmp	r4, #0
 8008fd0:	d0f0      	beq.n	8008fb4 <drv_sd_fs_list_dir+0x24>
    f_closedir(&dir);
 8008fd2:	a807      	add	r0, sp, #28
 8008fd4:	f002 f998 	bl	800b308 <f_closedir>
    return drv_sd_fs_map_result(res);
 8008fd8:	4620      	mov	r0, r4
 8008fda:	e7e7      	b.n	8008fac <drv_sd_fs_list_dir+0x1c>
        return SD_ERR_PARAM;
 8008fdc:	2007      	movs	r0, #7
}
 8008fde:	4770      	bx	lr
        return SD_ERR_PARAM;
 8008fe0:	2007      	movs	r0, #7
}
 8008fe2:	b012      	add	sp, #72	; 0x48
 8008fe4:	bd70      	pop	{r4, r5, r6, pc}
 8008fe6:	bf00      	nop
 8008fe8:	240037f1 	.word	0x240037f1

08008fec <drv_sd_fs_consume_write_protect_event>:

bool drv_sd_fs_consume_write_protect_event(void) {
    if (!fs_write_protected_event) {
 8008fec:	4b02      	ldr	r3, [pc, #8]	; (8008ff8 <drv_sd_fs_consume_write_protect_event+0xc>)
 8008fee:	7818      	ldrb	r0, [r3, #0]
 8008ff0:	b108      	cbz	r0, 8008ff6 <drv_sd_fs_consume_write_protect_event+0xa>
        return false;
    }
    fs_write_protected_event = false;
 8008ff2:	2200      	movs	r2, #0
 8008ff4:	701a      	strb	r2, [r3, #0]
    return true;
}
 8008ff6:	4770      	bx	lr
 8008ff8:	240037f3 	.word	0x240037f3

08008ffc <drv_sd_fs_is_read_only>:

bool drv_sd_fs_is_read_only(void) {
    return fs_read_only;
 8008ffc:	4b01      	ldr	r3, [pc, #4]	; (8009004 <drv_sd_fs_is_read_only+0x8>)
}
 8008ffe:	7818      	ldrb	r0, [r3, #0]
 8009000:	4770      	bx	lr
 8009002:	bf00      	nop
 8009004:	240037f2 	.word	0x240037f2

08009008 <drv_sd_hal_init>:
    .slowdown = 0U,
};
static bool sd_hal_initialized = false;
static bool sd_connected = false;

void drv_sd_hal_init(void) {
 8009008:	b510      	push	{r4, lr}
    if (!sd_hal_initialized) {
 800900a:	4c07      	ldr	r4, [pc, #28]	; (8009028 <drv_sd_hal_init+0x20>)
 800900c:	7823      	ldrb	r3, [r4, #0]
 800900e:	b103      	cbz	r3, 8009012 <drv_sd_hal_init+0xa>
        sdcObjectInit(sdcd);
        sdcStart(sdcd, &sd_cfg);
        sd_hal_initialized = true;
    }
}
 8009010:	bd10      	pop	{r4, pc}
        sdcObjectInit(sdcd);
 8009012:	4806      	ldr	r0, [pc, #24]	; (800902c <drv_sd_hal_init+0x24>)
 8009014:	f7f8 faaa 	bl	800156c <sdcObjectInit>
        sdcStart(sdcd, &sd_cfg);
 8009018:	4905      	ldr	r1, [pc, #20]	; (8009030 <drv_sd_hal_init+0x28>)
 800901a:	4804      	ldr	r0, [pc, #16]	; (800902c <drv_sd_hal_init+0x24>)
 800901c:	f7f8 fab2 	bl	8001584 <sdcStart>
        sd_hal_initialized = true;
 8009020:	2301      	movs	r3, #1
 8009022:	7023      	strb	r3, [r4, #0]
}
 8009024:	bd10      	pop	{r4, pc}
 8009026:	bf00      	nop
 8009028:	24003a25 	.word	0x24003a25
 800902c:	240009c4 	.word	0x240009c4
 8009030:	08015320 	.word	0x08015320

08009034 <drv_sd_hal_is_card_present>:
    drv_sd_hal_sync();
    sdcStop(sdcd);
}

bool drv_sd_hal_is_card_present(void) {
    return sdcIsCardInserted(sdcd) == true;
 8009034:	4801      	ldr	r0, [pc, #4]	; (800903c <drv_sd_hal_is_card_present+0x8>)
 8009036:	f7fc bddd 	b.w	8005bf4 <sdc_lld_is_card_inserted>
 800903a:	bf00      	nop
 800903c:	240009c4 	.word	0x240009c4

08009040 <drv_sd_hal_connect>:
}

sd_hal_status_t drv_sd_hal_connect(void) {
 8009040:	b510      	push	{r4, lr}
    if (sd_connected) {
 8009042:	4c0a      	ldr	r4, [pc, #40]	; (800906c <drv_sd_hal_connect+0x2c>)
 8009044:	7823      	ldrb	r3, [r4, #0]
 8009046:	b10b      	cbz	r3, 800904c <drv_sd_hal_connect+0xc>
        return SD_HAL_OK;
 8009048:	2000      	movs	r0, #0
    if (sdcConnect(sdcd) != HAL_SUCCESS) {
        return SD_HAL_ERROR;
    }
    sd_connected = true;
    return SD_HAL_OK;
}
 800904a:	bd10      	pop	{r4, pc}
    return sdcIsCardInserted(sdcd) == true;
 800904c:	4808      	ldr	r0, [pc, #32]	; (8009070 <drv_sd_hal_connect+0x30>)
 800904e:	f7fc fdd1 	bl	8005bf4 <sdc_lld_is_card_inserted>
    if (!drv_sd_hal_is_card_present()) {
 8009052:	b130      	cbz	r0, 8009062 <drv_sd_hal_connect+0x22>
    if (sdcConnect(sdcd) != HAL_SUCCESS) {
 8009054:	4806      	ldr	r0, [pc, #24]	; (8009070 <drv_sd_hal_connect+0x30>)
 8009056:	f7f8 f8d5 	bl	8001204 <sdcConnect>
 800905a:	b920      	cbnz	r0, 8009066 <drv_sd_hal_connect+0x26>
    sd_connected = true;
 800905c:	2301      	movs	r3, #1
 800905e:	7023      	strb	r3, [r4, #0]
}
 8009060:	bd10      	pop	{r4, pc}
        return SD_HAL_NO_CARD;
 8009062:	2001      	movs	r0, #1
}
 8009064:	bd10      	pop	{r4, pc}
        return SD_HAL_ERROR;
 8009066:	2002      	movs	r0, #2
}
 8009068:	bd10      	pop	{r4, pc}
 800906a:	bf00      	nop
 800906c:	24003a24 	.word	0x24003a24
 8009070:	240009c4 	.word	0x240009c4

08009074 <drv_sd_hal_disconnect>:

void drv_sd_hal_disconnect(void) {
 8009074:	b510      	push	{r4, lr}
    if (!sd_connected) {
 8009076:	4c05      	ldr	r4, [pc, #20]	; (800908c <drv_sd_hal_disconnect+0x18>)
 8009078:	7823      	ldrb	r3, [r4, #0]
 800907a:	b903      	cbnz	r3, 800907e <drv_sd_hal_disconnect+0xa>
        return;
    }
    sdcDisconnect(sdcd);
    sd_connected = false;
}
 800907c:	bd10      	pop	{r4, pc}
    sdcDisconnect(sdcd);
 800907e:	4804      	ldr	r0, [pc, #16]	; (8009090 <drv_sd_hal_disconnect+0x1c>)
 8009080:	f7f8 f8a2 	bl	80011c8 <sdcDisconnect>
    sd_connected = false;
 8009084:	2300      	movs	r3, #0
 8009086:	7023      	strb	r3, [r4, #0]
}
 8009088:	bd10      	pop	{r4, pc}
 800908a:	bf00      	nop
 800908c:	24003a24 	.word	0x24003a24
 8009090:	240009c4 	.word	0x240009c4

08009094 <drv_sd_hal_read_blocks>:
        return SD_HAL_ERROR;
    }
    return SD_HAL_ERROR;
}

sd_hal_status_t drv_sd_hal_read_blocks(uint8_t *buffer, uint32_t sector, uint32_t count) {
 8009094:	b570      	push	{r4, r5, r6, lr}
 8009096:	4605      	mov	r5, r0
    return sdcIsCardInserted(sdcd) == true;
 8009098:	480f      	ldr	r0, [pc, #60]	; (80090d8 <drv_sd_hal_read_blocks+0x44>)
sd_hal_status_t drv_sd_hal_read_blocks(uint8_t *buffer, uint32_t sector, uint32_t count) {
 800909a:	460c      	mov	r4, r1
 800909c:	4616      	mov	r6, r2
    return sdcIsCardInserted(sdcd) == true;
 800909e:	f7fc fda9 	bl	8005bf4 <sdc_lld_is_card_inserted>
    if (!drv_sd_hal_is_card_present() || !sd_connected) {
 80090a2:	b110      	cbz	r0, 80090aa <drv_sd_hal_read_blocks+0x16>
 80090a4:	4b0d      	ldr	r3, [pc, #52]	; (80090dc <drv_sd_hal_read_blocks+0x48>)
 80090a6:	781b      	ldrb	r3, [r3, #0]
 80090a8:	b90b      	cbnz	r3, 80090ae <drv_sd_hal_read_blocks+0x1a>
        return SD_HAL_NO_CARD;
 80090aa:	2001      	movs	r0, #1
    sdcflags_t errors = sdcGetAndClearErrors(sdcd);
    if ((res == HAL_SUCCESS) && (errors == SDC_NO_ERROR)) {
        return SD_HAL_OK;
    }
    return drv_sd_hal_translate(errors);
}
 80090ac:	bd70      	pop	{r4, r5, r6, pc}
    msg_t res = sdcRead(sdcd, sector, buffer, count);
 80090ae:	4633      	mov	r3, r6
 80090b0:	462a      	mov	r2, r5
 80090b2:	4621      	mov	r1, r4
 80090b4:	4808      	ldr	r0, [pc, #32]	; (80090d8 <drv_sd_hal_read_blocks+0x44>)
 80090b6:	f7f8 f849 	bl	800114c <sdcRead>
    sdcflags_t errors = sdcGetAndClearErrors(sdcd);
 80090ba:	4807      	ldr	r0, [pc, #28]	; (80090d8 <drv_sd_hal_read_blocks+0x44>)
 80090bc:	f7f8 fa70 	bl	80015a0 <sdcGetAndClearErrors>
    if (flags == SDC_NO_ERROR) {
 80090c0:	2800      	cmp	r0, #0
 80090c2:	d0f3      	beq.n	80090ac <drv_sd_hal_read_blocks+0x18>
    if ((flags & (SDC_CMD_CRC_ERROR | SDC_DATA_CRC_ERROR)) != 0U) {
 80090c4:	0783      	lsls	r3, r0, #30
 80090c6:	d105      	bne.n	80090d4 <drv_sd_hal_read_blocks+0x40>
        return SD_HAL_ERROR;
 80090c8:	f010 0f0c 	tst.w	r0, #12
 80090cc:	bf14      	ite	ne
 80090ce:	2004      	movne	r0, #4
 80090d0:	2002      	moveq	r0, #2
}
 80090d2:	bd70      	pop	{r4, r5, r6, pc}
        return SD_HAL_CRC;
 80090d4:	2003      	movs	r0, #3
}
 80090d6:	bd70      	pop	{r4, r5, r6, pc}
 80090d8:	240009c4 	.word	0x240009c4
 80090dc:	24003a24 	.word	0x24003a24

080090e0 <drv_sd_hal_write_blocks>:

sd_hal_status_t drv_sd_hal_write_blocks(const uint8_t *buffer, uint32_t sector, uint32_t count) {
 80090e0:	b570      	push	{r4, r5, r6, lr}
 80090e2:	4605      	mov	r5, r0
    return sdcIsCardInserted(sdcd) == true;
 80090e4:	480f      	ldr	r0, [pc, #60]	; (8009124 <drv_sd_hal_write_blocks+0x44>)
sd_hal_status_t drv_sd_hal_write_blocks(const uint8_t *buffer, uint32_t sector, uint32_t count) {
 80090e6:	460c      	mov	r4, r1
 80090e8:	4616      	mov	r6, r2
    return sdcIsCardInserted(sdcd) == true;
 80090ea:	f7fc fd83 	bl	8005bf4 <sdc_lld_is_card_inserted>
    if (!drv_sd_hal_is_card_present() || !sd_connected) {
 80090ee:	b110      	cbz	r0, 80090f6 <drv_sd_hal_write_blocks+0x16>
 80090f0:	4b0d      	ldr	r3, [pc, #52]	; (8009128 <drv_sd_hal_write_blocks+0x48>)
 80090f2:	781b      	ldrb	r3, [r3, #0]
 80090f4:	b90b      	cbnz	r3, 80090fa <drv_sd_hal_write_blocks+0x1a>
        return SD_HAL_NO_CARD;
 80090f6:	2001      	movs	r0, #1
    sdcflags_t errors = sdcGetAndClearErrors(sdcd);
    if ((res == HAL_SUCCESS) && (errors == SDC_NO_ERROR)) {
        return SD_HAL_OK;
    }
    return drv_sd_hal_translate(errors);
}
 80090f8:	bd70      	pop	{r4, r5, r6, pc}
    msg_t res = sdcWrite(sdcd, sector, buffer, count);
 80090fa:	4633      	mov	r3, r6
 80090fc:	462a      	mov	r2, r5
 80090fe:	4621      	mov	r1, r4
 8009100:	4808      	ldr	r0, [pc, #32]	; (8009124 <drv_sd_hal_write_blocks+0x44>)
 8009102:	f7f8 f83b 	bl	800117c <sdcWrite>
    sdcflags_t errors = sdcGetAndClearErrors(sdcd);
 8009106:	4807      	ldr	r0, [pc, #28]	; (8009124 <drv_sd_hal_write_blocks+0x44>)
 8009108:	f7f8 fa4a 	bl	80015a0 <sdcGetAndClearErrors>
    if (flags == SDC_NO_ERROR) {
 800910c:	2800      	cmp	r0, #0
 800910e:	d0f3      	beq.n	80090f8 <drv_sd_hal_write_blocks+0x18>
    if ((flags & (SDC_CMD_CRC_ERROR | SDC_DATA_CRC_ERROR)) != 0U) {
 8009110:	0783      	lsls	r3, r0, #30
 8009112:	d105      	bne.n	8009120 <drv_sd_hal_write_blocks+0x40>
        return SD_HAL_ERROR;
 8009114:	f010 0f0c 	tst.w	r0, #12
 8009118:	bf14      	ite	ne
 800911a:	2004      	movne	r0, #4
 800911c:	2002      	moveq	r0, #2
}
 800911e:	bd70      	pop	{r4, r5, r6, pc}
        return SD_HAL_CRC;
 8009120:	2003      	movs	r0, #3
}
 8009122:	bd70      	pop	{r4, r5, r6, pc}
 8009124:	240009c4 	.word	0x240009c4
 8009128:	24003a24 	.word	0x24003a24

0800912c <drv_sd_hal_sync>:

void drv_sd_hal_sync(void) {
    (void)sdcSync(sdcd);
 800912c:	4801      	ldr	r0, [pc, #4]	; (8009134 <drv_sd_hal_sync+0x8>)
 800912e:	f7f8 b83d 	b.w	80011ac <sdcSync>
 8009132:	bf00      	nop
 8009134:	240009c4 	.word	0x240009c4

08009138 <drv_sd_hal_get_info>:
}

sd_hal_status_t drv_sd_hal_get_info(BlockDeviceInfo *info) {
    if (info == NULL) {
 8009138:	b188      	cbz	r0, 800915e <drv_sd_hal_get_info+0x26>
sd_hal_status_t drv_sd_hal_get_info(BlockDeviceInfo *info) {
 800913a:	b510      	push	{r4, lr}
 800913c:	4604      	mov	r4, r0
    return sdcIsCardInserted(sdcd) == true;
 800913e:	4809      	ldr	r0, [pc, #36]	; (8009164 <drv_sd_hal_get_info+0x2c>)
 8009140:	f7fc fd58 	bl	8005bf4 <sdc_lld_is_card_inserted>
        return SD_HAL_ERROR;
    }
    if (!drv_sd_hal_is_card_present() || !sd_connected) {
 8009144:	b110      	cbz	r0, 800914c <drv_sd_hal_get_info+0x14>
 8009146:	4b08      	ldr	r3, [pc, #32]	; (8009168 <drv_sd_hal_get_info+0x30>)
 8009148:	781b      	ldrb	r3, [r3, #0]
 800914a:	b90b      	cbnz	r3, 8009150 <drv_sd_hal_get_info+0x18>
        return SD_HAL_NO_CARD;
 800914c:	2001      	movs	r0, #1
    }
    if (sdcGetInfo(sdcd, info) != HAL_SUCCESS) {
        return SD_HAL_ERROR;
    }
    return SD_HAL_OK;
}
 800914e:	bd10      	pop	{r4, pc}
    if (sdcGetInfo(sdcd, info) != HAL_SUCCESS) {
 8009150:	4621      	mov	r1, r4
 8009152:	4804      	ldr	r0, [pc, #16]	; (8009164 <drv_sd_hal_get_info+0x2c>)
 8009154:	f7f7 ffc6 	bl	80010e4 <sdcGetInfo>
 8009158:	0040      	lsls	r0, r0, #1
 800915a:	b2c0      	uxtb	r0, r0
}
 800915c:	bd10      	pop	{r4, pc}
        return SD_HAL_ERROR;
 800915e:	2002      	movs	r0, #2
}
 8009160:	4770      	bx	lr
 8009162:	bf00      	nop
 8009164:	240009c4 	.word	0x240009c4
 8009168:	24003a24 	.word	0x24003a24

0800916c <build_project_path>:
        }
    }
    return ~crc;
}

static bool build_project_path(char *dst, const char *project_name, const char *suffix) {
 800916c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    const char prefix[] = "/projects/";
 8009170:	4d1d      	ldr	r5, [pc, #116]	; (80091e8 <build_project_path+0x7c>)
static bool build_project_path(char *dst, const char *project_name, const char *suffix) {
 8009172:	b084      	sub	sp, #16
 8009174:	4688      	mov	r8, r1
 8009176:	4617      	mov	r7, r2
 8009178:	4604      	mov	r4, r0
    const char prefix[] = "/projects/";
 800917a:	ab01      	add	r3, sp, #4
 800917c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8009180:	c303      	stmia	r3!, {r0, r1}
 8009182:	f823 2b02 	strh.w	r2, [r3], #2
 8009186:	0c12      	lsrs	r2, r2, #16
    size_t prefix_len = sizeof(prefix) - 1U;
    size_t name_len = strlen(project_name);
 8009188:	4640      	mov	r0, r8
    const char prefix[] = "/projects/";
 800918a:	701a      	strb	r2, [r3, #0]
    size_t name_len = strlen(project_name);
 800918c:	f7f7 fb98 	bl	80008c0 <strlen>
 8009190:	4605      	mov	r5, r0
    size_t suffix_len = (suffix != NULL) ? strlen(suffix) : 0U;
 8009192:	4638      	mov	r0, r7
 8009194:	f7f7 fb94 	bl	80008c0 <strlen>
    size_t total = prefix_len + name_len + suffix_len;
 8009198:	f105 0a0a 	add.w	sl, r5, #10
 800919c:	eb0a 0900 	add.w	r9, sl, r0
    if (name_len == 0U || total >= SD_PATH_MAX) {
 80091a0:	b1bd      	cbz	r5, 80091d2 <build_project_path+0x66>
 80091a2:	f1b9 0f9f 	cmp.w	r9, #159	; 0x9f
 80091a6:	d814      	bhi.n	80091d2 <build_project_path+0x66>
        return false;
    }
    memcpy(dst, prefix, prefix_len);
 80091a8:	ab01      	add	r3, sp, #4
 80091aa:	4606      	mov	r6, r0
    memcpy(dst + prefix_len, project_name, name_len);
 80091ac:	462a      	mov	r2, r5
    memcpy(dst, prefix, prefix_len);
 80091ae:	cb03      	ldmia	r3!, {r0, r1}
 80091b0:	881b      	ldrh	r3, [r3, #0]
 80091b2:	6020      	str	r0, [r4, #0]
    memcpy(dst + prefix_len, project_name, name_len);
 80091b4:	f104 000a 	add.w	r0, r4, #10
    memcpy(dst, prefix, prefix_len);
 80091b8:	6061      	str	r1, [r4, #4]
    memcpy(dst + prefix_len, project_name, name_len);
 80091ba:	4641      	mov	r1, r8
    memcpy(dst, prefix, prefix_len);
 80091bc:	8123      	strh	r3, [r4, #8]
    memcpy(dst + prefix_len, project_name, name_len);
 80091be:	f7f7 fadd 	bl	800077c <memcpy>
    if (suffix_len > 0U) {
 80091c2:	b956      	cbnz	r6, 80091da <build_project_path+0x6e>
        memcpy(dst + prefix_len + name_len, suffix, suffix_len);
    }
    dst[total] = '\0';
 80091c4:	2300      	movs	r3, #0
    return true;
 80091c6:	2001      	movs	r0, #1
    dst[total] = '\0';
 80091c8:	f804 3009 	strb.w	r3, [r4, r9]
}
 80091cc:	b004      	add	sp, #16
 80091ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return false;
 80091d2:	2000      	movs	r0, #0
}
 80091d4:	b004      	add	sp, #16
 80091d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        memcpy(dst + prefix_len + name_len, suffix, suffix_len);
 80091da:	4632      	mov	r2, r6
 80091dc:	4639      	mov	r1, r7
 80091de:	eb04 000a 	add.w	r0, r4, sl
 80091e2:	f7f7 facb 	bl	800077c <memcpy>
 80091e6:	e7ed      	b.n	80091c4 <build_project_path+0x58>
 80091e8:	08015328 	.word	0x08015328

080091ec <build_pattern_path>:

static bool build_pattern_path(char *dst, const char *project_name, const char *pattern_name) {
 80091ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    const char pattern_dir[] = "/patterns/";
 80091f0:	4d1e      	ldr	r5, [pc, #120]	; (800926c <build_pattern_path+0x80>)
static bool build_pattern_path(char *dst, const char *project_name, const char *pattern_name) {
 80091f2:	b084      	sub	sp, #16
 80091f4:	460f      	mov	r7, r1
 80091f6:	4604      	mov	r4, r0
    const char pattern_dir[] = "/patterns/";
 80091f8:	ab01      	add	r3, sp, #4
static bool build_pattern_path(char *dst, const char *project_name, const char *pattern_name) {
 80091fa:	4616      	mov	r6, r2
    const char pattern_dir[] = "/patterns/";
 80091fc:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8009200:	c303      	stmia	r3!, {r0, r1}
 8009202:	f823 2b02 	strh.w	r2, [r3], #2
 8009206:	0c12      	lsrs	r2, r2, #16
    const char ext[] = ".pat";
    if (!build_project_path(dst, project_name, pattern_dir)) {
 8009208:	4639      	mov	r1, r7
 800920a:	4620      	mov	r0, r4
    const char pattern_dir[] = "/patterns/";
 800920c:	701a      	strb	r2, [r3, #0]
    if (!build_project_path(dst, project_name, pattern_dir)) {
 800920e:	aa01      	add	r2, sp, #4
 8009210:	f7ff ffac 	bl	800916c <build_project_path>
 8009214:	4605      	mov	r5, r0
 8009216:	b1f8      	cbz	r0, 8009258 <build_pattern_path+0x6c>
        return false;
    }
    size_t base_len = strlen(dst);
 8009218:	4620      	mov	r0, r4
 800921a:	f7f7 fb51 	bl	80008c0 <strlen>
 800921e:	4607      	mov	r7, r0
    size_t pattern_len = strlen(pattern_name);
 8009220:	4630      	mov	r0, r6
 8009222:	f7f7 fb4d 	bl	80008c0 <strlen>
    size_t total = base_len + pattern_len + (sizeof(ext) - 1U);
 8009226:	eb07 0800 	add.w	r8, r7, r0
 800922a:	f108 0904 	add.w	r9, r8, #4
    if (pattern_len == 0U || total >= SD_PATH_MAX) {
 800922e:	b1b8      	cbz	r0, 8009260 <build_pattern_path+0x74>
 8009230:	f1b9 0f9f 	cmp.w	r9, #159	; 0x9f
 8009234:	bf94      	ite	ls
 8009236:	f04f 0a00 	movls.w	sl, #0
 800923a:	f04f 0a01 	movhi.w	sl, #1
 800923e:	f1ba 0f00 	cmp.w	sl, #0
 8009242:	d10d      	bne.n	8009260 <build_pattern_path+0x74>
        return false;
    }
    memcpy(dst + base_len, pattern_name, pattern_len);
 8009244:	4602      	mov	r2, r0
 8009246:	4631      	mov	r1, r6
 8009248:	19e0      	adds	r0, r4, r7
 800924a:	f7f7 fa97 	bl	800077c <memcpy>
    memcpy(dst + base_len + pattern_len, ext, sizeof(ext) - 1U);
 800924e:	4b08      	ldr	r3, [pc, #32]	; (8009270 <build_pattern_path+0x84>)
 8009250:	f844 3008 	str.w	r3, [r4, r8]
    dst[total] = '\0';
 8009254:	f804 a009 	strb.w	sl, [r4, r9]
    return true;
}
 8009258:	4628      	mov	r0, r5
 800925a:	b004      	add	sp, #16
 800925c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return false;
 8009260:	2500      	movs	r5, #0
}
 8009262:	4628      	mov	r0, r5
 8009264:	b004      	add	sp, #16
 8009266:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800926a:	bf00      	nop
 800926c:	08015334 	.word	0x08015334
 8009270:	7461702e 	.word	0x7461702e

08009274 <list_projects_cb>:
        *loaded_size = header.size_bytes;
    }
    return SD_OK;
}

static FRESULT list_projects_cb(FILINFO *info, void *arg) {
 8009274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009276:	7a03      	ldrb	r3, [r0, #8]
    project_list_ctx_t *params = (project_list_ctx_t *)arg;
    if (!(info->fattrib & AM_DIR)) {
 8009278:	f013 0310 	ands.w	r3, r3, #16
 800927c:	d01c      	beq.n	80092b8 <list_projects_cb+0x44>
        return FR_OK;
    }
    if (info->fname[0] == '.') {
 800927e:	7a43      	ldrb	r3, [r0, #9]
 8009280:	2b2e      	cmp	r3, #46	; 0x2e
 8009282:	d01e      	beq.n	80092c2 <list_projects_cb+0x4e>
 8009284:	460c      	mov	r4, r1
        return FR_OK;
    }
    if (*(params->listed) >= params->max_projects) {
 8009286:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
 800928a:	681b      	ldr	r3, [r3, #0]
 800928c:	4293      	cmp	r3, r2
 800928e:	d215      	bcs.n	80092bc <list_projects_cb+0x48>
        return FR_EXIST; /* stop iteration */
    }
    sd_project_info_t *dst = &params->projects[*(params->listed)];
 8009290:	eb03 1303 	add.w	r3, r3, r3, lsl #4
 8009294:	680e      	ldr	r6, [r1, #0]
    strncpy(dst->name, info->fname, SD_MAX_NAME_LEN - 1U);
 8009296:	223f      	movs	r2, #63	; 0x3f
 8009298:	f100 0109 	add.w	r1, r0, #9
    sd_project_info_t *dst = &params->projects[*(params->listed)];
 800929c:	eb06 0783 	add.w	r7, r6, r3, lsl #2
 80092a0:	009d      	lsls	r5, r3, #2
    strncpy(dst->name, info->fname, SD_MAX_NAME_LEN - 1U);
 80092a2:	1d38      	adds	r0, r7, #4
 80092a4:	f005 fb56 	bl	800e954 <strncpy>
    dst->name[SD_MAX_NAME_LEN - 1U] = '\0';
 80092a8:	2300      	movs	r3, #0
 80092aa:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    dst->generation = 0U;
    (*(params->listed))++;
 80092ae:	68a1      	ldr	r1, [r4, #8]
    dst->generation = 0U;
 80092b0:	5173      	str	r3, [r6, r5]
    (*(params->listed))++;
 80092b2:	680a      	ldr	r2, [r1, #0]
 80092b4:	3201      	adds	r2, #1
 80092b6:	600a      	str	r2, [r1, #0]
    return FR_OK;
}
 80092b8:	4618      	mov	r0, r3
 80092ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return FR_EXIST; /* stop iteration */
 80092bc:	2308      	movs	r3, #8
}
 80092be:	4618      	mov	r0, r3
 80092c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return FR_OK;
 80092c2:	2300      	movs	r3, #0
}
 80092c4:	4618      	mov	r0, r3
 80092c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080092c8 <drv_sd_project_load_pattern>:
                                       uint32_t   *generation) {
 80092c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80092cc:	f5ad 7d35 	sub.w	sp, sp, #724	; 0x2d4
    if (project_name == NULL || pattern_name == NULL || buffer == NULL || buffer_size == 0U) {
 80092d0:	2800      	cmp	r0, #0
 80092d2:	d06f      	beq.n	80093b4 <drv_sd_project_load_pattern+0xec>
 80092d4:	460d      	mov	r5, r1
 80092d6:	2900      	cmp	r1, #0
 80092d8:	d06c      	beq.n	80093b4 <drv_sd_project_load_pattern+0xec>
 80092da:	4617      	mov	r7, r2
 80092dc:	2a00      	cmp	r2, #0
 80092de:	d069      	beq.n	80093b4 <drv_sd_project_load_pattern+0xec>
 80092e0:	461e      	mov	r6, r3
 80092e2:	2b00      	cmp	r3, #0
 80092e4:	d066      	beq.n	80093b4 <drv_sd_project_load_pattern+0xec>
    if (!drv_sd_fs_is_mounted()) {
 80092e6:	4604      	mov	r4, r0
 80092e8:	f7ff fd9c 	bl	8008e24 <drv_sd_fs_is_mounted>
 80092ec:	2800      	cmp	r0, #0
 80092ee:	d067      	beq.n	80093c0 <drv_sd_project_load_pattern+0xf8>
    if (!build_pattern_path(path, project_name, pattern_name)) {
 80092f0:	462a      	mov	r2, r5
 80092f2:	4621      	mov	r1, r4
 80092f4:	a801      	add	r0, sp, #4
 80092f6:	f7ff ff79 	bl	80091ec <build_pattern_path>
 80092fa:	2800      	cmp	r0, #0
 80092fc:	d05a      	beq.n	80093b4 <drv_sd_project_load_pattern+0xec>
    sd_error_t err = drv_sd_fs_open(&file, path, FA_READ);
 80092fe:	2201      	movs	r2, #1
 8009300:	a901      	add	r1, sp, #4
 8009302:	a829      	add	r0, sp, #164	; 0xa4
 8009304:	f7ff fd94 	bl	8008e30 <drv_sd_fs_open>
 8009308:	4604      	mov	r4, r0
    if (err != SD_OK) {
 800930a:	2800      	cmp	r0, #0
 800930c:	d153      	bne.n	80093b6 <drv_sd_project_load_pattern+0xee>
    err = drv_sd_fs_read(&file, sd_io_buffer, sizeof(header), &br);
 800930e:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 80093f4 <drv_sd_project_load_pattern+0x12c>
 8009312:	466b      	mov	r3, sp
    UINT br = 0;
 8009314:	9000      	str	r0, [sp, #0]
    err = drv_sd_fs_read(&file, sd_io_buffer, sizeof(header), &br);
 8009316:	2214      	movs	r2, #20
 8009318:	4649      	mov	r1, r9
 800931a:	a829      	add	r0, sp, #164	; 0xa4
 800931c:	f7ff fdba 	bl	8008e94 <drv_sd_fs_read>
    if (err != SD_OK || br != sizeof(header)) {
 8009320:	2800      	cmp	r0, #0
 8009322:	d153      	bne.n	80093cc <drv_sd_project_load_pattern+0x104>
 8009324:	9b00      	ldr	r3, [sp, #0]
 8009326:	2b14      	cmp	r3, #20
 8009328:	d150      	bne.n	80093cc <drv_sd_project_load_pattern+0x104>
    if (header.magic != SD_PATTERN_MAGIC || header.version != SD_PATTERN_VERSION || header.size_bytes > buffer_size) {
 800932a:	4b31      	ldr	r3, [pc, #196]	; (80093f0 <drv_sd_project_load_pattern+0x128>)
    memcpy(&header, sd_io_buffer, sizeof(header));
 800932c:	f8d9 5008 	ldr.w	r5, [r9, #8]
    if (header.magic != SD_PATTERN_MAGIC || header.version != SD_PATTERN_VERSION || header.size_bytes > buffer_size) {
 8009330:	e9d9 2100 	ldrd	r2, r1, [r9]
 8009334:	429a      	cmp	r2, r3
 8009336:	bf08      	it	eq
 8009338:	f1b1 1f01 	cmpeq.w	r1, #65537	; 0x10001
 800933c:	d146      	bne.n	80093cc <drv_sd_project_load_pattern+0x104>
 800933e:	42ae      	cmp	r6, r5
 8009340:	d344      	bcc.n	80093cc <drv_sd_project_load_pattern+0x104>
    if (header.size_bytes > SD_MAX_SAMPLE_CHUNK) {
 8009342:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
    memcpy(&header, sd_io_buffer, sizeof(header));
 8009346:	e9d9 8603 	ldrd	r8, r6, [r9, #12]
    if (header.size_bytes > SD_MAX_SAMPLE_CHUNK) {
 800934a:	d846      	bhi.n	80093da <drv_sd_project_load_pattern+0x112>
    err = drv_sd_fs_read(&file, sd_io_buffer, (UINT)header.size_bytes, &br);
 800934c:	466b      	mov	r3, sp
 800934e:	462a      	mov	r2, r5
 8009350:	4928      	ldr	r1, [pc, #160]	; (80093f4 <drv_sd_project_load_pattern+0x12c>)
 8009352:	a829      	add	r0, sp, #164	; 0xa4
 8009354:	f7ff fd9e 	bl	8008e94 <drv_sd_fs_read>
 8009358:	4604      	mov	r4, r0
    drv_sd_fs_close(&file);
 800935a:	a829      	add	r0, sp, #164	; 0xa4
 800935c:	f7ff fd8c 	bl	8008e78 <drv_sd_fs_close>
    if (err != SD_OK || br != header.size_bytes) {
 8009360:	2c00      	cmp	r4, #0
 8009362:	d138      	bne.n	80093d6 <drv_sd_project_load_pattern+0x10e>
 8009364:	9b00      	ldr	r3, [sp, #0]
 8009366:	42ab      	cmp	r3, r5
 8009368:	d135      	bne.n	80093d6 <drv_sd_project_load_pattern+0x10e>
    memcpy(buffer, sd_io_buffer, header.size_bytes);
 800936a:	4638      	mov	r0, r7
 800936c:	462a      	mov	r2, r5
 800936e:	4921      	ldr	r1, [pc, #132]	; (80093f4 <drv_sd_project_load_pattern+0x12c>)
 8009370:	f7f7 fa04 	bl	800077c <memcpy>
    for (size_t i = 0; i < len; ++i) {
 8009374:	b3c5      	cbz	r5, 80093e8 <drv_sd_project_load_pattern+0x120>
 8009376:	44a9      	add	r9, r5
 8009378:	4f1e      	ldr	r7, [pc, #120]	; (80093f4 <drv_sd_project_load_pattern+0x12c>)
    crc = ~crc;
 800937a:	f04f 32ff 	mov.w	r2, #4294967295
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 800937e:	481e      	ldr	r0, [pc, #120]	; (80093f8 <drv_sd_project_load_pattern+0x130>)
        crc ^= data[i];
 8009380:	f817 3b01 	ldrb.w	r3, [r7], #1
 8009384:	405a      	eors	r2, r3
 8009386:	2308      	movs	r3, #8
            uint32_t mask = (uint32_t)(-(int32_t)(crc & 1U));
 8009388:	f342 0100 	sbfx	r1, r2, #0, #1
        for (uint8_t b = 0; b < 8U; ++b) {
 800938c:	3b01      	subs	r3, #1
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 800938e:	4001      	ands	r1, r0
        for (uint8_t b = 0; b < 8U; ++b) {
 8009390:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 8009394:	ea81 0252 	eor.w	r2, r1, r2, lsr #1
        for (uint8_t b = 0; b < 8U; ++b) {
 8009398:	d1f6      	bne.n	8009388 <drv_sd_project_load_pattern+0xc0>
    for (size_t i = 0; i < len; ++i) {
 800939a:	45b9      	cmp	r9, r7
 800939c:	d1f0      	bne.n	8009380 <drv_sd_project_load_pattern+0xb8>
    return ~crc;
 800939e:	43d2      	mvns	r2, r2
    if (crc != header.crc32) {
 80093a0:	4296      	cmp	r6, r2
 80093a2:	d11f      	bne.n	80093e4 <drv_sd_project_load_pattern+0x11c>
    if (loaded_size != NULL) {
 80093a4:	9bbc      	ldr	r3, [sp, #752]	; 0x2f0
 80093a6:	b103      	cbz	r3, 80093aa <drv_sd_project_load_pattern+0xe2>
        *loaded_size = header.size_bytes;
 80093a8:	601d      	str	r5, [r3, #0]
    if (generation != NULL) {
 80093aa:	9bbd      	ldr	r3, [sp, #756]	; 0x2f4
 80093ac:	b11b      	cbz	r3, 80093b6 <drv_sd_project_load_pattern+0xee>
        *generation = header.generation;
 80093ae:	f8c3 8000 	str.w	r8, [r3]
 80093b2:	e000      	b.n	80093b6 <drv_sd_project_load_pattern+0xee>
        return SD_ERR_PARAM;
 80093b4:	2407      	movs	r4, #7
}
 80093b6:	4620      	mov	r0, r4
 80093b8:	f50d 7d35 	add.w	sp, sp, #724	; 0x2d4
 80093bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return SD_ERR_NOT_MOUNTED;
 80093c0:	2402      	movs	r4, #2
}
 80093c2:	4620      	mov	r0, r4
 80093c4:	f50d 7d35 	add.w	sp, sp, #724	; 0x2d4
 80093c8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        drv_sd_fs_close(&file);
 80093cc:	a829      	add	r0, sp, #164	; 0xa4
        return SD_ERR_CORRUPTED;
 80093ce:	2409      	movs	r4, #9
        drv_sd_fs_close(&file);
 80093d0:	f7ff fd52 	bl	8008e78 <drv_sd_fs_close>
        return SD_ERR_CORRUPTED;
 80093d4:	e7ef      	b.n	80093b6 <drv_sd_project_load_pattern+0xee>
        return SD_ERR_IO;
 80093d6:	2404      	movs	r4, #4
 80093d8:	e7ed      	b.n	80093b6 <drv_sd_project_load_pattern+0xee>
        drv_sd_fs_close(&file);
 80093da:	a829      	add	r0, sp, #164	; 0xa4
        return SD_ERR_PARAM;
 80093dc:	2407      	movs	r4, #7
        drv_sd_fs_close(&file);
 80093de:	f7ff fd4b 	bl	8008e78 <drv_sd_fs_close>
        return SD_ERR_PARAM;
 80093e2:	e7e8      	b.n	80093b6 <drv_sd_project_load_pattern+0xee>
        return SD_ERR_CRC;
 80093e4:	2405      	movs	r4, #5
 80093e6:	e7e6      	b.n	80093b6 <drv_sd_project_load_pattern+0xee>
    crc = ~crc;
 80093e8:	f04f 32ff 	mov.w	r2, #4294967295
 80093ec:	e7d7      	b.n	800939e <drv_sd_project_load_pattern+0xd6>
 80093ee:	bf00      	nop
 80093f0:	42525450 	.word	0x42525450
 80093f4:	30001360 	.word	0x30001360
 80093f8:	edb88320 	.word	0xedb88320

080093fc <drv_sd_project_save_pattern>:
                                       uint32_t generation) {
 80093fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009400:	f5ad 7d5c 	sub.w	sp, sp, #880	; 0x370
    if (project_name == NULL || pattern_name == NULL || data == NULL || data_size == 0U || data_size > SD_MAX_PATTERN_SIZE) {
 8009404:	b388      	cbz	r0, 800946a <drv_sd_project_save_pattern+0x6e>
 8009406:	460f      	mov	r7, r1
 8009408:	b379      	cbz	r1, 800946a <drv_sd_project_save_pattern+0x6e>
 800940a:	461d      	mov	r5, r3
 800940c:	3b01      	subs	r3, #1
 800940e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009412:	d22a      	bcs.n	800946a <drv_sd_project_save_pattern+0x6e>
 8009414:	fab2 f882 	clz	r8, r2
 8009418:	4616      	mov	r6, r2
 800941a:	ea4f 1858 	mov.w	r8, r8, lsr #5
 800941e:	b322      	cbz	r2, 800946a <drv_sd_project_save_pattern+0x6e>
    if (!drv_sd_fs_is_mounted()) {
 8009420:	4604      	mov	r4, r0
 8009422:	f7ff fcff 	bl	8008e24 <drv_sd_fs_is_mounted>
 8009426:	2800      	cmp	r0, #0
 8009428:	f000 8087 	beq.w	800953a <drv_sd_project_save_pattern+0x13e>
    if (!build_project_path(path, project_name, "")) {
 800942c:	4a4a      	ldr	r2, [pc, #296]	; (8009558 <drv_sd_project_save_pattern+0x15c>)
 800942e:	4621      	mov	r1, r4
 8009430:	a851      	add	r0, sp, #324	; 0x144
 8009432:	f7ff fe9b 	bl	800916c <build_project_path>
 8009436:	b1c0      	cbz	r0, 800946a <drv_sd_project_save_pattern+0x6e>
    (void)drv_sd_fs_mkdir(path);
 8009438:	a851      	add	r0, sp, #324	; 0x144
 800943a:	f7ff fd93 	bl	8008f64 <drv_sd_fs_mkdir>
    if (!build_project_path(path, project_name, "/patterns")) {
 800943e:	4a47      	ldr	r2, [pc, #284]	; (800955c <drv_sd_project_save_pattern+0x160>)
 8009440:	4621      	mov	r1, r4
 8009442:	a851      	add	r0, sp, #324	; 0x144
 8009444:	f7ff fe92 	bl	800916c <build_project_path>
 8009448:	b178      	cbz	r0, 800946a <drv_sd_project_save_pattern+0x6e>
    (void)drv_sd_fs_mkdir(path);
 800944a:	a851      	add	r0, sp, #324	; 0x144
 800944c:	f7ff fd8a 	bl	8008f64 <drv_sd_fs_mkdir>
    if (!build_pattern_path(path_final, project_name, pattern_name)) {
 8009450:	463a      	mov	r2, r7
 8009452:	4621      	mov	r1, r4
 8009454:	a801      	add	r0, sp, #4
 8009456:	f7ff fec9 	bl	80091ec <build_pattern_path>
 800945a:	b130      	cbz	r0, 800946a <drv_sd_project_save_pattern+0x6e>
    size_t src_len = strlen(src);
 800945c:	a801      	add	r0, sp, #4
 800945e:	f7f7 fa2f 	bl	80008c0 <strlen>
    size_t total = src_len + (sizeof(tmp_suffix) - 1U);
 8009462:	1d07      	adds	r7, r0, #4
    size_t src_len = strlen(src);
 8009464:	4604      	mov	r4, r0
    if (total >= SD_PATH_MAX) {
 8009466:	2f9f      	cmp	r7, #159	; 0x9f
 8009468:	d905      	bls.n	8009476 <drv_sd_project_save_pattern+0x7a>
        return SD_ERR_PARAM;
 800946a:	2407      	movs	r4, #7
}
 800946c:	4620      	mov	r0, r4
 800946e:	f50d 7d5c 	add.w	sp, sp, #880	; 0x370
 8009472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    memcpy(dst, src, src_len);
 8009476:	4602      	mov	r2, r0
 8009478:	a901      	add	r1, sp, #4
 800947a:	a829      	add	r0, sp, #164	; 0xa4
 800947c:	f7f7 f97e 	bl	800077c <memcpy>
    memcpy(dst + src_len, tmp_suffix, sizeof(tmp_suffix) - 1U);
 8009480:	aa29      	add	r2, sp, #164	; 0xa4
 8009482:	4b37      	ldr	r3, [pc, #220]	; (8009560 <drv_sd_project_save_pattern+0x164>)
    sd_error_t err = drv_sd_fs_open(&file, path_tmp, FA_WRITE | FA_CREATE_ALWAYS);
 8009484:	a851      	add	r0, sp, #324	; 0x144
    memcpy(dst + src_len, tmp_suffix, sizeof(tmp_suffix) - 1U);
 8009486:	5113      	str	r3, [r2, r4]
    dst[total] = '\0';
 8009488:	4613      	mov	r3, r2
 800948a:	f802 8007 	strb.w	r8, [r2, r7]
    sd_error_t err = drv_sd_fs_open(&file, path_tmp, FA_WRITE | FA_CREATE_ALWAYS);
 800948e:	220a      	movs	r2, #10
 8009490:	4619      	mov	r1, r3
 8009492:	f7ff fccd 	bl	8008e30 <drv_sd_fs_open>
    if (err != SD_OK) {
 8009496:	4604      	mov	r4, r0
 8009498:	2800      	cmp	r0, #0
 800949a:	d1e7      	bne.n	800946c <drv_sd_project_save_pattern+0x70>
    memcpy(sd_io_buffer, data, data_size);
 800949c:	4f31      	ldr	r7, [pc, #196]	; (8009564 <drv_sd_project_save_pattern+0x168>)
 800949e:	4631      	mov	r1, r6
 80094a0:	462a      	mov	r2, r5
 80094a2:	4830      	ldr	r0, [pc, #192]	; (8009564 <drv_sd_project_save_pattern+0x168>)
 80094a4:	f7f7 f96a 	bl	800077c <memcpy>
    for (size_t i = 0; i < len; ++i) {
 80094a8:	463e      	mov	r6, r7
    crc = ~crc;
 80094aa:	f04f 30ff 	mov.w	r0, #4294967295
    for (size_t i = 0; i < len; ++i) {
 80094ae:	2200      	movs	r2, #0
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 80094b0:	4b2d      	ldr	r3, [pc, #180]	; (8009568 <drv_sd_project_save_pattern+0x16c>)
        crc ^= data[i];
 80094b2:	f816 1b01 	ldrb.w	r1, [r6], #1
 80094b6:	2408      	movs	r4, #8
 80094b8:	4048      	eors	r0, r1
            uint32_t mask = (uint32_t)(-(int32_t)(crc & 1U));
 80094ba:	f340 0100 	sbfx	r1, r0, #0, #1
        for (uint8_t b = 0; b < 8U; ++b) {
 80094be:	f104 3cff 	add.w	ip, r4, #4294967295
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 80094c2:	4019      	ands	r1, r3
        for (uint8_t b = 0; b < 8U; ++b) {
 80094c4:	f01c 04ff 	ands.w	r4, ip, #255	; 0xff
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 80094c8:	ea81 0050 	eor.w	r0, r1, r0, lsr #1
        for (uint8_t b = 0; b < 8U; ++b) {
 80094cc:	d1f5      	bne.n	80094ba <drv_sd_project_save_pattern+0xbe>
    for (size_t i = 0; i < len; ++i) {
 80094ce:	3201      	adds	r2, #1
 80094d0:	4295      	cmp	r5, r2
 80094d2:	d8ee      	bhi.n	80094b2 <drv_sd_project_save_pattern+0xb6>
    memcpy(sd_io_buffer, &header, sizeof(header));
 80094d4:	9be2      	ldr	r3, [sp, #904]	; 0x388
    return ~crc;
 80094d6:	43c0      	mvns	r0, r0
    memcpy(sd_io_buffer, &header, sizeof(header));
 80094d8:	4a24      	ldr	r2, [pc, #144]	; (800956c <drv_sd_project_save_pattern+0x170>)
 80094da:	60fb      	str	r3, [r7, #12]
 80094dc:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80094e0:	6138      	str	r0, [r7, #16]
    err = drv_sd_fs_write(&file, sd_io_buffer, sizeof(header), &bw);
 80094e2:	a851      	add	r0, sp, #324	; 0x144
 80094e4:	491f      	ldr	r1, [pc, #124]	; (8009564 <drv_sd_project_save_pattern+0x168>)
    memcpy(sd_io_buffer, &header, sizeof(header));
 80094e6:	60bd      	str	r5, [r7, #8]
    UINT bw = 0;
 80094e8:	9400      	str	r4, [sp, #0]
    memcpy(sd_io_buffer, &header, sizeof(header));
 80094ea:	e9c7 2300 	strd	r2, r3, [r7]
    err = drv_sd_fs_write(&file, sd_io_buffer, sizeof(header), &bw);
 80094ee:	466b      	mov	r3, sp
 80094f0:	2214      	movs	r2, #20
 80094f2:	f7ff fcdf 	bl	8008eb4 <drv_sd_fs_write>
    if (err != SD_OK || bw != sizeof(header)) {
 80094f6:	bb30      	cbnz	r0, 8009546 <drv_sd_project_save_pattern+0x14a>
 80094f8:	9b00      	ldr	r3, [sp, #0]
 80094fa:	2b14      	cmp	r3, #20
 80094fc:	d123      	bne.n	8009546 <drv_sd_project_save_pattern+0x14a>
    err = drv_sd_fs_write(&file, sd_io_buffer, (UINT)data_size, &bw);
 80094fe:	466b      	mov	r3, sp
 8009500:	462a      	mov	r2, r5
 8009502:	4918      	ldr	r1, [pc, #96]	; (8009564 <drv_sd_project_save_pattern+0x168>)
 8009504:	a851      	add	r0, sp, #324	; 0x144
    bw = 0;
 8009506:	9400      	str	r4, [sp, #0]
    err = drv_sd_fs_write(&file, sd_io_buffer, (UINT)data_size, &bw);
 8009508:	f7ff fcd4 	bl	8008eb4 <drv_sd_fs_write>
    if (err != SD_OK || bw != data_size) {
 800950c:	b9d8      	cbnz	r0, 8009546 <drv_sd_project_save_pattern+0x14a>
 800950e:	9b00      	ldr	r3, [sp, #0]
 8009510:	42ab      	cmp	r3, r5
 8009512:	d118      	bne.n	8009546 <drv_sd_project_save_pattern+0x14a>
    err = drv_sd_fs_sync(&file);
 8009514:	a851      	add	r0, sp, #324	; 0x144
 8009516:	f7ff fce1 	bl	8008edc <drv_sd_fs_sync>
 800951a:	4604      	mov	r4, r0
    drv_sd_fs_close(&file);
 800951c:	a851      	add	r0, sp, #324	; 0x144
 800951e:	f7ff fcab 	bl	8008e78 <drv_sd_fs_close>
    if (err != SD_OK) {
 8009522:	b934      	cbnz	r4, 8009532 <drv_sd_project_save_pattern+0x136>
    err = drv_sd_fs_rename(path_tmp, path_final);
 8009524:	a901      	add	r1, sp, #4
 8009526:	a829      	add	r0, sp, #164	; 0xa4
 8009528:	f7ff fcf0 	bl	8008f0c <drv_sd_fs_rename>
    if (err != SD_OK) {
 800952c:	4604      	mov	r4, r0
 800952e:	2800      	cmp	r0, #0
 8009530:	d09c      	beq.n	800946c <drv_sd_project_save_pattern+0x70>
        drv_sd_fs_delete(path_tmp);
 8009532:	a829      	add	r0, sp, #164	; 0xa4
 8009534:	f7ff fd00 	bl	8008f38 <drv_sd_fs_delete>
        return err;
 8009538:	e798      	b.n	800946c <drv_sd_project_save_pattern+0x70>
        return SD_ERR_NOT_MOUNTED;
 800953a:	2402      	movs	r4, #2
}
 800953c:	4620      	mov	r0, r4
 800953e:	f50d 7d5c 	add.w	sp, sp, #880	; 0x370
 8009542:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        drv_sd_fs_close(&file);
 8009546:	a851      	add	r0, sp, #324	; 0x144
        return SD_ERR_IO;
 8009548:	2404      	movs	r4, #4
        drv_sd_fs_close(&file);
 800954a:	f7ff fc95 	bl	8008e78 <drv_sd_fs_close>
        drv_sd_fs_delete(path_tmp);
 800954e:	a829      	add	r0, sp, #164	; 0xa4
 8009550:	f7ff fcf2 	bl	8008f38 <drv_sd_fs_delete>
        return SD_ERR_IO;
 8009554:	e78a      	b.n	800946c <drv_sd_project_save_pattern+0x70>
 8009556:	bf00      	nop
 8009558:	08015378 	.word	0x08015378
 800955c:	08015340 	.word	0x08015340
 8009560:	706d742e 	.word	0x706d742e
 8009564:	30001360 	.word	0x30001360
 8009568:	edb88320 	.word	0xedb88320
 800956c:	42525450 	.word	0x42525450

08009570 <drv_sd_project_load_sample>:
    if (sample_name == NULL || buffer == NULL || buffer_size == 0U) {
 8009570:	2a00      	cmp	r2, #0
 8009572:	bf18      	it	ne
 8009574:	2900      	cmpne	r1, #0
                                      size_t     *loaded_size) {
 8009576:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800957a:	f5ad 7d3b 	sub.w	sp, sp, #748	; 0x2ec
    if (sample_name == NULL || buffer == NULL || buffer_size == 0U) {
 800957e:	f000 80b4 	beq.w	80096ea <drv_sd_project_load_sample+0x17a>
 8009582:	4604      	mov	r4, r0
 8009584:	2800      	cmp	r0, #0
 8009586:	f000 80b0 	beq.w	80096ea <drv_sd_project_load_sample+0x17a>
    if (!drv_sd_fs_is_mounted()) {
 800958a:	460e      	mov	r6, r1
 800958c:	4698      	mov	r8, r3
 800958e:	4615      	mov	r5, r2
 8009590:	f7ff fc48 	bl	8008e24 <drv_sd_fs_is_mounted>
 8009594:	2800      	cmp	r0, #0
 8009596:	f000 80ae 	beq.w	80096f6 <drv_sd_project_load_sample+0x186>
    const char prefix[] = "/samples/";
 800959a:	f10d 09bc 	add.w	r9, sp, #188	; 0xbc
 800959e:	4a60      	ldr	r2, [pc, #384]	; (8009720 <drv_sd_project_load_sample+0x1b0>)
 80095a0:	464b      	mov	r3, r9
 80095a2:	ca07      	ldmia	r2, {r0, r1, r2}
 80095a4:	c303      	stmia	r3!, {r0, r1}
    size_t name_len = strlen(sample_name);
 80095a6:	4620      	mov	r0, r4
    const char prefix[] = "/samples/";
 80095a8:	801a      	strh	r2, [r3, #0]
    size_t name_len = strlen(sample_name);
 80095aa:	f7f7 f989 	bl	80008c0 <strlen>
 80095ae:	4603      	mov	r3, r0
    size_t total = prefix_len + name_len;
 80095b0:	f100 0a09 	add.w	sl, r0, #9
    if (name_len == 0U || total >= SD_PATH_MAX) {
 80095b4:	2800      	cmp	r0, #0
 80095b6:	f000 8098 	beq.w	80096ea <drv_sd_project_load_sample+0x17a>
 80095ba:	f1ba 0f9f 	cmp.w	sl, #159	; 0x9f
 80095be:	bf94      	ite	ls
 80095c0:	f04f 0b00 	movls.w	fp, #0
 80095c4:	f04f 0b01 	movhi.w	fp, #1
 80095c8:	f1bb 0f00 	cmp.w	fp, #0
 80095cc:	f040 808d 	bne.w	80096ea <drv_sd_project_load_sample+0x17a>
    memcpy(dst, prefix, prefix_len);
 80095d0:	af07      	add	r7, sp, #28
 80095d2:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
 80095d6:	46bc      	mov	ip, r7
 80095d8:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    memcpy(dst + prefix_len, sample_name, name_len);
 80095dc:	4621      	mov	r1, r4
    memcpy(dst, prefix, prefix_len);
 80095de:	f88c 2000 	strb.w	r2, [ip]
    memcpy(dst + prefix_len, sample_name, name_len);
 80095e2:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 80095e6:	461a      	mov	r2, r3
 80095e8:	f7f7 f8c8 	bl	800077c <memcpy>
    sd_error_t err = drv_sd_fs_open(&file, path, FA_READ);
 80095ec:	4639      	mov	r1, r7
    dst[total] = '\0';
 80095ee:	f807 b00a 	strb.w	fp, [r7, sl]
    sd_error_t err = drv_sd_fs_open(&file, path, FA_READ);
 80095f2:	2201      	movs	r2, #1
 80095f4:	4648      	mov	r0, r9
 80095f6:	f7ff fc1b 	bl	8008e30 <drv_sd_fs_open>
    if (err != SD_OK) {
 80095fa:	4607      	mov	r7, r0
 80095fc:	2800      	cmp	r0, #0
 80095fe:	d175      	bne.n	80096ec <drv_sd_project_load_sample+0x17c>
    err = drv_sd_fs_read(&file, sd_io_buffer, sizeof(header), &br);
 8009600:	f8df b124 	ldr.w	fp, [pc, #292]	; 8009728 <drv_sd_project_load_sample+0x1b8>
 8009604:	ab05      	add	r3, sp, #20
    UINT br = 0;
 8009606:	9005      	str	r0, [sp, #20]
    err = drv_sd_fs_read(&file, sd_io_buffer, sizeof(header), &br);
 8009608:	2214      	movs	r2, #20
 800960a:	4659      	mov	r1, fp
 800960c:	4648      	mov	r0, r9
 800960e:	f7ff fc41 	bl	8008e94 <drv_sd_fs_read>
    if (err != SD_OK || br != sizeof(header)) {
 8009612:	4607      	mov	r7, r0
 8009614:	2800      	cmp	r0, #0
 8009616:	d174      	bne.n	8009702 <drv_sd_project_load_sample+0x192>
 8009618:	9b05      	ldr	r3, [sp, #20]
 800961a:	2b14      	cmp	r3, #20
 800961c:	d171      	bne.n	8009702 <drv_sd_project_load_sample+0x192>
    if (header.magic != SD_SAMPLE_MAGIC || header.version != SD_SAMPLE_VERSION || header.size_bytes > buffer_size || header.size_bytes > (64U * 1024U * 1024U)) {
 800961e:	4a41      	ldr	r2, [pc, #260]	; (8009724 <drv_sd_project_load_sample+0x1b4>)
 8009620:	e9db 1300 	ldrd	r1, r3, [fp]
 8009624:	4291      	cmp	r1, r2
 8009626:	bf08      	it	eq
 8009628:	f1b3 1f01 	cmpeq.w	r3, #65537	; 0x10001
    memcpy(&header, sd_io_buffer, sizeof(header));
 800962c:	f8db 2008 	ldr.w	r2, [fp, #8]
    if (header.magic != SD_SAMPLE_MAGIC || header.version != SD_SAMPLE_VERSION || header.size_bytes > buffer_size || header.size_bytes > (64U * 1024U * 1024U)) {
 8009630:	bf14      	ite	ne
 8009632:	2301      	movne	r3, #1
 8009634:	2300      	moveq	r3, #0
    memcpy(&header, sd_io_buffer, sizeof(header));
 8009636:	9200      	str	r2, [sp, #0]
    if (header.magic != SD_SAMPLE_MAGIC || header.version != SD_SAMPLE_VERSION || header.size_bytes > buffer_size || header.size_bytes > (64U * 1024U * 1024U)) {
 8009638:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800963c:	bf88      	it	hi
 800963e:	f043 0301 	orrhi.w	r3, r3, #1
 8009642:	2b00      	cmp	r3, #0
 8009644:	d15d      	bne.n	8009702 <drv_sd_project_load_sample+0x192>
 8009646:	4295      	cmp	r5, r2
 8009648:	4613      	mov	r3, r2
 800964a:	d35a      	bcc.n	8009702 <drv_sd_project_load_sample+0x192>
    memcpy(&header, sd_io_buffer, sizeof(header));
 800964c:	f8db 2010 	ldr.w	r2, [fp, #16]
 8009650:	9201      	str	r2, [sp, #4]
    while (remaining > 0U) {
 8009652:	2b00      	cmp	r3, #0
 8009654:	d061      	beq.n	800971a <drv_sd_project_load_sample+0x1aa>
    uint32_t crc = 0U;
 8009656:	2400      	movs	r4, #0
        err = drv_sd_fs_read(&file, sd_io_buffer, chunk, &read);
 8009658:	4933      	ldr	r1, [pc, #204]	; (8009728 <drv_sd_project_load_sample+0x1b8>)
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 800965a:	4d34      	ldr	r5, [pc, #208]	; (800972c <drv_sd_project_load_sample+0x1bc>)
 800965c:	461f      	mov	r7, r3
    uint32_t offset = 0U;
 800965e:	46a2      	mov	sl, r4
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 8009660:	9002      	str	r0, [sp, #8]
 8009662:	f8cd 800c 	str.w	r8, [sp, #12]
        UINT chunk = (remaining > SD_MAX_SAMPLE_CHUNK) ? SD_MAX_SAMPLE_CHUNK : remaining;
 8009666:	f5b7 3f80 	cmp.w	r7, #65536	; 0x10000
        UINT read = 0;
 800966a:	f04f 0300 	mov.w	r3, #0
        UINT chunk = (remaining > SD_MAX_SAMPLE_CHUNK) ? SD_MAX_SAMPLE_CHUNK : remaining;
 800966e:	46b8      	mov	r8, r7
        err = drv_sd_fs_read(&file, sd_io_buffer, chunk, &read);
 8009670:	4648      	mov	r0, r9
        UINT chunk = (remaining > SD_MAX_SAMPLE_CHUNK) ? SD_MAX_SAMPLE_CHUNK : remaining;
 8009672:	bf28      	it	cs
 8009674:	f44f 3880 	movcs.w	r8, #65536	; 0x10000
        UINT read = 0;
 8009678:	9306      	str	r3, [sp, #24]
        err = drv_sd_fs_read(&file, sd_io_buffer, chunk, &read);
 800967a:	ab06      	add	r3, sp, #24
 800967c:	4642      	mov	r2, r8
 800967e:	f7ff fc09 	bl	8008e94 <drv_sd_fs_read>
        if (err != SD_OK || read != chunk) {
 8009682:	2800      	cmp	r0, #0
 8009684:	d142      	bne.n	800970c <drv_sd_project_load_sample+0x19c>
 8009686:	9b06      	ldr	r3, [sp, #24]
 8009688:	4927      	ldr	r1, [pc, #156]	; (8009728 <drv_sd_project_load_sample+0x1b8>)
 800968a:	4543      	cmp	r3, r8
 800968c:	d13e      	bne.n	800970c <drv_sd_project_load_sample+0x19c>
    crc = ~crc;
 800968e:	43e4      	mvns	r4, r4
    for (size_t i = 0; i < len; ++i) {
 8009690:	4a25      	ldr	r2, [pc, #148]	; (8009728 <drv_sd_project_load_sample+0x1b8>)
 8009692:	eb0b 0e08 	add.w	lr, fp, r8
        crc ^= data[i];
 8009696:	f812 3b01 	ldrb.w	r3, [r2], #1
 800969a:	405c      	eors	r4, r3
 800969c:	2308      	movs	r3, #8
            uint32_t mask = (uint32_t)(-(int32_t)(crc & 1U));
 800969e:	f344 0000 	sbfx	r0, r4, #0, #1
        for (uint8_t b = 0; b < 8U; ++b) {
 80096a2:	3b01      	subs	r3, #1
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 80096a4:	4028      	ands	r0, r5
        for (uint8_t b = 0; b < 8U; ++b) {
 80096a6:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
            crc = (crc >> 1) ^ (0xEDB88320UL & mask);
 80096aa:	ea80 0454 	eor.w	r4, r0, r4, lsr #1
        for (uint8_t b = 0; b < 8U; ++b) {
 80096ae:	d1f6      	bne.n	800969e <drv_sd_project_load_sample+0x12e>
    for (size_t i = 0; i < len; ++i) {
 80096b0:	4596      	cmp	lr, r2
 80096b2:	d1f0      	bne.n	8009696 <drv_sd_project_load_sample+0x126>
        memcpy(&buffer[offset], sd_io_buffer, chunk);
 80096b4:	eb06 000a 	add.w	r0, r6, sl
 80096b8:	4642      	mov	r2, r8
 80096ba:	f7f7 f85f 	bl	800077c <memcpy>
    while (remaining > 0U) {
 80096be:	ebb7 0708 	subs.w	r7, r7, r8
    return ~crc;
 80096c2:	ea6f 0404 	mvn.w	r4, r4
        offset += chunk;
 80096c6:	44c2      	add	sl, r8
    while (remaining > 0U) {
 80096c8:	4917      	ldr	r1, [pc, #92]	; (8009728 <drv_sd_project_load_sample+0x1b8>)
 80096ca:	d1cc      	bne.n	8009666 <drv_sd_project_load_sample+0xf6>
 80096cc:	e9dd 7802 	ldrd	r7, r8, [sp, #8]
    drv_sd_fs_close(&file);
 80096d0:	4648      	mov	r0, r9
 80096d2:	f7ff fbd1 	bl	8008e78 <drv_sd_fs_close>
    if (crc != header.crc32) {
 80096d6:	9b01      	ldr	r3, [sp, #4]
 80096d8:	42a3      	cmp	r3, r4
 80096da:	d11c      	bne.n	8009716 <drv_sd_project_load_sample+0x1a6>
    if (loaded_size != NULL) {
 80096dc:	f1b8 0f00 	cmp.w	r8, #0
 80096e0:	d004      	beq.n	80096ec <drv_sd_project_load_sample+0x17c>
        *loaded_size = header.size_bytes;
 80096e2:	9b00      	ldr	r3, [sp, #0]
 80096e4:	f8c8 3000 	str.w	r3, [r8]
 80096e8:	e000      	b.n	80096ec <drv_sd_project_load_sample+0x17c>
        return SD_ERR_PARAM;
 80096ea:	2707      	movs	r7, #7
}
 80096ec:	4638      	mov	r0, r7
 80096ee:	f50d 7d3b 	add.w	sp, sp, #748	; 0x2ec
 80096f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return SD_ERR_NOT_MOUNTED;
 80096f6:	2702      	movs	r7, #2
}
 80096f8:	4638      	mov	r0, r7
 80096fa:	f50d 7d3b 	add.w	sp, sp, #748	; 0x2ec
 80096fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        drv_sd_fs_close(&file);
 8009702:	4648      	mov	r0, r9
        return SD_ERR_CORRUPTED;
 8009704:	2709      	movs	r7, #9
        drv_sd_fs_close(&file);
 8009706:	f7ff fbb7 	bl	8008e78 <drv_sd_fs_close>
        return SD_ERR_CORRUPTED;
 800970a:	e7ef      	b.n	80096ec <drv_sd_project_load_sample+0x17c>
            drv_sd_fs_close(&file);
 800970c:	4648      	mov	r0, r9
            return SD_ERR_IO;
 800970e:	2704      	movs	r7, #4
            drv_sd_fs_close(&file);
 8009710:	f7ff fbb2 	bl	8008e78 <drv_sd_fs_close>
            return SD_ERR_IO;
 8009714:	e7ea      	b.n	80096ec <drv_sd_project_load_sample+0x17c>
        return SD_ERR_CRC;
 8009716:	2705      	movs	r7, #5
 8009718:	e7e8      	b.n	80096ec <drv_sd_project_load_sample+0x17c>
    uint32_t crc = 0U;
 800971a:	9c00      	ldr	r4, [sp, #0]
 800971c:	e7d8      	b.n	80096d0 <drv_sd_project_load_sample+0x160>
 800971e:	bf00      	nop
 8009720:	0801534c 	.word	0x0801534c
 8009724:	42525350 	.word	0x42525350
 8009728:	30001360 	.word	0x30001360
 800972c:	edb88320 	.word	0xedb88320

08009730 <drv_sd_project_list_projects>:

sd_error_t drv_sd_project_list_projects(sd_project_info_t *projects,
                                        size_t max_projects,
                                        size_t *listed) {
    if (projects == NULL || listed == NULL || max_projects == 0U) {
 8009730:	2900      	cmp	r1, #0
 8009732:	bf18      	it	ne
 8009734:	2a00      	cmpne	r2, #0
 8009736:	d025      	beq.n	8009784 <drv_sd_project_list_projects+0x54>
                                        size_t *listed) {
 8009738:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (projects == NULL || listed == NULL || max_projects == 0U) {
 800973a:	fab0 f780 	clz	r7, r0
                                        size_t *listed) {
 800973e:	b085      	sub	sp, #20
 8009740:	4604      	mov	r4, r0
    if (projects == NULL || listed == NULL || max_projects == 0U) {
 8009742:	097f      	lsrs	r7, r7, #5
 8009744:	b1c0      	cbz	r0, 8009778 <drv_sd_project_list_projects+0x48>
        return SD_ERR_PARAM;
    }
    if (!drv_sd_fs_is_mounted()) {
 8009746:	460e      	mov	r6, r1
 8009748:	4615      	mov	r5, r2
 800974a:	f7ff fb6b 	bl	8008e24 <drv_sd_fs_is_mounted>
 800974e:	b1b0      	cbz	r0, 800977e <drv_sd_project_list_projects+0x4e>
    project_list_ctx_t params = {
        .projects = projects,
        .max_projects = max_projects,
        .listed = listed,
    };
    (void)drv_sd_fs_mkdir("/projects");
 8009750:	480d      	ldr	r0, [pc, #52]	; (8009788 <drv_sd_project_list_projects+0x58>)
    *listed = 0U;
 8009752:	602f      	str	r7, [r5, #0]
    project_list_ctx_t params = {
 8009754:	9503      	str	r5, [sp, #12]
 8009756:	e9cd 4601 	strd	r4, r6, [sp, #4]
    (void)drv_sd_fs_mkdir("/projects");
 800975a:	f7ff fc03 	bl	8008f64 <drv_sd_fs_mkdir>
    sd_error_t res = drv_sd_fs_list_dir("/projects", list_projects_cb, &params);
 800975e:	aa01      	add	r2, sp, #4
 8009760:	490a      	ldr	r1, [pc, #40]	; (800978c <drv_sd_project_list_projects+0x5c>)
 8009762:	4809      	ldr	r0, [pc, #36]	; (8009788 <drv_sd_project_list_projects+0x58>)
 8009764:	f7ff fc14 	bl	8008f90 <drv_sd_fs_list_dir>
    if (res == SD_ERR_FS && *listed > 0U) {
 8009768:	2806      	cmp	r0, #6
 800976a:	d103      	bne.n	8009774 <drv_sd_project_list_projects+0x44>
 800976c:	682b      	ldr	r3, [r5, #0]
        return SD_OK;
 800976e:	2b00      	cmp	r3, #0
 8009770:	bf18      	it	ne
 8009772:	2000      	movne	r0, #0
    }
    return res;
}
 8009774:	b005      	add	sp, #20
 8009776:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SD_ERR_PARAM;
 8009778:	2007      	movs	r0, #7
}
 800977a:	b005      	add	sp, #20
 800977c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SD_ERR_NOT_MOUNTED;
 800977e:	2002      	movs	r0, #2
}
 8009780:	b005      	add	sp, #20
 8009782:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SD_ERR_PARAM;
 8009784:	2007      	movs	r0, #7
}
 8009786:	4770      	bx	lr
 8009788:	08015358 	.word	0x08015358
 800978c:	08009275 	.word	0x08009275

08009790 <sd_stats_record>:
    for (size_t i = 0; i < pending_count; ++i) {
        (void)chMBPostTimeout(&sd_mb, (msg_t)pending[i], TIME_IMMEDIATE);
    }
}

static void sd_stats_record(sd_error_t res, uint32_t latency_us) {
 8009790:	b538      	push	{r3, r4, r5, lr}
    g_sd_stats.ops_total++;
 8009792:	4c35      	ldr	r4, [pc, #212]	; (8009868 <sd_stats_record+0xd8>)
 8009794:	6825      	ldr	r5, [r4, #0]
 8009796:	1c6a      	adds	r2, r5, #1
 8009798:	6022      	str	r2, [r4, #0]
    if (res == SD_OK) {
 800979a:	b9b8      	cbnz	r0, 80097cc <sd_stats_record+0x3c>
        g_sd_stats.ops_success++;
 800979c:	6863      	ldr	r3, [r4, #4]
 800979e:	3301      	adds	r3, #1
 80097a0:	6063      	str	r3, [r4, #4]
    case SD_ERR_TIMEOUT: g_sd_stats.err_timeout++; break;
    case SD_ERR_BUSY: g_sd_stats.err_busy++; break;
    case SD_ERR_CONTEXT: g_sd_stats.err_context++; break;
    default: break;
    }
    if (latency_us < g_sd_stats.latency_min_us || g_sd_stats.latency_min_us == 0U) {
 80097a2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80097a4:	b10b      	cbz	r3, 80097aa <sd_stats_record+0x1a>
 80097a6:	428b      	cmp	r3, r1
 80097a8:	d900      	bls.n	80097ac <sd_stats_record+0x1c>
        g_sd_stats.latency_min_us = latency_us;
 80097aa:	63e1      	str	r1, [r4, #60]	; 0x3c
    }
    if (latency_us > g_sd_stats.latency_max_us) {
 80097ac:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80097ae:	428b      	cmp	r3, r1
        g_sd_stats.latency_max_us = latency_us;
 80097b0:	bf38      	it	cc
 80097b2:	6421      	strcc	r1, [r4, #64]	; 0x40
    }
    if (g_sd_stats.ops_total > 0U) {
 80097b4:	b14a      	cbz	r2, 80097ca <sd_stats_record+0x3a>
        g_sd_stats.latency_avg_us = (uint32_t)(((uint64_t)g_sd_stats.latency_avg_us * (g_sd_stats.ops_total - 1U) + latency_us) / g_sd_stats.ops_total);
 80097b6:	2300      	movs	r3, #0
 80097b8:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80097ba:	468c      	mov	ip, r1
 80097bc:	4619      	mov	r1, r3
 80097be:	fbe0 c105 	umlal	ip, r1, r0, r5
 80097c2:	4660      	mov	r0, ip
 80097c4:	f7f6 fe48 	bl	8000458 <__aeabi_uldivmod>
 80097c8:	6460      	str	r0, [r4, #68]	; 0x44
    }
}
 80097ca:	bd38      	pop	{r3, r4, r5, pc}
    switch (res) {
 80097cc:	1e43      	subs	r3, r0, #1
        g_sd_stats.ops_error++;
 80097ce:	68a0      	ldr	r0, [r4, #8]
 80097d0:	3001      	adds	r0, #1
 80097d2:	60a0      	str	r0, [r4, #8]
    switch (res) {
 80097d4:	2b0b      	cmp	r3, #11
 80097d6:	d8e4      	bhi.n	80097a2 <sd_stats_record+0x12>
 80097d8:	a001      	add	r0, pc, #4	; (adr r0, 80097e0 <sd_stats_record+0x50>)
 80097da:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 80097de:	bf00      	nop
 80097e0:	08009819 	.word	0x08009819
 80097e4:	080097a3 	.word	0x080097a3
 80097e8:	08009821 	.word	0x08009821
 80097ec:	08009829 	.word	0x08009829
 80097f0:	08009831 	.word	0x08009831
 80097f4:	08009839 	.word	0x08009839
 80097f8:	08009841 	.word	0x08009841
 80097fc:	08009849 	.word	0x08009849
 8009800:	08009851 	.word	0x08009851
 8009804:	08009859 	.word	0x08009859
 8009808:	08009861 	.word	0x08009861
 800980c:	08009811 	.word	0x08009811
    case SD_ERR_CONTEXT: g_sd_stats.err_context++; break;
 8009810:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009812:	3301      	adds	r3, #1
 8009814:	6363      	str	r3, [r4, #52]	; 0x34
 8009816:	e7c4      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_NO_CARD: g_sd_stats.err_no_card++; break;
 8009818:	68e3      	ldr	r3, [r4, #12]
 800981a:	3301      	adds	r3, #1
 800981c:	60e3      	str	r3, [r4, #12]
 800981e:	e7c0      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_BUSY: g_sd_stats.err_busy++; break;
 8009820:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009822:	3301      	adds	r3, #1
 8009824:	6323      	str	r3, [r4, #48]	; 0x30
 8009826:	e7bc      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_IO: g_sd_stats.err_io++; break;
 8009828:	6923      	ldr	r3, [r4, #16]
 800982a:	3301      	adds	r3, #1
 800982c:	6123      	str	r3, [r4, #16]
 800982e:	e7b8      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_CRC: g_sd_stats.err_crc++; break;
 8009830:	6963      	ldr	r3, [r4, #20]
 8009832:	3301      	adds	r3, #1
 8009834:	6163      	str	r3, [r4, #20]
 8009836:	e7b4      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_FS: g_sd_stats.err_fs++; break;
 8009838:	69a3      	ldr	r3, [r4, #24]
 800983a:	3301      	adds	r3, #1
 800983c:	61a3      	str	r3, [r4, #24]
 800983e:	e7b0      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_PARAM: g_sd_stats.err_param++; break;
 8009840:	69e3      	ldr	r3, [r4, #28]
 8009842:	3301      	adds	r3, #1
 8009844:	61e3      	str	r3, [r4, #28]
 8009846:	e7ac      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_FULL: g_sd_stats.err_full++; break;
 8009848:	6a23      	ldr	r3, [r4, #32]
 800984a:	3301      	adds	r3, #1
 800984c:	6223      	str	r3, [r4, #32]
 800984e:	e7a8      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_CORRUPTED: g_sd_stats.err_corrupted++; break;
 8009850:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009852:	3301      	adds	r3, #1
 8009854:	6263      	str	r3, [r4, #36]	; 0x24
 8009856:	e7a4      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_FAULT: g_sd_stats.err_fault++; break;
 8009858:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800985a:	3301      	adds	r3, #1
 800985c:	62a3      	str	r3, [r4, #40]	; 0x28
 800985e:	e7a0      	b.n	80097a2 <sd_stats_record+0x12>
    case SD_ERR_TIMEOUT: g_sd_stats.err_timeout++; break;
 8009860:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009862:	3301      	adds	r3, #1
 8009864:	62e3      	str	r3, [r4, #44]	; 0x2c
 8009866:	e79c      	b.n	80097a2 <sd_stats_record+0x12>
 8009868:	240037a8 	.word	0x240037a8

0800986c <sdThread>:
  __sch_get_currthread()->name = name;
 800986c:	4ba8      	ldr	r3, [pc, #672]	; (8009b10 <sdThread+0x2a4>)
 800986e:	4aa9      	ldr	r2, [pc, #676]	; (8009b14 <sdThread+0x2a8>)
 8009870:	68db      	ldr	r3, [r3, #12]
    if (res == SD_ERR_FAULT) {
        sd_set_state(SD_STATE_FAULT);
    }
}

static THD_FUNCTION(sdThread, arg) {
 8009872:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009876:	f8df a2b4 	ldr.w	sl, [pc, #692]	; 8009b2c <sdThread+0x2c0>
 800987a:	b08f      	sub	sp, #60	; 0x3c
    (void)arg;
    chRegSetThreadName("sdThread");
    for (;;) {
        msg_t msg;
        if (chMBFetchTimeout(&sd_mb, &msg, TIME_INFINITE) != MSG_OK) {
 800987c:	4ea6      	ldr	r6, [pc, #664]	; (8009b18 <sdThread+0x2ac>)

void drv_sd_thread_release(sd_request_t *req) {
    if (req == NULL) {
        return;
    }
    chMtxLock(&sd_alloc_mutex);
 800987e:	f8df b2b0 	ldr.w	fp, [pc, #688]	; 8009b30 <sdThread+0x2c4>
 8009882:	621a      	str	r2, [r3, #32]
        if (chMBFetchTimeout(&sd_mb, &msg, TIME_INFINITE) != MSG_OK) {
 8009884:	f04f 32ff 	mov.w	r2, #4294967295
 8009888:	a904      	add	r1, sp, #16
 800988a:	4630      	mov	r0, r6
 800988c:	f7fd f908 	bl	8006aa0 <chMBFetchTimeout>
 8009890:	4604      	mov	r4, r0
 8009892:	2800      	cmp	r0, #0
 8009894:	d1f6      	bne.n	8009884 <sdThread+0x18>
        sd_request_t *req = (sd_request_t *)msg;
 8009896:	9d04      	ldr	r5, [sp, #16]
 8009898:	f7f7 f9b0 	bl	8000bfc <stGetCounter>
 800989c:	9003      	str	r0, [sp, #12]
        if (req->cancelled) {
 800989e:	7c6b      	ldrb	r3, [r5, #17]
 80098a0:	2b00      	cmp	r3, #0
 80098a2:	f040 8147 	bne.w	8009b34 <sdThread+0x2c8>
        bool io_request = (req->type != SD_REQ_INIT && req->type != SD_REQ_GET_STATS && req->type != SD_REQ_CLEAR_STATS);
 80098a6:	782c      	ldrb	r4, [r5, #0]
        sd_state_t prev_state = g_sd_state;
 80098a8:	f89a 7000 	ldrb.w	r7, [sl]
        bool io_request = (req->type != SD_REQ_INIT && req->type != SD_REQ_GET_STATS && req->type != SD_REQ_CLEAR_STATS);
 80098ac:	1fe3      	subs	r3, r4, #7
 80098ae:	2b01      	cmp	r3, #1
 80098b0:	d904      	bls.n	80098bc <sdThread+0x50>
 80098b2:	b11c      	cbz	r4, 80098bc <sdThread+0x50>
    g_sd_state = new_state;
 80098b4:	2306      	movs	r3, #6
 80098b6:	f88a 3000 	strb.w	r3, [sl]
        switch (req->type) {
 80098ba:	782c      	ldrb	r4, [r5, #0]
 80098bc:	2c08      	cmp	r4, #8
 80098be:	f200 81d4 	bhi.w	8009c6a <sdThread+0x3fe>
 80098c2:	e8df f014 	tbh	[pc, r4, lsl #1]
 80098c6:	0115      	.short	0x0115
 80098c8:	00fd0107 	.word	0x00fd0107
 80098cc:	00d500ec 	.word	0x00d500ec
 80098d0:	005a00c8 	.word	0x005a00c8
 80098d4:	00090051 	.word	0x00090051
    memset(&g_sd_stats, 0, sizeof(g_sd_stats));
 80098d8:	2248      	movs	r2, #72	; 0x48
 80098da:	2100      	movs	r1, #0
 80098dc:	488f      	ldr	r0, [pc, #572]	; (8009b1c <sdThread+0x2b0>)
 80098de:	f004 ff81 	bl	800e7e4 <memset>
        req->result = res;
 80098e2:	2400      	movs	r4, #0
        g_sd_last_error = res;
 80098e4:	4b8e      	ldr	r3, [pc, #568]	; (8009b20 <sdThread+0x2b4>)
    g_sd_state = new_state;
 80098e6:	f88a 7000 	strb.w	r7, [sl]
        req->result = res;
 80098ea:	706c      	strb	r4, [r5, #1]
        g_sd_last_error = res;
 80098ec:	701c      	strb	r4, [r3, #0]
    if (drv_sd_fs_consume_write_protect_event()) {
 80098ee:	f7ff fb7d 	bl	8008fec <drv_sd_fs_consume_write_protect_event>
 80098f2:	2800      	cmp	r0, #0
 80098f4:	d17d      	bne.n	80099f2 <sdThread+0x186>
 80098f6:	f7f7 f981 	bl	8000bfc <stGetCounter>
 80098fa:	9b03      	ldr	r3, [sp, #12]
        uint32_t latency_us = (uint32_t)TIME_I2US(chVTTimeElapsedSinceX(start));
 80098fc:	4f89      	ldr	r7, [pc, #548]	; (8009b24 <sdThread+0x2b8>)
 80098fe:	f242 720f 	movw	r2, #9999	; 0x270f
 8009902:	1ac3      	subs	r3, r0, r3
 8009904:	2100      	movs	r1, #0
 8009906:	fbe3 2107 	umlal	r2, r1, r3, r7
 800990a:	2300      	movs	r3, #0
 800990c:	4610      	mov	r0, r2
 800990e:	f242 7210 	movw	r2, #10000	; 0x2710
 8009912:	f7f6 fda1 	bl	8000458 <__aeabi_uldivmod>
 8009916:	4601      	mov	r1, r0
        sd_stats_record(res, latency_us);
 8009918:	4620      	mov	r0, r4
 800991a:	f7ff ff39 	bl	8009790 <sd_stats_record>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800991e:	2330      	movs	r3, #48	; 0x30
 8009920:	f383 8811 	msr	BASEPRI, r3
  if (bsp->sem.cnt < (cnt_t)1) {
 8009924:	68eb      	ldr	r3, [r5, #12]
 8009926:	2b00      	cmp	r3, #0
 8009928:	f340 8169 	ble.w	8009bfe <sdThread+0x392>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800992c:	f7fc fcc0 	bl	80062b0 <chSchRescheduleS>
 8009930:	2300      	movs	r3, #0
 8009932:	f383 8811 	msr	BASEPRI, r3
    if (req == NULL) {
 8009936:	7c2b      	ldrb	r3, [r5, #16]
 8009938:	2b01      	cmp	r3, #1
 800993a:	d1a3      	bne.n	8009884 <sdThread+0x18>
 800993c:	fab5 f485 	clz	r4, r5
 8009940:	0964      	lsrs	r4, r4, #5
 8009942:	2d00      	cmp	r5, #0
 8009944:	d09e      	beq.n	8009884 <sdThread+0x18>
    chMtxLock(&sd_alloc_mutex);
 8009946:	4658      	mov	r0, fp
 8009948:	f7fc ffa8 	bl	800689c <chMtxLock>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 800994c:	4a76      	ldr	r2, [pc, #472]	; (8009b28 <sdThread+0x2bc>)
 800994e:	4623      	mov	r3, r4
        if (&sd_requests[i] == req) {
 8009950:	4295      	cmp	r5, r2
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009952:	f102 023c 	add.w	r2, r2, #60	; 0x3c
        if (&sd_requests[i] == req) {
 8009956:	f000 812d 	beq.w	8009bb4 <sdThread+0x348>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 800995a:	3301      	adds	r3, #1
 800995c:	2b08      	cmp	r3, #8
 800995e:	d1f7      	bne.n	8009950 <sdThread+0xe4>
            sd_request_in_use[i] = false;
            break;
        }
    }
    chMtxUnlock(&sd_alloc_mutex);
 8009960:	4658      	mov	r0, fp
 8009962:	f7fc ffa5 	bl	80068b0 <chMtxUnlock>
 8009966:	e78d      	b.n	8009884 <sdThread+0x18>
            res = sd_handle_get_stats(req);
 8009968:	6968      	ldr	r0, [r5, #20]
    if (req->params.stats.stats == NULL) {
 800996a:	2800      	cmp	r0, #0
 800996c:	f000 8169 	beq.w	8009c42 <sdThread+0x3d6>
    memcpy(req->params.stats.stats, &g_sd_stats, sizeof(g_sd_stats));
 8009970:	2248      	movs	r2, #72	; 0x48
 8009972:	496a      	ldr	r1, [pc, #424]	; (8009b1c <sdThread+0x2b0>)
 8009974:	f7f6 ff02 	bl	800077c <memcpy>
    g_sd_state = new_state;
 8009978:	e7b3      	b.n	80098e2 <sdThread+0x76>
    if (!drv_sd_fs_is_mounted()) {
 800997a:	f7ff fa53 	bl	8008e24 <drv_sd_fs_is_mounted>
 800997e:	2800      	cmp	r0, #0
 8009980:	f000 8150 	beq.w	8009c24 <sdThread+0x3b8>
    return drv_sd_project_list_projects(req->params.list.projects,
 8009984:	6968      	ldr	r0, [r5, #20]
 8009986:	e9d5 1206 	ldrd	r1, r2, [r5, #24]
 800998a:	f7ff fed1 	bl	8009730 <drv_sd_project_list_projects>
 800998e:	4604      	mov	r4, r0
        g_sd_last_error = res;
 8009990:	4a63      	ldr	r2, [pc, #396]	; (8009b20 <sdThread+0x2b4>)
 8009992:	1e63      	subs	r3, r4, #1
    g_sd_state = new_state;
 8009994:	f88a 7000 	strb.w	r7, [sl]
        req->result = res;
 8009998:	706c      	strb	r4, [r5, #1]
        g_sd_last_error = res;
 800999a:	7014      	strb	r4, [r2, #0]
    if (res == SD_OK) {
 800999c:	2b09      	cmp	r3, #9
 800999e:	d8a6      	bhi.n	80098ee <sdThread+0x82>
 80099a0:	a201      	add	r2, pc, #4	; (adr r2, 80099a8 <sdThread+0x13c>)
 80099a2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80099a6:	bf00      	nop
 80099a8:	08009ae9 	.word	0x08009ae9
 80099ac:	080098ef 	.word	0x080098ef
 80099b0:	080098ef 	.word	0x080098ef
 80099b4:	080099dd 	.word	0x080099dd
 80099b8:	080099e5 	.word	0x080099e5
 80099bc:	080099dd 	.word	0x080099dd
 80099c0:	080098ef 	.word	0x080098ef
 80099c4:	080099dd 	.word	0x080099dd
 80099c8:	080098ef 	.word	0x080098ef
 80099cc:	08009b09 	.word	0x08009b09
        req->result = res;
 80099d0:	2406      	movs	r4, #6
        g_sd_last_error = res;
 80099d2:	4b53      	ldr	r3, [pc, #332]	; (8009b20 <sdThread+0x2b4>)
    g_sd_state = new_state;
 80099d4:	f88a 7000 	strb.w	r7, [sl]
        req->result = res;
 80099d8:	706c      	strb	r4, [r5, #1]
        g_sd_last_error = res;
 80099da:	701c      	strb	r4, [r3, #0]
        if (g_sd_state == SD_STATE_MOUNTED_RW) {
 80099dc:	f89a 3000 	ldrb.w	r3, [sl]
 80099e0:	2b02      	cmp	r3, #2
 80099e2:	d184      	bne.n	80098ee <sdThread+0x82>
    g_sd_state = new_state;
 80099e4:	2304      	movs	r3, #4
 80099e6:	f88a 3000 	strb.w	r3, [sl]
    if (drv_sd_fs_consume_write_protect_event()) {
 80099ea:	f7ff faff 	bl	8008fec <drv_sd_fs_consume_write_protect_event>
 80099ee:	2800      	cmp	r0, #0
 80099f0:	d081      	beq.n	80098f6 <sdThread+0x8a>
    size_t pending_count = 0U;
 80099f2:	2700      	movs	r7, #0
    g_sd_state = new_state;
 80099f4:	2303      	movs	r3, #3
 80099f6:	46a0      	mov	r8, r4
    while (chMBFetchTimeout(&sd_mb, &msg, TIME_IMMEDIATE) == MSG_OK) {
 80099f8:	46b9      	mov	r9, r7
    g_sd_state = new_state;
 80099fa:	f88a 3000 	strb.w	r3, [sl]
    while (chMBFetchTimeout(&sd_mb, &msg, TIME_IMMEDIATE) == MSG_OK) {
 80099fe:	2200      	movs	r2, #0
 8009a00:	a905      	add	r1, sp, #20
 8009a02:	4630      	mov	r0, r6
 8009a04:	f7fd f84c 	bl	8006aa0 <chMBFetchTimeout>
 8009a08:	b990      	cbnz	r0, 8009a30 <sdThread+0x1c4>
        sd_request_t *req = (sd_request_t *)msg;
 8009a0a:	9c05      	ldr	r4, [sp, #20]
    if (req == NULL) {
 8009a0c:	b11c      	cbz	r4, 8009a16 <sdThread+0x1aa>
        if (sd_request_is_write(req)) {
 8009a0e:	7823      	ldrb	r3, [r4, #0]
 8009a10:	2b04      	cmp	r3, #4
 8009a12:	f000 80d6 	beq.w	8009bc2 <sdThread+0x356>
            pending[pending_count++] = req;
 8009a16:	ab0e      	add	r3, sp, #56	; 0x38
    while (chMBFetchTimeout(&sd_mb, &msg, TIME_IMMEDIATE) == MSG_OK) {
 8009a18:	2200      	movs	r2, #0
 8009a1a:	a905      	add	r1, sp, #20
 8009a1c:	4630      	mov	r0, r6
            pending[pending_count++] = req;
 8009a1e:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 8009a22:	3701      	adds	r7, #1
 8009a24:	f843 4c20 	str.w	r4, [r3, #-32]
    while (chMBFetchTimeout(&sd_mb, &msg, TIME_IMMEDIATE) == MSG_OK) {
 8009a28:	f7fd f83a 	bl	8006aa0 <chMBFetchTimeout>
 8009a2c:	2800      	cmp	r0, #0
 8009a2e:	d0ec      	beq.n	8009a0a <sdThread+0x19e>
    for (size_t i = 0; i < pending_count; ++i) {
 8009a30:	4644      	mov	r4, r8
 8009a32:	2f00      	cmp	r7, #0
 8009a34:	f43f af5f 	beq.w	80098f6 <sdThread+0x8a>
 8009a38:	f10d 0814 	add.w	r8, sp, #20
 8009a3c:	f04f 0900 	mov.w	r9, #0
 8009a40:	f109 0901 	add.w	r9, r9, #1
        (void)chMBPostTimeout(&sd_mb, (msg_t)pending[i], TIME_IMMEDIATE);
 8009a44:	2200      	movs	r2, #0
 8009a46:	f858 1f04 	ldr.w	r1, [r8, #4]!
 8009a4a:	4630      	mov	r0, r6
 8009a4c:	f7fc ffd2 	bl	80069f4 <chMBPostTimeout>
    for (size_t i = 0; i < pending_count; ++i) {
 8009a50:	454f      	cmp	r7, r9
 8009a52:	d1f5      	bne.n	8009a40 <sdThread+0x1d4>
 8009a54:	e74f      	b.n	80098f6 <sdThread+0x8a>
    if (!drv_sd_fs_is_mounted()) {
 8009a56:	f7ff f9e5 	bl	8008e24 <drv_sd_fs_is_mounted>
 8009a5a:	2800      	cmp	r0, #0
 8009a5c:	f000 80e2 	beq.w	8009c24 <sdThread+0x3b8>
    return drv_sd_project_load_sample(req->params.sample.sample_name,
 8009a60:	e9d5 2307 	ldrd	r2, r3, [r5, #28]
 8009a64:	e9d5 0105 	ldrd	r0, r1, [r5, #20]
 8009a68:	f7ff fd82 	bl	8009570 <drv_sd_project_load_sample>
 8009a6c:	4604      	mov	r4, r0
}
 8009a6e:	e78f      	b.n	8009990 <sdThread+0x124>
    if (g_sd_state == SD_STATE_MOUNTED_RO || g_sd_state == SD_STATE_DEGRADED) {
 8009a70:	f89a 3000 	ldrb.w	r3, [sl]
 8009a74:	3b03      	subs	r3, #3
 8009a76:	2b01      	cmp	r3, #1
 8009a78:	d9aa      	bls.n	80099d0 <sdThread+0x164>
    if (!drv_sd_fs_is_mounted()) {
 8009a7a:	f7ff f9d3 	bl	8008e24 <drv_sd_fs_is_mounted>
 8009a7e:	2800      	cmp	r0, #0
 8009a80:	f000 80d0 	beq.w	8009c24 <sdThread+0x3b8>
    return drv_sd_project_save_pattern(req->params.pattern.project_name,
 8009a84:	f895 4034 	ldrb.w	r4, [r5, #52]	; 0x34
 8009a88:	e9d5 0105 	ldrd	r0, r1, [r5, #20]
 8009a8c:	e9d5 230b 	ldrd	r2, r3, [r5, #44]	; 0x2c
 8009a90:	b104      	cbz	r4, 8009a94 <sdThread+0x228>
 8009a92:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8009a94:	9400      	str	r4, [sp, #0]
 8009a96:	f7ff fcb1 	bl	80093fc <drv_sd_project_save_pattern>
 8009a9a:	4604      	mov	r4, r0
}
 8009a9c:	e778      	b.n	8009990 <sdThread+0x124>
    if (!drv_sd_fs_is_mounted()) {
 8009a9e:	f7ff f9c1 	bl	8008e24 <drv_sd_fs_is_mounted>
 8009aa2:	2800      	cmp	r0, #0
 8009aa4:	f000 80be 	beq.w	8009c24 <sdThread+0x3b8>
    return drv_sd_project_load_pattern(req->params.pattern.project_name,
 8009aa8:	6aac      	ldr	r4, [r5, #40]	; 0x28
 8009aaa:	e9d5 2307 	ldrd	r2, r3, [r5, #28]
 8009aae:	e9d5 0105 	ldrd	r0, r1, [r5, #20]
 8009ab2:	9401      	str	r4, [sp, #4]
 8009ab4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8009ab6:	9400      	str	r4, [sp, #0]
 8009ab8:	f7ff fc06 	bl	80092c8 <drv_sd_project_load_pattern>
 8009abc:	4604      	mov	r4, r0
}
 8009abe:	e767      	b.n	8009990 <sdThread+0x124>
    drv_sd_fs_unmount();
 8009ac0:	f7ff f992 	bl	8008de8 <drv_sd_fs_unmount>
        req->result = res;
 8009ac4:	2400      	movs	r4, #0
        g_sd_last_error = res;
 8009ac6:	4b16      	ldr	r3, [pc, #88]	; (8009b20 <sdThread+0x2b4>)
        req->result = res;
 8009ac8:	706c      	strb	r4, [r5, #1]
        g_sd_last_error = res;
 8009aca:	701c      	strb	r4, [r3, #0]
    g_sd_state = new_state;
 8009acc:	2301      	movs	r3, #1
 8009ace:	f88a 3000 	strb.w	r3, [sl]
    if (res == SD_OK) {
 8009ad2:	e70c      	b.n	80098ee <sdThread+0x82>
            res = sd_handle_mount(req->params.mount_ro);
 8009ad4:	7d2f      	ldrb	r7, [r5, #20]
    if (!drv_sd_hal_is_card_present()) {
 8009ad6:	f7ff faad 	bl	8009034 <drv_sd_hal_is_card_present>
 8009ada:	2800      	cmp	r0, #0
 8009adc:	f040 80a9 	bne.w	8009c32 <sdThread+0x3c6>
        req->result = res;
 8009ae0:	2301      	movs	r3, #1
        g_sd_last_error = res;
 8009ae2:	4a0f      	ldr	r2, [pc, #60]	; (8009b20 <sdThread+0x2b4>)
        req->result = res;
 8009ae4:	706b      	strb	r3, [r5, #1]
        g_sd_last_error = res;
 8009ae6:	7013      	strb	r3, [r2, #0]
    g_sd_state = new_state;
 8009ae8:	2401      	movs	r4, #1
 8009aea:	f88a 4000 	strb.w	r4, [sl]
        return;
 8009aee:	e6fe      	b.n	80098ee <sdThread+0x82>
    drv_sd_hal_init();
 8009af0:	f7ff fa8a 	bl	8009008 <drv_sd_hal_init>
    drv_sd_fs_unmount();
 8009af4:	f7ff f978 	bl	8008de8 <drv_sd_fs_unmount>
        req->result = res;
 8009af8:	2300      	movs	r3, #0
        g_sd_last_error = res;
 8009afa:	4a09      	ldr	r2, [pc, #36]	; (8009b20 <sdThread+0x2b4>)
        req->result = res;
 8009afc:	706b      	strb	r3, [r5, #1]
        g_sd_last_error = res;
 8009afe:	7013      	strb	r3, [r2, #0]
    g_sd_state = new_state;
 8009b00:	2301      	movs	r3, #1
 8009b02:	f88a 3000 	strb.w	r3, [sl]
    if (res == SD_OK) {
 8009b06:	e6f2      	b.n	80098ee <sdThread+0x82>
    g_sd_state = new_state;
 8009b08:	2305      	movs	r3, #5
 8009b0a:	f88a 3000 	strb.w	r3, [sl]
}
 8009b0e:	e6ee      	b.n	80098ee <sdThread+0x82>
 8009b10:	24000c20 	.word	0x24000c20
 8009b14:	08015364 	.word	0x08015364
 8009b18:	24004450 	.word	0x24004450
 8009b1c:	240037a8 	.word	0x240037a8
 8009b20:	240037a5 	.word	0x240037a5
 8009b24:	000f4240 	.word	0x000f4240
 8009b28:	24004480 	.word	0x24004480
 8009b2c:	240037a6 	.word	0x240037a6
 8009b30:	24004420 	.word	0x24004420
            sd_error_t cancel_res = (req->result != SD_OK) ? req->result : SD_ERR_TIMEOUT;
 8009b34:	786f      	ldrb	r7, [r5, #1]
            g_sd_last_error = cancel_res;
 8009b36:	4b50      	ldr	r3, [pc, #320]	; (8009c78 <sdThread+0x40c>)
            sd_error_t cancel_res = (req->result != SD_OK) ? req->result : SD_ERR_TIMEOUT;
 8009b38:	2f00      	cmp	r7, #0
 8009b3a:	bf08      	it	eq
 8009b3c:	270b      	moveq	r7, #11
            req->result = cancel_res;
 8009b3e:	706f      	strb	r7, [r5, #1]
            g_sd_last_error = cancel_res;
 8009b40:	701f      	strb	r7, [r3, #0]
 8009b42:	f7f7 f85b 	bl	8000bfc <stGetCounter>
 8009b46:	9b03      	ldr	r3, [sp, #12]
            uint32_t latency_us = (uint32_t)TIME_I2US(chVTTimeElapsedSinceX(start));
 8009b48:	4621      	mov	r1, r4
 8009b4a:	4a4c      	ldr	r2, [pc, #304]	; (8009c7c <sdThread+0x410>)
 8009b4c:	1ac3      	subs	r3, r0, r3
 8009b4e:	f242 700f 	movw	r0, #9999	; 0x270f
 8009b52:	fbe3 0102 	umlal	r0, r1, r3, r2
 8009b56:	f242 7210 	movw	r2, #10000	; 0x2710
 8009b5a:	2300      	movs	r3, #0
 8009b5c:	f7f6 fc7c 	bl	8000458 <__aeabi_uldivmod>
 8009b60:	4601      	mov	r1, r0
            sd_stats_record(cancel_res, latency_us);
 8009b62:	4638      	mov	r0, r7
 8009b64:	f7ff fe14 	bl	8009790 <sd_stats_record>
 8009b68:	2330      	movs	r3, #48	; 0x30
 8009b6a:	f383 8811 	msr	BASEPRI, r3
  if (bsp->sem.cnt < (cnt_t)1) {
 8009b6e:	68eb      	ldr	r3, [r5, #12]
 8009b70:	2b00      	cmp	r3, #0
 8009b72:	dd53      	ble.n	8009c1c <sdThread+0x3b0>
  chSchRescheduleS();
 8009b74:	f7fc fb9c 	bl	80062b0 <chSchRescheduleS>
 8009b78:	2300      	movs	r3, #0
 8009b7a:	f383 8811 	msr	BASEPRI, r3
    if (req == NULL) {
 8009b7e:	7c2b      	ldrb	r3, [r5, #16]
 8009b80:	2b01      	cmp	r3, #1
 8009b82:	f47f ae7f 	bne.w	8009884 <sdThread+0x18>
 8009b86:	fab5 f485 	clz	r4, r5
 8009b8a:	0964      	lsrs	r4, r4, #5
 8009b8c:	2d00      	cmp	r5, #0
 8009b8e:	f43f ae79 	beq.w	8009884 <sdThread+0x18>
    chMtxLock(&sd_alloc_mutex);
 8009b92:	4658      	mov	r0, fp
 8009b94:	f7fc fe82 	bl	800689c <chMtxLock>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009b98:	4a39      	ldr	r2, [pc, #228]	; (8009c80 <sdThread+0x414>)
 8009b9a:	4623      	mov	r3, r4
        if (&sd_requests[i] == req) {
 8009b9c:	4295      	cmp	r5, r2
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009b9e:	f102 023c 	add.w	r2, r2, #60	; 0x3c
        if (&sd_requests[i] == req) {
 8009ba2:	d007      	beq.n	8009bb4 <sdThread+0x348>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009ba4:	3301      	adds	r3, #1
 8009ba6:	2b08      	cmp	r3, #8
 8009ba8:	f43f aeda 	beq.w	8009960 <sdThread+0xf4>
        if (&sd_requests[i] == req) {
 8009bac:	4295      	cmp	r5, r2
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009bae:	f102 023c 	add.w	r2, r2, #60	; 0x3c
        if (&sd_requests[i] == req) {
 8009bb2:	d1f7      	bne.n	8009ba4 <sdThread+0x338>
            sd_request_in_use[i] = false;
 8009bb4:	2200      	movs	r2, #0
 8009bb6:	4933      	ldr	r1, [pc, #204]	; (8009c84 <sdThread+0x418>)
    chMtxUnlock(&sd_alloc_mutex);
 8009bb8:	4658      	mov	r0, fp
            sd_request_in_use[i] = false;
 8009bba:	54ca      	strb	r2, [r1, r3]
    chMtxUnlock(&sd_alloc_mutex);
 8009bbc:	f7fc fe78 	bl	80068b0 <chMtxUnlock>
 8009bc0:	e660      	b.n	8009884 <sdThread+0x18>
            req->result = SD_ERR_FS;
 8009bc2:	2306      	movs	r3, #6
            g_sd_last_error = SD_ERR_FS;
 8009bc4:	4a2c      	ldr	r2, [pc, #176]	; (8009c78 <sdThread+0x40c>)
            req->result = SD_ERR_FS;
 8009bc6:	7063      	strb	r3, [r4, #1]
            g_sd_last_error = SD_ERR_FS;
 8009bc8:	7013      	strb	r3, [r2, #0]
 8009bca:	2330      	movs	r3, #48	; 0x30
 8009bcc:	f383 8811 	msr	BASEPRI, r3
  if (bsp->sem.cnt < (cnt_t)1) {
 8009bd0:	68e3      	ldr	r3, [r4, #12]
 8009bd2:	2b00      	cmp	r3, #0
 8009bd4:	dd1e      	ble.n	8009c14 <sdThread+0x3a8>
  chSchRescheduleS();
 8009bd6:	f7fc fb6b 	bl	80062b0 <chSchRescheduleS>
 8009bda:	f389 8811 	msr	BASEPRI, r9
    chMtxLock(&sd_alloc_mutex);
 8009bde:	4658      	mov	r0, fp
 8009be0:	f7fc fe5c 	bl	800689c <chMtxLock>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009be4:	4b26      	ldr	r3, [pc, #152]	; (8009c80 <sdThread+0x414>)
 8009be6:	2200      	movs	r2, #0
        if (&sd_requests[i] == req) {
 8009be8:	429c      	cmp	r4, r3
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009bea:	f103 033c 	add.w	r3, r3, #60	; 0x3c
        if (&sd_requests[i] == req) {
 8009bee:	d00a      	beq.n	8009c06 <sdThread+0x39a>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009bf0:	3201      	adds	r2, #1
 8009bf2:	2a08      	cmp	r2, #8
 8009bf4:	d1f8      	bne.n	8009be8 <sdThread+0x37c>
    chMtxUnlock(&sd_alloc_mutex);
 8009bf6:	4658      	mov	r0, fp
 8009bf8:	f7fc fe5a 	bl	80068b0 <chMtxUnlock>
 8009bfc:	e6ff      	b.n	80099fe <sdThread+0x192>
    chSemSignalI(&bsp->sem);
 8009bfe:	1d28      	adds	r0, r5, #4
 8009c00:	f7fc fdd6 	bl	80067b0 <chSemSignalI>
 8009c04:	e692      	b.n	800992c <sdThread+0xc0>
            sd_request_in_use[i] = false;
 8009c06:	4b1f      	ldr	r3, [pc, #124]	; (8009c84 <sdThread+0x418>)
    chMtxUnlock(&sd_alloc_mutex);
 8009c08:	4658      	mov	r0, fp
            sd_request_in_use[i] = false;
 8009c0a:	f803 9002 	strb.w	r9, [r3, r2]
    chMtxUnlock(&sd_alloc_mutex);
 8009c0e:	f7fc fe4f 	bl	80068b0 <chMtxUnlock>
 8009c12:	e6f4      	b.n	80099fe <sdThread+0x192>
 8009c14:	1d20      	adds	r0, r4, #4
 8009c16:	f7fc fdcb 	bl	80067b0 <chSemSignalI>
 8009c1a:	e7dc      	b.n	8009bd6 <sdThread+0x36a>
 8009c1c:	1d28      	adds	r0, r5, #4
 8009c1e:	f7fc fdc7 	bl	80067b0 <chSemSignalI>
 8009c22:	e7a7      	b.n	8009b74 <sdThread+0x308>
        req->result = res;
 8009c24:	2402      	movs	r4, #2
        g_sd_last_error = res;
 8009c26:	4b14      	ldr	r3, [pc, #80]	; (8009c78 <sdThread+0x40c>)
    g_sd_state = new_state;
 8009c28:	f88a 7000 	strb.w	r7, [sl]
        req->result = res;
 8009c2c:	706c      	strb	r4, [r5, #1]
        g_sd_last_error = res;
 8009c2e:	701c      	strb	r4, [r3, #0]
    if (res == SD_OK) {
 8009c30:	e65d      	b.n	80098ee <sdThread+0x82>
    sd_error_t res = drv_sd_fs_mount(read_only ? SD_FS_RO : SD_FS_RW);
 8009c32:	4638      	mov	r0, r7
 8009c34:	f7ff f85a 	bl	8008cec <drv_sd_fs_mount>
    if (res == SD_OK) {
 8009c38:	4681      	mov	r9, r0
 8009c3a:	b148      	cbz	r0, 8009c50 <sdThread+0x3e4>
 8009c3c:	4627      	mov	r7, r4
 8009c3e:	4604      	mov	r4, r0
 8009c40:	e6a6      	b.n	8009990 <sdThread+0x124>
        req->result = res;
 8009c42:	2307      	movs	r3, #7
        g_sd_last_error = res;
 8009c44:	4a0c      	ldr	r2, [pc, #48]	; (8009c78 <sdThread+0x40c>)
    g_sd_state = new_state;
 8009c46:	f88a 7000 	strb.w	r7, [sl]
        req->result = res;
 8009c4a:	706b      	strb	r3, [r5, #1]
        g_sd_last_error = res;
 8009c4c:	7013      	strb	r3, [r2, #0]
    if (res == SD_OK) {
 8009c4e:	e64e      	b.n	80098ee <sdThread+0x82>
        bool fs_ro = drv_sd_fs_is_read_only();
 8009c50:	f7ff f9d4 	bl	8008ffc <drv_sd_fs_is_read_only>
        g_sd_last_error = res;
 8009c54:	4b08      	ldr	r3, [pc, #32]	; (8009c78 <sdThread+0x40c>)
        sd_set_state((read_only || fs_ro) ? SD_STATE_MOUNTED_RO : SD_STATE_MOUNTED_RW);
 8009c56:	4338      	orrs	r0, r7
        g_sd_last_error = res;
 8009c58:	464c      	mov	r4, r9
 8009c5a:	f883 9000 	strb.w	r9, [r3]
        sd_set_state((read_only || fs_ro) ? SD_STATE_MOUNTED_RO : SD_STATE_MOUNTED_RW);
 8009c5e:	1c83      	adds	r3, r0, #2
        req->result = res;
 8009c60:	f885 9001 	strb.w	r9, [r5, #1]
    g_sd_state = new_state;
 8009c64:	f88a 3000 	strb.w	r3, [sl]
    if (res == SD_OK) {
 8009c68:	e641      	b.n	80098ee <sdThread+0x82>
        req->result = res;
 8009c6a:	2407      	movs	r4, #7
        g_sd_last_error = res;
 8009c6c:	4b02      	ldr	r3, [pc, #8]	; (8009c78 <sdThread+0x40c>)
    g_sd_state = new_state;
 8009c6e:	f88a 7000 	strb.w	r7, [sl]
        req->result = res;
 8009c72:	706c      	strb	r4, [r5, #1]
        g_sd_last_error = res;
 8009c74:	701c      	strb	r4, [r3, #0]
    if (res == SD_OK) {
 8009c76:	e63a      	b.n	80098ee <sdThread+0x82>
 8009c78:	240037a5 	.word	0x240037a5
 8009c7c:	000f4240 	.word	0x000f4240
 8009c80:	24004480 	.word	0x24004480
 8009c84:	24004478 	.word	0x24004478

08009c88 <drv_sd_thread_start>:
void drv_sd_thread_start(void) {
 8009c88:	b510      	push	{r4, lr}
    chMBObjectInit(&sd_mb, sd_mailbox_buffer, SD_FIFO_DEPTH);
 8009c8a:	2208      	movs	r2, #8
void drv_sd_thread_start(void) {
 8009c8c:	b082      	sub	sp, #8
    chMBObjectInit(&sd_mb, sd_mailbox_buffer, SD_FIFO_DEPTH);
 8009c8e:	490a      	ldr	r1, [pc, #40]	; (8009cb8 <drv_sd_thread_start+0x30>)
 8009c90:	480a      	ldr	r0, [pc, #40]	; (8009cbc <drv_sd_thread_start+0x34>)
 8009c92:	f7fc fe6b 	bl	800696c <chMBObjectInit>
    chMtxObjectInit(&sd_alloc_mutex);
 8009c96:	480a      	ldr	r0, [pc, #40]	; (8009cc0 <drv_sd_thread_start+0x38>)
 8009c98:	f7fc fd9a 	bl	80067d0 <chMtxObjectInit>
    memset(sd_request_in_use, 0, sizeof(sd_request_in_use));
 8009c9c:	4c09      	ldr	r4, [pc, #36]	; (8009cc4 <drv_sd_thread_start+0x3c>)
 8009c9e:	2000      	movs	r0, #0
    chThdCreateStatic(sdThreadWA, sizeof(sdThreadWA), SD_THREAD_PRIORITY, sdThread, NULL);
 8009ca0:	4b09      	ldr	r3, [pc, #36]	; (8009cc8 <drv_sd_thread_start+0x40>)
 8009ca2:	227e      	movs	r2, #126	; 0x7e
 8009ca4:	f44f 611e 	mov.w	r1, #2528	; 0x9e0
 8009ca8:	9000      	str	r0, [sp, #0]
    memset(sd_request_in_use, 0, sizeof(sd_request_in_use));
 8009caa:	e9c4 0000 	strd	r0, r0, [r4]
    chThdCreateStatic(sdThreadWA, sizeof(sdThreadWA), SD_THREAD_PRIORITY, sdThread, NULL);
 8009cae:	4807      	ldr	r0, [pc, #28]	; (8009ccc <drv_sd_thread_start+0x44>)
 8009cb0:	f7fc fbfa 	bl	80064a8 <chThdCreateStatic>
}
 8009cb4:	b002      	add	sp, #8
 8009cb6:	bd10      	pop	{r4, pc}
 8009cb8:	24004430 	.word	0x24004430
 8009cbc:	24004450 	.word	0x24004450
 8009cc0:	24004420 	.word	0x24004420
 8009cc4:	24004478 	.word	0x24004478
 8009cc8:	0800986d 	.word	0x0800986d
 8009ccc:	24003a40 	.word	0x24003a40

08009cd0 <drv_sd_thread_alloc>:
sd_request_t* drv_sd_thread_alloc(void) {
 8009cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    chMtxLock(&sd_alloc_mutex);
 8009cd2:	4814      	ldr	r0, [pc, #80]	; (8009d24 <drv_sd_thread_alloc+0x54>)
 8009cd4:	f7fc fde2 	bl	800689c <chMtxLock>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009cd8:	4a13      	ldr	r2, [pc, #76]	; (8009d28 <drv_sd_thread_alloc+0x58>)
 8009cda:	2300      	movs	r3, #0
        if (!sd_request_in_use[i]) {
 8009cdc:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8009ce0:	b141      	cbz	r1, 8009cf4 <drv_sd_thread_alloc+0x24>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009ce2:	3301      	adds	r3, #1
 8009ce4:	2b08      	cmp	r3, #8
 8009ce6:	d1f9      	bne.n	8009cdc <drv_sd_thread_alloc+0xc>
    sd_request_t *req = NULL;
 8009ce8:	2400      	movs	r4, #0
    chMtxUnlock(&sd_alloc_mutex);
 8009cea:	480e      	ldr	r0, [pc, #56]	; (8009d24 <drv_sd_thread_alloc+0x54>)
 8009cec:	f7fc fde0 	bl	80068b0 <chMtxUnlock>
}
 8009cf0:	4620      	mov	r0, r4
 8009cf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            sd_request_in_use[i] = true;
 8009cf4:	ebc3 1403 	rsb	r4, r3, r3, lsl #4
            req = &sd_requests[i];
 8009cf8:	4e0c      	ldr	r6, [pc, #48]	; (8009d2c <drv_sd_thread_alloc+0x5c>)
            sd_request_in_use[i] = true;
 8009cfa:	2701      	movs	r7, #1
 8009cfc:	4a0c      	ldr	r2, [pc, #48]	; (8009d30 <drv_sd_thread_alloc+0x60>)
 8009cfe:	00a5      	lsls	r5, r4, #2
            req = &sd_requests[i];
 8009d00:	eb06 0484 	add.w	r4, r6, r4, lsl #2
            sd_request_in_use[i] = true;
 8009d04:	54d7      	strb	r7, [r2, r3]
            memset(req, 0, sizeof(*req));
 8009d06:	223c      	movs	r2, #60	; 0x3c
 8009d08:	4620      	mov	r0, r4
 8009d0a:	f004 fd6b 	bl	800e7e4 <memset>
  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8009d0e:	1d28      	adds	r0, r5, #4
 8009d10:	4639      	mov	r1, r7
 8009d12:	4430      	add	r0, r6
 8009d14:	f7fc fd00 	bl	8006718 <chSemObjectInit>
    chMtxUnlock(&sd_alloc_mutex);
 8009d18:	4802      	ldr	r0, [pc, #8]	; (8009d24 <drv_sd_thread_alloc+0x54>)
 8009d1a:	f7fc fdc9 	bl	80068b0 <chMtxUnlock>
}
 8009d1e:	4620      	mov	r0, r4
 8009d20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009d22:	bf00      	nop
 8009d24:	24004420 	.word	0x24004420
 8009d28:	24004477 	.word	0x24004477
 8009d2c:	24004480 	.word	0x24004480
 8009d30:	24004478 	.word	0x24004478

08009d34 <drv_sd_thread_release>:
    if (req == NULL) {
 8009d34:	b190      	cbz	r0, 8009d5c <drv_sd_thread_release+0x28>
void drv_sd_thread_release(sd_request_t *req) {
 8009d36:	b510      	push	{r4, lr}
 8009d38:	4604      	mov	r4, r0
    chMtxLock(&sd_alloc_mutex);
 8009d3a:	480d      	ldr	r0, [pc, #52]	; (8009d70 <drv_sd_thread_release+0x3c>)
 8009d3c:	f7fc fdae 	bl	800689c <chMtxLock>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009d40:	4b0c      	ldr	r3, [pc, #48]	; (8009d74 <drv_sd_thread_release+0x40>)
 8009d42:	2200      	movs	r2, #0
        if (&sd_requests[i] == req) {
 8009d44:	429c      	cmp	r4, r3
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009d46:	f103 033c 	add.w	r3, r3, #60	; 0x3c
        if (&sd_requests[i] == req) {
 8009d4a:	d008      	beq.n	8009d5e <drv_sd_thread_release+0x2a>
    for (size_t i = 0; i < SD_FIFO_DEPTH; ++i) {
 8009d4c:	3201      	adds	r2, #1
 8009d4e:	2a08      	cmp	r2, #8
 8009d50:	d1f8      	bne.n	8009d44 <drv_sd_thread_release+0x10>
    chMtxUnlock(&sd_alloc_mutex);
 8009d52:	4807      	ldr	r0, [pc, #28]	; (8009d70 <drv_sd_thread_release+0x3c>)
}
 8009d54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chMtxUnlock(&sd_alloc_mutex);
 8009d58:	f7fc bdaa 	b.w	80068b0 <chMtxUnlock>
 8009d5c:	4770      	bx	lr
            sd_request_in_use[i] = false;
 8009d5e:	4b06      	ldr	r3, [pc, #24]	; (8009d78 <drv_sd_thread_release+0x44>)
 8009d60:	2100      	movs	r1, #0
    chMtxUnlock(&sd_alloc_mutex);
 8009d62:	4803      	ldr	r0, [pc, #12]	; (8009d70 <drv_sd_thread_release+0x3c>)
            sd_request_in_use[i] = false;
 8009d64:	5499      	strb	r1, [r3, r2]
}
 8009d66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chMtxUnlock(&sd_alloc_mutex);
 8009d6a:	f7fc bda1 	b.w	80068b0 <chMtxUnlock>
 8009d6e:	bf00      	nop
 8009d70:	24004420 	.word	0x24004420
 8009d74:	24004480 	.word	0x24004480
 8009d78:	24004478 	.word	0x24004478

08009d7c <drv_sd_thread_post>:

bool drv_sd_thread_post(sd_request_t *req) {
    if (req == NULL) {
 8009d7c:	4601      	mov	r1, r0
 8009d7e:	b168      	cbz	r0, 8009d9c <drv_sd_thread_post+0x20>
        return false;
    }
    msg_t msg = (msg_t)req;
    msg_t status = chMBPostTimeout(&sd_mb, msg, TIME_IMMEDIATE);
 8009d80:	2200      	movs	r2, #0
 8009d82:	4807      	ldr	r0, [pc, #28]	; (8009da0 <drv_sd_thread_post+0x24>)
bool drv_sd_thread_post(sd_request_t *req) {
 8009d84:	b508      	push	{r3, lr}
    msg_t status = chMBPostTimeout(&sd_mb, msg, TIME_IMMEDIATE);
 8009d86:	f7fc fe35 	bl	80069f4 <chMBPostTimeout>
    if (status != MSG_OK) {
 8009d8a:	b908      	cbnz	r0, 8009d90 <drv_sd_thread_post+0x14>
        g_sd_stats.busy_rejections++;
        return false;
    }
    return true;
 8009d8c:	2001      	movs	r0, #1
}
 8009d8e:	bd08      	pop	{r3, pc}
        g_sd_stats.busy_rejections++;
 8009d90:	4a04      	ldr	r2, [pc, #16]	; (8009da4 <drv_sd_thread_post+0x28>)
        return false;
 8009d92:	2000      	movs	r0, #0
        g_sd_stats.busy_rejections++;
 8009d94:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8009d96:	3301      	adds	r3, #1
 8009d98:	6393      	str	r3, [r2, #56]	; 0x38
}
 8009d9a:	bd08      	pop	{r3, pc}
 8009d9c:	4770      	bx	lr
 8009d9e:	bf00      	nop
 8009da0:	24004450 	.word	0x24004450
 8009da4:	240037a8 	.word	0x240037a8

08009da8 <disk_status>:
/*-----------------------------------------------------------------------*/
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status(BYTE pdrv) {
    if (pdrv != DEV_MMC) {
 8009da8:	b108      	cbz	r0, 8009dae <disk_status+0x6>
        return STA_NOINIT;
 8009daa:	2001      	movs	r0, #1
    if (!drv_sd_hal_is_card_present()) {
        sd_status = STA_NOINIT | STA_NODISK;
    }

    return sd_status;
}
 8009dac:	4770      	bx	lr
DSTATUS disk_status(BYTE pdrv) {
 8009dae:	b508      	push	{r3, lr}
    if (!drv_sd_hal_is_card_present()) {
 8009db0:	f7ff f940 	bl	8009034 <drv_sd_hal_is_card_present>
 8009db4:	b110      	cbz	r0, 8009dbc <disk_status+0x14>
    return sd_status;
 8009db6:	4b04      	ldr	r3, [pc, #16]	; (8009dc8 <disk_status+0x20>)
 8009db8:	7818      	ldrb	r0, [r3, #0]
}
 8009dba:	bd08      	pop	{r3, pc}
        sd_status = STA_NOINIT | STA_NODISK;
 8009dbc:	2303      	movs	r3, #3
 8009dbe:	4a02      	ldr	r2, [pc, #8]	; (8009dc8 <disk_status+0x20>)
 8009dc0:	4618      	mov	r0, r3
 8009dc2:	7013      	strb	r3, [r2, #0]
}
 8009dc4:	bd08      	pop	{r3, pc}
 8009dc6:	bf00      	nop
 8009dc8:	24000018 	.word	0x24000018

08009dcc <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Inidialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(BYTE pdrv) {
    if (pdrv != DEV_MMC) {
 8009dcc:	b108      	cbz	r0, 8009dd2 <disk_initialize+0x6>
        return STA_NOINIT;
 8009dce:	2001      	movs	r0, #1
        return sd_status;
    }

    sd_status = 0U;
    return sd_status;
}
 8009dd0:	4770      	bx	lr
DSTATUS disk_initialize(BYTE pdrv) {
 8009dd2:	b508      	push	{r3, lr}
    drv_sd_hal_init();
 8009dd4:	f7ff f918 	bl	8009008 <drv_sd_hal_init>
    if (!drv_sd_hal_is_card_present()) {
 8009dd8:	f7ff f92c 	bl	8009034 <drv_sd_hal_is_card_present>
 8009ddc:	b128      	cbz	r0, 8009dea <disk_initialize+0x1e>
    sd_hal_status_t status = drv_sd_hal_connect();
 8009dde:	f7ff f92f 	bl	8009040 <drv_sd_hal_connect>
    if (status != SD_HAL_OK) {
 8009de2:	b938      	cbnz	r0, 8009df4 <disk_initialize+0x28>
    sd_status = 0U;
 8009de4:	4b06      	ldr	r3, [pc, #24]	; (8009e00 <disk_initialize+0x34>)
 8009de6:	7018      	strb	r0, [r3, #0]
}
 8009de8:	bd08      	pop	{r3, pc}
        sd_status = STA_NOINIT | STA_NODISK;
 8009dea:	2303      	movs	r3, #3
 8009dec:	4a04      	ldr	r2, [pc, #16]	; (8009e00 <disk_initialize+0x34>)
        return sd_status;
 8009dee:	4618      	mov	r0, r3
        sd_status = STA_NOINIT | STA_NODISK;
 8009df0:	7013      	strb	r3, [r2, #0]
}
 8009df2:	bd08      	pop	{r3, pc}
        sd_status = STA_NOINIT;
 8009df4:	2301      	movs	r3, #1
 8009df6:	4a02      	ldr	r2, [pc, #8]	; (8009e00 <disk_initialize+0x34>)
        return sd_status;
 8009df8:	4618      	mov	r0, r3
        sd_status = STA_NOINIT;
 8009dfa:	7013      	strb	r3, [r2, #0]
}
 8009dfc:	bd08      	pop	{r3, pc}
 8009dfe:	bf00      	nop
 8009e00:	24000018 	.word	0x24000018

08009e04 <disk_read>:
/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/

DRESULT disk_read(BYTE pdrv, BYTE *buff, LBA_t sector, UINT count) {
    if (pdrv != DEV_MMC || buff == NULL || count == 0U) {
 8009e04:	2b00      	cmp	r3, #0
 8009e06:	bf18      	it	ne
 8009e08:	2900      	cmpne	r1, #0
 8009e0a:	d014      	beq.n	8009e36 <disk_read+0x32>
 8009e0c:	b998      	cbnz	r0, 8009e36 <disk_read+0x32>
DRESULT disk_read(BYTE pdrv, BYTE *buff, LBA_t sector, UINT count) {
 8009e0e:	b570      	push	{r4, r5, r6, lr}
 8009e10:	460c      	mov	r4, r1
 8009e12:	4616      	mov	r6, r2
 8009e14:	461d      	mov	r5, r3
        return RES_PARERR;
    }

    if (!drv_sd_hal_is_card_present()) {
 8009e16:	f7ff f90d 	bl	8009034 <drv_sd_hal_is_card_present>
 8009e1a:	b170      	cbz	r0, 8009e3a <disk_read+0x36>
        sd_status = STA_NOINIT | STA_NODISK;
        return RES_NOTRDY;
    }

    (void)drv_sd_hal_connect();
 8009e1c:	f7ff f910 	bl	8009040 <drv_sd_hal_connect>

    sd_hal_status_t status = drv_sd_hal_read_blocks(buff, (uint32_t)sector, (uint32_t)count);
 8009e20:	462a      	mov	r2, r5
 8009e22:	4631      	mov	r1, r6
 8009e24:	4620      	mov	r0, r4
 8009e26:	f7ff f935 	bl	8009094 <drv_sd_hal_read_blocks>
    switch (status) {
 8009e2a:	b118      	cbz	r0, 8009e34 <disk_read+0x30>
 8009e2c:	2801      	cmp	r0, #1
 8009e2e:	bf14      	ite	ne
 8009e30:	2001      	movne	r0, #1
 8009e32:	2003      	moveq	r0, #3
    return sd_map_status(status);
}
 8009e34:	bd70      	pop	{r4, r5, r6, pc}
        return RES_PARERR;
 8009e36:	2004      	movs	r0, #4
}
 8009e38:	4770      	bx	lr
        sd_status = STA_NOINIT | STA_NODISK;
 8009e3a:	2303      	movs	r3, #3
 8009e3c:	4a01      	ldr	r2, [pc, #4]	; (8009e44 <disk_read+0x40>)
        return RES_NOTRDY;
 8009e3e:	4618      	mov	r0, r3
        sd_status = STA_NOINIT | STA_NODISK;
 8009e40:	7013      	strb	r3, [r2, #0]
}
 8009e42:	bd70      	pop	{r4, r5, r6, pc}
 8009e44:	24000018 	.word	0x24000018

08009e48 <disk_write>:
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/

#if FF_FS_READONLY == 0
DRESULT disk_write(BYTE pdrv, const BYTE *buff, LBA_t sector, UINT count) {
    if (pdrv != DEV_MMC || buff == NULL || count == 0U) {
 8009e48:	2b00      	cmp	r3, #0
 8009e4a:	bf18      	it	ne
 8009e4c:	2900      	cmpne	r1, #0
 8009e4e:	d014      	beq.n	8009e7a <disk_write+0x32>
 8009e50:	b998      	cbnz	r0, 8009e7a <disk_write+0x32>
DRESULT disk_write(BYTE pdrv, const BYTE *buff, LBA_t sector, UINT count) {
 8009e52:	b570      	push	{r4, r5, r6, lr}
 8009e54:	460c      	mov	r4, r1
 8009e56:	4616      	mov	r6, r2
 8009e58:	461d      	mov	r5, r3
        return RES_PARERR;
    }

    if (!drv_sd_hal_is_card_present()) {
 8009e5a:	f7ff f8eb 	bl	8009034 <drv_sd_hal_is_card_present>
 8009e5e:	b170      	cbz	r0, 8009e7e <disk_write+0x36>
        sd_status = STA_NOINIT | STA_NODISK;
        return RES_NOTRDY;
    }

    (void)drv_sd_hal_connect();
 8009e60:	f7ff f8ee 	bl	8009040 <drv_sd_hal_connect>

    sd_hal_status_t status = drv_sd_hal_write_blocks(buff, (uint32_t)sector, (uint32_t)count);
 8009e64:	462a      	mov	r2, r5
 8009e66:	4631      	mov	r1, r6
 8009e68:	4620      	mov	r0, r4
 8009e6a:	f7ff f939 	bl	80090e0 <drv_sd_hal_write_blocks>
    switch (status) {
 8009e6e:	b118      	cbz	r0, 8009e78 <disk_write+0x30>
 8009e70:	2801      	cmp	r0, #1
 8009e72:	bf14      	ite	ne
 8009e74:	2001      	movne	r0, #1
 8009e76:	2003      	moveq	r0, #3
    return sd_map_status(status);
}
 8009e78:	bd70      	pop	{r4, r5, r6, pc}
        return RES_PARERR;
 8009e7a:	2004      	movs	r0, #4
}
 8009e7c:	4770      	bx	lr
        sd_status = STA_NOINIT | STA_NODISK;
 8009e7e:	2303      	movs	r3, #3
 8009e80:	4a01      	ldr	r2, [pc, #4]	; (8009e88 <disk_write+0x40>)
        return RES_NOTRDY;
 8009e82:	4618      	mov	r0, r3
        sd_status = STA_NOINIT | STA_NODISK;
 8009e84:	7013      	strb	r3, [r2, #0]
}
 8009e86:	bd70      	pop	{r4, r5, r6, pc}
 8009e88:	24000018 	.word	0x24000018

08009e8c <disk_ioctl>:
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void *buff) {
    if (pdrv != DEV_MMC) {
 8009e8c:	bb28      	cbnz	r0, 8009eda <disk_ioctl+0x4e>
DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void *buff) {
 8009e8e:	b530      	push	{r4, r5, lr}
 8009e90:	b083      	sub	sp, #12
 8009e92:	460c      	mov	r4, r1
 8009e94:	4615      	mov	r5, r2
        return RES_PARERR;
    }

    if (!drv_sd_hal_is_card_present()) {
 8009e96:	f7ff f8cd 	bl	8009034 <drv_sd_hal_is_card_present>
 8009e9a:	b300      	cbz	r0, 8009ede <disk_ioctl+0x52>
        return RES_NOTRDY;
    }

    if ((buff == NULL) && (cmd != CTRL_SYNC)) {
 8009e9c:	b905      	cbnz	r5, 8009ea0 <disk_ioctl+0x14>
 8009e9e:	b92c      	cbnz	r4, 8009eac <disk_ioctl+0x20>
        return RES_PARERR;
    }

    switch (cmd) {
 8009ea0:	2c03      	cmp	r4, #3
 8009ea2:	d803      	bhi.n	8009eac <disk_ioctl+0x20>
 8009ea4:	e8df f004 	tbb	[pc, r4]
 8009ea8:	05090e15 	.word	0x05090e15
 8009eac:	2004      	movs	r0, #4
        *((DWORD *)buff) = 1U;
        return RES_OK;
    default:
        return RES_PARERR;
    }
}
 8009eae:	b003      	add	sp, #12
 8009eb0:	bd30      	pop	{r4, r5, pc}
        *((DWORD *)buff) = 1U;
 8009eb2:	2301      	movs	r3, #1
        return RES_OK;
 8009eb4:	2000      	movs	r0, #0
        *((DWORD *)buff) = 1U;
 8009eb6:	602b      	str	r3, [r5, #0]
        return RES_OK;
 8009eb8:	e7f9      	b.n	8009eae <disk_ioctl+0x22>
        *((WORD *)buff) = (WORD)MMCSD_BLOCK_SIZE;
 8009eba:	f44f 7300 	mov.w	r3, #512	; 0x200
        return RES_OK;
 8009ebe:	2000      	movs	r0, #0
        *((WORD *)buff) = (WORD)MMCSD_BLOCK_SIZE;
 8009ec0:	802b      	strh	r3, [r5, #0]
        return RES_OK;
 8009ec2:	e7f4      	b.n	8009eae <disk_ioctl+0x22>
        if (drv_sd_hal_get_info(&info) != SD_HAL_OK) {
 8009ec4:	4668      	mov	r0, sp
 8009ec6:	f7ff f937 	bl	8009138 <drv_sd_hal_get_info>
 8009eca:	b958      	cbnz	r0, 8009ee4 <disk_ioctl+0x58>
        *((LBA_t *)buff) = (LBA_t)info.blk_num;
 8009ecc:	9b01      	ldr	r3, [sp, #4]
 8009ece:	602b      	str	r3, [r5, #0]
        return RES_OK;
 8009ed0:	e7ed      	b.n	8009eae <disk_ioctl+0x22>
        drv_sd_hal_sync();
 8009ed2:	f7ff f92b 	bl	800912c <drv_sd_hal_sync>
        return RES_OK;
 8009ed6:	4620      	mov	r0, r4
 8009ed8:	e7e9      	b.n	8009eae <disk_ioctl+0x22>
        return RES_PARERR;
 8009eda:	2004      	movs	r0, #4
}
 8009edc:	4770      	bx	lr
        return RES_NOTRDY;
 8009ede:	2003      	movs	r0, #3
}
 8009ee0:	b003      	add	sp, #12
 8009ee2:	bd30      	pop	{r4, r5, pc}
            return RES_ERROR;
 8009ee4:	4620      	mov	r0, r4
 8009ee6:	e7e2      	b.n	8009eae <disk_ioctl+0x22>

08009ee8 <get_ldnumber>:
/*-----------------------------------------------------------------------*/

static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
	const TCHAR** path		/* Pointer to pointer to the path name */
)
{
 8009ee8:	4601      	mov	r1, r0
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *vsp;
	char vchr;
#endif

	tt = tp = *path;
 8009eea:	6800      	ldr	r0, [r0, #0]
	if (!tp) return -1;		/* Invalid path name? */
 8009eec:	b1a0      	cbz	r0, 8009f18 <get_ldnumber+0x30>
 8009eee:	4602      	mov	r2, r0
	do {					/* Find a colon in the path */
		chr = *tt++;
 8009ef0:	f812 3b01 	ldrb.w	r3, [r2], #1
	} while (!IsTerminator(chr) && chr != ':');
 8009ef4:	2b20      	cmp	r3, #32
 8009ef6:	d90b      	bls.n	8009f10 <get_ldnumber+0x28>
 8009ef8:	2b3a      	cmp	r3, #58	; 0x3a
 8009efa:	d1f9      	bne.n	8009ef0 <get_ldnumber+0x8>

	if (chr == ':') {	/* Is there a DOS/Windows style volume ID? */
		i = FF_VOLUMES;
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is it a numeric volume ID + colon? */
 8009efc:	1c83      	adds	r3, r0, #2
					if (IsLower(chr)) chr -= 0x20;
				} while (vchr && (TCHAR)vchr == chr);
			} while ((vchr || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
		}
#endif
		if (i >= FF_VOLUMES) return -1;	/* Not found or invalid volume ID */
 8009efe:	429a      	cmp	r2, r3
 8009f00:	d10a      	bne.n	8009f18 <get_ldnumber+0x30>
 8009f02:	7800      	ldrb	r0, [r0, #0]
 8009f04:	3830      	subs	r0, #48	; 0x30
 8009f06:	bf18      	it	ne
 8009f08:	2001      	movne	r0, #1
 8009f0a:	b928      	cbnz	r0, 8009f18 <get_ldnumber+0x30>
		*path = tt;		/* Snip the drive prefix off */
 8009f0c:	600a      	str	r2, [r1, #0]
		return i;		/* Return the found drive number */
 8009f0e:	4770      	bx	lr
	if (chr == ':') {	/* Is there a DOS/Windows style volume ID? */
 8009f10:	2b3a      	cmp	r3, #58	; 0x3a
 8009f12:	d0f3      	beq.n	8009efc <get_ldnumber+0x14>
#endif
	/* No drive prefix */
#if FF_FS_RPATH
	return (int)CurrVol;	/* Default drive is current drive */
#else
	return 0;				/* Default drive is 0 */
 8009f14:	2000      	movs	r0, #0
 8009f16:	4770      	bx	lr
	if (!tp) return -1;		/* Invalid path name? */
 8009f18:	f04f 30ff 	mov.w	r0, #4294967295
#endif
}
 8009f1c:	4770      	bx	lr
 8009f1e:	bf00      	nop

08009f20 <validate>:

static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR structure, to check validity */
	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
)
{
 8009f20:	b538      	push	{r3, r4, r5, lr}
 8009f22:	460d      	mov	r5, r1
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8009f24:	b140      	cbz	r0, 8009f38 <validate+0x18>
 8009f26:	6803      	ldr	r3, [r0, #0]
 8009f28:	4604      	mov	r4, r0
 8009f2a:	b12b      	cbz	r3, 8009f38 <validate+0x18>
 8009f2c:	781a      	ldrb	r2, [r3, #0]
 8009f2e:	b11a      	cbz	r2, 8009f38 <validate+0x18>
 8009f30:	8880      	ldrh	r0, [r0, #4]
 8009f32:	88da      	ldrh	r2, [r3, #6]
 8009f34:	4290      	cmp	r0, r2
 8009f36:	d003      	beq.n	8009f40 <validate+0x20>
	FRESULT res = FR_INVALID_OBJECT;
 8009f38:	2009      	movs	r0, #9
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the hosting physical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Return corresponding filesystem object if it is valid */
 8009f3a:	2300      	movs	r3, #0
 8009f3c:	602b      	str	r3, [r5, #0]
	return res;
}
 8009f3e:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the hosting physical drive is kept initialized */
 8009f40:	7858      	ldrb	r0, [r3, #1]
 8009f42:	f7ff ff31 	bl	8009da8 <disk_status>
 8009f46:	f010 0001 	ands.w	r0, r0, #1
 8009f4a:	d1f5      	bne.n	8009f38 <validate+0x18>
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Return corresponding filesystem object if it is valid */
 8009f4c:	6823      	ldr	r3, [r4, #0]
 8009f4e:	e7f5      	b.n	8009f3c <validate+0x1c>

08009f50 <sync_window.part.0>:
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 8009f50:	b570      	push	{r4, r5, r6, lr}
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
 8009f52:	f100 0630 	add.w	r6, r0, #48	; 0x30
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 8009f56:	4604      	mov	r4, r0
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
 8009f58:	69c2      	ldr	r2, [r0, #28]
 8009f5a:	2301      	movs	r3, #1
 8009f5c:	4631      	mov	r1, r6
 8009f5e:	7840      	ldrb	r0, [r0, #1]
 8009f60:	f7ff ff72 	bl	8009e48 <disk_write>
 8009f64:	b960      	cbnz	r0, 8009f80 <sync_window.part.0+0x30>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8009f66:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009f68:	4605      	mov	r5, r0
			fs->wflag = 0;	/* Clear window dirty flag */
 8009f6a:	7120      	strb	r0, [r4, #4]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8009f6c:	e9d4 2106 	ldrd	r2, r1, [r4, #24]
 8009f70:	1acb      	subs	r3, r1, r3
 8009f72:	4293      	cmp	r3, r2
 8009f74:	d202      	bcs.n	8009f7c <sync_window.part.0+0x2c>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8009f76:	78e3      	ldrb	r3, [r4, #3]
 8009f78:	2b02      	cmp	r3, #2
 8009f7a:	d004      	beq.n	8009f86 <sync_window.part.0+0x36>
}
 8009f7c:	4628      	mov	r0, r5
 8009f7e:	bd70      	pop	{r4, r5, r6, pc}
			res = FR_DISK_ERR;
 8009f80:	2501      	movs	r5, #1
}
 8009f82:	4628      	mov	r0, r5
 8009f84:	bd70      	pop	{r4, r5, r6, pc}
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8009f86:	440a      	add	r2, r1
 8009f88:	7860      	ldrb	r0, [r4, #1]
 8009f8a:	4631      	mov	r1, r6
 8009f8c:	2301      	movs	r3, #1
 8009f8e:	f7ff ff5b 	bl	8009e48 <disk_write>
 8009f92:	e7f3      	b.n	8009f7c <sync_window.part.0+0x2c>

08009f94 <dir_clear>:
{
 8009f94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Is the disk access window dirty? */
 8009f96:	7903      	ldrb	r3, [r0, #4]
{
 8009f98:	4605      	mov	r5, r0
 8009f9a:	460c      	mov	r4, r1
	if (fs->wflag) {	/* Is the disk access window dirty? */
 8009f9c:	bb33      	cbnz	r3, 8009fec <dir_clear+0x58>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8009f9e:	696b      	ldr	r3, [r5, #20]
	clst -= 2;		/* Cluster number is origin from 2 */
 8009fa0:	1ea1      	subs	r1, r4, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8009fa2:	3b02      	subs	r3, #2
 8009fa4:	4299      	cmp	r1, r3
 8009fa6:	d227      	bcs.n	8009ff8 <dir_clear+0x64>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 8009fa8:	896b      	ldrh	r3, [r5, #10]
 8009faa:	6aee      	ldr	r6, [r5, #44]	; 0x2c
 8009fac:	fb01 6603 	mla	r6, r1, r3, r6
	memset(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 8009fb0:	f105 0730 	add.w	r7, r5, #48	; 0x30
 8009fb4:	f44f 7200 	mov.w	r2, #512	; 0x200
 8009fb8:	2100      	movs	r1, #0
	fs->winsect = sect;				/* Set window to top of the cluster */
 8009fba:	61ee      	str	r6, [r5, #28]
	memset(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 8009fbc:	4638      	mov	r0, r7
 8009fbe:	f004 fc11 	bl	800e7e4 <memset>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 8009fc2:	896b      	ldrh	r3, [r5, #10]
 8009fc4:	b1d3      	cbz	r3, 8009ffc <dir_clear+0x68>
 8009fc6:	2400      	movs	r4, #0
 8009fc8:	e003      	b.n	8009fd2 <dir_clear+0x3e>
 8009fca:	3401      	adds	r4, #1
 8009fcc:	896b      	ldrh	r3, [r5, #10]
 8009fce:	42a3      	cmp	r3, r4
 8009fd0:	d908      	bls.n	8009fe4 <dir_clear+0x50>
 8009fd2:	1932      	adds	r2, r6, r4
 8009fd4:	2301      	movs	r3, #1
 8009fd6:	4639      	mov	r1, r7
 8009fd8:	7868      	ldrb	r0, [r5, #1]
 8009fda:	f7ff ff35 	bl	8009e48 <disk_write>
 8009fde:	2800      	cmp	r0, #0
 8009fe0:	d0f3      	beq.n	8009fca <dir_clear+0x36>
 8009fe2:	896b      	ldrh	r3, [r5, #10]
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 8009fe4:	1ae0      	subs	r0, r4, r3
 8009fe6:	bf18      	it	ne
 8009fe8:	2001      	movne	r0, #1
}
 8009fea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009fec:	f7ff ffb0 	bl	8009f50 <sync_window.part.0>
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8009ff0:	2800      	cmp	r0, #0
 8009ff2:	d0d4      	beq.n	8009f9e <dir_clear+0xa>
 8009ff4:	2001      	movs	r0, #1
}
 8009ff6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8009ff8:	2600      	movs	r6, #0
 8009ffa:	e7d9      	b.n	8009fb0 <dir_clear+0x1c>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 8009ffc:	461c      	mov	r4, r3
 8009ffe:	e7f1      	b.n	8009fe4 <dir_clear+0x50>

0800a000 <sync_fs>:
{
 800a000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Is the disk access window dirty? */
 800a002:	7903      	ldrb	r3, [r0, #4]
{
 800a004:	4604      	mov	r4, r0
	if (fs->wflag) {	/* Is the disk access window dirty? */
 800a006:	b95b      	cbnz	r3, 800a020 <sync_fs+0x20>
		if (fs->fsi_flag == 1) {	/* Allocation changed? */
 800a008:	7965      	ldrb	r5, [r4, #5]
 800a00a:	2d01      	cmp	r5, #1
 800a00c:	d00f      	beq.n	800a02e <sync_fs+0x2e>
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 800a00e:	2200      	movs	r2, #0
 800a010:	7860      	ldrb	r0, [r4, #1]
 800a012:	4611      	mov	r1, r2
 800a014:	f7ff ff3a 	bl	8009e8c <disk_ioctl>
 800a018:	3800      	subs	r0, #0
 800a01a:	bf18      	it	ne
 800a01c:	2001      	movne	r0, #1
}
 800a01e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a020:	f7ff ff96 	bl	8009f50 <sync_window.part.0>
	if (res == FR_OK) {
 800a024:	2800      	cmp	r0, #0
 800a026:	d1fa      	bne.n	800a01e <sync_fs+0x1e>
		if (fs->fsi_flag == 1) {	/* Allocation changed? */
 800a028:	7965      	ldrb	r5, [r4, #5]
 800a02a:	2d01      	cmp	r5, #1
 800a02c:	d1ef      	bne.n	800a00e <sync_fs+0xe>
			if (fs->fs_type == FS_FAT32) {	/* FAT32: Update FSInfo sector */
 800a02e:	7823      	ldrb	r3, [r4, #0]
			fs->fsi_flag = 0;
 800a030:	2600      	movs	r6, #0
			if (fs->fs_type == FS_FAT32) {	/* FAT32: Update FSInfo sector */
 800a032:	2b03      	cmp	r3, #3
			fs->fsi_flag = 0;
 800a034:	7166      	strb	r6, [r4, #5]
			if (fs->fs_type == FS_FAT32) {	/* FAT32: Update FSInfo sector */
 800a036:	d1ea      	bne.n	800a00e <sync_fs+0xe>
				memset(fs->win, 0, sizeof fs->win);
 800a038:	f104 0730 	add.w	r7, r4, #48	; 0x30
 800a03c:	4631      	mov	r1, r6
 800a03e:	f44f 7200 	mov.w	r2, #512	; 0x200
 800a042:	4638      	mov	r0, r7
 800a044:	f004 fbce 	bl	800e7e4 <memset>
	*ptr++ = (BYTE)val; val >>= 8;
 800a048:	2252      	movs	r2, #82	; 0x52
	*ptr++ = (BYTE)val; val >>= 8;
 800a04a:	2055      	movs	r0, #85	; 0x55
				disk_write(fs->pdrv, fs->win, fs->winsect = fs->volbase + 1, 1);	/* Write it into the FSInfo sector (Next to VBR) */
 800a04c:	462b      	mov	r3, r5
	*ptr++ = (BYTE)val; val >>= 8;
 800a04e:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
	*ptr++ = (BYTE)val;
 800a052:	2541      	movs	r5, #65	; 0x41
	*ptr++ = (BYTE)val; val >>= 8;
 800a054:	f884 2031 	strb.w	r2, [r4, #49]	; 0x31
	*ptr++ = (BYTE)val; val >>= 8;
 800a058:	2261      	movs	r2, #97	; 0x61
 800a05a:	f884 022e 	strb.w	r0, [r4, #558]	; 0x22e
				disk_write(fs->pdrv, fs->win, fs->winsect = fs->volbase + 1, 1);	/* Write it into the FSInfo sector (Next to VBR) */
 800a05e:	4639      	mov	r1, r7
	*ptr++ = (BYTE)val; val >>= 8;
 800a060:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
	*ptr++ = (BYTE)val;
 800a064:	f884 2217 	strb.w	r2, [r4, #535]	; 0x217
				st_32(fs->win + FSI_Free_Count, fs->free_clst);	/* Number of free clusters */
 800a068:	6922      	ldr	r2, [r4, #16]
	*ptr++ = (BYTE)val;
 800a06a:	f884 5033 	strb.w	r5, [r4, #51]	; 0x33
	*ptr++ = (BYTE)val; val >>= 8;
 800a06e:	0a10      	lsrs	r0, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800a070:	f884 5216 	strb.w	r5, [r4, #534]	; 0x216
	*ptr++ = (BYTE)val; val >>= 8;
 800a074:	2572      	movs	r5, #114	; 0x72
 800a076:	f884 2218 	strb.w	r2, [r4, #536]	; 0x218
	*ptr++ = (BYTE)val; val >>= 8;
 800a07a:	f884 0219 	strb.w	r0, [r4, #537]	; 0x219
 800a07e:	0c10      	lsrs	r0, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800a080:	f884 5214 	strb.w	r5, [r4, #532]	; 0x214
	*ptr++ = (BYTE)val; val >>= 8;
 800a084:	0e12      	lsrs	r2, r2, #24
 800a086:	f884 021a 	strb.w	r0, [r4, #538]	; 0x21a
				st_32(fs->win + FSI_Nxt_Free, fs->last_clst);	/* Last allocated culuster */
 800a08a:	68e0      	ldr	r0, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 800a08c:	f884 5215 	strb.w	r5, [r4, #533]	; 0x215
	*ptr++ = (BYTE)val; val >>= 8;
 800a090:	0a05      	lsrs	r5, r0, #8
	*ptr++ = (BYTE)val;
 800a092:	f884 221b 	strb.w	r2, [r4, #539]	; 0x21b
	*ptr++ = (BYTE)val; val >>= 8;
 800a096:	f884 021c 	strb.w	r0, [r4, #540]	; 0x21c
				disk_write(fs->pdrv, fs->win, fs->winsect = fs->volbase + 1, 1);	/* Write it into the FSInfo sector (Next to VBR) */
 800a09a:	6a22      	ldr	r2, [r4, #32]
	*ptr++ = (BYTE)val; val >>= 8;
 800a09c:	f884 521d 	strb.w	r5, [r4, #541]	; 0x21d
 800a0a0:	0c05      	lsrs	r5, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800a0a2:	0e00      	lsrs	r0, r0, #24
				disk_write(fs->pdrv, fs->win, fs->winsect = fs->volbase + 1, 1);	/* Write it into the FSInfo sector (Next to VBR) */
 800a0a4:	3201      	adds	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 800a0a6:	f884 622c 	strb.w	r6, [r4, #556]	; 0x22c
	*ptr++ = (BYTE)val;
 800a0aa:	f884 021f 	strb.w	r0, [r4, #543]	; 0x21f
 800a0ae:	20aa      	movs	r0, #170	; 0xaa
	*ptr++ = (BYTE)val; val >>= 8;
 800a0b0:	f884 622d 	strb.w	r6, [r4, #557]	; 0x22d
	*ptr++ = (BYTE)val;
 800a0b4:	f884 022f 	strb.w	r0, [r4, #559]	; 0x22f
				disk_write(fs->pdrv, fs->win, fs->winsect = fs->volbase + 1, 1);	/* Write it into the FSInfo sector (Next to VBR) */
 800a0b8:	61e2      	str	r2, [r4, #28]
 800a0ba:	7860      	ldrb	r0, [r4, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 800a0bc:	f884 521e 	strb.w	r5, [r4, #542]	; 0x21e
				disk_write(fs->pdrv, fs->win, fs->winsect = fs->volbase + 1, 1);	/* Write it into the FSInfo sector (Next to VBR) */
 800a0c0:	f7ff fec2 	bl	8009e48 <disk_write>
 800a0c4:	e7a3      	b.n	800a00e <sync_fs+0xe>
 800a0c6:	bf00      	nop

0800a0c8 <move_window>:
{
 800a0c8:	b538      	push	{r3, r4, r5, lr}
	if (sect != fs->winsect) {	/* Window offset changed? */
 800a0ca:	69c3      	ldr	r3, [r0, #28]
 800a0cc:	428b      	cmp	r3, r1
 800a0ce:	d015      	beq.n	800a0fc <move_window+0x34>
	if (fs->wflag) {	/* Is the disk access window dirty? */
 800a0d0:	7903      	ldrb	r3, [r0, #4]
 800a0d2:	4604      	mov	r4, r0
 800a0d4:	460d      	mov	r5, r1
 800a0d6:	b963      	cbnz	r3, 800a0f2 <move_window+0x2a>
			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
 800a0d8:	2301      	movs	r3, #1
 800a0da:	462a      	mov	r2, r5
 800a0dc:	f104 0130 	add.w	r1, r4, #48	; 0x30
 800a0e0:	7860      	ldrb	r0, [r4, #1]
 800a0e2:	f7ff fe8f 	bl	8009e04 <disk_read>
 800a0e6:	b110      	cbz	r0, 800a0ee <move_window+0x26>
				res = FR_DISK_ERR;
 800a0e8:	2001      	movs	r0, #1
				sect = (LBA_t)0 - 1;	/* Invalidate window if read data is not valid */
 800a0ea:	f04f 35ff 	mov.w	r5, #4294967295
			fs->winsect = sect;
 800a0ee:	61e5      	str	r5, [r4, #28]
}
 800a0f0:	bd38      	pop	{r3, r4, r5, pc}
 800a0f2:	f7ff ff2d 	bl	8009f50 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 800a0f6:	2800      	cmp	r0, #0
 800a0f8:	d0ee      	beq.n	800a0d8 <move_window+0x10>
 800a0fa:	e7f9      	b.n	800a0f0 <move_window+0x28>
	FRESULT res = FR_OK;
 800a0fc:	2000      	movs	r0, #0
}
 800a0fe:	bd38      	pop	{r3, r4, r5, pc}

0800a100 <get_fileinfo.part.0.constprop.0.isra.0>:
static void get_fileinfo (
 800a100:	b530      	push	{r4, r5, lr}
 800a102:	1e42      	subs	r2, r0, #1
	si = di = 0;
 800a104:	f04f 0e00 	mov.w	lr, #0
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 800a108:	252e      	movs	r5, #46	; 0x2e
 800a10a:	f100 040a 	add.w	r4, r0, #10
 800a10e:	e007      	b.n	800a120 <get_fileinfo.part.0.constprop.0.isra.0+0x20>
		fno->fname[di++] = c;
 800a110:	eb01 0c0e 	add.w	ip, r1, lr
 800a114:	f10e 0e01 	add.w	lr, lr, #1
 800a118:	f88c 3009 	strb.w	r3, [ip, #9]
	while (si < 11) {		/* Copy name body and extension */
 800a11c:	42a2      	cmp	r2, r4
 800a11e:	d012      	beq.n	800a146 <get_fileinfo.part.0.constprop.0.isra.0+0x46>
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
 800a120:	4694      	mov	ip, r2
		c = (TCHAR)dp->dir[si++];
 800a122:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		if (c == ' ') continue;		/* Skip padding spaces */
 800a126:	2b20      	cmp	r3, #32
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 800a128:	f1ac 0c07 	sub.w	ip, ip, #7
		if (c == ' ') continue;		/* Skip padding spaces */
 800a12c:	d0f6      	beq.n	800a11c <get_fileinfo.part.0.constprop.0.isra.0+0x1c>
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
 800a12e:	2b05      	cmp	r3, #5
 800a130:	bf08      	it	eq
 800a132:	23e5      	moveq	r3, #229	; 0xe5
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 800a134:	4584      	cmp	ip, r0
 800a136:	d1eb      	bne.n	800a110 <get_fileinfo.part.0.constprop.0.isra.0+0x10>
 800a138:	eb01 0c0e 	add.w	ip, r1, lr
 800a13c:	f10e 0e01 	add.w	lr, lr, #1
 800a140:	f88c 5009 	strb.w	r5, [ip, #9]
 800a144:	e7e4      	b.n	800a110 <get_fileinfo.part.0.constprop.0.isra.0+0x10>
	fno->fname[di] = 0;		/* Terminate the SFN */
 800a146:	2300      	movs	r3, #0
 800a148:	448e      	add	lr, r1
 800a14a:	f88e 3009 	strb.w	r3, [lr, #9]
	fno->fattrib = dp->dir[DIR_Attr] & AM_MASK;		/* Attribute */
 800a14e:	7ac3      	ldrb	r3, [r0, #11]
 800a150:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a154:	720b      	strb	r3, [r1, #8]
	rv = rv << 8 | ptr[0];
 800a156:	69c3      	ldr	r3, [r0, #28]
	fno->fsize = ld_32(dp->dir + DIR_FileSize);		/* Size */
 800a158:	600b      	str	r3, [r1, #0]
	fno->ftime = ld_16(dp->dir + DIR_ModTime + 0);	/* Last modified time */
 800a15a:	8ac3      	ldrh	r3, [r0, #22]
 800a15c:	80cb      	strh	r3, [r1, #6]
	fno->fdate = ld_16(dp->dir + DIR_ModTime + 2);	/* Last Modified date */
 800a15e:	8b03      	ldrh	r3, [r0, #24]
 800a160:	808b      	strh	r3, [r1, #4]
}
 800a162:	bd30      	pop	{r4, r5, pc}

0800a164 <get_fat.isra.0>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800a164:	2901      	cmp	r1, #1
 800a166:	d90e      	bls.n	800a186 <get_fat.isra.0+0x22>
static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 800a168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800a16a:	6943      	ldr	r3, [r0, #20]
 800a16c:	460c      	mov	r4, r1
 800a16e:	4605      	mov	r5, r0
 800a170:	4299      	cmp	r1, r3
 800a172:	d206      	bcs.n	800a182 <get_fat.isra.0+0x1e>
		switch (fs->fs_type) {
 800a174:	7803      	ldrb	r3, [r0, #0]
 800a176:	2b02      	cmp	r3, #2
 800a178:	d021      	beq.n	800a1be <get_fat.isra.0+0x5a>
 800a17a:	2b03      	cmp	r3, #3
 800a17c:	d010      	beq.n	800a1a0 <get_fat.isra.0+0x3c>
 800a17e:	2b01      	cmp	r3, #1
 800a180:	d003      	beq.n	800a18a <get_fat.isra.0+0x26>
 800a182:	2001      	movs	r0, #1
}
 800a184:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;	/* Internal error */
 800a186:	2001      	movs	r0, #1
}
 800a188:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800a18a:	6a41      	ldr	r1, [r0, #36]	; 0x24
			bc = (UINT)clst; bc += bc / 2;
 800a18c:	eb04 0754 	add.w	r7, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800a190:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 800a194:	f7ff ff98 	bl	800a0c8 <move_window>
 800a198:	b1f0      	cbz	r0, 800a1d8 <get_fat.isra.0+0x74>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800a19a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800a19e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800a1a0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800a1a2:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 800a1a6:	f7ff ff8f 	bl	800a0c8 <move_window>
 800a1aa:	2800      	cmp	r0, #0
 800a1ac:	d1f5      	bne.n	800a19a <get_fat.isra.0+0x36>
			val = ld_32(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 800a1ae:	00a4      	lsls	r4, r4, #2
 800a1b0:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800a1b4:	4425      	add	r5, r4
 800a1b6:	6b28      	ldr	r0, [r5, #48]	; 0x30
			val = ld_32(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 800a1b8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 800a1bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800a1be:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800a1c0:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 800a1c4:	f7ff ff80 	bl	800a0c8 <move_window>
 800a1c8:	2800      	cmp	r0, #0
 800a1ca:	d1e6      	bne.n	800a19a <get_fat.isra.0+0x36>
			val = ld_16(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 800a1cc:	0063      	lsls	r3, r4, #1
 800a1ce:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 800a1d2:	442b      	add	r3, r5
 800a1d4:	8e18      	ldrh	r0, [r3, #48]	; 0x30
}
 800a1d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800a1d8:	f3c7 0308 	ubfx	r3, r7, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800a1dc:	6a69      	ldr	r1, [r5, #36]	; 0x24
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800a1de:	3701      	adds	r7, #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800a1e0:	4628      	mov	r0, r5
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800a1e2:	442b      	add	r3, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800a1e4:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800a1e8:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800a1ec:	f7ff ff6c 	bl	800a0c8 <move_window>
 800a1f0:	2800      	cmp	r0, #0
 800a1f2:	d1d2      	bne.n	800a19a <get_fat.isra.0+0x36>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 800a1f4:	f3c7 0708 	ubfx	r7, r7, #0, #9
 800a1f8:	442f      	add	r7, r5
 800a1fa:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800a1fe:	ea46 2003 	orr.w	r0, r6, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 800a202:	07e3      	lsls	r3, r4, #31
 800a204:	bf4c      	ite	mi
 800a206:	0900      	lsrmi	r0, r0, #4
 800a208:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
}
 800a20c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a20e:	bf00      	nop

0800a210 <dir_sdi.constprop.0>:
static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 800a210:	b538      	push	{r3, r4, r5, lr}
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 800a212:	6881      	ldr	r1, [r0, #8]
	dp->dptr = ofs;				/* Set current offset */
 800a214:	2300      	movs	r3, #0
static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 800a216:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 800a218:	6805      	ldr	r5, [r0, #0]
	dp->dptr = ofs;				/* Set current offset */
 800a21a:	6103      	str	r3, [r0, #16]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800a21c:	b981      	cbnz	r1, 800a240 <dir_sdi.constprop.0+0x30>
 800a21e:	782b      	ldrb	r3, [r5, #0]
 800a220:	2b02      	cmp	r3, #2
 800a222:	d809      	bhi.n	800a238 <dir_sdi.constprop.0+0x28>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 800a224:	892b      	ldrh	r3, [r5, #8]
 800a226:	b1f3      	cbz	r3, 800a266 <dir_sdi.constprop.0+0x56>
		dp->sect = fs->dirbase;
 800a228:	6aab      	ldr	r3, [r5, #40]	; 0x28
	dp->clust = clst;					/* Current cluster# */
 800a22a:	e9c4 1305 	strd	r1, r3, [r4, #20]
	if (dp->sect == 0) return FR_INT_ERR;
 800a22e:	b1d3      	cbz	r3, 800a266 <dir_sdi.constprop.0+0x56>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800a230:	3530      	adds	r5, #48	; 0x30
	return FR_OK;
 800a232:	2000      	movs	r0, #0
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800a234:	61e5      	str	r5, [r4, #28]
}
 800a236:	bd38      	pop	{r3, r4, r5, pc}
		clst = (DWORD)fs->dirbase;
 800a238:	6aab      	ldr	r3, [r5, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 800a23a:	2b00      	cmp	r3, #0
 800a23c:	d0f2      	beq.n	800a224 <dir_sdi.constprop.0+0x14>
 800a23e:	4619      	mov	r1, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800a240:	896a      	ldrh	r2, [r5, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 800a242:	b12a      	cbz	r2, 800a250 <dir_sdi.constprop.0+0x40>
 800a244:	e011      	b.n	800a26a <dir_sdi.constprop.0+0x5a>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800a246:	2801      	cmp	r0, #1
 800a248:	d90d      	bls.n	800a266 <dir_sdi.constprop.0+0x56>
 800a24a:	696b      	ldr	r3, [r5, #20]
 800a24c:	4298      	cmp	r0, r3
 800a24e:	d20a      	bcs.n	800a266 <dir_sdi.constprop.0+0x56>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800a250:	6820      	ldr	r0, [r4, #0]
 800a252:	f7ff ff87 	bl	800a164 <get_fat.isra.0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800a256:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800a258:	4601      	mov	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800a25a:	d1f4      	bne.n	800a246 <dir_sdi.constprop.0+0x36>
 800a25c:	2001      	movs	r0, #1
}
 800a25e:	bd38      	pop	{r3, r4, r5, pc}
		dp->sect = fs->dirbase;
 800a260:	2300      	movs	r3, #0
 800a262:	e9c4 1305 	strd	r1, r3, [r4, #20]
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 800a266:	2002      	movs	r0, #2
}
 800a268:	bd38      	pop	{r3, r4, r5, pc}
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800a26a:	696b      	ldr	r3, [r5, #20]
	clst -= 2;		/* Cluster number is origin from 2 */
 800a26c:	1e88      	subs	r0, r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800a26e:	3b02      	subs	r3, #2
 800a270:	4298      	cmp	r0, r3
 800a272:	d2f5      	bcs.n	800a260 <dir_sdi.constprop.0+0x50>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 800a274:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a276:	fb00 3302 	mla	r3, r0, r2, r3
 800a27a:	e7d6      	b.n	800a22a <dir_sdi.constprop.0+0x1a>

0800a27c <check_fs>:
{
 800a27c:	b570      	push	{r4, r5, r6, lr}
	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
 800a27e:	f04f 36ff 	mov.w	r6, #4294967295
 800a282:	2300      	movs	r3, #0
{
 800a284:	4604      	mov	r4, r0
	if (sect != fs->winsect) {	/* Window offset changed? */
 800a286:	42b1      	cmp	r1, r6
	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
 800a288:	7103      	strb	r3, [r0, #4]
 800a28a:	61c6      	str	r6, [r0, #28]
	if (sect != fs->winsect) {	/* Window offset changed? */
 800a28c:	d00c      	beq.n	800a2a8 <check_fs+0x2c>
			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
 800a28e:	460d      	mov	r5, r1
 800a290:	460a      	mov	r2, r1
 800a292:	2301      	movs	r3, #1
 800a294:	f100 0130 	add.w	r1, r0, #48	; 0x30
 800a298:	7840      	ldrb	r0, [r0, #1]
 800a29a:	f7ff fdb3 	bl	8009e04 <disk_read>
 800a29e:	b110      	cbz	r0, 800a2a6 <check_fs+0x2a>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 800a2a0:	2004      	movs	r0, #4
			fs->winsect = sect;
 800a2a2:	61e6      	str	r6, [r4, #28]
}
 800a2a4:	bd70      	pop	{r4, r5, r6, pc}
			fs->winsect = sect;
 800a2a6:	61e5      	str	r5, [r4, #28]
	b = fs->win[BS_JmpBoot];
 800a2a8:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 800a2ac:	f8b4 522e 	ldrh.w	r5, [r4, #558]	; 0x22e
	if (b == 0xEB || b == 0xE9 || b == 0xE8) {	/* Valid JumpBoot code? (short jump, near jump or near call) */
 800a2b0:	f102 0318 	add.w	r3, r2, #24
 800a2b4:	b2db      	uxtb	r3, r3
 800a2b6:	2b01      	cmp	r3, #1
 800a2b8:	d901      	bls.n	800a2be <check_fs+0x42>
 800a2ba:	2aeb      	cmp	r2, #235	; 0xeb
 800a2bc:	d115      	bne.n	800a2ea <check_fs+0x6e>
		if (sign == 0xAA55 && !memcmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) {
 800a2be:	f64a 2355 	movw	r3, #43605	; 0xaa55
 800a2c2:	429d      	cmp	r5, r3
 800a2c4:	d018      	beq.n	800a2f8 <check_fs+0x7c>
		w = ld_16(fs->win + BPB_BytsPerSec);
 800a2c6:	f8b4 303b 	ldrh.w	r3, [r4, #59]	; 0x3b
		if ((w & (w - 1)) == 0 && w >= FF_MIN_SS && w <= FF_MAX_SS	/* Properness of sector size (512-4096 and 2^n) */
 800a2ca:	1e5a      	subs	r2, r3, #1
 800a2cc:	421a      	tst	r2, r3
 800a2ce:	d10a      	bne.n	800a2e6 <check_fs+0x6a>
		b = fs->win[BPB_SecPerClus];
 800a2d0:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
			&& b != 0 && (b & (b - 1)) == 0				/* Properness of cluster size (2^n) */
 800a2d4:	b13a      	cbz	r2, 800a2e6 <check_fs+0x6a>
 800a2d6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a2da:	d104      	bne.n	800a2e6 <check_fs+0x6a>
 800a2dc:	1e53      	subs	r3, r2, #1
 800a2de:	4213      	tst	r3, r2
 800a2e0:	d101      	bne.n	800a2e6 <check_fs+0x6a>
			&& ld_16(fs->win + BPB_RsvdSecCnt) != 0		/* Properness of number of reserved sectors (MNBZ) */
 800a2e2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800a2e4:	bb03      	cbnz	r3, 800a328 <check_fs+0xac>
	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (with valid or invalid BS) */
 800a2e6:	2003      	movs	r0, #3
}
 800a2e8:	bd70      	pop	{r4, r5, r6, pc}
	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (with valid or invalid BS) */
 800a2ea:	f64a 2055 	movw	r0, #43605	; 0xaa55
 800a2ee:	4285      	cmp	r5, r0
 800a2f0:	bf14      	ite	ne
 800a2f2:	2003      	movne	r0, #3
 800a2f4:	2002      	moveq	r0, #2
}
 800a2f6:	bd70      	pop	{r4, r5, r6, pc}
		if (sign == 0xAA55 && !memcmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) {
 800a2f8:	2208      	movs	r2, #8
 800a2fa:	4918      	ldr	r1, [pc, #96]	; (800a35c <check_fs+0xe0>)
 800a2fc:	f104 0082 	add.w	r0, r4, #130	; 0x82
 800a300:	f004 fa40 	bl	800e784 <memcmp>
 800a304:	2800      	cmp	r0, #0
 800a306:	d0cd      	beq.n	800a2a4 <check_fs+0x28>
		w = ld_16(fs->win + BPB_BytsPerSec);
 800a308:	f8b4 303b 	ldrh.w	r3, [r4, #59]	; 0x3b
		if ((w & (w - 1)) == 0 && w >= FF_MIN_SS && w <= FF_MAX_SS	/* Properness of sector size (512-4096 and 2^n) */
 800a30c:	1e5a      	subs	r2, r3, #1
 800a30e:	421a      	tst	r2, r3
 800a310:	d121      	bne.n	800a356 <check_fs+0xda>
		b = fs->win[BPB_SecPerClus];
 800a312:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
			&& b != 0 && (b & (b - 1)) == 0				/* Properness of cluster size (2^n) */
 800a316:	b1f2      	cbz	r2, 800a356 <check_fs+0xda>
 800a318:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a31c:	d11b      	bne.n	800a356 <check_fs+0xda>
 800a31e:	1e53      	subs	r3, r2, #1
 800a320:	4213      	tst	r3, r2
 800a322:	d118      	bne.n	800a356 <check_fs+0xda>
			&& ld_16(fs->win + BPB_RsvdSecCnt) != 0		/* Properness of number of reserved sectors (MNBZ) */
 800a324:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800a326:	b1b3      	cbz	r3, 800a356 <check_fs+0xda>
			&& (UINT)fs->win[BPB_NumFATs] - 1 <= 1		/* Properness of number of FATs (1 or 2) */
 800a328:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800a32c:	3b01      	subs	r3, #1
 800a32e:	2b01      	cmp	r3, #1
 800a330:	d8db      	bhi.n	800a2ea <check_fs+0x6e>
			&& ld_16(fs->win + BPB_RootEntCnt) != 0		/* Properness of root dir size (MNBZ) */
 800a332:	f8b4 3041 	ldrh.w	r3, [r4, #65]	; 0x41
 800a336:	2b00      	cmp	r3, #0
 800a338:	d0d7      	beq.n	800a2ea <check_fs+0x6e>
			&& (ld_16(fs->win + BPB_TotSec16) >= 128 || ld_32(fs->win + BPB_TotSec32) >= 0x10000)	/* Properness of volume size (>=128) */
 800a33a:	f8b4 3043 	ldrh.w	r3, [r4, #67]	; 0x43
 800a33e:	2b7f      	cmp	r3, #127	; 0x7f
 800a340:	d803      	bhi.n	800a34a <check_fs+0xce>
	rv = rv << 8 | ptr[0];
 800a342:	6d23      	ldr	r3, [r4, #80]	; 0x50
			&& (ld_16(fs->win + BPB_TotSec16) >= 128 || ld_32(fs->win + BPB_TotSec32) >= 0x10000)	/* Properness of volume size (>=128) */
 800a344:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a348:	d3cf      	bcc.n	800a2ea <check_fs+0x6e>
			&& ld_16(fs->win + BPB_FATSz16) != 0) {		/* Properness of FAT size (MNBZ) */
 800a34a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 800a34e:	2b00      	cmp	r3, #0
 800a350:	d0cb      	beq.n	800a2ea <check_fs+0x6e>
			return 0;	/* It is an FAT32 VBR */
 800a352:	2000      	movs	r0, #0
}
 800a354:	bd70      	pop	{r4, r5, r6, pc}
	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (with valid or invalid BS) */
 800a356:	2002      	movs	r0, #2
}
 800a358:	bd70      	pop	{r4, r5, r6, pc}
 800a35a:	bf00      	nop
 800a35c:	08015370 	.word	0x08015370

0800a360 <mount_volume>:
	*rfs = 0;
 800a360:	2300      	movs	r3, #0
{
 800a362:	b5f0      	push	{r4, r5, r6, r7, lr}
	*rfs = 0;
 800a364:	600b      	str	r3, [r1, #0]
{
 800a366:	b085      	sub	sp, #20
 800a368:	460e      	mov	r6, r1
 800a36a:	4615      	mov	r5, r2
	vol = get_ldnumber(path);
 800a36c:	f7ff fdbc 	bl	8009ee8 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 800a370:	2800      	cmp	r0, #0
 800a372:	f2c0 80c4 	blt.w	800a4fe <mount_volume+0x19e>
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 800a376:	4b89      	ldr	r3, [pc, #548]	; (800a59c <mount_volume+0x23c>)
 800a378:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 800a37c:	2c00      	cmp	r4, #0
 800a37e:	f000 80c2 	beq.w	800a506 <mount_volume+0x1a6>
	*rfs = fs;							/* Return pointer to the filesystem object */
 800a382:	6034      	str	r4, [r6, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 800a384:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 800a388:	7823      	ldrb	r3, [r4, #0]
 800a38a:	b17b      	cbz	r3, 800a3ac <mount_volume+0x4c>
		stat = disk_status(fs->pdrv);
 800a38c:	7860      	ldrb	r0, [r4, #1]
 800a38e:	f7ff fd0b 	bl	8009da8 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 800a392:	07c3      	lsls	r3, r0, #31
 800a394:	d40a      	bmi.n	800a3ac <mount_volume+0x4c>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 800a396:	2d00      	cmp	r5, #0
 800a398:	f000 80a8 	beq.w	800a4ec <mount_volume+0x18c>
 800a39c:	f010 0504 	ands.w	r5, r0, #4
 800a3a0:	f000 80a4 	beq.w	800a4ec <mount_volume+0x18c>
				return FR_WRITE_PROTECTED;
 800a3a4:	250a      	movs	r5, #10
}
 800a3a6:	4628      	mov	r0, r5
 800a3a8:	b005      	add	sp, #20
 800a3aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	fs->fs_type = 0;					/* Invalidate the filesystem object */
 800a3ac:	2300      	movs	r3, #0
	stat = disk_initialize(fs->pdrv);	/* Initialize the volume hosting physical drive */
 800a3ae:	7860      	ldrb	r0, [r4, #1]
	fs->fs_type = 0;					/* Invalidate the filesystem object */
 800a3b0:	7023      	strb	r3, [r4, #0]
	stat = disk_initialize(fs->pdrv);	/* Initialize the volume hosting physical drive */
 800a3b2:	f7ff fd0b 	bl	8009dcc <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 800a3b6:	07c7      	lsls	r7, r0, #31
 800a3b8:	f100 809b 	bmi.w	800a4f2 <mount_volume+0x192>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 800a3bc:	b10d      	cbz	r5, 800a3c2 <mount_volume+0x62>
 800a3be:	0746      	lsls	r6, r0, #29
 800a3c0:	d4f0      	bmi.n	800a3a4 <mount_volume+0x44>
	fmt = check_fs(fs, 0);				/* Load sector 0 and check if it is an FAT VBR as SFD format */
 800a3c2:	2100      	movs	r1, #0
 800a3c4:	4620      	mov	r0, r4
 800a3c6:	f7ff ff59 	bl	800a27c <check_fs>
	if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;	/* Returns if it is an FAT VBR as auto scan, not a BS or disk error */
 800a3ca:	2802      	cmp	r0, #2
 800a3cc:	d06d      	beq.n	800a4aa <mount_volume+0x14a>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occurred in the disk I/O layer */
 800a3ce:	2804      	cmp	r0, #4
 800a3d0:	f000 8093 	beq.w	800a4fa <mount_volume+0x19a>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800a3d4:	2801      	cmp	r0, #1
 800a3d6:	f200 8088 	bhi.w	800a4ea <mount_volume+0x18a>
		if (ld_16(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800a3da:	f8b4 303b 	ldrh.w	r3, [r4, #59]	; 0x3b
	bsect = fs->winsect;					/* Volume offset in the hosting physical drive */
 800a3de:	69e1      	ldr	r1, [r4, #28]
		if (ld_16(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800a3e0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a3e4:	f040 8081 	bne.w	800a4ea <mount_volume+0x18a>
		fasize = ld_16(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 800a3e8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
		if (fasize == 0) fasize = ld_32(fs->win + BPB_FATSz32);
 800a3ec:	b903      	cbnz	r3, 800a3f0 <mount_volume+0x90>
	rv = rv << 8 | ptr[0];
 800a3ee:	6d63      	ldr	r3, [r4, #84]	; 0x54
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800a3f0:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
		fs->fsize = fasize;
 800a3f4:	61a3      	str	r3, [r4, #24]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800a3f6:	1e50      	subs	r0, r2, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800a3f8:	70e2      	strb	r2, [r4, #3]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800a3fa:	2801      	cmp	r0, #1
 800a3fc:	d875      	bhi.n	800a4ea <mount_volume+0x18a>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 800a3fe:	f894 003d 	ldrb.w	r0, [r4, #61]	; 0x3d
 800a402:	b285      	uxth	r5, r0
 800a404:	8165      	strh	r5, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 800a406:	2d00      	cmp	r5, #0
 800a408:	d06f      	beq.n	800a4ea <mount_volume+0x18a>
 800a40a:	1e45      	subs	r5, r0, #1
 800a40c:	4205      	tst	r5, r0
 800a40e:	d16c      	bne.n	800a4ea <mount_volume+0x18a>
		fs->n_rootdir = ld_16(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800a410:	f8b4 6041 	ldrh.w	r6, [r4, #65]	; 0x41
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800a414:	0735      	lsls	r5, r6, #28
		fs->n_rootdir = ld_16(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800a416:	8126      	strh	r6, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800a418:	d167      	bne.n	800a4ea <mount_volume+0x18a>
		tsect = ld_16(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
 800a41a:	f8b4 5043 	ldrh.w	r5, [r4, #67]	; 0x43
		if (tsect == 0) tsect = ld_32(fs->win + BPB_TotSec32);
 800a41e:	b905      	cbnz	r5, 800a422 <mount_volume+0xc2>
	rv = rv << 8 | ptr[0];
 800a420:	6d25      	ldr	r5, [r4, #80]	; 0x50
		nrsv = ld_16(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 800a422:	8fe7      	ldrh	r7, [r4, #62]	; 0x3e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 800a424:	2f00      	cmp	r7, #0
 800a426:	d060      	beq.n	800a4ea <mount_volume+0x18a>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800a428:	fb03 f202 	mul.w	r2, r3, r2
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800a42c:	eb07 1c16 	add.w	ip, r7, r6, lsr #4
 800a430:	4494      	add	ip, r2
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 800a432:	4565      	cmp	r5, ip
 800a434:	d359      	bcc.n	800a4ea <mount_volume+0x18a>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800a436:	eba5 050c 	sub.w	r5, r5, ip
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 800a43a:	4285      	cmp	r5, r0
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800a43c:	fbb5 fef0 	udiv	lr, r5, r0
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 800a440:	d353      	bcc.n	800a4ea <mount_volume+0x18a>
 800a442:	4857      	ldr	r0, [pc, #348]	; (800a5a0 <mount_volume+0x240>)
 800a444:	4586      	cmp	lr, r0
 800a446:	d850      	bhi.n	800a4ea <mount_volume+0x18a>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800a448:	f64f 70f5 	movw	r0, #65525	; 0xfff5
 800a44c:	4586      	cmp	lr, r0
 800a44e:	d85c      	bhi.n	800a50a <mount_volume+0x1aa>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800a450:	f640 70f5 	movw	r0, #4085	; 0xff5
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800a454:	440f      	add	r7, r1
		fs->database = bsect + sysect;					/* Data start sector */
 800a456:	eb01 050c 	add.w	r5, r1, ip
		fs->volbase = bsect;							/* Volume start sector */
 800a45a:	6221      	str	r1, [r4, #32]
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800a45c:	4586      	cmp	lr, r0
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800a45e:	f10e 0002 	add.w	r0, lr, #2
		fs->database = bsect + sysect;					/* Data start sector */
 800a462:	62e5      	str	r5, [r4, #44]	; 0x2c
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800a464:	6160      	str	r0, [r4, #20]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800a466:	6267      	str	r7, [r4, #36]	; 0x24
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800a468:	d870      	bhi.n	800a54c <mount_volume+0x1ec>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800a46a:	2e00      	cmp	r6, #0
 800a46c:	d03d      	beq.n	800a4ea <mount_volume+0x18a>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800a46e:	eb00 0140 	add.w	r1, r0, r0, lsl #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800a472:	4417      	add	r7, r2
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800a474:	f000 0201 	and.w	r2, r0, #1
 800a478:	eb02 0251 	add.w	r2, r2, r1, lsr #1
 800a47c:	2101      	movs	r1, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800a47e:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800a482:	62a7      	str	r7, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800a484:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
 800a488:	d32f      	bcc.n	800a4ea <mount_volume+0x18a>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Invalidate cluster allocation information */
 800a48a:	f04f 32ff 	mov.w	r2, #4294967295
		fs->fsi_flag = 0x80;	/* Disable FSInfo by default */
 800a48e:	2080      	movs	r0, #128	; 0x80
	fs->fs_type = (BYTE)fmt;/* FAT sub-type (the filesystem object gets valid) */
 800a490:	b2cb      	uxtb	r3, r1
		fs->fsi_flag = 0x80;	/* Disable FSInfo by default */
 800a492:	7160      	strb	r0, [r4, #5]
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Invalidate cluster allocation information */
 800a494:	e9c4 2203 	strd	r2, r2, [r4, #12]
	fs->id = ++Fsid;		/* Volume mount ID */
 800a498:	4a42      	ldr	r2, [pc, #264]	; (800a5a4 <mount_volume+0x244>)
	return FR_OK;
 800a49a:	2500      	movs	r5, #0
	fs->fs_type = (BYTE)fmt;/* FAT sub-type (the filesystem object gets valid) */
 800a49c:	7023      	strb	r3, [r4, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 800a49e:	8813      	ldrh	r3, [r2, #0]
 800a4a0:	3301      	adds	r3, #1
 800a4a2:	b29b      	uxth	r3, r3
 800a4a4:	8013      	strh	r3, [r2, #0]
 800a4a6:	80e3      	strh	r3, [r4, #6]
	return FR_OK;
 800a4a8:	e020      	b.n	800a4ec <mount_volume+0x18c>
	rv = rv << 8 | ptr[0];
 800a4aa:	f8d4 01f6 	ldr.w	r0, [r4, #502]	; 0x1f6
 800a4ae:	466d      	mov	r5, sp
 800a4b0:	f8d4 1206 	ldr.w	r1, [r4, #518]	; 0x206
 800a4b4:	ae04      	add	r6, sp, #16
 800a4b6:	f8d4 2216 	ldr.w	r2, [r4, #534]	; 0x216
 800a4ba:	f8d4 3226 	ldr.w	r3, [r4, #550]	; 0x226
		mbr_pt[i] = ld_32(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
 800a4be:	e9cd 0100 	strd	r0, r1, [sp]
 800a4c2:	e9cd 2302 	strd	r2, r3, [sp, #8]
	for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
 800a4c6:	e001      	b.n	800a4cc <mount_volume+0x16c>
	} while (part == 0 && fmt >= 2 && ++i < 4);
 800a4c8:	42ae      	cmp	r6, r5
 800a4ca:	d00c      	beq.n	800a4e6 <mount_volume+0x186>
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
 800a4cc:	f855 1b04 	ldr.w	r1, [r5], #4
 800a4d0:	2003      	movs	r0, #3
 800a4d2:	2900      	cmp	r1, #0
 800a4d4:	d0f8      	beq.n	800a4c8 <mount_volume+0x168>
 800a4d6:	4620      	mov	r0, r4
 800a4d8:	f7ff fed0 	bl	800a27c <check_fs>
	} while (part == 0 && fmt >= 2 && ++i < 4);
 800a4dc:	2801      	cmp	r0, #1
 800a4de:	f67f af7c 	bls.w	800a3da <mount_volume+0x7a>
 800a4e2:	42ae      	cmp	r6, r5
 800a4e4:	d1f2      	bne.n	800a4cc <mount_volume+0x16c>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occurred in the disk I/O layer */
 800a4e6:	2804      	cmp	r0, #4
 800a4e8:	d007      	beq.n	800a4fa <mount_volume+0x19a>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800a4ea:	250d      	movs	r5, #13
}
 800a4ec:	4628      	mov	r0, r5
 800a4ee:	b005      	add	sp, #20
 800a4f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800a4f2:	2503      	movs	r5, #3
}
 800a4f4:	4628      	mov	r0, r5
 800a4f6:	b005      	add	sp, #20
 800a4f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occurred in the disk I/O layer */
 800a4fa:	2501      	movs	r5, #1
 800a4fc:	e7f6      	b.n	800a4ec <mount_volume+0x18c>
	if (vol < 0) return FR_INVALID_DRIVE;
 800a4fe:	250b      	movs	r5, #11
}
 800a500:	4628      	mov	r0, r5
 800a502:	b005      	add	sp, #20
 800a504:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 800a506:	250c      	movs	r5, #12
 800a508:	e7f0      	b.n	800a4ec <mount_volume+0x18c>
		fs->database = bsect + sysect;					/* Data start sector */
 800a50a:	eb01 000c 	add.w	r0, r1, ip
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800a50e:	f10e 0202 	add.w	r2, lr, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800a512:	440f      	add	r7, r1
		fs->volbase = bsect;							/* Volume start sector */
 800a514:	6221      	str	r1, [r4, #32]
		fs->database = bsect + sysect;					/* Data start sector */
 800a516:	62e0      	str	r0, [r4, #44]	; 0x2c
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800a518:	f8b4 005a 	ldrh.w	r0, [r4, #90]	; 0x5a
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800a51c:	6267      	str	r7, [r4, #36]	; 0x24
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800a51e:	4330      	orrs	r0, r6
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800a520:	6162      	str	r2, [r4, #20]
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800a522:	d1e2      	bne.n	800a4ea <mount_volume+0x18a>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800a524:	0092      	lsls	r2, r2, #2
	rv = rv << 8 | ptr[0];
 800a526:	6de0      	ldr	r0, [r4, #92]	; 0x5c
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800a528:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
			fs->dirbase = ld_32(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800a52c:	62a0      	str	r0, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800a52e:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
 800a532:	d3da      	bcc.n	800a4ea <mount_volume+0x18a>
			&& ld_16(fs->win + BPB_FSInfo32) == 1	/* FAT32: Enable FSInfo feature only if FSInfo sector is next to VBR */
 800a534:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Invalidate cluster allocation information */
 800a538:	f04f 33ff 	mov.w	r3, #4294967295
		fs->fsi_flag = 0x80;	/* Disable FSInfo by default */
 800a53c:	2080      	movs	r0, #128	; 0x80
			&& ld_16(fs->win + BPB_FSInfo32) == 1	/* FAT32: Enable FSInfo feature only if FSInfo sector is next to VBR */
 800a53e:	2a01      	cmp	r2, #1
		fs->fsi_flag = 0x80;	/* Disable FSInfo by default */
 800a540:	7160      	strb	r0, [r4, #5]
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Invalidate cluster allocation information */
 800a542:	e9c4 3303 	strd	r3, r3, [r4, #12]
			&& ld_16(fs->win + BPB_FSInfo32) == 1	/* FAT32: Enable FSInfo feature only if FSInfo sector is next to VBR */
 800a546:	d007      	beq.n	800a558 <mount_volume+0x1f8>
				fs->last_clst = ld_32(fs->win + FSI_Nxt_Free);
 800a548:	2303      	movs	r3, #3
 800a54a:	e7a5      	b.n	800a498 <mount_volume+0x138>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800a54c:	2e00      	cmp	r6, #0
 800a54e:	d0cc      	beq.n	800a4ea <mount_volume+0x18a>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800a550:	4417      	add	r7, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 800a552:	2102      	movs	r1, #2
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800a554:	0042      	lsls	r2, r0, #1
 800a556:	e792      	b.n	800a47e <mount_volume+0x11e>
			&& move_window(fs, bsect + 1) == FR_OK)
 800a558:	3101      	adds	r1, #1
 800a55a:	4620      	mov	r0, r4
 800a55c:	f7ff fdb4 	bl	800a0c8 <move_window>
 800a560:	2800      	cmp	r0, #0
 800a562:	d1f1      	bne.n	800a548 <mount_volume+0x1e8>
	rv = rv << 8 | ptr[0];
 800a564:	6b22      	ldr	r2, [r4, #48]	; 0x30
			if (   ld_32(fs->win + FSI_LeadSig) == 0x41615252	/* Load FSInfo data if available */
 800a566:	4b10      	ldr	r3, [pc, #64]	; (800a5a8 <mount_volume+0x248>)
			fs->fsi_flag = 0;
 800a568:	7160      	strb	r0, [r4, #5]
			if (   ld_32(fs->win + FSI_LeadSig) == 0x41615252	/* Load FSInfo data if available */
 800a56a:	429a      	cmp	r2, r3
 800a56c:	d1ec      	bne.n	800a548 <mount_volume+0x1e8>
				&& ld_32(fs->win + FSI_StrucSig) == 0x61417272
 800a56e:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
	rv = rv << 8 | ptr[0];
 800a572:	f8d4 2214 	ldr.w	r2, [r4, #532]	; 0x214
				&& ld_32(fs->win + FSI_StrucSig) == 0x61417272
 800a576:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 800a57a:	3320      	adds	r3, #32
 800a57c:	429a      	cmp	r2, r3
 800a57e:	d1e3      	bne.n	800a548 <mount_volume+0x1e8>
	rv = rv << 8 | ptr[0];
 800a580:	f8d4 222c 	ldr.w	r2, [r4, #556]	; 0x22c
				&& ld_32(fs->win + FSI_TrailSig) == 0xAA550000)
 800a584:	4b09      	ldr	r3, [pc, #36]	; (800a5ac <mount_volume+0x24c>)
 800a586:	429a      	cmp	r2, r3
 800a588:	d1de      	bne.n	800a548 <mount_volume+0x1e8>
	rv = rv << 8 | ptr[0];
 800a58a:	f8d4 1218 	ldr.w	r1, [r4, #536]	; 0x218
				fs->last_clst = ld_32(fs->win + FSI_Nxt_Free);
 800a58e:	2303      	movs	r3, #3
	rv = rv << 8 | ptr[0];
 800a590:	f8d4 221c 	ldr.w	r2, [r4, #540]	; 0x21c
				fs->last_clst = ld_32(fs->win + FSI_Nxt_Free);
 800a594:	e9c4 2103 	strd	r2, r1, [r4, #12]
 800a598:	e77e      	b.n	800a498 <mount_volume+0x138>
 800a59a:	bf00      	nop
 800a59c:	24004660 	.word	0x24004660
 800a5a0:	0ffffff5 	.word	0x0ffffff5
 800a5a4:	24004664 	.word	0x24004664
 800a5a8:	41615252 	.word	0x41615252
 800a5ac:	aa550000 	.word	0xaa550000

0800a5b0 <put_fat.part.0>:
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 800a5b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		switch (fs->fs_type) {
 800a5b4:	7805      	ldrb	r5, [r0, #0]
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 800a5b6:	4606      	mov	r6, r0
 800a5b8:	460c      	mov	r4, r1
 800a5ba:	4690      	mov	r8, r2
		switch (fs->fs_type) {
 800a5bc:	2d02      	cmp	r5, #2
 800a5be:	d007      	beq.n	800a5d0 <put_fat.part.0+0x20>
 800a5c0:	2d03      	cmp	r5, #3
 800a5c2:	d046      	beq.n	800a652 <put_fat.part.0+0xa2>
 800a5c4:	2d01      	cmp	r5, #1
 800a5c6:	d01b      	beq.n	800a600 <put_fat.part.0+0x50>
 800a5c8:	2702      	movs	r7, #2
}
 800a5ca:	4638      	mov	r0, r7
 800a5cc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800a5d0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800a5d2:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 800a5d6:	f7ff fd77 	bl	800a0c8 <move_window>
			if (res != FR_OK) break;
 800a5da:	4607      	mov	r7, r0
 800a5dc:	2800      	cmp	r0, #0
 800a5de:	d1f4      	bne.n	800a5ca <put_fat.part.0+0x1a>
			st_16(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 800a5e0:	0064      	lsls	r4, r4, #1
 800a5e2:	f106 0330 	add.w	r3, r6, #48	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 800a5e6:	f3c8 2207 	ubfx	r2, r8, #8, #8
			fs->wflag = 1;
 800a5ea:	2101      	movs	r1, #1
			st_16(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 800a5ec:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
}
 800a5f0:	4638      	mov	r0, r7
	*ptr++ = (BYTE)val; val >>= 8;
 800a5f2:	f803 8004 	strb.w	r8, [r3, r4]
			st_16(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 800a5f6:	4423      	add	r3, r4
	*ptr++ = (BYTE)val;
 800a5f8:	705a      	strb	r2, [r3, #1]
			fs->wflag = 1;
 800a5fa:	7131      	strb	r1, [r6, #4]
}
 800a5fc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800a600:	6a41      	ldr	r1, [r0, #36]	; 0x24
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 800a602:	eb04 0954 	add.w	r9, r4, r4, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800a606:	eb01 2159 	add.w	r1, r1, r9, lsr #9
 800a60a:	f7ff fd5d 	bl	800a0c8 <move_window>
			if (res != FR_OK) break;
 800a60e:	4607      	mov	r7, r0
 800a610:	2800      	cmp	r0, #0
 800a612:	d1da      	bne.n	800a5ca <put_fat.part.0+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
 800a614:	f014 0401 	ands.w	r4, r4, #1
			p = fs->win + bc++ % SS(fs);
 800a618:	f109 0a01 	add.w	sl, r9, #1
 800a61c:	f106 0b30 	add.w	fp, r6, #48	; 0x30
 800a620:	f3c9 0908 	ubfx	r9, r9, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
 800a624:	d035      	beq.n	800a692 <put_fat.part.0+0xe2>
 800a626:	f81b 3009 	ldrb.w	r3, [fp, r9]
 800a62a:	f003 030f 	and.w	r3, r3, #15
 800a62e:	ea43 1308 	orr.w	r3, r3, r8, lsl #4
 800a632:	f80b 3009 	strb.w	r3, [fp, r9]
			fs->wflag = 1;
 800a636:	7135      	strb	r5, [r6, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800a638:	6a75      	ldr	r5, [r6, #36]	; 0x24
	if (sect != fs->winsect) {	/* Window offset changed? */
 800a63a:	69f3      	ldr	r3, [r6, #28]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800a63c:	eb05 255a 	add.w	r5, r5, sl, lsr #9
	if (sect != fs->winsect) {	/* Window offset changed? */
 800a640:	42ab      	cmp	r3, r5
 800a642:	d03e      	beq.n	800a6c2 <put_fat.part.0+0x112>
	if (fs->wflag) {	/* Is the disk access window dirty? */
 800a644:	4630      	mov	r0, r6
 800a646:	f7ff fc83 	bl	8009f50 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 800a64a:	2800      	cmp	r0, #0
 800a64c:	d03f      	beq.n	800a6ce <put_fat.part.0+0x11e>
 800a64e:	4607      	mov	r7, r0
	return res;
 800a650:	e7bb      	b.n	800a5ca <put_fat.part.0+0x1a>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 800a652:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800a654:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 800a658:	f7ff fd36 	bl	800a0c8 <move_window>
			if (res != FR_OK) break;
 800a65c:	4607      	mov	r7, r0
 800a65e:	2800      	cmp	r0, #0
 800a660:	d1b3      	bne.n	800a5ca <put_fat.part.0+0x1a>
				val = (val & 0x0FFFFFFF) | (ld_32(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800a662:	00a4      	lsls	r4, r4, #2
 800a664:	f106 0130 	add.w	r1, r6, #48	; 0x30
 800a668:	f028 4270 	bic.w	r2, r8, #4026531840	; 0xf0000000
			fs->wflag = 1;
 800a66c:	2001      	movs	r0, #1
				val = (val & 0x0FFFFFFF) | (ld_32(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800a66e:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800a672:	590b      	ldr	r3, [r1, r4]
				val = (val & 0x0FFFFFFF) | (ld_32(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800a674:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800a678:	4313      	orrs	r3, r2
 800a67a:	190a      	adds	r2, r1, r4
	*ptr++ = (BYTE)val; val >>= 8;
 800a67c:	550b      	strb	r3, [r1, r4]
 800a67e:	0a19      	lsrs	r1, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800a680:	7051      	strb	r1, [r2, #1]
 800a682:	0c19      	lsrs	r1, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800a684:	0e1b      	lsrs	r3, r3, #24
 800a686:	7091      	strb	r1, [r2, #2]
	*ptr++ = (BYTE)val;
 800a688:	70d3      	strb	r3, [r2, #3]
			fs->wflag = 1;
 800a68a:	7130      	strb	r0, [r6, #4]
}
 800a68c:	4638      	mov	r0, r7
 800a68e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
 800a692:	f80b 8009 	strb.w	r8, [fp, r9]
			fs->wflag = 1;
 800a696:	7135      	strb	r5, [r6, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800a698:	6a75      	ldr	r5, [r6, #36]	; 0x24
	if (sect != fs->winsect) {	/* Window offset changed? */
 800a69a:	69f3      	ldr	r3, [r6, #28]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800a69c:	eb05 255a 	add.w	r5, r5, sl, lsr #9
	if (sect != fs->winsect) {	/* Window offset changed? */
 800a6a0:	429d      	cmp	r5, r3
 800a6a2:	d1cf      	bne.n	800a644 <put_fat.part.0+0x94>
			p = fs->win + bc % SS(fs);
 800a6a4:	f3ca 0a08 	ubfx	sl, sl, #0, #9
 800a6a8:	44d3      	add	fp, sl
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
 800a6aa:	f89b 3000 	ldrb.w	r3, [fp]
 800a6ae:	f3c8 2203 	ubfx	r2, r8, #8, #4
 800a6b2:	f023 030f 	bic.w	r3, r3, #15
 800a6b6:	4313      	orrs	r3, r2
			fs->wflag = 1;
 800a6b8:	2201      	movs	r2, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
 800a6ba:	f88b 3000 	strb.w	r3, [fp]
			fs->wflag = 1;
 800a6be:	7132      	strb	r2, [r6, #4]
			break;
 800a6c0:	e783      	b.n	800a5ca <put_fat.part.0+0x1a>
			p = fs->win + bc % SS(fs);
 800a6c2:	f3ca 0a08 	ubfx	sl, sl, #0, #9
 800a6c6:	44d3      	add	fp, sl
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
 800a6c8:	f3c8 1307 	ubfx	r3, r8, #4, #8
 800a6cc:	e7f4      	b.n	800a6b8 <put_fat.part.0+0x108>
			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
 800a6ce:	2301      	movs	r3, #1
 800a6d0:	462a      	mov	r2, r5
 800a6d2:	4659      	mov	r1, fp
 800a6d4:	7870      	ldrb	r0, [r6, #1]
 800a6d6:	f7ff fb95 	bl	8009e04 <disk_read>
 800a6da:	b120      	cbz	r0, 800a6e6 <put_fat.part.0+0x136>
			fs->winsect = sect;
 800a6dc:	f04f 33ff 	mov.w	r3, #4294967295
				res = FR_DISK_ERR;
 800a6e0:	2701      	movs	r7, #1
			fs->winsect = sect;
 800a6e2:	61f3      	str	r3, [r6, #28]
			if (res != FR_OK) break;
 800a6e4:	e771      	b.n	800a5ca <put_fat.part.0+0x1a>
			p = fs->win + bc % SS(fs);
 800a6e6:	f3ca 0a08 	ubfx	sl, sl, #0, #9
			fs->winsect = sect;
 800a6ea:	61f5      	str	r5, [r6, #28]
			p = fs->win + bc % SS(fs);
 800a6ec:	44d3      	add	fp, sl
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
 800a6ee:	2c00      	cmp	r4, #0
 800a6f0:	d0db      	beq.n	800a6aa <put_fat.part.0+0xfa>
 800a6f2:	e7e9      	b.n	800a6c8 <put_fat.part.0+0x118>

0800a6f4 <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800a6f4:	2901      	cmp	r1, #1
{
 800a6f6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a6f8:	460e      	mov	r6, r1
	FATFS *fs = obj->fs;
 800a6fa:	6805      	ldr	r5, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800a6fc:	d92a      	bls.n	800a754 <remove_chain+0x60>
 800a6fe:	696b      	ldr	r3, [r5, #20]
 800a700:	428b      	cmp	r3, r1
 800a702:	d927      	bls.n	800a754 <remove_chain+0x60>
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 800a704:	4607      	mov	r7, r0
 800a706:	4611      	mov	r1, r2
 800a708:	bb32      	cbnz	r2, 800a758 <remove_chain+0x64>
 800a70a:	4628      	mov	r0, r5
 800a70c:	e014      	b.n	800a738 <remove_chain+0x44>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800a70e:	696b      	ldr	r3, [r5, #20]
 800a710:	429e      	cmp	r6, r3
	} while (clst < fs->n_fatent);	/* Repeat until the last link */
 800a712:	4626      	mov	r6, r4
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800a714:	d21e      	bcs.n	800a754 <remove_chain+0x60>
 800a716:	f7ff ff4b 	bl	800a5b0 <put_fat.part.0>
			if (res != FR_OK) return res;
 800a71a:	b9e0      	cbnz	r0, 800a756 <remove_chain+0x62>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update allocation information if it is valid */
 800a71c:	e9d5 2304 	ldrd	r2, r3, [r5, #16]
 800a720:	1e99      	subs	r1, r3, #2
			fs->free_clst++;
 800a722:	1c50      	adds	r0, r2, #1
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update allocation information if it is valid */
 800a724:	428a      	cmp	r2, r1
 800a726:	d204      	bcs.n	800a732 <remove_chain+0x3e>
			fs->fsi_flag |= 1;
 800a728:	796a      	ldrb	r2, [r5, #5]
			fs->free_clst++;
 800a72a:	6128      	str	r0, [r5, #16]
			fs->fsi_flag |= 1;
 800a72c:	f042 0201 	orr.w	r2, r2, #1
 800a730:	716a      	strb	r2, [r5, #5]
	} while (clst < fs->n_fatent);	/* Repeat until the last link */
 800a732:	42a3      	cmp	r3, r4
 800a734:	d91c      	bls.n	800a770 <remove_chain+0x7c>
 800a736:	6838      	ldr	r0, [r7, #0]
		nxt = get_fat(obj, clst);			/* Get cluster status */
 800a738:	4631      	mov	r1, r6
 800a73a:	f7ff fd13 	bl	800a164 <get_fat.isra.0>
 800a73e:	4604      	mov	r4, r0
		if (nxt == 0) break;				/* Empty cluster? */
 800a740:	4631      	mov	r1, r6
 800a742:	2200      	movs	r2, #0
 800a744:	4628      	mov	r0, r5
 800a746:	b19c      	cbz	r4, 800a770 <remove_chain+0x7c>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 800a748:	2c01      	cmp	r4, #1
 800a74a:	d003      	beq.n	800a754 <remove_chain+0x60>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800a74c:	1c63      	adds	r3, r4, #1
 800a74e:	d011      	beq.n	800a774 <remove_chain+0x80>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800a750:	2e01      	cmp	r6, #1
 800a752:	d8dc      	bhi.n	800a70e <remove_chain+0x1a>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800a754:	2002      	movs	r0, #2
}
 800a756:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800a758:	4293      	cmp	r3, r2
 800a75a:	d9fb      	bls.n	800a754 <remove_chain+0x60>
 800a75c:	2a01      	cmp	r2, #1
 800a75e:	d0f9      	beq.n	800a754 <remove_chain+0x60>
 800a760:	f04f 32ff 	mov.w	r2, #4294967295
 800a764:	4628      	mov	r0, r5
 800a766:	f7ff ff23 	bl	800a5b0 <put_fat.part.0>
		if (res != FR_OK) return res;
 800a76a:	2800      	cmp	r0, #0
 800a76c:	d0e3      	beq.n	800a736 <remove_chain+0x42>
}
 800a76e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return FR_OK;
 800a770:	2000      	movs	r0, #0
}
 800a772:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800a774:	2001      	movs	r0, #1
}
 800a776:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800a778 <create_chain>:
{
 800a778:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a77c:	4605      	mov	r5, r0
	if (clst == 0) {	/* Create a new chain */
 800a77e:	460f      	mov	r7, r1
	FATFS *fs = obj->fs;
 800a780:	6806      	ldr	r6, [r0, #0]
	if (clst == 0) {	/* Create a new chain */
 800a782:	2900      	cmp	r1, #0
 800a784:	d156      	bne.n	800a834 <create_chain+0xbc>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 800a786:	f8d6 800c 	ldr.w	r8, [r6, #12]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800a78a:	f1b8 0f00 	cmp.w	r8, #0
 800a78e:	d049      	beq.n	800a824 <create_chain+0xac>
 800a790:	6973      	ldr	r3, [r6, #20]
 800a792:	4543      	cmp	r3, r8
 800a794:	bf98      	it	ls
 800a796:	f04f 0801 	movls.w	r8, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 800a79a:	6933      	ldr	r3, [r6, #16]
 800a79c:	2b00      	cmp	r3, #0
 800a79e:	d046      	beq.n	800a82e <create_chain+0xb6>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800a7a0:	6973      	ldr	r3, [r6, #20]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 800a7a2:	4644      	mov	r4, r8
 800a7a4:	e006      	b.n	800a7b4 <create_chain+0x3c>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 800a7a6:	2801      	cmp	r0, #1
 800a7a8:	d03a      	beq.n	800a820 <create_chain+0xa8>
 800a7aa:	1c43      	adds	r3, r0, #1
 800a7ac:	d038      	beq.n	800a820 <create_chain+0xa8>
				if (ncl == scl) return 0;		/* No free cluster found? */
 800a7ae:	4544      	cmp	r4, r8
 800a7b0:	d03d      	beq.n	800a82e <create_chain+0xb6>
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800a7b2:	6973      	ldr	r3, [r6, #20]
				ncl++;							/* Next cluster */
 800a7b4:	3401      	adds	r4, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800a7b6:	429c      	cmp	r4, r3
 800a7b8:	d304      	bcc.n	800a7c4 <create_chain+0x4c>
					if (ncl > scl) return 0;	/* No free cluster found? */
 800a7ba:	f1b8 0f01 	cmp.w	r8, #1
					ncl = 2;
 800a7be:	f04f 0402 	mov.w	r4, #2
					if (ncl > scl) return 0;	/* No free cluster found? */
 800a7c2:	d034      	beq.n	800a82e <create_chain+0xb6>
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 800a7c4:	4621      	mov	r1, r4
 800a7c6:	6828      	ldr	r0, [r5, #0]
 800a7c8:	f7ff fccc 	bl	800a164 <get_fat.isra.0>
				if (cs == 0) break;				/* Found a free cluster? */
 800a7cc:	2800      	cmp	r0, #0
 800a7ce:	d1ea      	bne.n	800a7a6 <create_chain+0x2e>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800a7d0:	2c01      	cmp	r4, #1
 800a7d2:	d95c      	bls.n	800a88e <create_chain+0x116>
 800a7d4:	6973      	ldr	r3, [r6, #20]
 800a7d6:	42a3      	cmp	r3, r4
 800a7d8:	d959      	bls.n	800a88e <create_chain+0x116>
 800a7da:	f04f 32ff 	mov.w	r2, #4294967295
 800a7de:	4621      	mov	r1, r4
 800a7e0:	4630      	mov	r0, r6
 800a7e2:	f7ff fee5 	bl	800a5b0 <put_fat.part.0>
		if (res == FR_OK && clst != 0) {
 800a7e6:	b950      	cbnz	r0, 800a7fe <create_chain+0x86>
 800a7e8:	b14f      	cbz	r7, 800a7fe <create_chain+0x86>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800a7ea:	2f01      	cmp	r7, #1
 800a7ec:	d04f      	beq.n	800a88e <create_chain+0x116>
 800a7ee:	6973      	ldr	r3, [r6, #20]
 800a7f0:	429f      	cmp	r7, r3
 800a7f2:	d24c      	bcs.n	800a88e <create_chain+0x116>
 800a7f4:	4622      	mov	r2, r4
 800a7f6:	4639      	mov	r1, r7
 800a7f8:	4630      	mov	r0, r6
 800a7fa:	f7ff fed9 	bl	800a5b0 <put_fat.part.0>
	if (res == FR_OK) {			/* Update allocation information if the function succeeded */
 800a7fe:	2800      	cmp	r0, #0
 800a800:	d143      	bne.n	800a88a <create_chain+0x112>
		if (fs->free_clst > 0 && fs->free_clst <= fs->n_fatent - 2) {
 800a802:	6933      	ldr	r3, [r6, #16]
		fs->last_clst = ncl;
 800a804:	60f4      	str	r4, [r6, #12]
		if (fs->free_clst > 0 && fs->free_clst <= fs->n_fatent - 2) {
 800a806:	2b00      	cmp	r3, #0
 800a808:	d03d      	beq.n	800a886 <create_chain+0x10e>
 800a80a:	6972      	ldr	r2, [r6, #20]
 800a80c:	3a02      	subs	r2, #2
 800a80e:	4293      	cmp	r3, r2
 800a810:	d839      	bhi.n	800a886 <create_chain+0x10e>
			fs->fsi_flag |= 1;
 800a812:	7972      	ldrb	r2, [r6, #5]
			fs->free_clst--;
 800a814:	3b01      	subs	r3, #1
			fs->fsi_flag |= 1;
 800a816:	4620      	mov	r0, r4
 800a818:	f042 0201 	orr.w	r2, r2, #1
			fs->free_clst--;
 800a81c:	6133      	str	r3, [r6, #16]
			fs->fsi_flag |= 1;
 800a81e:	7172      	strb	r2, [r6, #5]
}
 800a820:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 800a824:	6933      	ldr	r3, [r6, #16]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800a826:	f04f 0801 	mov.w	r8, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 800a82a:	2b00      	cmp	r3, #0
 800a82c:	d1b8      	bne.n	800a7a0 <create_chain+0x28>
					if (ncl > scl) return 0;	/* No free cluster found? */
 800a82e:	2000      	movs	r0, #0
}
 800a830:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cs = get_fat(obj, clst);			/* Check the cluster status */
 800a834:	4630      	mov	r0, r6
 800a836:	f7ff fc95 	bl	800a164 <get_fat.isra.0>
		if (cs < 2) return 1;				/* Test for insanity */
 800a83a:	2801      	cmp	r0, #1
 800a83c:	d927      	bls.n	800a88e <create_chain+0x116>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 800a83e:	1c41      	adds	r1, r0, #1
 800a840:	d028      	beq.n	800a894 <create_chain+0x11c>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800a842:	6973      	ldr	r3, [r6, #20]
 800a844:	4283      	cmp	r3, r0
 800a846:	d8eb      	bhi.n	800a820 <create_chain+0xa8>
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 800a848:	6932      	ldr	r2, [r6, #16]
 800a84a:	2a00      	cmp	r2, #0
 800a84c:	d0ef      	beq.n	800a82e <create_chain+0xb6>
			ncl = scl + 1;						/* Test if next cluster is free */
 800a84e:	1c7c      	adds	r4, r7, #1
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 800a850:	6828      	ldr	r0, [r5, #0]
			if (ncl >= fs->n_fatent) ncl = 2;
 800a852:	42a3      	cmp	r3, r4
 800a854:	bf98      	it	ls
 800a856:	2402      	movls	r4, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 800a858:	4621      	mov	r1, r4
 800a85a:	f7ff fc83 	bl	800a164 <get_fat.isra.0>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 800a85e:	2801      	cmp	r0, #1
 800a860:	d0de      	beq.n	800a820 <create_chain+0xa8>
 800a862:	1c42      	adds	r2, r0, #1
 800a864:	d0dc      	beq.n	800a820 <create_chain+0xa8>
			if (cs != 0) {						/* Not free? */
 800a866:	b148      	cbz	r0, 800a87c <create_chain+0x104>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 800a868:	f8d6 800c 	ldr.w	r8, [r6, #12]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 800a86c:	6973      	ldr	r3, [r6, #20]
 800a86e:	f1b8 0f01 	cmp.w	r8, #1
 800a872:	d906      	bls.n	800a882 <create_chain+0x10a>
 800a874:	4543      	cmp	r3, r8
 800a876:	bf98      	it	ls
 800a878:	46b8      	movls	r8, r7
 800a87a:	e792      	b.n	800a7a2 <create_chain+0x2a>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 800a87c:	2c00      	cmp	r4, #0
 800a87e:	d1a9      	bne.n	800a7d4 <create_chain+0x5c>
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 800a880:	6973      	ldr	r3, [r6, #20]
 800a882:	46b8      	mov	r8, r7
 800a884:	e78d      	b.n	800a7a2 <create_chain+0x2a>
 800a886:	4620      	mov	r0, r4
 800a888:	e7ca      	b.n	800a820 <create_chain+0xa8>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800a88a:	2801      	cmp	r0, #1
 800a88c:	d002      	beq.n	800a894 <create_chain+0x11c>
		if (cs < 2) return 1;				/* Test for insanity */
 800a88e:	2001      	movs	r0, #1
}
 800a890:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800a894:	f04f 30ff 	mov.w	r0, #4294967295
 800a898:	e7c2      	b.n	800a820 <create_chain+0xa8>
 800a89a:	bf00      	nop

0800a89c <dir_next>:
{
 800a89c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800a8a0:	6905      	ldr	r5, [r0, #16]
{
 800a8a2:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 800a8a4:	6806      	ldr	r6, [r0, #0]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800a8a6:	3520      	adds	r5, #32
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 800a8a8:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 800a8ac:	d304      	bcc.n	800a8b8 <dir_next+0x1c>
 800a8ae:	2300      	movs	r3, #0
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 800a8b0:	2004      	movs	r0, #4
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 800a8b2:	61a3      	str	r3, [r4, #24]
}
 800a8b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 800a8b8:	6983      	ldr	r3, [r0, #24]
 800a8ba:	2b00      	cmp	r3, #0
 800a8bc:	d04d      	beq.n	800a95a <dir_next+0xbe>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800a8be:	f3c5 0808 	ubfx	r8, r5, #0, #9
 800a8c2:	f1b8 0f00 	cmp.w	r8, #0
 800a8c6:	d136      	bne.n	800a936 <dir_next+0x9a>
		dp->sect++;				/* Next sector */
 800a8c8:	460f      	mov	r7, r1
 800a8ca:	3301      	adds	r3, #1
		if (dp->clust == 0) {	/* Static table */
 800a8cc:	6941      	ldr	r1, [r0, #20]
		dp->sect++;				/* Next sector */
 800a8ce:	6183      	str	r3, [r0, #24]
		if (dp->clust == 0) {	/* Static table */
 800a8d0:	2900      	cmp	r1, #0
 800a8d2:	d037      	beq.n	800a944 <dir_next+0xa8>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 800a8d4:	8973      	ldrh	r3, [r6, #10]
 800a8d6:	3b01      	subs	r3, #1
 800a8d8:	ea13 2955 	ands.w	r9, r3, r5, lsr #9
 800a8dc:	d12b      	bne.n	800a936 <dir_next+0x9a>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 800a8de:	4630      	mov	r0, r6
 800a8e0:	f7ff fc40 	bl	800a164 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 800a8e4:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 800a8e6:	4682      	mov	sl, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 800a8e8:	d933      	bls.n	800a952 <dir_next+0xb6>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800a8ea:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a8ee:	d02e      	beq.n	800a94e <dir_next+0xb2>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 800a8f0:	6973      	ldr	r3, [r6, #20]
 800a8f2:	4283      	cmp	r3, r0
 800a8f4:	d812      	bhi.n	800a91c <dir_next+0x80>
					if (!stretch) {								/* If no stretch, report EOT */
 800a8f6:	2f00      	cmp	r7, #0
 800a8f8:	d0d9      	beq.n	800a8ae <dir_next+0x12>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 800a8fa:	6961      	ldr	r1, [r4, #20]
 800a8fc:	4620      	mov	r0, r4
 800a8fe:	f7ff ff3b 	bl	800a778 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800a902:	4682      	mov	sl, r0
 800a904:	b338      	cbz	r0, 800a956 <dir_next+0xba>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 800a906:	2801      	cmp	r0, #1
 800a908:	d023      	beq.n	800a952 <dir_next+0xb6>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800a90a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a90e:	d01e      	beq.n	800a94e <dir_next+0xb2>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 800a910:	4601      	mov	r1, r0
 800a912:	4630      	mov	r0, r6
 800a914:	f7ff fb3e 	bl	8009f94 <dir_clear>
 800a918:	b9c8      	cbnz	r0, 800a94e <dir_next+0xb2>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800a91a:	6973      	ldr	r3, [r6, #20]
 800a91c:	3b02      	subs	r3, #2
	clst -= 2;		/* Cluster number is origin from 2 */
 800a91e:	f1aa 0102 	sub.w	r1, sl, #2
				dp->clust = clst;		/* Initialize data for new cluster */
 800a922:	f8c4 a014 	str.w	sl, [r4, #20]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800a926:	4299      	cmp	r1, r3
 800a928:	d203      	bcs.n	800a932 <dir_next+0x96>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 800a92a:	8972      	ldrh	r2, [r6, #10]
 800a92c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800a92e:	fb01 3902 	mla	r9, r1, r2, r3
				dp->sect = clst2sect(fs, clst);
 800a932:	f8c4 9018 	str.w	r9, [r4, #24]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800a936:	3630      	adds	r6, #48	; 0x30
	return FR_OK;
 800a938:	2000      	movs	r0, #0
	dp->dptr = ofs;						/* Current entry */
 800a93a:	6125      	str	r5, [r4, #16]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800a93c:	4446      	add	r6, r8
 800a93e:	61e6      	str	r6, [r4, #28]
}
 800a940:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800a944:	8933      	ldrh	r3, [r6, #8]
 800a946:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 800a94a:	d8f4      	bhi.n	800a936 <dir_next+0x9a>
 800a94c:	e7af      	b.n	800a8ae <dir_next+0x12>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800a94e:	2001      	movs	r0, #1
 800a950:	e7b0      	b.n	800a8b4 <dir_next+0x18>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 800a952:	2002      	movs	r0, #2
 800a954:	e7ae      	b.n	800a8b4 <dir_next+0x18>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800a956:	2007      	movs	r0, #7
 800a958:	e7ac      	b.n	800a8b4 <dir_next+0x18>
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 800a95a:	2004      	movs	r0, #4
 800a95c:	e7aa      	b.n	800a8b4 <dir_next+0x18>
 800a95e:	bf00      	nop

0800a960 <follow_path>:
{
 800a960:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		while (IsSeparator(*path)) path++;	/* Strip heading separators */
 800a964:	780b      	ldrb	r3, [r1, #0]
{
 800a966:	b083      	sub	sp, #12
	FATFS *fs = dp->obj.fs;
 800a968:	6802      	ldr	r2, [r0, #0]
{
 800a96a:	4688      	mov	r8, r1
		while (IsSeparator(*path)) path++;	/* Strip heading separators */
 800a96c:	2b2f      	cmp	r3, #47	; 0x2f
{
 800a96e:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 800a970:	9201      	str	r2, [sp, #4]
		while (IsSeparator(*path)) path++;	/* Strip heading separators */
 800a972:	d103      	bne.n	800a97c <follow_path+0x1c>
 800a974:	f818 3f01 	ldrb.w	r3, [r8, #1]!
 800a978:	2b2f      	cmp	r3, #47	; 0x2f
 800a97a:	d0fb      	beq.n	800a974 <follow_path+0x14>
 800a97c:	2b5c      	cmp	r3, #92	; 0x5c
 800a97e:	d0f9      	beq.n	800a974 <follow_path+0x14>
		dp->obj.sclust = 0;					/* Start at the root directory */
 800a980:	2300      	movs	r3, #0
 800a982:	60ab      	str	r3, [r5, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800a984:	f898 3000 	ldrb.w	r3, [r8]
 800a988:	2b1f      	cmp	r3, #31
 800a98a:	f240 80c3 	bls.w	800ab14 <follow_path+0x1b4>
	p = *path; sfn = dp->fn;
 800a98e:	f105 0620 	add.w	r6, r5, #32
	memset(sfn, ' ', 11);
 800a992:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
 800a996:	6073      	str	r3, [r6, #4]
 800a998:	6033      	str	r3, [r6, #0]
 800a99a:	f8c6 3007 	str.w	r3, [r6, #7]
		c = (BYTE)p[si++];				/* Get a byte */
 800a99e:	f898 4000 	ldrb.w	r4, [r8]
		if (c <= ' ') break; 			/* Break if end of the path name */
 800a9a2:	2c20      	cmp	r4, #32
 800a9a4:	f240 8081 	bls.w	800aaaa <follow_path+0x14a>
 800a9a8:	46c3      	mov	fp, r8
	si = i = 0; ni = 8;
 800a9aa:	2700      	movs	r7, #0
 800a9ac:	f04f 0908 	mov.w	r9, #8
		c = (BYTE)p[si++];				/* Get a byte */
 800a9b0:	f04f 0a01 	mov.w	sl, #1
		if (IsSeparator(c)) {			/* Break if a separator is found */
 800a9b4:	2c2f      	cmp	r4, #47	; 0x2f
 800a9b6:	d07d      	beq.n	800aab4 <follow_path+0x154>
 800a9b8:	2c5c      	cmp	r4, #92	; 0x5c
 800a9ba:	d07b      	beq.n	800aab4 <follow_path+0x154>
		if (c == '.' || i >= ni) {		/* End of body or field overflow? */
 800a9bc:	2c2e      	cmp	r4, #46	; 0x2e
 800a9be:	d055      	beq.n	800aa6c <follow_path+0x10c>
 800a9c0:	45b9      	cmp	r9, r7
 800a9c2:	d953      	bls.n	800aa6c <follow_path+0x10c>
		if (c >= 0x80) {				/* Is SBC extended character? */
 800a9c4:	0623      	lsls	r3, r4, #24
 800a9c6:	d503      	bpl.n	800a9d0 <follow_path+0x70>
			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
 800a9c8:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 800a9cc:	4b57      	ldr	r3, [pc, #348]	; (800ab2c <follow_path+0x1cc>)
 800a9ce:	5d1c      	ldrb	r4, [r3, r4]
			if (strchr("*+,:;<=>[]|\"\?\x7F", (int)c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
 800a9d0:	4621      	mov	r1, r4
 800a9d2:	4857      	ldr	r0, [pc, #348]	; (800ab30 <follow_path+0x1d0>)
 800a9d4:	f003 ff58 	bl	800e888 <strchr>
 800a9d8:	2800      	cmp	r0, #0
 800a9da:	d166      	bne.n	800aaaa <follow_path+0x14a>
			if (IsLower(c)) c -= 0x20;	/* To upper */
 800a9dc:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 800a9e0:	2b19      	cmp	r3, #25
 800a9e2:	d801      	bhi.n	800a9e8 <follow_path+0x88>
 800a9e4:	3c20      	subs	r4, #32
 800a9e6:	b2e4      	uxtb	r4, r4
			sfn[i++] = c;
 800a9e8:	55f4      	strb	r4, [r6, r7]
 800a9ea:	3701      	adds	r7, #1
		c = (BYTE)p[si++];				/* Get a byte */
 800a9ec:	f81b 4f01 	ldrb.w	r4, [fp, #1]!
 800a9f0:	f10a 0a01 	add.w	sl, sl, #1
		if (c <= ' ') break; 			/* Break if end of the path name */
 800a9f4:	2c20      	cmp	r4, #32
 800a9f6:	d8dd      	bhi.n	800a9b4 <follow_path+0x54>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800a9f8:	f895 3020 	ldrb.w	r3, [r5, #32]
	*path = &p[si];						/* Return pointer to the next segment */
 800a9fc:	44d0      	add	r8, sl
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800a9fe:	2be5      	cmp	r3, #229	; 0xe5
 800aa00:	f000 8081 	beq.w	800ab06 <follow_path+0x1a6>
	sfn[NSFLAG] = (c <= ' ' || p[si] <= ' ') ? NS_LAST : 0;	/* Set last segment flag if end of the path */
 800aa04:	f04f 0a04 	mov.w	sl, #4
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800aa08:	4628      	mov	r0, r5
	sfn[NSFLAG] = (c <= ' ' || p[si] <= ' ') ? NS_LAST : 0;	/* Set last segment flag if end of the path */
 800aa0a:	f885 a02b 	strb.w	sl, [r5, #43]	; 0x2b
	FATFS *fs = dp->obj.fs;
 800aa0e:	682f      	ldr	r7, [r5, #0]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800aa10:	f7ff fbfe 	bl	800a210 <dir_sdi.constprop.0>
	if (res != FR_OK) return res;
 800aa14:	4604      	mov	r4, r0
 800aa16:	b1b0      	cbz	r0, 800aa46 <follow_path+0xe6>
 800aa18:	e01e      	b.n	800aa58 <follow_path+0xf8>
		et = dp->dir[DIR_Name];		/* Entry type */
 800aa1a:	69eb      	ldr	r3, [r5, #28]
		if (et == 0) { res = FR_NO_FILE; break; }	/* Reached end of directory table */
 800aa1c:	781c      	ldrb	r4, [r3, #0]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !memcmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 800aa1e:	4618      	mov	r0, r3
		if (et == 0) { res = FR_NO_FILE; break; }	/* Reached end of directory table */
 800aa20:	b1e4      	cbz	r4, 800aa5c <follow_path+0xfc>
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
 800aa22:	f893 b00b 	ldrb.w	fp, [r3, #11]
 800aa26:	f00b 043f 	and.w	r4, fp, #63	; 0x3f
 800aa2a:	71ac      	strb	r4, [r5, #6]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !memcmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 800aa2c:	7adc      	ldrb	r4, [r3, #11]
 800aa2e:	f014 0408 	ands.w	r4, r4, #8
 800aa32:	d102      	bne.n	800aa3a <follow_path+0xda>
 800aa34:	f003 fea6 	bl	800e784 <memcmp>
 800aa38:	b308      	cbz	r0, 800aa7e <follow_path+0x11e>
		res = dir_next(dp, 0);	/* Next entry */
 800aa3a:	2100      	movs	r1, #0
 800aa3c:	4628      	mov	r0, r5
 800aa3e:	f7ff ff2d 	bl	800a89c <dir_next>
	} while (res == FR_OK);
 800aa42:	4604      	mov	r4, r0
 800aa44:	b940      	cbnz	r0, 800aa58 <follow_path+0xf8>
		res = move_window(fs, dp->sect);
 800aa46:	69a9      	ldr	r1, [r5, #24]
 800aa48:	4638      	mov	r0, r7
 800aa4a:	f7ff fb3d 	bl	800a0c8 <move_window>
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !memcmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 800aa4e:	220b      	movs	r2, #11
 800aa50:	4631      	mov	r1, r6
		if (res != FR_OK) break;
 800aa52:	4604      	mov	r4, r0
 800aa54:	2800      	cmp	r0, #0
 800aa56:	d0e0      	beq.n	800aa1a <follow_path+0xba>
				if (res == FR_NO_FILE) {	/* Object is not found */
 800aa58:	2c04      	cmp	r4, #4
 800aa5a:	d127      	bne.n	800aaac <follow_path+0x14c>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800aa5c:	f1ba 0f00 	cmp.w	sl, #0
 800aa60:	d14c      	bne.n	800aafc <follow_path+0x19c>
 800aa62:	2405      	movs	r4, #5
}
 800aa64:	4620      	mov	r0, r4
 800aa66:	b003      	add	sp, #12
 800aa68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
 800aa6c:	f1b9 0f0b 	cmp.w	r9, #11
 800aa70:	d01b      	beq.n	800aaaa <follow_path+0x14a>
 800aa72:	2c2e      	cmp	r4, #46	; 0x2e
 800aa74:	d119      	bne.n	800aaaa <follow_path+0x14a>
			i = 8; ni = 11;				/* Enter file extension field */
 800aa76:	2708      	movs	r7, #8
 800aa78:	f04f 090b 	mov.w	r9, #11
 800aa7c:	e7b6      	b.n	800a9ec <follow_path+0x8c>
			if (ns & NS_LAST) break;		/* If last segment matched, the function completed */
 800aa7e:	f1ba 0f00 	cmp.w	sl, #0
 800aa82:	d113      	bne.n	800aaac <follow_path+0x14c>
			if (!(dp->obj.attr & AM_DIR)) {
 800aa84:	f01b 0f10 	tst.w	fp, #16
 800aa88:	d0eb      	beq.n	800aa62 <follow_path+0x102>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800aa8a:	9901      	ldr	r1, [sp, #4]
 800aa8c:	692a      	ldr	r2, [r5, #16]
 800aa8e:	f101 0330 	add.w	r3, r1, #48	; 0x30
	if (fs->fs_type == FS_FAT32) {
 800aa92:	7809      	ldrb	r1, [r1, #0]
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800aa94:	f3c2 0208 	ubfx	r2, r2, #0, #9
	if (fs->fs_type == FS_FAT32) {
 800aa98:	2903      	cmp	r1, #3
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800aa9a:	4413      	add	r3, r2
	cl = ld_16(dir + DIR_FstClusLO);
 800aa9c:	8b5a      	ldrh	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 800aa9e:	d102      	bne.n	800aaa6 <follow_path+0x146>
		cl |= (DWORD)ld_16(dir + DIR_FstClusHI) << 16;
 800aaa0:	8a9b      	ldrh	r3, [r3, #20]
 800aaa2:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800aaa6:	60aa      	str	r2, [r5, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800aaa8:	e773      	b.n	800a992 <follow_path+0x32>
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 800aaaa:	2406      	movs	r4, #6
}
 800aaac:	4620      	mov	r0, r4
 800aaae:	b003      	add	sp, #12
 800aab0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			while (IsSeparator(p[si])) si++;	/* Skip duplicated separators */
 800aab4:	f818 300a 	ldrb.w	r3, [r8, sl]
 800aab8:	eb08 020a 	add.w	r2, r8, sl
 800aabc:	2b5c      	cmp	r3, #92	; 0x5c
 800aabe:	d001      	beq.n	800aac4 <follow_path+0x164>
 800aac0:	2b2f      	cmp	r3, #47	; 0x2f
 800aac2:	d130      	bne.n	800ab26 <follow_path+0x1c6>
 800aac4:	f10a 0301 	add.w	r3, sl, #1
 800aac8:	4443      	add	r3, r8
 800aaca:	4698      	mov	r8, r3
 800aacc:	f813 2b01 	ldrb.w	r2, [r3], #1
 800aad0:	2a2f      	cmp	r2, #47	; 0x2f
 800aad2:	d0fa      	beq.n	800aaca <follow_path+0x16a>
 800aad4:	2a5c      	cmp	r2, #92	; 0x5c
 800aad6:	d0f8      	beq.n	800aaca <follow_path+0x16a>
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 800aad8:	2f00      	cmp	r7, #0
 800aada:	d0e6      	beq.n	800aaaa <follow_path+0x14a>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800aadc:	f895 3020 	ldrb.w	r3, [r5, #32]
 800aae0:	2be5      	cmp	r3, #229	; 0xe5
 800aae2:	d010      	beq.n	800ab06 <follow_path+0x1a6>
	sfn[NSFLAG] = (c <= ' ' || p[si] <= ' ') ? NS_LAST : 0;	/* Set last segment flag if end of the path */
 800aae4:	f898 a000 	ldrb.w	sl, [r8]
 800aae8:	f1ba 0f20 	cmp.w	sl, #32
 800aaec:	bf8c      	ite	hi
 800aaee:	f04f 0a00 	movhi.w	sl, #0
 800aaf2:	f04f 0a01 	movls.w	sl, #1
 800aaf6:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800aafa:	e785      	b.n	800aa08 <follow_path+0xa8>
			res = dir_find(dp);				/* Find an object with the segment name */
 800aafc:	2404      	movs	r4, #4
}
 800aafe:	4620      	mov	r0, r4
 800ab00:	b003      	add	sp, #12
 800ab02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800ab06:	2305      	movs	r3, #5
	sfn[NSFLAG] = (c <= ' ' || p[si] <= ' ') ? NS_LAST : 0;	/* Set last segment flag if end of the path */
 800ab08:	2c20      	cmp	r4, #32
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800ab0a:	f885 3020 	strb.w	r3, [r5, #32]
	sfn[NSFLAG] = (c <= ' ' || p[si] <= ' ') ? NS_LAST : 0;	/* Set last segment flag if end of the path */
 800ab0e:	f67f af79 	bls.w	800aa04 <follow_path+0xa4>
 800ab12:	e7e7      	b.n	800aae4 <follow_path+0x184>
		dp->fn[NSFLAG] = NS_NONAME;
 800ab14:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 800ab16:	4628      	mov	r0, r5
		dp->fn[NSFLAG] = NS_NONAME;
 800ab18:	f885 302b 	strb.w	r3, [r5, #43]	; 0x2b
}
 800ab1c:	b003      	add	sp, #12
 800ab1e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 800ab22:	f7ff bb75 	b.w	800a210 <dir_sdi.constprop.0>
			while (IsSeparator(p[si])) si++;	/* Skip duplicated separators */
 800ab26:	4690      	mov	r8, r2
 800ab28:	e7d6      	b.n	800aad8 <follow_path+0x178>
 800ab2a:	bf00      	nop
 800ab2c:	0801538c 	.word	0x0801538c
 800ab30:	0801537c 	.word	0x0801537c

0800ab34 <dir_read.constprop.0>:
static FRESULT dir_read (
 800ab34:	b538      	push	{r3, r4, r5, lr}
	FRESULT res = FR_NO_FILE;
 800ab36:	2304      	movs	r3, #4
static FRESULT dir_read (
 800ab38:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 800ab3a:	6805      	ldr	r5, [r0, #0]
	while (dp->sect) {
 800ab3c:	e01b      	b.n	800ab76 <dir_read.constprop.0+0x42>
		res = move_window(fs, dp->sect);
 800ab3e:	f7ff fac3 	bl	800a0c8 <move_window>
 800ab42:	4603      	mov	r3, r0
		res = dir_next(dp, 0);		/* Next entry */
 800ab44:	2100      	movs	r1, #0
 800ab46:	4620      	mov	r0, r4
		if (res != FR_OK) break;
 800ab48:	b9f3      	cbnz	r3, 800ab88 <dir_read.constprop.0+0x54>
		et = dp->dir[DIR_Name];	/* Test for the entry type */
 800ab4a:	69e3      	ldr	r3, [r4, #28]
 800ab4c:	781a      	ldrb	r2, [r3, #0]
		if (et == 0) {
 800ab4e:	b1d2      	cbz	r2, 800ab86 <dir_read.constprop.0+0x52>
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800ab50:	7adb      	ldrb	r3, [r3, #11]
			if (et != DDEM && et != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 800ab52:	2ae5      	cmp	r2, #229	; 0xe5
 800ab54:	bf18      	it	ne
 800ab56:	2a2e      	cmpne	r2, #46	; 0x2e
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800ab58:	f003 033f 	and.w	r3, r3, #63	; 0x3f
			if (et != DDEM && et != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 800ab5c:	f023 0c20 	bic.w	ip, r3, #32
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800ab60:	71a3      	strb	r3, [r4, #6]
			if (et != DDEM && et != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 800ab62:	d004      	beq.n	800ab6e <dir_read.constprop.0+0x3a>
 800ab64:	2b0f      	cmp	r3, #15
 800ab66:	d002      	beq.n	800ab6e <dir_read.constprop.0+0x3a>
 800ab68:	f1bc 0f08 	cmp.w	ip, #8
 800ab6c:	d108      	bne.n	800ab80 <dir_read.constprop.0+0x4c>
		res = dir_next(dp, 0);		/* Next entry */
 800ab6e:	f7ff fe95 	bl	800a89c <dir_next>
		if (res != FR_OK) break;
 800ab72:	4603      	mov	r3, r0
 800ab74:	b940      	cbnz	r0, 800ab88 <dir_read.constprop.0+0x54>
	while (dp->sect) {
 800ab76:	69a1      	ldr	r1, [r4, #24]
		res = move_window(fs, dp->sect);
 800ab78:	4628      	mov	r0, r5
	while (dp->sect) {
 800ab7a:	2900      	cmp	r1, #0
 800ab7c:	d1df      	bne.n	800ab3e <dir_read.constprop.0+0xa>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800ab7e:	b91b      	cbnz	r3, 800ab88 <dir_read.constprop.0+0x54>
		res = move_window(fs, dp->sect);
 800ab80:	2300      	movs	r3, #0
}
 800ab82:	4618      	mov	r0, r3
 800ab84:	bd38      	pop	{r3, r4, r5, pc}
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 800ab86:	2304      	movs	r3, #4
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800ab88:	2200      	movs	r2, #0
}
 800ab8a:	4618      	mov	r0, r3
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800ab8c:	61a2      	str	r2, [r4, #24]
}
 800ab8e:	bd38      	pop	{r3, r4, r5, pc}

0800ab90 <dir_register>:
{
 800ab90:	b570      	push	{r4, r5, r6, lr}
 800ab92:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 800ab94:	6806      	ldr	r6, [r0, #0]
	res = dir_sdi(dp, 0);
 800ab96:	f7ff fb3b 	bl	800a210 <dir_sdi.constprop.0>
	if (res == FR_OK) {
 800ab9a:	4604      	mov	r4, r0
 800ab9c:	b148      	cbz	r0, 800abb2 <dir_register+0x22>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 800ab9e:	2c04      	cmp	r4, #4
 800aba0:	bf08      	it	eq
 800aba2:	2407      	moveq	r4, #7
}
 800aba4:	4620      	mov	r0, r4
 800aba6:	bd70      	pop	{r4, r5, r6, pc}
			res = dir_next(dp, 1);	/* Next entry with table stretch enabled */
 800aba8:	f7ff fe78 	bl	800a89c <dir_next>
		} while (res == FR_OK);
 800abac:	4604      	mov	r4, r0
 800abae:	2800      	cmp	r0, #0
 800abb0:	d1f5      	bne.n	800ab9e <dir_register+0xe>
			res = move_window(fs, dp->sect);
 800abb2:	69a9      	ldr	r1, [r5, #24]
 800abb4:	4630      	mov	r0, r6
 800abb6:	f7ff fa87 	bl	800a0c8 <move_window>
			if (res != FR_OK) break;
 800abba:	4604      	mov	r4, r0
 800abbc:	2800      	cmp	r0, #0
 800abbe:	d1ee      	bne.n	800ab9e <dir_register+0xe>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {	/* Is the entry free? */
 800abc0:	69eb      	ldr	r3, [r5, #28]
 800abc2:	781b      	ldrb	r3, [r3, #0]
 800abc4:	2be5      	cmp	r3, #229	; 0xe5
 800abc6:	d003      	beq.n	800abd0 <dir_register+0x40>
			res = dir_next(dp, 1);	/* Next entry with table stretch enabled */
 800abc8:	2101      	movs	r1, #1
 800abca:	4628      	mov	r0, r5
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {	/* Is the entry free? */
 800abcc:	2b00      	cmp	r3, #0
 800abce:	d1eb      	bne.n	800aba8 <dir_register+0x18>
		res = move_window(fs, dp->sect);
 800abd0:	69a9      	ldr	r1, [r5, #24]
 800abd2:	4630      	mov	r0, r6
 800abd4:	f7ff fa78 	bl	800a0c8 <move_window>
		if (res == FR_OK) {
 800abd8:	4604      	mov	r4, r0
 800abda:	b108      	cbz	r0, 800abe0 <dir_register+0x50>
}
 800abdc:	4620      	mov	r0, r4
 800abde:	bd70      	pop	{r4, r5, r6, pc}
			memset(dp->dir, 0, SZDIRE);	/* Clean the entry */
 800abe0:	4601      	mov	r1, r0
 800abe2:	2220      	movs	r2, #32
 800abe4:	69e8      	ldr	r0, [r5, #28]
 800abe6:	f003 fdfd 	bl	800e7e4 <memset>
			memcpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800abea:	f105 0320 	add.w	r3, r5, #32
 800abee:	69ea      	ldr	r2, [r5, #28]
			fs->wflag = 1;
 800abf0:	2501      	movs	r5, #1
			memcpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800abf2:	cb03      	ldmia	r3!, {r0, r1}
 800abf4:	6010      	str	r0, [r2, #0]
}
 800abf6:	4620      	mov	r0, r4
			memcpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800abf8:	6051      	str	r1, [r2, #4]
 800abfa:	8819      	ldrh	r1, [r3, #0]
 800abfc:	789b      	ldrb	r3, [r3, #2]
 800abfe:	8111      	strh	r1, [r2, #8]
 800ac00:	7293      	strb	r3, [r2, #10]
			fs->wflag = 1;
 800ac02:	7135      	strb	r5, [r6, #4]
}
 800ac04:	bd70      	pop	{r4, r5, r6, pc}
 800ac06:	bf00      	nop

0800ac08 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object to be registered (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mount option: 0=Do not mount (delayed mount), 1=Mount immediately */
)
{
 800ac08:	b510      	push	{r4, lr}
 800ac0a:	b084      	sub	sp, #16
 800ac0c:	4614      	mov	r4, r2
 800ac0e:	9001      	str	r0, [sp, #4]
	FRESULT res;
	const TCHAR *rp = path;


	/* Get volume ID (logical drive number) */
	vol = get_ldnumber(&rp);
 800ac10:	a803      	add	r0, sp, #12
{
 800ac12:	9100      	str	r1, [sp, #0]
	const TCHAR *rp = path;
 800ac14:	9103      	str	r1, [sp, #12]
	vol = get_ldnumber(&rp);
 800ac16:	f7ff f967 	bl	8009ee8 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 800ac1a:	2800      	cmp	r0, #0
 800ac1c:	db19      	blt.n	800ac52 <f_mount+0x4a>

	cfs = FatFs[vol];			/* Pointer to the filesystem object of the volume */
 800ac1e:	4a0e      	ldr	r2, [pc, #56]	; (800ac58 <f_mount+0x50>)
 800ac20:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
	if (cfs) {					/* Unregister current filesystem object */
 800ac24:	b11b      	cbz	r3, 800ac2e <f_mount+0x26>
		FatFs[vol] = 0;
 800ac26:	2100      	movs	r1, #0
 800ac28:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
		clear_share(cfs);
#endif
#if FF_FS_REENTRANT				/* Discard mutex of the current volume */
		ff_mutex_delete(vol);
#endif
		cfs->fs_type = 0;		/* Invalidate the filesystem object to be unregistered */
 800ac2c:	7019      	strb	r1, [r3, #0]
	}

	if (fs) {					/* Register new filesystem object */
 800ac2e:	9b01      	ldr	r3, [sp, #4]
 800ac30:	b123      	cbz	r3, 800ac3c <f_mount+0x34>
			}
			SysLock = 1;		/* System mutex is ready */
		}
#endif
#endif
		fs->fs_type = 0;		/* Invalidate the new filesystem object */
 800ac32:	2100      	movs	r1, #0
		fs->pdrv = LD2PD(vol);	/* Volume hosting physical drive */
 800ac34:	7058      	strb	r0, [r3, #1]
		fs->fs_type = 0;		/* Invalidate the new filesystem object */
 800ac36:	7019      	strb	r1, [r3, #0]
		FatFs[vol] = fs;		/* Register it */
 800ac38:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
	}

	if (opt == 0) return FR_OK;	/* Do not mount now, it will be mounted in subsequent file functions */
 800ac3c:	b914      	cbnz	r4, 800ac44 <f_mount+0x3c>
 800ac3e:	4620      	mov	r0, r4

	res = mount_volume(&path, &fs, 0);	/* Force mounted the volume in this function */
	LEAVE_FF(fs, res);
}
 800ac40:	b004      	add	sp, #16
 800ac42:	bd10      	pop	{r4, pc}
	res = mount_volume(&path, &fs, 0);	/* Force mounted the volume in this function */
 800ac44:	2200      	movs	r2, #0
 800ac46:	a901      	add	r1, sp, #4
 800ac48:	4668      	mov	r0, sp
 800ac4a:	f7ff fb89 	bl	800a360 <mount_volume>
}
 800ac4e:	b004      	add	sp, #16
 800ac50:	bd10      	pop	{r4, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 800ac52:	200b      	movs	r0, #11
}
 800ac54:	b004      	add	sp, #16
 800ac56:	bd10      	pop	{r4, pc}
 800ac58:	24004660 	.word	0x24004660

0800ac5c <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and open mode flags */
)
{
 800ac5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ac60:	b08e      	sub	sp, #56	; 0x38
 800ac62:	9101      	str	r1, [sp, #4]
	DIR dj;
	FATFS *fs;
	DEF_NAMEBUFF


	if (!fp) return FR_INVALID_OBJECT;	/* Reject null pointer */
 800ac64:	2800      	cmp	r0, #0
 800ac66:	d07d      	beq.n	800ad64 <f_open+0x108>

	/* Get logical drive number and mount the volume if needed */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
 800ac68:	f002 063f 	and.w	r6, r2, #63	; 0x3f
	res = mount_volume(&path, &fs, mode);
 800ac6c:	4617      	mov	r7, r2
 800ac6e:	4604      	mov	r4, r0
 800ac70:	a902      	add	r1, sp, #8
 800ac72:	a801      	add	r0, sp, #4
 800ac74:	4632      	mov	r2, r6
 800ac76:	f7ff fb73 	bl	800a360 <mount_volume>

	if (res == FR_OK) {
 800ac7a:	4605      	mov	r5, r0
 800ac7c:	b128      	cbz	r0, 800ac8a <f_open+0x2e>
		}

		FREE_NAMEBUFF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800ac7e:	2300      	movs	r3, #0
 800ac80:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 800ac82:	4628      	mov	r0, r5
 800ac84:	b00e      	add	sp, #56	; 0x38
 800ac86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		fp->obj.fs = fs;
 800ac8a:	f8dd 8008 	ldr.w	r8, [sp, #8]
		res = follow_path(&dj, path);	/* Follow the file path */
 800ac8e:	a803      	add	r0, sp, #12
 800ac90:	9901      	ldr	r1, [sp, #4]
		fp->obj.fs = fs;
 800ac92:	f8c4 8000 	str.w	r8, [r4]
		dj.obj.fs = fs;
 800ac96:	f8cd 800c 	str.w	r8, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 800ac9a:	f7ff fe61 	bl	800a960 <follow_path>
		if (res == FR_OK) {
 800ac9e:	2800      	cmp	r0, #0
 800aca0:	d14f      	bne.n	800ad42 <f_open+0xe6>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 800aca2:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
 800aca6:	2b00      	cmp	r3, #0
 800aca8:	db61      	blt.n	800ad6e <f_open+0x112>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800acaa:	f017 0f1c 	tst.w	r7, #28
 800acae:	d04f      	beq.n	800ad50 <f_open+0xf4>
				if (mode & FA_CREATE_NEW) {
 800acb0:	0779      	lsls	r1, r7, #29
 800acb2:	d460      	bmi.n	800ad76 <f_open+0x11a>
					if (dj.obj.attr & (AM_RDO | AM_DIR)) res = FR_DENIED;	/* Cannot overwrite it (R/O or DIR) */
 800acb4:	f89d 3012 	ldrb.w	r3, [sp, #18]
 800acb8:	f013 0f11 	tst.w	r3, #17
 800acbc:	d150      	bne.n	800ad60 <f_open+0x104>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 800acbe:	0739      	lsls	r1, r7, #28
 800acc0:	d462      	bmi.n	800ad88 <f_open+0x12c>
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 800acc2:	f8d8 301c 	ldr.w	r3, [r8, #28]
 800acc6:	6223      	str	r3, [r4, #32]
			fp->dir_ptr = dj.dir;
 800acc8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800acca:	6263      	str	r3, [r4, #36]	; 0x24
	if (fs->fs_type == FS_FAT32) {
 800accc:	f898 2000 	ldrb.w	r2, [r8]
	cl = ld_16(dir + DIR_FstClusLO);
 800acd0:	8b5f      	ldrh	r7, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 800acd2:	2a03      	cmp	r2, #3
 800acd4:	f000 809a 	beq.w	800ae0c <f_open+0x1b0>
			fp->err = 0;		/* Clear error flag */
 800acd8:	2100      	movs	r1, #0
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 800acda:	60a7      	str	r7, [r4, #8]
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 800acdc:	f104 0a28 	add.w	sl, r4, #40	; 0x28
	rv = rv << 8 | ptr[0];
 800ace0:	f8d3 901c 	ldr.w	r9, [r3, #28]
			fp->obj.id = fs->id;	/* Set current volume mount ID */
 800ace4:	f8b8 3006 	ldrh.w	r3, [r8, #6]
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 800ace8:	f44f 7200 	mov.w	r2, #512	; 0x200
			fp->err = 0;		/* Clear error flag */
 800acec:	7461      	strb	r1, [r4, #17]
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 800acee:	4650      	mov	r0, sl
			fp->sect = 0;		/* Invalidate current data sector */
 800acf0:	61e1      	str	r1, [r4, #28]
			fp->fptr = 0;		/* Set file pointer top of the file */
 800acf2:	6161      	str	r1, [r4, #20]
				fp->obj.objsize = ld_32(dj.dir + DIR_FileSize);
 800acf4:	f8c4 900c 	str.w	r9, [r4, #12]
			fp->obj.id = fs->id;	/* Set current volume mount ID */
 800acf8:	80a3      	strh	r3, [r4, #4]
			fp->flag = mode;	/* Set file access mode */
 800acfa:	7426      	strb	r6, [r4, #16]
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 800acfc:	f003 fd72 	bl	800e7e4 <memset>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800ad00:	06b1      	lsls	r1, r6, #26
 800ad02:	d5be      	bpl.n	800ac82 <f_open+0x26>
 800ad04:	f1b9 0f00 	cmp.w	r9, #0
 800ad08:	d0bb      	beq.n	800ac82 <f_open+0x26>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800ad0a:	f8b8 300a 	ldrh.w	r3, [r8, #10]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 800ad0e:	f8c4 9014 	str.w	r9, [r4, #20]
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800ad12:	ebb9 2f43 	cmp.w	r9, r3, lsl #9
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800ad16:	ea4f 2643 	mov.w	r6, r3, lsl #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800ad1a:	d806      	bhi.n	800ad2a <f_open+0xce>
 800ad1c:	e07a      	b.n	800ae14 <f_open+0x1b8>
 800ad1e:	1c42      	adds	r2, r0, #1
 800ad20:	f000 809b 	beq.w	800ae5a <f_open+0x1fe>
 800ad24:	454e      	cmp	r6, r9
 800ad26:	f080 8098 	bcs.w	800ae5a <f_open+0x1fe>
					clst = get_fat(&fp->obj, clst);
 800ad2a:	4639      	mov	r1, r7
 800ad2c:	6820      	ldr	r0, [r4, #0]
 800ad2e:	f7ff fa19 	bl	800a164 <get_fat.isra.0>
					if (clst <= 1) res = FR_INT_ERR;
 800ad32:	2801      	cmp	r0, #1
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800ad34:	eba9 0906 	sub.w	r9, r9, r6
					clst = get_fat(&fp->obj, clst);
 800ad38:	4607      	mov	r7, r0
					if (clst <= 1) res = FR_INT_ERR;
 800ad3a:	d8f0      	bhi.n	800ad1e <f_open+0xc2>
 800ad3c:	2502      	movs	r5, #2
				fp->clust = clst;
 800ad3e:	61a0      	str	r0, [r4, #24]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800ad40:	e79d      	b.n	800ac7e <f_open+0x22>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800ad42:	f017 0f1c 	tst.w	r7, #28
 800ad46:	d001      	beq.n	800ad4c <f_open+0xf0>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 800ad48:	2804      	cmp	r0, #4
 800ad4a:	d016      	beq.n	800ad7a <f_open+0x11e>
 800ad4c:	4605      	mov	r5, r0
 800ad4e:	e796      	b.n	800ac7e <f_open+0x22>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 800ad50:	f89d 3012 	ldrb.w	r3, [sp, #18]
 800ad54:	06da      	lsls	r2, r3, #27
 800ad56:	d40c      	bmi.n	800ad72 <f_open+0x116>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 800ad58:	07ba      	lsls	r2, r7, #30
 800ad5a:	d552      	bpl.n	800ae02 <f_open+0x1a6>
 800ad5c:	07df      	lsls	r7, r3, #31
 800ad5e:	d550      	bpl.n	800ae02 <f_open+0x1a6>
					if (dj.obj.attr & (AM_RDO | AM_DIR)) res = FR_DENIED;	/* Cannot overwrite it (R/O or DIR) */
 800ad60:	2507      	movs	r5, #7
 800ad62:	e78c      	b.n	800ac7e <f_open+0x22>
	if (!fp) return FR_INVALID_OBJECT;	/* Reject null pointer */
 800ad64:	2509      	movs	r5, #9
}
 800ad66:	4628      	mov	r0, r5
 800ad68:	b00e      	add	sp, #56	; 0x38
 800ad6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				res = FR_INVALID_NAME;
 800ad6e:	2506      	movs	r5, #6
 800ad70:	e785      	b.n	800ac7e <f_open+0x22>
					res = FR_NO_FILE;
 800ad72:	2504      	movs	r5, #4
 800ad74:	e783      	b.n	800ac7e <f_open+0x22>
					res = FR_EXIST;				/* Cannot create as new file */
 800ad76:	2508      	movs	r5, #8
 800ad78:	e781      	b.n	800ac7e <f_open+0x22>
					res = dir_register(&dj);
 800ad7a:	a803      	add	r0, sp, #12
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 800ad7c:	f046 0608 	orr.w	r6, r6, #8
					res = dir_register(&dj);
 800ad80:	f7ff ff06 	bl	800ab90 <dir_register>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 800ad84:	2800      	cmp	r0, #0
 800ad86:	d1e1      	bne.n	800ad4c <f_open+0xf0>
					st_32(dj.dir + DIR_CrtTime, tm);	/* Set created time */
 800ad88:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
 800ad8a:	2200      	movs	r2, #0
	*ptr++ = (BYTE)val; val >>= 8;
 800ad8c:	2021      	movs	r0, #33	; 0x21
	*ptr++ = (BYTE)val;
 800ad8e:	215a      	movs	r1, #90	; 0x5a
	*ptr++ = (BYTE)val; val >>= 8;
 800ad90:	739a      	strb	r2, [r3, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 800ad92:	73da      	strb	r2, [r3, #15]
	*ptr++ = (BYTE)val; val >>= 8;
 800ad94:	7418      	strb	r0, [r3, #16]
	*ptr++ = (BYTE)val;
 800ad96:	7459      	strb	r1, [r3, #17]
					st_32(dj.dir + DIR_ModTime, tm);	/* Set modified time (tmp setting) */
 800ad98:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
 800ad9a:	7618      	strb	r0, [r3, #24]
	*ptr++ = (BYTE)val;
 800ad9c:	7659      	strb	r1, [r3, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 800ad9e:	759a      	strb	r2, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 800ada0:	75da      	strb	r2, [r3, #23]
	if (fs->fs_type == FS_FAT32) {
 800ada2:	f898 2000 	ldrb.w	r2, [r8]
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 800ada6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	if (fs->fs_type == FS_FAT32) {
 800ada8:	2a03      	cmp	r2, #3
	cl = ld_16(dir + DIR_FstClusLO);
 800adaa:	8b5f      	ldrh	r7, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 800adac:	d102      	bne.n	800adb4 <f_open+0x158>
		cl |= (DWORD)ld_16(dir + DIR_FstClusHI) << 16;
 800adae:	8a9a      	ldrh	r2, [r3, #20]
 800adb0:	ea47 4702 	orr.w	r7, r7, r2, lsl #16
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 800adb4:	2220      	movs	r2, #32
 800adb6:	72da      	strb	r2, [r3, #11]
	*ptr++ = (BYTE)val; val >>= 8;
 800adb8:	2200      	movs	r2, #0
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 800adba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
 800adbc:	769a      	strb	r2, [r3, #26]
	*ptr++ = (BYTE)val;
 800adbe:	76da      	strb	r2, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 800adc0:	f898 1000 	ldrb.w	r1, [r8]
 800adc4:	2903      	cmp	r1, #3
 800adc6:	d101      	bne.n	800adcc <f_open+0x170>
	*ptr++ = (BYTE)val; val >>= 8;
 800adc8:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 800adca:	755a      	strb	r2, [r3, #21]
					st_32(dj.dir + DIR_FileSize, 0);
 800adcc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
 800adce:	2200      	movs	r2, #0
 800add0:	771a      	strb	r2, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 800add2:	775a      	strb	r2, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 800add4:	779a      	strb	r2, [r3, #30]
	*ptr++ = (BYTE)val;
 800add6:	77da      	strb	r2, [r3, #31]
					fs->wflag = 1;
 800add8:	2301      	movs	r3, #1
 800adda:	f888 3004 	strb.w	r3, [r8, #4]
					if (cl != 0) {						/* Remove the cluster chain if exist */
 800adde:	b187      	cbz	r7, 800ae02 <f_open+0x1a6>
						res = remove_chain(&dj.obj, cl, 0);
 800ade0:	a803      	add	r0, sp, #12
 800ade2:	4639      	mov	r1, r7
						LBA_t sc = fs->winsect;
 800ade4:	f8d8 901c 	ldr.w	r9, [r8, #28]
						res = remove_chain(&dj.obj, cl, 0);
 800ade8:	f7ff fc84 	bl	800a6f4 <remove_chain>
						if (res == FR_OK) {
 800adec:	2800      	cmp	r0, #0
 800adee:	d1ad      	bne.n	800ad4c <f_open+0xf0>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800adf0:	3f01      	subs	r7, #1
							res = move_window(fs, sc);
 800adf2:	4649      	mov	r1, r9
 800adf4:	4640      	mov	r0, r8
 800adf6:	f7ff f967 	bl	800a0c8 <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800adfa:	f8c8 700c 	str.w	r7, [r8, #12]
		if (res == FR_OK) {
 800adfe:	2800      	cmp	r0, #0
 800ae00:	d1a4      	bne.n	800ad4c <f_open+0xf0>
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 800ae02:	0730      	lsls	r0, r6, #28
 800ae04:	bf48      	it	mi
 800ae06:	f046 0640 	orrmi.w	r6, r6, #64	; 0x40
 800ae0a:	e75a      	b.n	800acc2 <f_open+0x66>
		cl |= (DWORD)ld_16(dir + DIR_FstClusHI) << 16;
 800ae0c:	8a9a      	ldrh	r2, [r3, #20]
 800ae0e:	ea47 4702 	orr.w	r7, r7, r2, lsl #16
 800ae12:	e761      	b.n	800acd8 <f_open+0x7c>
				fp->clust = clst;
 800ae14:	61a7      	str	r7, [r4, #24]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800ae16:	f3c9 0308 	ubfx	r3, r9, #0, #9
 800ae1a:	2b00      	cmp	r3, #0
 800ae1c:	f43f af31 	beq.w	800ac82 <f_open+0x26>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800ae20:	f8d8 3014 	ldr.w	r3, [r8, #20]
	clst -= 2;		/* Cluster number is origin from 2 */
 800ae24:	3f02      	subs	r7, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800ae26:	3b02      	subs	r3, #2
 800ae28:	429f      	cmp	r7, r3
 800ae2a:	d206      	bcs.n	800ae3a <f_open+0x1de>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 800ae2c:	f8b8 200a 	ldrh.w	r2, [r8, #10]
 800ae30:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 800ae34:	fb07 3202 	mla	r2, r7, r2, r3
					if (sec == 0) {
 800ae38:	b90a      	cbnz	r2, 800ae3e <f_open+0x1e2>
 800ae3a:	2502      	movs	r5, #2
 800ae3c:	e71f      	b.n	800ac7e <f_open+0x22>
						fp->sect = sec + (DWORD)(ofs / SS(fs));
 800ae3e:	eb02 2259 	add.w	r2, r2, r9, lsr #9
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 800ae42:	4651      	mov	r1, sl
 800ae44:	2301      	movs	r3, #1
						fp->sect = sec + (DWORD)(ofs / SS(fs));
 800ae46:	61e2      	str	r2, [r4, #28]
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 800ae48:	f898 0001 	ldrb.w	r0, [r8, #1]
 800ae4c:	f7fe ffda 	bl	8009e04 <disk_read>
 800ae50:	2800      	cmp	r0, #0
 800ae52:	f43f af16 	beq.w	800ac82 <f_open+0x26>
 800ae56:	2501      	movs	r5, #1
 800ae58:	e711      	b.n	800ac7e <f_open+0x22>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800ae5a:	1c78      	adds	r0, r7, #1
				fp->clust = clst;
 800ae5c:	61a7      	str	r7, [r4, #24]
					if (clst <= 1) res = FR_INT_ERR;
 800ae5e:	bf0c      	ite	eq
 800ae60:	2301      	moveq	r3, #1
 800ae62:	2300      	movne	r3, #0
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800ae64:	d1d7      	bne.n	800ae16 <f_open+0x1ba>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800ae66:	461d      	mov	r5, r3
 800ae68:	e709      	b.n	800ac7e <f_open+0x22>
 800ae6a:	bf00      	nop

0800ae6c <f_read>:
	FIL* fp, 	/* Open file to be read */
	void* buff,	/* Data buffer to store the read data */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Number of bytes read */
)
{
 800ae6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ae70:	461e      	mov	r6, r3
 800ae72:	b087      	sub	sp, #28
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 800ae74:	2300      	movs	r3, #0
{
 800ae76:	4688      	mov	r8, r1
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 800ae78:	a905      	add	r1, sp, #20
{
 800ae7a:	4604      	mov	r4, r0
	*br = 0;	/* Clear read byte counter */
 800ae7c:	6033      	str	r3, [r6, #0]
{
 800ae7e:	4691      	mov	r9, r2
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 800ae80:	f7ff f84e 	bl	8009f20 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800ae84:	4605      	mov	r5, r0
 800ae86:	2800      	cmp	r0, #0
 800ae88:	d15d      	bne.n	800af46 <f_read+0xda>
 800ae8a:	7c65      	ldrb	r5, [r4, #17]
 800ae8c:	2d00      	cmp	r5, #0
 800ae8e:	d15a      	bne.n	800af46 <f_read+0xda>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800ae90:	7c23      	ldrb	r3, [r4, #16]
 800ae92:	f013 0301 	ands.w	r3, r3, #1
 800ae96:	9301      	str	r3, [sp, #4]
 800ae98:	f000 8090 	beq.w	800afbc <f_read+0x150>
	remain = fp->obj.objsize - fp->fptr;
 800ae9c:	6960      	ldr	r0, [r4, #20]
 800ae9e:	68e7      	ldr	r7, [r4, #12]
 800aea0:	1a3f      	subs	r7, r7, r0
 800aea2:	454f      	cmp	r7, r9
 800aea4:	bf28      	it	cs
 800aea6:	464f      	movcs	r7, r9
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {	/* Repeat until btr bytes read */
 800aea8:	2f00      	cmp	r7, #0
 800aeaa:	d04c      	beq.n	800af46 <f_read+0xda>
			}
#if !FF_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
#if !FF_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800aeac:	f104 0b28 	add.w	fp, r4, #40	; 0x28
 800aeb0:	46b2      	mov	sl, r6
 800aeb2:	9502      	str	r5, [sp, #8]
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800aeb4:	f3c0 0108 	ubfx	r1, r0, #0, #9
 800aeb8:	bb71      	cbnz	r1, 800af18 <f_read+0xac>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800aeba:	f8dd 9014 	ldr.w	r9, [sp, #20]
 800aebe:	f8b9 200a 	ldrh.w	r2, [r9, #10]
 800aec2:	3a01      	subs	r2, #1
			if (csect == 0) {					/* On the cluster boundary? */
 800aec4:	ea12 2250 	ands.w	r2, r2, r0, lsr #9
 800aec8:	d041      	beq.n	800af4e <f_read+0xe2>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 800aeca:	69a0      	ldr	r0, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800aecc:	f8d9 3014 	ldr.w	r3, [r9, #20]
	clst -= 2;		/* Cluster number is origin from 2 */
 800aed0:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800aed2:	3b02      	subs	r3, #2
 800aed4:	4298      	cmp	r0, r3
 800aed6:	d247      	bcs.n	800af68 <f_read+0xfc>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 800aed8:	f8b9 100a 	ldrh.w	r1, [r9, #10]
 800aedc:	f8d9 602c 	ldr.w	r6, [r9, #44]	; 0x2c
 800aee0:	fb01 6600 	mla	r6, r1, r0, r6
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 800aee4:	2e00      	cmp	r6, #0
 800aee6:	d03f      	beq.n	800af68 <f_read+0xfc>
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 800aee8:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
			sect += csect;
 800aeec:	4416      	add	r6, r2
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 800aeee:	d242      	bcs.n	800af76 <f_read+0x10a>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 800aef0:	69e2      	ldr	r2, [r4, #28]
 800aef2:	42b2      	cmp	r2, r6
 800aef4:	d00c      	beq.n	800af10 <f_read+0xa4>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 800aef6:	f994 3010 	ldrsb.w	r3, [r4, #16]
 800aefa:	2b00      	cmp	r3, #0
 800aefc:	db60      	blt.n	800afc0 <f_read+0x154>
					fp->flag &= (BYTE)~FA_DIRTY;
				}
#endif
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 800aefe:	f899 0001 	ldrb.w	r0, [r9, #1]
 800af02:	2301      	movs	r3, #1
 800af04:	4632      	mov	r2, r6
 800af06:	4659      	mov	r1, fp
 800af08:	f7fe ff7c 	bl	8009e04 <disk_read>
 800af0c:	2800      	cmp	r0, #0
 800af0e:	d147      	bne.n	800afa0 <f_read+0x134>
			}
#endif
			fp->sect = sect;
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 800af10:	6961      	ldr	r1, [r4, #20]
			fp->sect = sect;
 800af12:	61e6      	str	r6, [r4, #28]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 800af14:	f3c1 0108 	ubfx	r1, r1, #0, #9
 800af18:	f5c1 7900 	rsb	r9, r1, #512	; 0x200
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		memcpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800af1c:	4640      	mov	r0, r8
 800af1e:	4459      	add	r1, fp
 800af20:	45b9      	cmp	r9, r7
 800af22:	bf28      	it	cs
 800af24:	46b9      	movcs	r9, r7
 800af26:	464a      	mov	r2, r9
 800af28:	f7f5 fc28 	bl	800077c <memcpy>
	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {	/* Repeat until btr bytes read */
 800af2c:	f8da 3000 	ldr.w	r3, [sl]
 800af30:	ebb7 0709 	subs.w	r7, r7, r9
 800af34:	6960      	ldr	r0, [r4, #20]
 800af36:	44c8      	add	r8, r9
 800af38:	444b      	add	r3, r9
 800af3a:	4448      	add	r0, r9
 800af3c:	f8ca 3000 	str.w	r3, [sl]
 800af40:	6160      	str	r0, [r4, #20]
 800af42:	d1b7      	bne.n	800aeb4 <f_read+0x48>
 800af44:	9d02      	ldr	r5, [sp, #8]
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 800af46:	4628      	mov	r0, r5
 800af48:	b007      	add	sp, #28
 800af4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (fp->fptr == 0) {			/* On the top of the file? */
 800af4e:	bb70      	cbnz	r0, 800afae <f_read+0x142>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 800af50:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800af52:	2801      	cmp	r0, #1
 800af54:	d908      	bls.n	800af68 <f_read+0xfc>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800af56:	1c43      	adds	r3, r0, #1
 800af58:	d022      	beq.n	800afa0 <f_read+0x134>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800af5a:	f8d9 3014 	ldr.w	r3, [r9, #20]
				fp->clust = clst;				/* Update current cluster */
 800af5e:	61a0      	str	r0, [r4, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 800af60:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800af62:	3b02      	subs	r3, #2
 800af64:	4298      	cmp	r0, r3
 800af66:	d3b7      	bcc.n	800aed8 <f_read+0x6c>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800af68:	2302      	movs	r3, #2
 800af6a:	461d      	mov	r5, r3
 800af6c:	7463      	strb	r3, [r4, #17]
}
 800af6e:	4628      	mov	r0, r5
 800af70:	b007      	add	sp, #28
 800af72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800af76:	eb02 2057 	add.w	r0, r2, r7, lsr #9
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 800af7a:	0a7d      	lsrs	r5, r7, #9
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800af7c:	4288      	cmp	r0, r1
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800af7e:	f899 0001 	ldrb.w	r0, [r9, #1]
					cc = fs->csize - csect;
 800af82:	bf88      	it	hi
 800af84:	1a8d      	subhi	r5, r1, r2
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800af86:	4632      	mov	r2, r6
 800af88:	4641      	mov	r1, r8
 800af8a:	462b      	mov	r3, r5
 800af8c:	f7fe ff3a 	bl	8009e04 <disk_read>
 800af90:	b930      	cbnz	r0, 800afa0 <f_read+0x134>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 800af92:	f994 2010 	ldrsb.w	r2, [r4, #16]
 800af96:	2a00      	cmp	r2, #0
 800af98:	db1f      	blt.n	800afda <f_read+0x16e>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 800af9a:	ea4f 2945 	mov.w	r9, r5, lsl #9
				continue;
 800af9e:	e7c5      	b.n	800af2c <f_read+0xc0>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800afa0:	9d01      	ldr	r5, [sp, #4]
 800afa2:	2301      	movs	r3, #1
}
 800afa4:	4628      	mov	r0, r5
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800afa6:	7463      	strb	r3, [r4, #17]
}
 800afa8:	b007      	add	sp, #28
 800afaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 800afae:	69a1      	ldr	r1, [r4, #24]
 800afb0:	6820      	ldr	r0, [r4, #0]
 800afb2:	9203      	str	r2, [sp, #12]
 800afb4:	f7ff f8d6 	bl	800a164 <get_fat.isra.0>
 800afb8:	9a03      	ldr	r2, [sp, #12]
 800afba:	e7ca      	b.n	800af52 <f_read+0xe6>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800afbc:	2507      	movs	r5, #7
 800afbe:	e7c2      	b.n	800af46 <f_read+0xda>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800afc0:	2301      	movs	r3, #1
 800afc2:	4659      	mov	r1, fp
 800afc4:	f899 0001 	ldrb.w	r0, [r9, #1]
 800afc8:	f7fe ff3e 	bl	8009e48 <disk_write>
 800afcc:	2800      	cmp	r0, #0
 800afce:	d1e7      	bne.n	800afa0 <f_read+0x134>
					fp->flag &= (BYTE)~FA_DIRTY;
 800afd0:	7c23      	ldrb	r3, [r4, #16]
 800afd2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800afd6:	7423      	strb	r3, [r4, #16]
 800afd8:	e791      	b.n	800aefe <f_read+0x92>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 800afda:	69e0      	ldr	r0, [r4, #28]
 800afdc:	1b80      	subs	r0, r0, r6
 800afde:	42a8      	cmp	r0, r5
 800afe0:	d2db      	bcs.n	800af9a <f_read+0x12e>
					memcpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 800afe2:	eb08 2040 	add.w	r0, r8, r0, lsl #9
 800afe6:	f44f 7200 	mov.w	r2, #512	; 0x200
 800afea:	4659      	mov	r1, fp
 800afec:	f7f5 fbc6 	bl	800077c <memcpy>
 800aff0:	e7d3      	b.n	800af9a <f_read+0x12e>
 800aff2:	bf00      	nop

0800aff4 <f_write>:
	FIL* fp,			/* Open file to be written */
	const void* buff,	/* Data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Number of bytes written */
)
{
 800aff4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800aff8:	461f      	mov	r7, r3
 800affa:	b085      	sub	sp, #20
	LBA_t sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 800affc:	2300      	movs	r3, #0
{
 800affe:	4688      	mov	r8, r1
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 800b000:	a903      	add	r1, sp, #12
{
 800b002:	4604      	mov	r4, r0
	*bw = 0;	/* Clear write byte counter */
 800b004:	603b      	str	r3, [r7, #0]
{
 800b006:	4615      	mov	r5, r2
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 800b008:	f7fe ff8a 	bl	8009f20 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800b00c:	4606      	mov	r6, r0
 800b00e:	2800      	cmp	r0, #0
 800b010:	d15b      	bne.n	800b0ca <f_write+0xd6>
 800b012:	7c66      	ldrb	r6, [r4, #17]
 800b014:	2e00      	cmp	r6, #0
 800b016:	d158      	bne.n	800b0ca <f_write+0xd6>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 800b018:	7c23      	ldrb	r3, [r4, #16]
 800b01a:	079a      	lsls	r2, r3, #30
 800b01c:	f140 80ae 	bpl.w	800b17c <f_write+0x188>

	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 800b020:	6961      	ldr	r1, [r4, #20]
 800b022:	42e9      	cmn	r1, r5
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 800b024:	bf28      	it	cs
 800b026:	43cd      	mvncs	r5, r1
	}

	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repeat until all data written */
 800b028:	2d00      	cmp	r5, #0
 800b02a:	d07a      	beq.n	800b122 <f_write+0x12e>
			}
#if FF_FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800b02c:	f104 0b28 	add.w	fp, r4, #40	; 0x28
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 800b030:	f3c1 0008 	ubfx	r0, r1, #0, #9
 800b034:	2800      	cmp	r0, #0
 800b036:	d156      	bne.n	800b0e6 <f_write+0xf2>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 800b038:	f8dd a00c 	ldr.w	sl, [sp, #12]
 800b03c:	f8ba 900a 	ldrh.w	r9, [sl, #10]
 800b040:	f109 39ff 	add.w	r9, r9, #4294967295
			if (csect == 0) {				/* On the cluster boundary? */
 800b044:	ea19 2951 	ands.w	r9, r9, r1, lsr #9
 800b048:	d10d      	bne.n	800b066 <f_write+0x72>
				if (fp->fptr == 0) {		/* On the top of the file? */
 800b04a:	2900      	cmp	r1, #0
 800b04c:	f040 808e 	bne.w	800b16c <f_write+0x178>
					clst = fp->obj.sclust;	/* Follow from the origin */
 800b050:	68a0      	ldr	r0, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 800b052:	2800      	cmp	r0, #0
 800b054:	d07b      	beq.n	800b14e <f_write+0x15a>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 800b056:	2801      	cmp	r0, #1
 800b058:	d034      	beq.n	800b0c4 <f_write+0xd0>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800b05a:	1c43      	adds	r3, r0, #1
 800b05c:	d07f      	beq.n	800b15e <f_write+0x16a>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 800b05e:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
 800b060:	61a0      	str	r0, [r4, #24]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 800b062:	2b00      	cmp	r3, #0
 800b064:	d061      	beq.n	800b12a <f_write+0x136>
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 800b066:	f994 3010 	ldrsb.w	r3, [r4, #16]
 800b06a:	2b00      	cmp	r3, #0
 800b06c:	db62      	blt.n	800b134 <f_write+0x140>
	clst -= 2;		/* Cluster number is origin from 2 */
 800b06e:	69a3      	ldr	r3, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800b070:	f8da 2014 	ldr.w	r2, [sl, #20]
	clst -= 2;		/* Cluster number is origin from 2 */
 800b074:	3b02      	subs	r3, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800b076:	3a02      	subs	r2, #2
 800b078:	4293      	cmp	r3, r2
 800b07a:	d223      	bcs.n	800b0c4 <f_write+0xd0>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 800b07c:	f8ba 100a 	ldrh.w	r1, [sl, #10]
 800b080:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
 800b084:	fb01 2203 	mla	r2, r1, r3, r2
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 800b088:	b1e2      	cbz	r2, 800b0c4 <f_write+0xd0>
			sect += csect;
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 800b08a:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
			sect += csect;
 800b08e:	444a      	add	r2, r9
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 800b090:	d31f      	bcc.n	800b0d2 <f_write+0xde>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800b092:	eb09 2055 	add.w	r0, r9, r5, lsr #9
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 800b096:	0a6b      	lsrs	r3, r5, #9
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800b098:	4288      	cmp	r0, r1
					cc = fs->csize - csect;
				}
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800b09a:	f89a 0001 	ldrb.w	r0, [sl, #1]
					cc = fs->csize - csect;
 800b09e:	bf88      	it	hi
 800b0a0:	eba1 0309 	subhi.w	r3, r1, r9
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800b0a4:	4641      	mov	r1, r8
 800b0a6:	e9cd 2300 	strd	r2, r3, [sp]
 800b0aa:	f7fe fecd 	bl	8009e48 <disk_write>
 800b0ae:	2800      	cmp	r0, #0
 800b0b0:	d155      	bne.n	800b15e <f_write+0x16a>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					memcpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 800b0b2:	69e1      	ldr	r1, [r4, #28]
 800b0b4:	9a00      	ldr	r2, [sp, #0]
 800b0b6:	9b01      	ldr	r3, [sp, #4]
 800b0b8:	1a89      	subs	r1, r1, r2
 800b0ba:	4299      	cmp	r1, r3
 800b0bc:	d36c      	bcc.n	800b198 <f_write+0x1a4>
					memcpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
					fp->flag &= (BYTE)~FA_DIRTY;
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 800b0be:	ea4f 2943 	mov.w	r9, r3, lsl #9
				continue;
 800b0c2:	e01e      	b.n	800b102 <f_write+0x10e>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 800b0c4:	2302      	movs	r3, #2
 800b0c6:	461e      	mov	r6, r3
 800b0c8:	7463      	strb	r3, [r4, #17]
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */

	LEAVE_FF(fs, FR_OK);
}
 800b0ca:	4630      	mov	r0, r6
 800b0cc:	b005      	add	sp, #20
 800b0ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 800b0d2:	69e3      	ldr	r3, [r4, #28]
				fp->fptr < fp->obj.objsize &&
 800b0d4:	6960      	ldr	r0, [r4, #20]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 800b0d6:	4293      	cmp	r3, r2
 800b0d8:	d002      	beq.n	800b0e0 <f_write+0xec>
 800b0da:	68e3      	ldr	r3, [r4, #12]
 800b0dc:	4298      	cmp	r0, r3
 800b0de:	d34f      	bcc.n	800b180 <f_write+0x18c>
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 800b0e0:	f3c0 0008 	ubfx	r0, r0, #0, #9
			fp->sect = sect;
 800b0e4:	61e2      	str	r2, [r4, #28]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 800b0e6:	f5c0 7900 	rsb	r9, r0, #512	; 0x200
		memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 800b0ea:	4641      	mov	r1, r8
 800b0ec:	4458      	add	r0, fp
 800b0ee:	45a9      	cmp	r9, r5
 800b0f0:	bf28      	it	cs
 800b0f2:	46a9      	movcs	r9, r5
 800b0f4:	464a      	mov	r2, r9
 800b0f6:	f7f5 fb41 	bl	800077c <memcpy>
		fp->flag |= FA_DIRTY;
 800b0fa:	7c23      	ldrb	r3, [r4, #16]
 800b0fc:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800b100:	7423      	strb	r3, [r4, #16]
	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repeat until all data written */
 800b102:	683b      	ldr	r3, [r7, #0]
 800b104:	44c8      	add	r8, r9
 800b106:	6961      	ldr	r1, [r4, #20]
 800b108:	444b      	add	r3, r9
 800b10a:	4449      	add	r1, r9
 800b10c:	603b      	str	r3, [r7, #0]
 800b10e:	68e3      	ldr	r3, [r4, #12]
 800b110:	6161      	str	r1, [r4, #20]
 800b112:	428b      	cmp	r3, r1
 800b114:	bf38      	it	cc
 800b116:	460b      	movcc	r3, r1
 800b118:	ebb5 0509 	subs.w	r5, r5, r9
 800b11c:	60e3      	str	r3, [r4, #12]
 800b11e:	d187      	bne.n	800b030 <f_write+0x3c>
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 800b120:	7c23      	ldrb	r3, [r4, #16]
 800b122:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b126:	7423      	strb	r3, [r4, #16]
	LEAVE_FF(fs, FR_OK);
 800b128:	e7cf      	b.n	800b0ca <f_write+0xd6>
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 800b12a:	f994 3010 	ldrsb.w	r3, [r4, #16]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 800b12e:	60a0      	str	r0, [r4, #8]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 800b130:	2b00      	cmp	r3, #0
 800b132:	da9c      	bge.n	800b06e <f_write+0x7a>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800b134:	2301      	movs	r3, #1
 800b136:	69e2      	ldr	r2, [r4, #28]
 800b138:	4659      	mov	r1, fp
 800b13a:	f89a 0001 	ldrb.w	r0, [sl, #1]
 800b13e:	f7fe fe83 	bl	8009e48 <disk_write>
 800b142:	b960      	cbnz	r0, 800b15e <f_write+0x16a>
				fp->flag &= (BYTE)~FA_DIRTY;
 800b144:	7c23      	ldrb	r3, [r4, #16]
 800b146:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800b14a:	7423      	strb	r3, [r4, #16]
 800b14c:	e78f      	b.n	800b06e <f_write+0x7a>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 800b14e:	4649      	mov	r1, r9
 800b150:	4620      	mov	r0, r4
 800b152:	f7ff fb11 	bl	800a778 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800b156:	2800      	cmp	r0, #0
 800b158:	f47f af7d 	bne.w	800b056 <f_write+0x62>
 800b15c:	e7e0      	b.n	800b120 <f_write+0x12c>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800b15e:	2301      	movs	r3, #1
 800b160:	461e      	mov	r6, r3
 800b162:	7463      	strb	r3, [r4, #17]
}
 800b164:	4630      	mov	r0, r6
 800b166:	b005      	add	sp, #20
 800b168:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800b16c:	69a1      	ldr	r1, [r4, #24]
 800b16e:	4620      	mov	r0, r4
 800b170:	f7ff fb02 	bl	800a778 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800b174:	2800      	cmp	r0, #0
 800b176:	f47f af6e 	bne.w	800b056 <f_write+0x62>
 800b17a:	e7d1      	b.n	800b120 <f_write+0x12c>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 800b17c:	2607      	movs	r6, #7
 800b17e:	e7a4      	b.n	800b0ca <f_write+0xd6>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
 800b180:	f89a 0001 	ldrb.w	r0, [sl, #1]
 800b184:	2301      	movs	r3, #1
 800b186:	4659      	mov	r1, fp
 800b188:	9200      	str	r2, [sp, #0]
 800b18a:	f7fe fe3b 	bl	8009e04 <disk_read>
				fp->fptr < fp->obj.objsize &&
 800b18e:	2800      	cmp	r0, #0
 800b190:	d1e5      	bne.n	800b15e <f_write+0x16a>
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 800b192:	6960      	ldr	r0, [r4, #20]
 800b194:	9a00      	ldr	r2, [sp, #0]
 800b196:	e7a3      	b.n	800b0e0 <f_write+0xec>
					memcpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 800b198:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b19c:	eb08 2141 	add.w	r1, r8, r1, lsl #9
 800b1a0:	4658      	mov	r0, fp
 800b1a2:	9300      	str	r3, [sp, #0]
 800b1a4:	f7f5 faea 	bl	800077c <memcpy>
					fp->flag &= (BYTE)~FA_DIRTY;
 800b1a8:	7c22      	ldrb	r2, [r4, #16]
 800b1aa:	9b00      	ldr	r3, [sp, #0]
 800b1ac:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800b1b0:	7422      	strb	r2, [r4, #16]
 800b1b2:	e784      	b.n	800b0be <f_write+0xca>

0800b1b4 <f_sync>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800b1b4:	2800      	cmp	r0, #0
 800b1b6:	d04a      	beq.n	800b24e <f_sync+0x9a>
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Open file to be synced */
)
{
 800b1b8:	b538      	push	{r3, r4, r5, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800b1ba:	6803      	ldr	r3, [r0, #0]
 800b1bc:	4604      	mov	r4, r0
 800b1be:	b12b      	cbz	r3, 800b1cc <f_sync+0x18>
 800b1c0:	781a      	ldrb	r2, [r3, #0]
 800b1c2:	b11a      	cbz	r2, 800b1cc <f_sync+0x18>
 800b1c4:	8881      	ldrh	r1, [r0, #4]
 800b1c6:	88da      	ldrh	r2, [r3, #6]
 800b1c8:	4291      	cmp	r1, r2
 800b1ca:	d001      	beq.n	800b1d0 <f_sync+0x1c>
	FRESULT res = FR_INVALID_OBJECT;
 800b1cc:	2009      	movs	r0, #9
			}
		}
	}

	LEAVE_FF(fs, res);
}
 800b1ce:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the hosting physical drive is kept initialized */
 800b1d0:	7858      	ldrb	r0, [r3, #1]
 800b1d2:	f7fe fde9 	bl	8009da8 <disk_status>
 800b1d6:	07c2      	lsls	r2, r0, #31
 800b1d8:	d4f8      	bmi.n	800b1cc <f_sync+0x18>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 800b1da:	7c23      	ldrb	r3, [r4, #16]
 800b1dc:	f013 0040 	ands.w	r0, r3, #64	; 0x40
 800b1e0:	d0f5      	beq.n	800b1ce <f_sync+0x1a>
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 800b1e2:	061b      	lsls	r3, r3, #24
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Return corresponding filesystem object if it is valid */
 800b1e4:	6825      	ldr	r5, [r4, #0]
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 800b1e6:	d434      	bmi.n	800b252 <f_sync+0x9e>
				res = move_window(fs, fp->dir_sect);
 800b1e8:	6a21      	ldr	r1, [r4, #32]
 800b1ea:	4628      	mov	r0, r5
 800b1ec:	f7fe ff6c 	bl	800a0c8 <move_window>
				if (res == FR_OK) {
 800b1f0:	2800      	cmp	r0, #0
 800b1f2:	d1ec      	bne.n	800b1ce <f_sync+0x1a>
					BYTE *dir = fp->dir_ptr;
 800b1f4:	6a63      	ldr	r3, [r4, #36]	; 0x24
					dir[DIR_Attr] |= AM_ARC;					/* Set archive attribute to indicate that the file has been changed */
 800b1f6:	7ada      	ldrb	r2, [r3, #11]
 800b1f8:	f042 0220 	orr.w	r2, r2, #32
 800b1fc:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);	/* Update file allocation information  */
 800b1fe:	68a2      	ldr	r2, [r4, #8]
 800b200:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800b202:	f3c2 2007 	ubfx	r0, r2, #8, #8
 800b206:	769a      	strb	r2, [r3, #26]
	*ptr++ = (BYTE)val;
 800b208:	76d8      	strb	r0, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 800b20a:	7809      	ldrb	r1, [r1, #0]
 800b20c:	2903      	cmp	r1, #3
 800b20e:	d103      	bne.n	800b218 <f_sync+0x64>
		st_16(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800b210:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800b212:	0a11      	lsrs	r1, r2, #8
 800b214:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 800b216:	7559      	strb	r1, [r3, #21]
					st_32(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 800b218:	68e2      	ldr	r2, [r4, #12]
					res = sync_fs(fs);							/* Restore it to the directory */
 800b21a:	4628      	mov	r0, r5
	*ptr++ = (BYTE)val; val >>= 8;
 800b21c:	0a11      	lsrs	r1, r2, #8
 800b21e:	771a      	strb	r2, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 800b220:	7759      	strb	r1, [r3, #29]
 800b222:	0c11      	lsrs	r1, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800b224:	0e12      	lsrs	r2, r2, #24
 800b226:	7799      	strb	r1, [r3, #30]
	*ptr++ = (BYTE)val; val >>= 8;
 800b228:	2100      	movs	r1, #0
	*ptr++ = (BYTE)val;
 800b22a:	77da      	strb	r2, [r3, #31]
					fs->wflag = 1;
 800b22c:	2201      	movs	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 800b22e:	7599      	strb	r1, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 800b230:	75d9      	strb	r1, [r3, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 800b232:	7499      	strb	r1, [r3, #18]
	*ptr++ = (BYTE)val;
 800b234:	74d9      	strb	r1, [r3, #19]
	*ptr++ = (BYTE)val; val >>= 8;
 800b236:	2121      	movs	r1, #33	; 0x21
 800b238:	7619      	strb	r1, [r3, #24]
	*ptr++ = (BYTE)val;
 800b23a:	215a      	movs	r1, #90	; 0x5a
 800b23c:	7659      	strb	r1, [r3, #25]
					fs->wflag = 1;
 800b23e:	712a      	strb	r2, [r5, #4]
					res = sync_fs(fs);							/* Restore it to the directory */
 800b240:	f7fe fede 	bl	800a000 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 800b244:	7c23      	ldrb	r3, [r4, #16]
 800b246:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800b24a:	7423      	strb	r3, [r4, #16]
}
 800b24c:	bd38      	pop	{r3, r4, r5, pc}
	FRESULT res = FR_INVALID_OBJECT;
 800b24e:	2009      	movs	r0, #9
}
 800b250:	4770      	bx	lr
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 800b252:	2301      	movs	r3, #1
 800b254:	69e2      	ldr	r2, [r4, #28]
 800b256:	f104 0128 	add.w	r1, r4, #40	; 0x28
 800b25a:	7868      	ldrb	r0, [r5, #1]
 800b25c:	f7fe fdf4 	bl	8009e48 <disk_write>
 800b260:	b920      	cbnz	r0, 800b26c <f_sync+0xb8>
				fp->flag &= (BYTE)~FA_DIRTY;
 800b262:	7c23      	ldrb	r3, [r4, #16]
 800b264:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800b268:	7423      	strb	r3, [r4, #16]
 800b26a:	e7bd      	b.n	800b1e8 <f_sync+0x34>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 800b26c:	2001      	movs	r0, #1
}
 800b26e:	bd38      	pop	{r3, r4, r5, pc}

0800b270 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Open file to be closed */
)
{
 800b270:	b510      	push	{r4, lr}
 800b272:	b082      	sub	sp, #8
 800b274:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 800b276:	f7ff ff9d 	bl	800b1b4 <f_sync>
	if (res == FR_OK)
 800b27a:	b108      	cbz	r0, 800b280 <f_close+0x10>
			unlock_volume(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 800b27c:	b002      	add	sp, #8
 800b27e:	bd10      	pop	{r4, pc}
		res = validate(&fp->obj, &fs);	/* Lock volume */
 800b280:	a901      	add	r1, sp, #4
 800b282:	4620      	mov	r0, r4
 800b284:	f7fe fe4c 	bl	8009f20 <validate>
		if (res == FR_OK) {
 800b288:	2800      	cmp	r0, #0
 800b28a:	d1f7      	bne.n	800b27c <f_close+0xc>
			fp->obj.fs = 0;	/* Invalidate file object */
 800b28c:	6020      	str	r0, [r4, #0]
}
 800b28e:	b002      	add	sp, #8
 800b290:	bd10      	pop	{r4, pc}
 800b292:	bf00      	nop

0800b294 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 800b294:	b530      	push	{r4, r5, lr}
 800b296:	b085      	sub	sp, #20
 800b298:	9101      	str	r1, [sp, #4]
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUFF


	if (!dp) return FR_INVALID_OBJECT;	/* Reject null pointer */
 800b29a:	2800      	cmp	r0, #0
 800b29c:	d030      	beq.n	800b300 <f_opendir+0x6c>

	res = mount_volume(&path, &fs, 0);	/* Get logical drive and mount the volume if needed */
 800b29e:	4604      	mov	r4, r0
 800b2a0:	2200      	movs	r2, #0
 800b2a2:	a903      	add	r1, sp, #12
 800b2a4:	a801      	add	r0, sp, #4
 800b2a6:	f7ff f85b 	bl	800a360 <mount_volume>
	if (res == FR_OK) {
 800b2aa:	b118      	cbz	r0, 800b2b4 <f_opendir+0x20>
			}
		}
		FREE_NAMEBUFF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function failed */
 800b2ac:	2300      	movs	r3, #0
 800b2ae:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 800b2b0:	b005      	add	sp, #20
 800b2b2:	bd30      	pop	{r4, r5, pc}
		dp->obj.fs = fs;
 800b2b4:	9d03      	ldr	r5, [sp, #12]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 800b2b6:	4620      	mov	r0, r4
 800b2b8:	9901      	ldr	r1, [sp, #4]
		dp->obj.fs = fs;
 800b2ba:	6025      	str	r5, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 800b2bc:	f7ff fb50 	bl	800a960 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 800b2c0:	b9d0      	cbnz	r0, 800b2f8 <f_opendir+0x64>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is neither the origin directory itself nor dot name in exFAT */
 800b2c2:	f994 302b 	ldrsb.w	r3, [r4, #43]	; 0x2b
 800b2c6:	2b00      	cmp	r3, #0
 800b2c8:	db0b      	blt.n	800b2e2 <f_opendir+0x4e>
				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
 800b2ca:	79a3      	ldrb	r3, [r4, #6]
 800b2cc:	06db      	lsls	r3, r3, #27
 800b2ce:	d515      	bpl.n	800b2fc <f_opendir+0x68>
	if (fs->fs_type == FS_FAT32) {
 800b2d0:	7829      	ldrb	r1, [r5, #0]
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800b2d2:	69e2      	ldr	r2, [r4, #28]
	if (fs->fs_type == FS_FAT32) {
 800b2d4:	2903      	cmp	r1, #3
	cl = ld_16(dir + DIR_FstClusLO);
 800b2d6:	8b53      	ldrh	r3, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 800b2d8:	d102      	bne.n	800b2e0 <f_opendir+0x4c>
		cl |= (DWORD)ld_16(dir + DIR_FstClusHI) << 16;
 800b2da:	8a92      	ldrh	r2, [r2, #20]
 800b2dc:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800b2e0:	60a3      	str	r3, [r4, #8]
				dp->obj.id = fs->id;		/* Set current volume mount ID */
 800b2e2:	88eb      	ldrh	r3, [r5, #6]
				res = dir_sdi(dp, 0);		/* Rewind directory */
 800b2e4:	4620      	mov	r0, r4
				dp->obj.id = fs->id;		/* Set current volume mount ID */
 800b2e6:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);		/* Rewind directory */
 800b2e8:	f7fe ff92 	bl	800a210 <dir_sdi.constprop.0>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800b2ec:	2804      	cmp	r0, #4
 800b2ee:	d005      	beq.n	800b2fc <f_opendir+0x68>
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function failed */
 800b2f0:	2800      	cmp	r0, #0
 800b2f2:	d1db      	bne.n	800b2ac <f_opendir+0x18>
}
 800b2f4:	b005      	add	sp, #20
 800b2f6:	bd30      	pop	{r4, r5, pc}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800b2f8:	2804      	cmp	r0, #4
 800b2fa:	d1d7      	bne.n	800b2ac <f_opendir+0x18>
					res = FR_NO_PATH;
 800b2fc:	2005      	movs	r0, #5
 800b2fe:	e7d5      	b.n	800b2ac <f_opendir+0x18>
	if (!dp) return FR_INVALID_OBJECT;	/* Reject null pointer */
 800b300:	2009      	movs	r0, #9
}
 800b302:	b005      	add	sp, #20
 800b304:	bd30      	pop	{r4, r5, pc}
 800b306:	bf00      	nop

0800b308 <f_closedir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800b308:	b198      	cbz	r0, 800b332 <f_closedir+0x2a>
 800b30a:	6803      	ldr	r3, [r0, #0]
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 800b30c:	b510      	push	{r4, lr}
 800b30e:	4604      	mov	r4, r0
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800b310:	b12b      	cbz	r3, 800b31e <f_closedir+0x16>
 800b312:	781a      	ldrb	r2, [r3, #0]
 800b314:	b11a      	cbz	r2, 800b31e <f_closedir+0x16>
 800b316:	8881      	ldrh	r1, [r0, #4]
 800b318:	88da      	ldrh	r2, [r3, #6]
 800b31a:	4291      	cmp	r1, r2
 800b31c:	d001      	beq.n	800b322 <f_closedir+0x1a>
	FRESULT res = FR_INVALID_OBJECT;
 800b31e:	2009      	movs	r0, #9
#if FF_FS_REENTRANT
		unlock_volume(fs, FR_OK);	/* Unlock volume */
#endif
	}
	return res;
}
 800b320:	bd10      	pop	{r4, pc}
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the hosting physical drive is kept initialized */
 800b322:	7858      	ldrb	r0, [r3, #1]
 800b324:	f7fe fd40 	bl	8009da8 <disk_status>
 800b328:	f010 0001 	ands.w	r0, r0, #1
 800b32c:	d1f7      	bne.n	800b31e <f_closedir+0x16>
		dp->obj.fs = 0;	/* Invalidate directory object */
 800b32e:	6020      	str	r0, [r4, #0]
}
 800b330:	bd10      	pop	{r4, pc}
	FRESULT res = FR_INVALID_OBJECT;
 800b332:	2009      	movs	r0, #9
}
 800b334:	4770      	bx	lr
 800b336:	bf00      	nop

0800b338 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 800b338:	b538      	push	{r3, r4, r5, lr}
 800b33a:	460d      	mov	r5, r1
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800b33c:	b140      	cbz	r0, 800b350 <f_readdir+0x18>
 800b33e:	6803      	ldr	r3, [r0, #0]
 800b340:	4604      	mov	r4, r0
 800b342:	b12b      	cbz	r3, 800b350 <f_readdir+0x18>
 800b344:	781a      	ldrb	r2, [r3, #0]
 800b346:	b11a      	cbz	r2, 800b350 <f_readdir+0x18>
 800b348:	8881      	ldrh	r1, [r0, #4]
 800b34a:	88da      	ldrh	r2, [r3, #6]
 800b34c:	4291      	cmp	r1, r2
 800b34e:	d006      	beq.n	800b35e <f_readdir+0x26>
{
 800b350:	2301      	movs	r3, #1
	FRESULT res = FR_INVALID_OBJECT;
 800b352:	2009      	movs	r0, #9
			}
			FREE_NAMEBUFF();
		}
	}

	if (fno && res != FR_OK) fno->fname[0] = 0;	/* Clear the file information if any error occured */
 800b354:	b115      	cbz	r5, 800b35c <f_readdir+0x24>
 800b356:	b10b      	cbz	r3, 800b35c <f_readdir+0x24>
 800b358:	2300      	movs	r3, #0
 800b35a:	726b      	strb	r3, [r5, #9]
	LEAVE_FF(fs, res);
}
 800b35c:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the hosting physical drive is kept initialized */
 800b35e:	7858      	ldrb	r0, [r3, #1]
 800b360:	f7fe fd22 	bl	8009da8 <disk_status>
 800b364:	f010 0301 	ands.w	r3, r0, #1
 800b368:	d1f2      	bne.n	800b350 <f_readdir+0x18>
			res = dir_sdi(dp, 0);		/* Rewind the directory object */
 800b36a:	4620      	mov	r0, r4
		if (!fno) {
 800b36c:	b1b5      	cbz	r5, 800b39c <f_readdir+0x64>
			fno->fname[0] = 0;				/* Clear file information */
 800b36e:	726b      	strb	r3, [r5, #9]
			res = DIR_READ_FILE(dp);		/* Read an item */
 800b370:	f7ff fbe0 	bl	800ab34 <dir_read.constprop.0>
			if (res == FR_OK) {				/* A valid entry is found */
 800b374:	f010 03fb 	ands.w	r3, r0, #251	; 0xfb
 800b378:	d1ee      	bne.n	800b358 <f_readdir+0x20>
	fno->fname[0] = 0;
 800b37a:	726b      	strb	r3, [r5, #9]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 800b37c:	69a3      	ldr	r3, [r4, #24]
 800b37e:	b11b      	cbz	r3, 800b388 <f_readdir+0x50>
 800b380:	4629      	mov	r1, r5
 800b382:	69e0      	ldr	r0, [r4, #28]
 800b384:	f7fe febc 	bl	800a100 <get_fileinfo.part.0.constprop.0.isra.0>
				res = dir_next(dp, 0);		/* Increment index for next */
 800b388:	2100      	movs	r1, #0
 800b38a:	4620      	mov	r0, r4
 800b38c:	f7ff fa86 	bl	800a89c <dir_next>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 800b390:	2804      	cmp	r0, #4
 800b392:	d007      	beq.n	800b3a4 <f_readdir+0x6c>
	if (fno && res != FR_OK) fno->fname[0] = 0;	/* Clear the file information if any error occured */
 800b394:	1e03      	subs	r3, r0, #0
 800b396:	bf18      	it	ne
 800b398:	2301      	movne	r3, #1
 800b39a:	e7db      	b.n	800b354 <f_readdir+0x1c>
}
 800b39c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			res = dir_sdi(dp, 0);		/* Rewind the directory object */
 800b3a0:	f7fe bf36 	b.w	800a210 <dir_sdi.constprop.0>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 800b3a4:	2000      	movs	r0, #0
}
 800b3a6:	bd38      	pop	{r3, r4, r5, pc}

0800b3a8 <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 800b3a8:	b530      	push	{r4, r5, lr}
 800b3aa:	b08f      	sub	sp, #60	; 0x3c
 800b3ac:	460d      	mov	r5, r1
	DIR dj;
	DEF_NAMEBUFF


	/* Get logical drive and mount the volume if needed */
	res = mount_volume(&path, &dj.obj.fs, 0);
 800b3ae:	2200      	movs	r2, #0
{
 800b3b0:	9001      	str	r0, [sp, #4]
	res = mount_volume(&path, &dj.obj.fs, 0);
 800b3b2:	a903      	add	r1, sp, #12
 800b3b4:	a801      	add	r0, sp, #4
 800b3b6:	f7fe ffd3 	bl	800a360 <mount_volume>

	if (res == FR_OK) {
 800b3ba:	4604      	mov	r4, r0
 800b3bc:	b128      	cbz	r0, 800b3ca <f_stat+0x22>
			}
		}
		FREE_NAMEBUFF();
	}

	if (fno && res != FR_OK) fno->fname[0] = 0;	/* Invalidate the file information if an error occured */
 800b3be:	b10d      	cbz	r5, 800b3c4 <f_stat+0x1c>
 800b3c0:	2300      	movs	r3, #0
 800b3c2:	726b      	strb	r3, [r5, #9]
	LEAVE_FF(dj.obj.fs, res);
}
 800b3c4:	4620      	mov	r0, r4
 800b3c6:	b00f      	add	sp, #60	; 0x3c
 800b3c8:	bd30      	pop	{r4, r5, pc}
		res = follow_path(&dj, path);	/* Follow the file path */
 800b3ca:	9901      	ldr	r1, [sp, #4]
 800b3cc:	a803      	add	r0, sp, #12
 800b3ce:	f7ff fac7 	bl	800a960 <follow_path>
		if (res == FR_OK) {				/* Follow completed */
 800b3d2:	4604      	mov	r4, r0
 800b3d4:	2800      	cmp	r0, #0
 800b3d6:	d1f2      	bne.n	800b3be <f_stat+0x16>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
 800b3d8:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
 800b3dc:	2b00      	cmp	r3, #0
 800b3de:	db0a      	blt.n	800b3f6 <f_stat+0x4e>
				if (fno) get_fileinfo(&dj, fno);
 800b3e0:	2d00      	cmp	r5, #0
 800b3e2:	d0ef      	beq.n	800b3c4 <f_stat+0x1c>
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 800b3e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
	fno->fname[0] = 0;
 800b3e6:	7268      	strb	r0, [r5, #9]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 800b3e8:	2b00      	cmp	r3, #0
 800b3ea:	d0eb      	beq.n	800b3c4 <f_stat+0x1c>
 800b3ec:	4629      	mov	r1, r5
 800b3ee:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b3f0:	f7fe fe86 	bl	800a100 <get_fileinfo.part.0.constprop.0.isra.0>
 800b3f4:	e7e6      	b.n	800b3c4 <f_stat+0x1c>
				res = FR_INVALID_NAME;
 800b3f6:	2406      	movs	r4, #6
 800b3f8:	e7e1      	b.n	800b3be <f_stat+0x16>
 800b3fa:	bf00      	nop

0800b3fc <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 800b3fc:	b570      	push	{r4, r5, r6, lr}
 800b3fe:	b09a      	sub	sp, #104	; 0x68
	FFOBJID obj;
#endif
	DEF_NAMEBUFF

	/* Get logical drive and mount the volume if needed */
	res = mount_volume(&path, &fs, FA_WRITE);
 800b400:	2202      	movs	r2, #2
{
 800b402:	9001      	str	r0, [sp, #4]
	res = mount_volume(&path, &fs, FA_WRITE);
 800b404:	a903      	add	r1, sp, #12
 800b406:	a801      	add	r0, sp, #4
 800b408:	f7fe ffaa 	bl	800a360 <mount_volume>
	if (res == FR_OK) {
 800b40c:	b108      	cbz	r0, 800b412 <f_unlink+0x16>
		}
		FREE_NAMEBUFF();
	}

	LEAVE_FF(fs, res);
}
 800b40e:	b01a      	add	sp, #104	; 0x68
 800b410:	bd70      	pop	{r4, r5, r6, pc}
		dj.obj.fs = fs;
 800b412:	9c03      	ldr	r4, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the path to the object */
 800b414:	a804      	add	r0, sp, #16
 800b416:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 800b418:	9404      	str	r4, [sp, #16]
		res = follow_path(&dj, path);	/* Follow the path to the object */
 800b41a:	f7ff faa1 	bl	800a960 <follow_path>
		if (res == FR_OK) {
 800b41e:	2800      	cmp	r0, #0
 800b420:	d1f5      	bne.n	800b40e <f_unlink+0x12>
			if (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME)) {
 800b422:	f89d 303b 	ldrb.w	r3, [sp, #59]	; 0x3b
 800b426:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 800b42a:	d125      	bne.n	800b478 <f_unlink+0x7c>
			} else if (dj.obj.attr & AM_RDO) {
 800b42c:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800b430:	07da      	lsls	r2, r3, #31
 800b432:	d423      	bmi.n	800b47c <f_unlink+0x80>
	if (fs->fs_type == FS_FAT32) {
 800b434:	7821      	ldrb	r1, [r4, #0]
				dclst = ld_clust(fs, dj.dir);
 800b436:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	if (fs->fs_type == FS_FAT32) {
 800b438:	2903      	cmp	r1, #3
	cl = ld_16(dir + DIR_FstClusLO);
 800b43a:	8b56      	ldrh	r6, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 800b43c:	d102      	bne.n	800b444 <f_unlink+0x48>
		cl |= (DWORD)ld_16(dir + DIR_FstClusHI) << 16;
 800b43e:	8a92      	ldrh	r2, [r2, #20]
 800b440:	ea46 4602 	orr.w	r6, r6, r2, lsl #16
			if (dj.obj.attr & AM_DIR) {		/* Is the object a sub-directory? */
 800b444:	06db      	lsls	r3, r3, #27
 800b446:	d41b      	bmi.n	800b480 <f_unlink+0x84>
	FATFS *fs = dp->obj.fs;
 800b448:	9d04      	ldr	r5, [sp, #16]
	res = move_window(fs, dp->sect);
 800b44a:	990a      	ldr	r1, [sp, #40]	; 0x28
 800b44c:	4628      	mov	r0, r5
 800b44e:	f7fe fe3b 	bl	800a0c8 <move_window>
	if (res == FR_OK) {
 800b452:	2800      	cmp	r0, #0
 800b454:	d1db      	bne.n	800b40e <f_unlink+0x12>
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 800b456:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800b458:	22e5      	movs	r2, #229	; 0xe5
 800b45a:	701a      	strb	r2, [r3, #0]
		fs->wflag = 1;
 800b45c:	2301      	movs	r3, #1
 800b45e:	712b      	strb	r3, [r5, #4]
			if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 800b460:	b136      	cbz	r6, 800b470 <f_unlink+0x74>
				res = remove_chain(&dj.obj, dclst, 0);
 800b462:	4602      	mov	r2, r0
 800b464:	4631      	mov	r1, r6
 800b466:	a804      	add	r0, sp, #16
 800b468:	f7ff f944 	bl	800a6f4 <remove_chain>
			if (res == FR_OK) res = sync_fs(fs);
 800b46c:	2800      	cmp	r0, #0
 800b46e:	d1ce      	bne.n	800b40e <f_unlink+0x12>
 800b470:	4620      	mov	r0, r4
 800b472:	f7fe fdc5 	bl	800a000 <sync_fs>
 800b476:	e7ca      	b.n	800b40e <f_unlink+0x12>
				res = FR_INVALID_NAME;	/* It must be a real object */
 800b478:	2006      	movs	r0, #6
 800b47a:	e7c8      	b.n	800b40e <f_unlink+0x12>
				res = FR_DENIED;		/* The object must not be read-only */
 800b47c:	2007      	movs	r0, #7
 800b47e:	e7c6      	b.n	800b40e <f_unlink+0x12>
					res = dir_sdi(&sdj, 0);
 800b480:	a80f      	add	r0, sp, #60	; 0x3c
					sdj.obj.fs = fs;		/* Open the sub-directory */
 800b482:	940f      	str	r4, [sp, #60]	; 0x3c
					sdj.obj.sclust = dclst;
 800b484:	9611      	str	r6, [sp, #68]	; 0x44
					res = dir_sdi(&sdj, 0);
 800b486:	f7fe fec3 	bl	800a210 <dir_sdi.constprop.0>
					if (res == FR_OK) {
 800b48a:	2800      	cmp	r0, #0
 800b48c:	d1bf      	bne.n	800b40e <f_unlink+0x12>
						res = DIR_READ_FILE(&sdj);			/* Check if the sub-directory is empty */
 800b48e:	a80f      	add	r0, sp, #60	; 0x3c
 800b490:	f7ff fb50 	bl	800ab34 <dir_read.constprop.0>
						if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 800b494:	2800      	cmp	r0, #0
 800b496:	d0f1      	beq.n	800b47c <f_unlink+0x80>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 800b498:	2804      	cmp	r0, #4
 800b49a:	d1b8      	bne.n	800b40e <f_unlink+0x12>
 800b49c:	e7d4      	b.n	800b448 <f_unlink+0x4c>
 800b49e:	bf00      	nop

0800b4a0 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 800b4a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b4a4:	b093      	sub	sp, #76	; 0x4c
	FFOBJID sobj;
	DWORD dcl, pcl, tm;
	DEF_NAMEBUFF


	res = mount_volume(&path, &fs, FA_WRITE);	/* Get logical drive and mount the volume if needed */
 800b4a6:	2202      	movs	r2, #2
{
 800b4a8:	9001      	str	r0, [sp, #4]
	res = mount_volume(&path, &fs, FA_WRITE);	/* Get logical drive and mount the volume if needed */
 800b4aa:	a902      	add	r1, sp, #8
 800b4ac:	a801      	add	r0, sp, #4
 800b4ae:	f7fe ff57 	bl	800a360 <mount_volume>
 800b4b2:	4604      	mov	r4, r0
	if (res == FR_OK) {
 800b4b4:	b118      	cbz	r0, 800b4be <f_mkdir+0x1e>
		}
		FREE_NAMEBUFF();
	}

	LEAVE_FF(fs, res);
}
 800b4b6:	4620      	mov	r0, r4
 800b4b8:	b013      	add	sp, #76	; 0x4c
 800b4ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		res = follow_path(&dj, path);			/* Follow the file path */
 800b4be:	e9dd 1301 	ldrd	r1, r3, [sp, #4]
 800b4c2:	4605      	mov	r5, r0
 800b4c4:	a807      	add	r0, sp, #28
		dj.obj.fs = fs;
 800b4c6:	9307      	str	r3, [sp, #28]
		res = follow_path(&dj, path);			/* Follow the file path */
 800b4c8:	f7ff fa4a 	bl	800a960 <follow_path>
		if (res == FR_OK) {						/* Invalid name or name collision */
 800b4cc:	4604      	mov	r4, r0
 800b4ce:	b950      	cbnz	r0, 800b4e6 <f_mkdir+0x46>
			res = (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME)) ? FR_INVALID_NAME : FR_EXIST;
 800b4d0:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
 800b4d4:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 800b4d8:	bf14      	ite	ne
 800b4da:	2406      	movne	r4, #6
 800b4dc:	2408      	moveq	r4, #8
}
 800b4de:	4620      	mov	r0, r4
 800b4e0:	b013      	add	sp, #76	; 0x4c
 800b4e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
 800b4e6:	2804      	cmp	r0, #4
 800b4e8:	d1e5      	bne.n	800b4b6 <f_mkdir+0x16>
			sobj.fs = fs;						/* New object ID to create a new chain */
 800b4ea:	9b02      	ldr	r3, [sp, #8]
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
 800b4ec:	4629      	mov	r1, r5
 800b4ee:	a803      	add	r0, sp, #12
			sobj.fs = fs;						/* New object ID to create a new chain */
 800b4f0:	9303      	str	r3, [sp, #12]
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
 800b4f2:	f7ff f941 	bl	800a778 <create_chain>
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
 800b4f6:	4605      	mov	r5, r0
 800b4f8:	b178      	cbz	r0, 800b51a <f_mkdir+0x7a>
			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
 800b4fa:	2801      	cmp	r0, #1
 800b4fc:	d00f      	beq.n	800b51e <f_mkdir+0x7e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
 800b4fe:	1c43      	adds	r3, r0, #1
 800b500:	d00f      	beq.n	800b522 <f_mkdir+0x82>
				res = dir_clear(fs, dcl);		/* Clear the allocated cluster as new direcotry table */
 800b502:	4601      	mov	r1, r0
 800b504:	9802      	ldr	r0, [sp, #8]
 800b506:	f7fe fd45 	bl	8009f94 <dir_clear>
 800b50a:	4604      	mov	r4, r0
				if (res == FR_OK) {
 800b50c:	b158      	cbz	r0, 800b526 <f_mkdir+0x86>
				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 800b50e:	2200      	movs	r2, #0
 800b510:	4629      	mov	r1, r5
 800b512:	a803      	add	r0, sp, #12
 800b514:	f7ff f8ee 	bl	800a6f4 <remove_chain>
 800b518:	e7cd      	b.n	800b4b6 <f_mkdir+0x16>
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
 800b51a:	2407      	movs	r4, #7
 800b51c:	e7f7      	b.n	800b50e <f_mkdir+0x6e>
			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
 800b51e:	2402      	movs	r4, #2
 800b520:	e7f5      	b.n	800b50e <f_mkdir+0x6e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
 800b522:	2401      	movs	r4, #1
 800b524:	e7f3      	b.n	800b50e <f_mkdir+0x6e>
						memset(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 800b526:	9b02      	ldr	r3, [sp, #8]
	*ptr++ = (BYTE)val; val >>= 8;
 800b528:	2221      	movs	r2, #33	; 0x21
	*ptr++ = (BYTE)val; val >>= 8;
 800b52a:	b2ee      	uxtb	r6, r5
						fs->win[DIR_Name] = '.';
 800b52c:	212e      	movs	r1, #46	; 0x2e
	*ptr++ = (BYTE)val; val >>= 8;
 800b52e:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
	*ptr++ = (BYTE)val;
 800b532:	225a      	movs	r2, #90	; 0x5a
	*ptr++ = (BYTE)val; val >>= 8;
 800b534:	f883 0046 	strb.w	r0, [r3, #70]	; 0x46
	*ptr++ = (BYTE)val;
 800b538:	f3c5 2707 	ubfx	r7, r5, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800b53c:	f883 0047 	strb.w	r0, [r3, #71]	; 0x47
	*ptr++ = (BYTE)val;
 800b540:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
						memset(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 800b544:	f04f 3220 	mov.w	r2, #538976288	; 0x20202020
	if (fs->fs_type == FS_FAT32) {
 800b548:	7818      	ldrb	r0, [r3, #0]
						memset(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 800b54a:	631a      	str	r2, [r3, #48]	; 0x30
 800b54c:	635a      	str	r2, [r3, #52]	; 0x34
	if (fs->fs_type == FS_FAT32) {
 800b54e:	2803      	cmp	r0, #3
						memset(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 800b550:	f8c3 2037 	str.w	r2, [r3, #55]	; 0x37
						fs->win[DIR_Attr] = AM_DIR;
 800b554:	f04f 0210 	mov.w	r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800b558:	f883 604a 	strb.w	r6, [r3, #74]	; 0x4a
						fs->win[DIR_Attr] = AM_DIR;
 800b55c:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
						memset(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 800b560:	f103 0230 	add.w	r2, r3, #48	; 0x30
						fs->win[DIR_Name] = '.';
 800b564:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
	*ptr++ = (BYTE)val;
 800b568:	f883 704b 	strb.w	r7, [r3, #75]	; 0x4b
	if (fs->fs_type == FS_FAT32) {
 800b56c:	d04d      	beq.n	800b60a <f_mkdir+0x16a>
						memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 800b56e:	f8d2 e004 	ldr.w	lr, [r2, #4]
 800b572:	f8d2 c008 	ldr.w	ip, [r2, #8]
 800b576:	68d4      	ldr	r4, [r2, #12]
 800b578:	f8d3 8030 	ldr.w	r8, [r3, #48]	; 0x30
 800b57c:	f8c3 e054 	str.w	lr, [r3, #84]	; 0x54
 800b580:	f8c3 8050 	str.w	r8, [r3, #80]	; 0x50
 800b584:	f8c3 c058 	str.w	ip, [r3, #88]	; 0x58
 800b588:	65dc      	str	r4, [r3, #92]	; 0x5c
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 800b58a:	9809      	ldr	r0, [sp, #36]	; 0x24
						memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 800b58c:	f8d2 c018 	ldr.w	ip, [r2, #24]
 800b590:	f8d2 8010 	ldr.w	r8, [r2, #16]
 800b594:	f8d2 e014 	ldr.w	lr, [r2, #20]
 800b598:	69d4      	ldr	r4, [r2, #28]
 800b59a:	f8c3 c068 	str.w	ip, [r3, #104]	; 0x68
	*ptr++ = (BYTE)val; val >>= 8;
 800b59e:	f883 006a 	strb.w	r0, [r3, #106]	; 0x6a
 800b5a2:	f3c0 2007 	ubfx	r0, r0, #8, #8
						memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 800b5a6:	f8c3 8060 	str.w	r8, [r3, #96]	; 0x60
 800b5aa:	f8c3 e064 	str.w	lr, [r3, #100]	; 0x64
 800b5ae:	66dc      	str	r4, [r3, #108]	; 0x6c
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 800b5b0:	f883 1051 	strb.w	r1, [r3, #81]	; 0x51
	*ptr++ = (BYTE)val;
 800b5b4:	f883 006b 	strb.w	r0, [r3, #107]	; 0x6b
						fs->wflag = 1;
 800b5b8:	2201      	movs	r2, #1
					res = dir_register(&dj);	/* Register the object to the parent directory */
 800b5ba:	a807      	add	r0, sp, #28
						fs->wflag = 1;
 800b5bc:	711a      	strb	r2, [r3, #4]
					res = dir_register(&dj);	/* Register the object to the parent directory */
 800b5be:	f7ff fae7 	bl	800ab90 <dir_register>
 800b5c2:	4604      	mov	r4, r0
			if (res == FR_OK) {
 800b5c4:	2800      	cmp	r0, #0
 800b5c6:	d1a2      	bne.n	800b50e <f_mkdir+0x6e>
					st_32(dj.dir + DIR_CrtTime, tm);	/* Created time */
 800b5c8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	*ptr++ = (BYTE)val;
 800b5ca:	215a      	movs	r1, #90	; 0x5a
	*ptr++ = (BYTE)val; val >>= 8;
 800b5cc:	2421      	movs	r4, #33	; 0x21
					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
 800b5ce:	9a02      	ldr	r2, [sp, #8]
	*ptr++ = (BYTE)val; val >>= 8;
 800b5d0:	7398      	strb	r0, [r3, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 800b5d2:	73d8      	strb	r0, [r3, #15]
	*ptr++ = (BYTE)val; val >>= 8;
 800b5d4:	741c      	strb	r4, [r3, #16]
	*ptr++ = (BYTE)val;
 800b5d6:	7459      	strb	r1, [r3, #17]
					st_32(dj.dir + DIR_ModTime, tm);
 800b5d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	*ptr++ = (BYTE)val; val >>= 8;
 800b5da:	761c      	strb	r4, [r3, #24]
	*ptr++ = (BYTE)val;
 800b5dc:	7659      	strb	r1, [r3, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 800b5de:	7598      	strb	r0, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 800b5e0:	75d8      	strb	r0, [r3, #23]
					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
 800b5e2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	*ptr++ = (BYTE)val; val >>= 8;
 800b5e4:	769e      	strb	r6, [r3, #26]
	*ptr++ = (BYTE)val;
 800b5e6:	76df      	strb	r7, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 800b5e8:	7811      	ldrb	r1, [r2, #0]
 800b5ea:	2903      	cmp	r1, #3
 800b5ec:	d103      	bne.n	800b5f6 <f_mkdir+0x156>
		st_16(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800b5ee:	0c2d      	lsrs	r5, r5, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800b5f0:	0a29      	lsrs	r1, r5, #8
 800b5f2:	751d      	strb	r5, [r3, #20]
	*ptr++ = (BYTE)val;
 800b5f4:	7559      	strb	r1, [r3, #21]
					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
 800b5f6:	990e      	ldr	r1, [sp, #56]	; 0x38
 800b5f8:	2410      	movs	r4, #16
					fs->wflag = 1;
 800b5fa:	2301      	movs	r3, #1
					res = sync_fs(fs);
 800b5fc:	4610      	mov	r0, r2
					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
 800b5fe:	72cc      	strb	r4, [r1, #11]
					fs->wflag = 1;
 800b600:	7113      	strb	r3, [r2, #4]
					res = sync_fs(fs);
 800b602:	f7fe fcfd 	bl	800a000 <sync_fs>
 800b606:	4604      	mov	r4, r0
 800b608:	e755      	b.n	800b4b6 <f_mkdir+0x16>
		st_16(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800b60a:	0c28      	lsrs	r0, r5, #16
						memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 800b60c:	f8d3 8030 	ldr.w	r8, [r3, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 800b610:	f883 0044 	strb.w	r0, [r3, #68]	; 0x44
 800b614:	0a00      	lsrs	r0, r0, #8
	*ptr++ = (BYTE)val;
 800b616:	f883 0045 	strb.w	r0, [r3, #69]	; 0x45
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 800b61a:	9809      	ldr	r0, [sp, #36]	; 0x24
						memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 800b61c:	f8d2 9004 	ldr.w	r9, [r2, #4]
 800b620:	f8d2 e008 	ldr.w	lr, [r2, #8]
		st_16(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800b624:	0c04      	lsrs	r4, r0, #16
						memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 800b626:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 800b62a:	f8c3 8050 	str.w	r8, [r3, #80]	; 0x50
 800b62e:	f8c3 9054 	str.w	r9, [r3, #84]	; 0x54
 800b632:	f8c3 e058 	str.w	lr, [r3, #88]	; 0x58
 800b636:	f8c3 c05c 	str.w	ip, [r3, #92]	; 0x5c
 800b63a:	f8d2 9014 	ldr.w	r9, [r2, #20]
 800b63e:	f8d2 e018 	ldr.w	lr, [r2, #24]
 800b642:	f8d2 8010 	ldr.w	r8, [r2, #16]
 800b646:	f8d2 c01c 	ldr.w	ip, [r2, #28]
 800b64a:	f8c3 9064 	str.w	r9, [r3, #100]	; 0x64
 800b64e:	f8c3 e068 	str.w	lr, [r3, #104]	; 0x68
	*ptr++ = (BYTE)val; val >>= 8;
 800b652:	f883 4064 	strb.w	r4, [r3, #100]	; 0x64
 800b656:	0a24      	lsrs	r4, r4, #8
 800b658:	f883 006a 	strb.w	r0, [r3, #106]	; 0x6a
 800b65c:	f3c0 2007 	ubfx	r0, r0, #8, #8
						memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 800b660:	f8c3 8060 	str.w	r8, [r3, #96]	; 0x60
 800b664:	f8c3 c06c 	str.w	ip, [r3, #108]	; 0x6c
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 800b668:	f883 1051 	strb.w	r1, [r3, #81]	; 0x51
	*ptr++ = (BYTE)val;
 800b66c:	f883 006b 	strb.w	r0, [r3, #107]	; 0x6b
 800b670:	f883 4065 	strb.w	r4, [r3, #101]	; 0x65
}
 800b674:	e7a0      	b.n	800b5b8 <f_mkdir+0x118>
 800b676:	bf00      	nop

0800b678 <f_rename>:

FRESULT f_rename (
	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
	const TCHAR* path_new	/* Pointer to the new name */
)
{
 800b678:	b530      	push	{r4, r5, lr}
 800b67a:	b0a3      	sub	sp, #140	; 0x8c
 800b67c:	9001      	str	r0, [sp, #4]
	DIR djo, djn;
	BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
	DEF_NAMEBUFF


	get_ldnumber(&path_new);	/* Snip the drive number of new name off */
 800b67e:	4668      	mov	r0, sp
{
 800b680:	9100      	str	r1, [sp, #0]
	get_ldnumber(&path_new);	/* Snip the drive number of new name off */
 800b682:	f7fe fc31 	bl	8009ee8 <get_ldnumber>
	res = mount_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
 800b686:	2202      	movs	r2, #2
 800b688:	a903      	add	r1, sp, #12
 800b68a:	a801      	add	r0, sp, #4
 800b68c:	f7fe fe68 	bl	800a360 <mount_volume>
	if (res == FR_OK) {
 800b690:	b108      	cbz	r0, 800b696 <f_rename+0x1e>
		}
		FREE_NAMEBUFF();
	}

	LEAVE_FF(fs, res);
}
 800b692:	b023      	add	sp, #140	; 0x8c
 800b694:	bd30      	pop	{r4, r5, pc}
		djo.obj.fs = fs;
 800b696:	9c03      	ldr	r4, [sp, #12]
		res = follow_path(&djo, path_old);	/* Check old object */
 800b698:	a80c      	add	r0, sp, #48	; 0x30
 800b69a:	9901      	ldr	r1, [sp, #4]
		djo.obj.fs = fs;
 800b69c:	940c      	str	r4, [sp, #48]	; 0x30
		res = follow_path(&djo, path_old);	/* Check old object */
 800b69e:	f7ff f95f 	bl	800a960 <follow_path>
		if (res == FR_OK) {
 800b6a2:	2800      	cmp	r0, #0
 800b6a4:	d1f5      	bne.n	800b692 <f_rename+0x1a>
			if (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME)) {
 800b6a6:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
 800b6aa:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 800b6ae:	d17e      	bne.n	800b7ae <f_rename+0x136>
				memcpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
 800b6b0:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 800b6b2:	f10d 0e10 	add.w	lr, sp, #16
				memcpy(&djn, &djo, sizeof djn);			/* Duplicate the directory object */
 800b6b6:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
				memcpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
 800b6ba:	6828      	ldr	r0, [r5, #0]
 800b6bc:	6869      	ldr	r1, [r5, #4]
 800b6be:	68aa      	ldr	r2, [r5, #8]
 800b6c0:	68eb      	ldr	r3, [r5, #12]
 800b6c2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 800b6c6:	6928      	ldr	r0, [r5, #16]
 800b6c8:	6969      	ldr	r1, [r5, #20]
 800b6ca:	69aa      	ldr	r2, [r5, #24]
 800b6cc:	69eb      	ldr	r3, [r5, #28]
 800b6ce:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
				memcpy(&djn, &djo, sizeof djn);			/* Duplicate the directory object */
 800b6d2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b6d6:	f10d 0e5c 	add.w	lr, sp, #92	; 0x5c
 800b6da:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 800b6de:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b6e2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 800b6e6:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 800b6ea:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
 800b6ee:	9900      	ldr	r1, [sp, #0]
 800b6f0:	a817      	add	r0, sp, #92	; 0x5c
 800b6f2:	f7ff f935 	bl	800a960 <follow_path>
				if (res == FR_OK) {						/* Is new name already in use by another object? */
 800b6f6:	2800      	cmp	r0, #0
 800b6f8:	d05b      	beq.n	800b7b2 <f_rename+0x13a>
				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
 800b6fa:	2804      	cmp	r0, #4
 800b6fc:	d1c9      	bne.n	800b692 <f_rename+0x1a>
					res = dir_register(&djn);			/* Register the new entry */
 800b6fe:	a817      	add	r0, sp, #92	; 0x5c
 800b700:	f7ff fa46 	bl	800ab90 <dir_register>
					if (res == FR_OK) {
 800b704:	2800      	cmp	r0, #0
 800b706:	d1c4      	bne.n	800b692 <f_rename+0x1a>
						dir = djn.dir;					/* Copy directory entry of the object except name */
 800b708:	9b1e      	ldr	r3, [sp, #120]	; 0x78
						memcpy(dir + 13, buf + 13, SZDIRE - 13);
 800b70a:	f8dd 201d 	ldr.w	r2, [sp, #29]
 800b70e:	f8dd 1029 	ldr.w	r1, [sp, #41]	; 0x29
 800b712:	f8c3 200d 	str.w	r2, [r3, #13]
 800b716:	f8dd 2021 	ldr.w	r2, [sp, #33]	; 0x21
 800b71a:	f8c3 1019 	str.w	r1, [r3, #25]
 800b71e:	f8c3 2011 	str.w	r2, [r3, #17]
 800b722:	f8bd 202d 	ldrh.w	r2, [sp, #45]	; 0x2d
 800b726:	f89d 102f 	ldrb.w	r1, [sp, #47]	; 0x2f
 800b72a:	f8a3 201d 	strh.w	r2, [r3, #29]
						dir[DIR_Attr] = buf[DIR_Attr];
 800b72e:	f89d 201b 	ldrb.w	r2, [sp, #27]
						memcpy(dir + 13, buf + 13, SZDIRE - 13);
 800b732:	77d9      	strb	r1, [r3, #31]
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
 800b734:	06d1      	lsls	r1, r2, #27
						memcpy(dir + 13, buf + 13, SZDIRE - 13);
 800b736:	f8dd 0025 	ldr.w	r0, [sp, #37]	; 0x25
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
 800b73a:	bf58      	it	pl
 800b73c:	f042 0220 	orrpl.w	r2, r2, #32
						memcpy(dir + 13, buf + 13, SZDIRE - 13);
 800b740:	f8c3 0015 	str.w	r0, [r3, #21]
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
 800b744:	72da      	strb	r2, [r3, #11]
						fs->wflag = 1;
 800b746:	2201      	movs	r2, #1
 800b748:	7122      	strb	r2, [r4, #4]
						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory being moved if needed */
 800b74a:	7ada      	ldrb	r2, [r3, #11]
 800b74c:	06d2      	lsls	r2, r2, #27
 800b74e:	d51d      	bpl.n	800b78c <f_rename+0x114>
 800b750:	990e      	ldr	r1, [sp, #56]	; 0x38
 800b752:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800b754:	4291      	cmp	r1, r2
 800b756:	d019      	beq.n	800b78c <f_rename+0x114>
	if (fs->fs_type == FS_FAT32) {
 800b758:	7821      	ldrb	r1, [r4, #0]
	cl = ld_16(dir + DIR_FstClusLO);
 800b75a:	8b5a      	ldrh	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 800b75c:	2903      	cmp	r1, #3
 800b75e:	d102      	bne.n	800b766 <f_rename+0xee>
		cl |= (DWORD)ld_16(dir + DIR_FstClusHI) << 16;
 800b760:	8a9b      	ldrh	r3, [r3, #20]
 800b762:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800b766:	6963      	ldr	r3, [r4, #20]
	clst -= 2;		/* Cluster number is origin from 2 */
 800b768:	3a02      	subs	r2, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800b76a:	3b02      	subs	r3, #2
 800b76c:	429a      	cmp	r2, r3
 800b76e:	d22b      	bcs.n	800b7c8 <f_rename+0x150>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 800b770:	8963      	ldrh	r3, [r4, #10]
 800b772:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800b774:	fb02 1103 	mla	r1, r2, r3, r1
							if (sect == 0) {
 800b778:	b331      	cbz	r1, 800b7c8 <f_rename+0x150>
								res = move_window(fs, sect);
 800b77a:	4620      	mov	r0, r4
 800b77c:	f7fe fca4 	bl	800a0c8 <move_window>
								if (res == FR_OK && dir[1] == '.') {
 800b780:	2800      	cmp	r0, #0
 800b782:	d186      	bne.n	800b692 <f_rename+0x1a>
 800b784:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 800b788:	2b2e      	cmp	r3, #46	; 0x2e
 800b78a:	d01f      	beq.n	800b7cc <f_rename+0x154>
	FATFS *fs = dp->obj.fs;
 800b78c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
	res = move_window(fs, dp->sect);
 800b78e:	9912      	ldr	r1, [sp, #72]	; 0x48
 800b790:	4628      	mov	r0, r5
 800b792:	f7fe fc99 	bl	800a0c8 <move_window>
	if (res == FR_OK) {
 800b796:	2800      	cmp	r0, #0
 800b798:	f47f af7b 	bne.w	800b692 <f_rename+0x1a>
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 800b79c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800b79e:	21e5      	movs	r1, #229	; 0xe5
		fs->wflag = 1;
 800b7a0:	2301      	movs	r3, #1
					res = sync_fs(fs);
 800b7a2:	4620      	mov	r0, r4
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 800b7a4:	7011      	strb	r1, [r2, #0]
		fs->wflag = 1;
 800b7a6:	712b      	strb	r3, [r5, #4]
					res = sync_fs(fs);
 800b7a8:	f7fe fc2a 	bl	800a000 <sync_fs>
 800b7ac:	e771      	b.n	800b692 <f_rename+0x1a>
				res = FR_INVALID_NAME;		/* Object must not be a dot name or blank name */
 800b7ae:	2006      	movs	r0, #6
 800b7b0:	e76f      	b.n	800b692 <f_rename+0x1a>
					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
 800b7b2:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800b7b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b7b6:	429a      	cmp	r2, r3
 800b7b8:	d001      	beq.n	800b7be <f_rename+0x146>
 800b7ba:	2008      	movs	r0, #8
 800b7bc:	e769      	b.n	800b692 <f_rename+0x1a>
 800b7be:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800b7c0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800b7c2:	429a      	cmp	r2, r3
 800b7c4:	d1f9      	bne.n	800b7ba <f_rename+0x142>
 800b7c6:	e79a      	b.n	800b6fe <f_rename+0x86>
 800b7c8:	2002      	movs	r0, #2
 800b7ca:	e762      	b.n	800b692 <f_rename+0x1a>
									st_clust(fs, dir, djn.obj.sclust);
 800b7cc:	9b19      	ldr	r3, [sp, #100]	; 0x64
	if (fs->fs_type == FS_FAT32) {
 800b7ce:	7822      	ldrb	r2, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800b7d0:	f3c3 2107 	ubfx	r1, r3, #8, #8
 800b7d4:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
	if (fs->fs_type == FS_FAT32) {
 800b7d8:	2a03      	cmp	r2, #3
	*ptr++ = (BYTE)val;
 800b7da:	f884 106b 	strb.w	r1, [r4, #107]	; 0x6b
	if (fs->fs_type == FS_FAT32) {
 800b7de:	d105      	bne.n	800b7ec <f_rename+0x174>
		st_16(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800b7e0:	0c1b      	lsrs	r3, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800b7e2:	0a1a      	lsrs	r2, r3, #8
 800b7e4:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
	*ptr++ = (BYTE)val;
 800b7e8:	f884 2065 	strb.w	r2, [r4, #101]	; 0x65
									fs->wflag = 1;
 800b7ec:	2301      	movs	r3, #1
 800b7ee:	7123      	strb	r3, [r4, #4]
			if (res == FR_OK) {		/* New entry has been created */
 800b7f0:	e7cc      	b.n	800b78c <f_rename+0x114>
 800b7f2:	bf00      	nop

0800b7f4 <usb_host_fifo_push>:
static volatile uint16_t midi_head = 0U;
static volatile uint16_t midi_tail = 0U;
static volatile uint32_t midi_overflow_total = 0U;

bool usb_host_fifo_push(const uint8_t packet[4])
{
 800b7f4:	b410      	push	{r4}
  uint16_t local_head = __atomic_load_n(&midi_head, __ATOMIC_RELAXED);
 800b7f6:	4c10      	ldr	r4, [pc, #64]	; (800b838 <usb_host_fifo_push+0x44>)
  uint16_t local_tail = __atomic_load_n(&midi_tail, __ATOMIC_ACQUIRE);
 800b7f8:	4b10      	ldr	r3, [pc, #64]	; (800b83c <usb_host_fifo_push+0x48>)
  uint16_t local_head = __atomic_load_n(&midi_head, __ATOMIC_RELAXED);
 800b7fa:	8822      	ldrh	r2, [r4, #0]
  uint16_t local_tail = __atomic_load_n(&midi_tail, __ATOMIC_ACQUIRE);
 800b7fc:	881b      	ldrh	r3, [r3, #0]
 800b7fe:	f3bf 8f5b 	dmb	ish
  uint16_t local_head = __atomic_load_n(&midi_head, __ATOMIC_RELAXED);
 800b802:	b292      	uxth	r2, r2
  uint16_t local_tail = __atomic_load_n(&midi_tail, __ATOMIC_ACQUIRE);
 800b804:	b299      	uxth	r1, r3
  uint16_t next_head = (local_head + 1U) & USB_HOST_MIDI_FIFO_MASK;
 800b806:	1c53      	adds	r3, r2, #1
 800b808:	f003 037f 	and.w	r3, r3, #127	; 0x7f

  if (next_head == local_tail)
 800b80c:	4299      	cmp	r1, r3
 800b80e:	d00a      	beq.n	800b826 <usb_host_fifo_push+0x32>
  {
    midi_overflow_total++;
    return false;
  }

  memcpy(midi_fifo[local_head].data, packet, sizeof(midi_fifo[local_head].data));
 800b810:	6800      	ldr	r0, [r0, #0]
 800b812:	490b      	ldr	r1, [pc, #44]	; (800b840 <usb_host_fifo_push+0x4c>)
 800b814:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
  __atomic_store_n(&midi_head, next_head, __ATOMIC_RELEASE);
 800b818:	f3bf 8f5b 	dmb	ish
 800b81c:	8023      	strh	r3, [r4, #0]
  return true;
 800b81e:	2001      	movs	r0, #1
}
 800b820:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b824:	4770      	bx	lr
    midi_overflow_total++;
 800b826:	4a07      	ldr	r2, [pc, #28]	; (800b844 <usb_host_fifo_push+0x50>)
    return false;
 800b828:	2000      	movs	r0, #0
}
 800b82a:	f85d 4b04 	ldr.w	r4, [sp], #4
    midi_overflow_total++;
 800b82e:	6813      	ldr	r3, [r2, #0]
 800b830:	3301      	adds	r3, #1
 800b832:	6013      	str	r3, [r2, #0]
}
 800b834:	4770      	bx	lr
 800b836:	bf00      	nop
 800b838:	24004868 	.word	0x24004868
 800b83c:	24004870 	.word	0x24004870
 800b840:	24004668 	.word	0x24004668
 800b844:	2400486c 	.word	0x2400486c

0800b848 <usb_host_fifo_overflow_total>:
  return true;
}

uint32_t usb_host_fifo_overflow_total(void)
{
  return midi_overflow_total;
 800b848:	4b01      	ldr	r3, [pc, #4]	; (800b850 <usb_host_fifo_overflow_total+0x8>)
 800b84a:	6818      	ldr	r0, [r3, #0]
}
 800b84c:	4770      	bx	lr
 800b84e:	bf00      	nop
 800b850:	2400486c 	.word	0x2400486c

0800b854 <usb_host_fifo_reset>:

void usb_host_fifo_reset(void)
{
  __atomic_store_n(&midi_head, 0U, __ATOMIC_RELEASE);
 800b854:	2300      	movs	r3, #0
 800b856:	4904      	ldr	r1, [pc, #16]	; (800b868 <usb_host_fifo_reset+0x14>)
  __atomic_store_n(&midi_tail, 0U, __ATOMIC_RELEASE);
 800b858:	4a04      	ldr	r2, [pc, #16]	; (800b86c <usb_host_fifo_reset+0x18>)
  __atomic_store_n(&midi_head, 0U, __ATOMIC_RELEASE);
 800b85a:	f3bf 8f5b 	dmb	ish
 800b85e:	800b      	strh	r3, [r1, #0]
  __atomic_store_n(&midi_tail, 0U, __ATOMIC_RELEASE);
 800b860:	f3bf 8f5b 	dmb	ish
 800b864:	8013      	strh	r3, [r2, #0]
}
 800b866:	4770      	bx	lr
 800b868:	24004868 	.word	0x24004868
 800b86c:	24004870 	.word	0x24004870

0800b870 <USBH_static_mem_reset>:
 800b870:	2330      	movs	r3, #48	; 0x30
 800b872:	f383 8811 	msr	BASEPRI, r3
}

void USBH_static_mem_reset(void)
{
  chSysLock();
  usbh_static_offset = 0U;
 800b876:	2300      	movs	r3, #0
 800b878:	4903      	ldr	r1, [pc, #12]	; (800b888 <USBH_static_mem_reset+0x18>)
  usbh_static_oom_count = 0U;
 800b87a:	4a04      	ldr	r2, [pc, #16]	; (800b88c <USBH_static_mem_reset+0x1c>)
  usbh_static_offset = 0U;
 800b87c:	600b      	str	r3, [r1, #0]
  usbh_static_oom_count = 0U;
 800b87e:	6013      	str	r3, [r2, #0]
 800b880:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 800b884:	4770      	bx	lr
 800b886:	bf00      	nop
 800b888:	24004874 	.word	0x24004874
 800b88c:	24004878 	.word	0x24004878

0800b890 <USBH_static_get_oom_count>:
 800b890:	2330      	movs	r3, #48	; 0x30
 800b892:	f383 8811 	msr	BASEPRI, r3
uint32_t USBH_static_get_oom_count(void)
{
  uint32_t count;

  chSysLock();
  count = usbh_static_oom_count;
 800b896:	4a03      	ldr	r2, [pc, #12]	; (800b8a4 <USBH_static_get_oom_count+0x14>)
 800b898:	2300      	movs	r3, #0
 800b89a:	6810      	ldr	r0, [r2, #0]
 800b89c:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return count;
}
 800b8a0:	4770      	bx	lr
 800b8a2:	bf00      	nop
 800b8a4:	24004878 	.word	0x24004878

0800b8a8 <USBH_UserProcess>:
}

static void USBH_UserProcess(USBH_HandleTypeDef *phost, uint8_t id)
{
  (void)phost;
  switch (id)
 800b8a8:	3902      	subs	r1, #2
{
 800b8aa:	b510      	push	{r4, lr}
  switch (id)
 800b8ac:	2904      	cmp	r1, #4
 800b8ae:	d811      	bhi.n	800b8d4 <USBH_UserProcess+0x2c>
 800b8b0:	e8df f001 	tbb	[pc, r1]
 800b8b4:	1e281003 	.word	0x1e281003
 800b8b8:	11          	.byte	0x11
 800b8b9:	00          	.byte	0x00
    midi_ready = false;
    usb_host_fifo_reset();
    overflow_streak = 0U;
    break;
  case HOST_USER_CLASS_ACTIVE:
    midi_ready = true;
 800b8ba:	4a1a      	ldr	r2, [pc, #104]	; (800b924 <USBH_UserProcess+0x7c>)
 800b8bc:	2101      	movs	r1, #1
 800b8be:	2330      	movs	r3, #48	; 0x30
 800b8c0:	7011      	strb	r1, [r2, #0]
 800b8c2:	f383 8811 	msr	BASEPRI, r3
 800b8c6:	f7f5 f999 	bl	8000bfc <stGetCounter>
 800b8ca:	2300      	movs	r3, #0
 800b8cc:	f383 8811 	msr	BASEPRI, r3
  reset_requested = true;
}

static void usb_host_update_activity(void)
{
  last_activity = chVTGetSystemTime();
 800b8d0:	4b15      	ldr	r3, [pc, #84]	; (800b928 <USBH_UserProcess+0x80>)
 800b8d2:	6018      	str	r0, [r3, #0]
}
 800b8d4:	bd10      	pop	{r4, pc}
    device_attached = false;
 800b8d6:	2300      	movs	r3, #0
    usb_error_count++;
 800b8d8:	4a14      	ldr	r2, [pc, #80]	; (800b92c <USBH_UserProcess+0x84>)
    midi_ready = false;
 800b8da:	4812      	ldr	r0, [pc, #72]	; (800b924 <USBH_UserProcess+0x7c>)
    device_attached = false;
 800b8dc:	4c14      	ldr	r4, [pc, #80]	; (800b930 <USBH_UserProcess+0x88>)
  reset_requested = true;
 800b8de:	4915      	ldr	r1, [pc, #84]	; (800b934 <USBH_UserProcess+0x8c>)
    device_attached = false;
 800b8e0:	7023      	strb	r3, [r4, #0]
    midi_ready = false;
 800b8e2:	7003      	strb	r3, [r0, #0]
  reset_requested = true;
 800b8e4:	2001      	movs	r0, #1
    usb_error_count++;
 800b8e6:	6813      	ldr	r3, [r2, #0]
 800b8e8:	4403      	add	r3, r0
 800b8ea:	6013      	str	r3, [r2, #0]
  reset_requested = true;
 800b8ec:	7008      	strb	r0, [r1, #0]
}
 800b8ee:	bd10      	pop	{r4, pc}
    device_attached = false;
 800b8f0:	2400      	movs	r4, #0
    midi_ready = false;
 800b8f2:	4b0c      	ldr	r3, [pc, #48]	; (800b924 <USBH_UserProcess+0x7c>)
    device_attached = false;
 800b8f4:	4a0e      	ldr	r2, [pc, #56]	; (800b930 <USBH_UserProcess+0x88>)
 800b8f6:	7014      	strb	r4, [r2, #0]
    midi_ready = false;
 800b8f8:	701c      	strb	r4, [r3, #0]
    usb_host_fifo_reset();
 800b8fa:	f7ff ffab 	bl	800b854 <usb_host_fifo_reset>
    overflow_streak = 0U;
 800b8fe:	4b0e      	ldr	r3, [pc, #56]	; (800b938 <USBH_UserProcess+0x90>)
 800b900:	601c      	str	r4, [r3, #0]
}
 800b902:	bd10      	pop	{r4, pc}
    device_attached = true;
 800b904:	4b0a      	ldr	r3, [pc, #40]	; (800b930 <USBH_UserProcess+0x88>)
 800b906:	2101      	movs	r1, #1
    midi_ready = false;
 800b908:	4a06      	ldr	r2, [pc, #24]	; (800b924 <USBH_UserProcess+0x7c>)
 800b90a:	2400      	movs	r4, #0
    device_attached = true;
 800b90c:	7019      	strb	r1, [r3, #0]
 800b90e:	2330      	movs	r3, #48	; 0x30
    midi_ready = false;
 800b910:	7014      	strb	r4, [r2, #0]
 800b912:	f383 8811 	msr	BASEPRI, r3
 800b916:	f7f5 f971 	bl	8000bfc <stGetCounter>
 800b91a:	f384 8811 	msr	BASEPRI, r4
  last_activity = chVTGetSystemTime();
 800b91e:	4b02      	ldr	r3, [pc, #8]	; (800b928 <USBH_UserProcess+0x80>)
 800b920:	6018      	str	r0, [r3, #0]
}
 800b922:	bd10      	pop	{r4, pc}
 800b924:	24004d84 	.word	0x24004d84
 800b928:	24004d80 	.word	0x24004d80
 800b92c:	24004d94 	.word	0x24004d94
 800b930:	2400487c 	.word	0x2400487c
 800b934:	24004d8c 	.word	0x24004d8c
 800b938:	24004d88 	.word	0x24004d88

0800b93c <usb_host_restart>:
    }
  }
}

static void usb_host_restart(void)
{
 800b93c:	b510      	push	{r4, lr}
  uint32_t oom_count = USBH_static_get_oom_count();
 800b93e:	f7ff ffa7 	bl	800b890 <USBH_static_get_oom_count>

  if (oom_count > 0U)
 800b942:	2800      	cmp	r0, #0
 800b944:	d14c      	bne.n	800b9e0 <usb_host_restart+0xa4>
  {
    usb_error_count++;
    USBH_ErrLog("USBH static pool OOM since last reset: %lu", (unsigned long)oom_count);
  }

  reset_requested = false;
 800b946:	2300      	movs	r3, #0
  midi_ready = false;
  device_attached = false;
 800b948:	492f      	ldr	r1, [pc, #188]	; (800ba08 <usb_host_restart+0xcc>)
  overflow_streak = 0U;

  if ((hUsbHostFS.pData != NULL) || host_started)
 800b94a:	4a30      	ldr	r2, [pc, #192]	; (800ba0c <usb_host_restart+0xd0>)
  reset_requested = false;
 800b94c:	4c30      	ldr	r4, [pc, #192]	; (800ba10 <usb_host_restart+0xd4>)
  midi_ready = false;
 800b94e:	4831      	ldr	r0, [pc, #196]	; (800ba14 <usb_host_restart+0xd8>)
  reset_requested = false;
 800b950:	7023      	strb	r3, [r4, #0]
  if ((hUsbHostFS.pData != NULL) || host_started)
 800b952:	f8d2 24f0 	ldr.w	r2, [r2, #1264]	; 0x4f0
  midi_ready = false;
 800b956:	7003      	strb	r3, [r0, #0]
  device_attached = false;
 800b958:	700b      	strb	r3, [r1, #0]
  overflow_streak = 0U;
 800b95a:	492f      	ldr	r1, [pc, #188]	; (800ba18 <usb_host_restart+0xdc>)
 800b95c:	600b      	str	r3, [r1, #0]
  if ((hUsbHostFS.pData != NULL) || host_started)
 800b95e:	2a00      	cmp	r2, #0
 800b960:	d039      	beq.n	800b9d6 <usb_host_restart+0x9a>
  {
    USBH_Stop(&hUsbHostFS);
 800b962:	482a      	ldr	r0, [pc, #168]	; (800ba0c <usb_host_restart+0xd0>)
 800b964:	f000 fbda 	bl	800c11c <USBH_Stop>
    USBH_DeInit(&hUsbHostFS);
 800b968:	4828      	ldr	r0, [pc, #160]	; (800ba0c <usb_host_restart+0xd0>)
 800b96a:	f000 fb23 	bl	800bfb4 <USBH_DeInit>
  }

  memset(&hUsbHostFS, 0, sizeof(hUsbHostFS));
 800b96e:	f44f 629f 	mov.w	r2, #1272	; 0x4f8
 800b972:	2100      	movs	r1, #0
 800b974:	4825      	ldr	r0, [pc, #148]	; (800ba0c <usb_host_restart+0xd0>)
 800b976:	f002 ff35 	bl	800e7e4 <memset>

  usb_host_fifo_reset();
 800b97a:	f7ff ff6b 	bl	800b854 <usb_host_fifo_reset>
  USBH_static_mem_reset();
 800b97e:	f7ff ff77 	bl	800b870 <USBH_static_mem_reset>

  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, 0) != USBH_OK)
 800b982:	2200      	movs	r2, #0
 800b984:	4925      	ldr	r1, [pc, #148]	; (800ba1c <usb_host_restart+0xe0>)
 800b986:	4821      	ldr	r0, [pc, #132]	; (800ba0c <usb_host_restart+0xd0>)
 800b988:	f000 fae8 	bl	800bf5c <USBH_Init>
 800b98c:	b130      	cbz	r0, 800b99c <usb_host_restart+0x60>
    return;
  }

  if (USBH_Start(&hUsbHostFS) != USBH_OK)
  {
    usb_error_count++;
 800b98e:	4a24      	ldr	r2, [pc, #144]	; (800ba20 <usb_host_restart+0xe4>)
  reset_requested = true;
 800b990:	2101      	movs	r1, #1
    usb_error_count++;
 800b992:	6813      	ldr	r3, [r2, #0]
 800b994:	440b      	add	r3, r1
 800b996:	6013      	str	r3, [r2, #0]
  reset_requested = true;
 800b998:	7021      	strb	r1, [r4, #0]
  else
  {
    host_started = true;
  }
  usb_host_update_activity();
}
 800b99a:	bd10      	pop	{r4, pc}
  if (USBH_RegisterClass(&hUsbHostFS, &USBH_MIDI_Class) != USBH_OK)
 800b99c:	4921      	ldr	r1, [pc, #132]	; (800ba24 <usb_host_restart+0xe8>)
 800b99e:	481b      	ldr	r0, [pc, #108]	; (800ba0c <usb_host_restart+0xd0>)
 800b9a0:	f000 fb20 	bl	800bfe4 <USBH_RegisterClass>
 800b9a4:	2800      	cmp	r0, #0
 800b9a6:	d1f2      	bne.n	800b98e <usb_host_restart+0x52>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 800b9a8:	4818      	ldr	r0, [pc, #96]	; (800ba0c <usb_host_restart+0xd0>)
 800b9aa:	f000 fbad 	bl	800c108 <USBH_Start>
 800b9ae:	2800      	cmp	r0, #0
 800b9b0:	d1ed      	bne.n	800b98e <usb_host_restart+0x52>
  if (host_started)
 800b9b2:	4b1d      	ldr	r3, [pc, #116]	; (800ba28 <usb_host_restart+0xec>)
 800b9b4:	781a      	ldrb	r2, [r3, #0]
 800b9b6:	b31a      	cbz	r2, 800ba00 <usb_host_restart+0xc4>
    usb_recovery_count++;
 800b9b8:	4a1c      	ldr	r2, [pc, #112]	; (800ba2c <usb_host_restart+0xf0>)
 800b9ba:	6813      	ldr	r3, [r2, #0]
 800b9bc:	3301      	adds	r3, #1
 800b9be:	6013      	str	r3, [r2, #0]
 800b9c0:	2330      	movs	r3, #48	; 0x30
 800b9c2:	f383 8811 	msr	BASEPRI, r3
 800b9c6:	f7f5 f919 	bl	8000bfc <stGetCounter>
 800b9ca:	2300      	movs	r3, #0
 800b9cc:	f383 8811 	msr	BASEPRI, r3
  last_activity = chVTGetSystemTime();
 800b9d0:	4b17      	ldr	r3, [pc, #92]	; (800ba30 <usb_host_restart+0xf4>)
 800b9d2:	6018      	str	r0, [r3, #0]
}
 800b9d4:	bd10      	pop	{r4, pc}
  if ((hUsbHostFS.pData != NULL) || host_started)
 800b9d6:	4b14      	ldr	r3, [pc, #80]	; (800ba28 <usb_host_restart+0xec>)
 800b9d8:	781b      	ldrb	r3, [r3, #0]
 800b9da:	2b00      	cmp	r3, #0
 800b9dc:	d0c7      	beq.n	800b96e <usb_host_restart+0x32>
 800b9de:	e7c0      	b.n	800b962 <usb_host_restart+0x26>
    usb_error_count++;
 800b9e0:	4a0f      	ldr	r2, [pc, #60]	; (800ba20 <usb_host_restart+0xe4>)
 800b9e2:	4604      	mov	r4, r0
    USBH_ErrLog("USBH static pool OOM since last reset: %lu", (unsigned long)oom_count);
 800b9e4:	4813      	ldr	r0, [pc, #76]	; (800ba34 <usb_host_restart+0xf8>)
    usb_error_count++;
 800b9e6:	6813      	ldr	r3, [r2, #0]
 800b9e8:	3301      	adds	r3, #1
 800b9ea:	6013      	str	r3, [r2, #0]
    USBH_ErrLog("USBH static pool OOM since last reset: %lu", (unsigned long)oom_count);
 800b9ec:	f002 feae 	bl	800e74c <printf>
 800b9f0:	4621      	mov	r1, r4
 800b9f2:	4811      	ldr	r0, [pc, #68]	; (800ba38 <usb_host_restart+0xfc>)
 800b9f4:	f002 feaa 	bl	800e74c <printf>
 800b9f8:	200a      	movs	r0, #10
 800b9fa:	f002 febb 	bl	800e774 <putchar>
 800b9fe:	e7a2      	b.n	800b946 <usb_host_restart+0xa>
    host_started = true;
 800ba00:	2201      	movs	r2, #1
 800ba02:	701a      	strb	r2, [r3, #0]
 800ba04:	e7dc      	b.n	800b9c0 <usb_host_restart+0x84>
 800ba06:	bf00      	nop
 800ba08:	2400487c 	.word	0x2400487c
 800ba0c:	24004884 	.word	0x24004884
 800ba10:	24004d8c 	.word	0x24004d8c
 800ba14:	24004d84 	.word	0x24004d84
 800ba18:	24004d88 	.word	0x24004d88
 800ba1c:	0800b8a9 	.word	0x0800b8a9
 800ba20:	24004d94 	.word	0x24004d94
 800ba24:	2400001c 	.word	0x2400001c
 800ba28:	24004d7d 	.word	0x24004d7d
 800ba2c:	24005780 	.word	0x24005780
 800ba30:	24004d80 	.word	0x24004d80
 800ba34:	0801540c 	.word	0x0801540c
 800ba38:	08015414 	.word	0x08015414

0800ba3c <usb_host_thread>:
 800ba3c:	4b39      	ldr	r3, [pc, #228]	; (800bb24 <usb_host_thread+0xe8>)
 800ba3e:	f04f 0930 	mov.w	r9, #48	; 0x30
 800ba42:	4a39      	ldr	r2, [pc, #228]	; (800bb28 <usb_host_thread+0xec>)
 800ba44:	68db      	ldr	r3, [r3, #12]
{
 800ba46:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 800ba4a:	621a      	str	r2, [r3, #32]
 800ba4c:	b083      	sub	sp, #12
 800ba4e:	f389 8811 	msr	BASEPRI, r9
 800ba52:	f7f5 f8d3 	bl	8000bfc <stGetCounter>
 800ba56:	2300      	movs	r3, #0
 800ba58:	f383 8811 	msr	BASEPRI, r3
  last_activity = chVTGetSystemTime();
 800ba5c:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 800bb48 <usb_host_thread+0x10c>
 800ba60:	f8df b0e8 	ldr.w	fp, [pc, #232]	; 800bb4c <usb_host_thread+0x110>
 800ba64:	4d31      	ldr	r5, [pc, #196]	; (800bb2c <usb_host_thread+0xf0>)
 800ba66:	4e32      	ldr	r6, [pc, #200]	; (800bb30 <usb_host_thread+0xf4>)
    USBH_Process(&hUsbHostFS);
 800ba68:	4c32      	ldr	r4, [pc, #200]	; (800bb34 <usb_host_thread+0xf8>)
  last_activity = chVTGetSystemTime();
 800ba6a:	f8c8 0000 	str.w	r0, [r8]
    USBH_Process(&hUsbHostFS);
 800ba6e:	4620      	mov	r0, r4
    midi_ready = USBH_MIDI_IsReady(&hUsbHostFS);
 800ba70:	4f31      	ldr	r7, [pc, #196]	; (800bb38 <usb_host_thread+0xfc>)
    USBH_Process(&hUsbHostFS);
 800ba72:	f000 fb65 	bl	800c140 <USBH_Process>
    midi_ready = USBH_MIDI_IsReady(&hUsbHostFS);
 800ba76:	4620      	mov	r0, r4
 800ba78:	f001 fcb8 	bl	800d3ec <USBH_MIDI_IsReady>
 800ba7c:	4603      	mov	r3, r0
    tx_overflow = USBH_MIDI_GetTxOverflow(&hUsbHostFS);
 800ba7e:	4620      	mov	r0, r4
    midi_ready = USBH_MIDI_IsReady(&hUsbHostFS);
 800ba80:	703b      	strb	r3, [r7, #0]
    tx_overflow = USBH_MIDI_GetTxOverflow(&hUsbHostFS);
 800ba82:	f001 fcf1 	bl	800d468 <USBH_MIDI_GetTxOverflow>
 800ba86:	4b2d      	ldr	r3, [pc, #180]	; (800bb3c <usb_host_thread+0x100>)
 800ba88:	6018      	str	r0, [r3, #0]
    fifo_overflow_total = usb_host_fifo_overflow_total();
 800ba8a:	f7ff fedd 	bl	800b848 <usb_host_fifo_overflow_total>
 800ba8e:	f8cb 0000 	str.w	r0, [fp]
  if (!midi_ready || reset_requested)
 800ba92:	783b      	ldrb	r3, [r7, #0]
 800ba94:	b35b      	cbz	r3, 800baee <usb_host_thread+0xb2>
 800ba96:	782b      	ldrb	r3, [r5, #0]
 800ba98:	f003 0aff 	and.w	sl, r3, #255	; 0xff
 800ba9c:	bb3b      	cbnz	r3, 800baee <usb_host_thread+0xb2>
 800ba9e:	4657      	mov	r7, sl
 800baa0:	e003      	b.n	800baaa <usb_host_thread+0x6e>
      overflow_streak = 0U;
 800baa2:	f8c6 a000 	str.w	sl, [r6]
    if (reset_requested)
 800baa6:	782b      	ldrb	r3, [r5, #0]
 800baa8:	bb0b      	cbnz	r3, 800baee <usb_host_thread+0xb2>
  while (USBH_MIDI_ReadEvent(&hUsbHostFS, packet))
 800baaa:	a901      	add	r1, sp, #4
 800baac:	4620      	mov	r0, r4
 800baae:	f001 fcad 	bl	800d40c <USBH_MIDI_ReadEvent>
 800bab2:	b1e0      	cbz	r0, 800baee <usb_host_thread+0xb2>
 800bab4:	f389 8811 	msr	BASEPRI, r9
 800bab8:	f7f5 f8a0 	bl	8000bfc <stGetCounter>
 800babc:	4603      	mov	r3, r0
 800babe:	f387 8811 	msr	BASEPRI, r7
    if (!usb_host_fifo_push(packet))
 800bac2:	a801      	add	r0, sp, #4
  last_activity = chVTGetSystemTime();
 800bac4:	f8c8 3000 	str.w	r3, [r8]
    if (!usb_host_fifo_push(packet))
 800bac8:	f7ff fe94 	bl	800b7f4 <usb_host_fifo_push>
 800bacc:	2800      	cmp	r0, #0
 800bace:	d1e8      	bne.n	800baa2 <usb_host_thread+0x66>
      fifo_overflow_total = usb_host_fifo_overflow_total();
 800bad0:	f7ff feba 	bl	800b848 <usb_host_fifo_overflow_total>
      overflow_streak++;
 800bad4:	6833      	ldr	r3, [r6, #0]
      fifo_overflow_total = usb_host_fifo_overflow_total();
 800bad6:	f8cb 0000 	str.w	r0, [fp]
      overflow_streak++;
 800bada:	3301      	adds	r3, #1
      if (overflow_streak >= USB_OVERFLOW_STREAK_LIMIT)
 800badc:	2b07      	cmp	r3, #7
      overflow_streak++;
 800bade:	6033      	str	r3, [r6, #0]
      if (overflow_streak >= USB_OVERFLOW_STREAK_LIMIT)
 800bae0:	d9e1      	bls.n	800baa6 <usb_host_thread+0x6a>
        usb_error_count++;
 800bae2:	4a17      	ldr	r2, [pc, #92]	; (800bb40 <usb_host_thread+0x104>)
 800bae4:	6813      	ldr	r3, [r2, #0]
 800bae6:	3301      	adds	r3, #1
 800bae8:	6013      	str	r3, [r2, #0]
  reset_requested = true;
 800baea:	2301      	movs	r3, #1
 800baec:	702b      	strb	r3, [r5, #0]
    if (device_attached &&
 800baee:	4b15      	ldr	r3, [pc, #84]	; (800bb44 <usb_host_thread+0x108>)
 800baf0:	781b      	ldrb	r3, [r3, #0]
 800baf2:	b93b      	cbnz	r3, 800bb04 <usb_host_thread+0xc8>
    if (reset_requested)
 800baf4:	782b      	ldrb	r3, [r5, #0]
 800baf6:	b10b      	cbz	r3, 800bafc <usb_host_thread+0xc0>
      usb_host_restart();
 800baf8:	f7ff ff20 	bl	800b93c <usb_host_restart>
    chThdSleepMicroseconds(USB_HOST_PROCESS_DELAY_US);
 800bafc:	2003      	movs	r0, #3
 800bafe:	f7fa fd81 	bl	8006604 <chThdSleep>
    USBH_Process(&hUsbHostFS);
 800bb02:	e7b4      	b.n	800ba6e <usb_host_thread+0x32>
        (chVTTimeElapsedSinceX(last_activity) >= TIME_MS2I(USB_IDLE_TIMEOUT_MS)))
 800bb04:	f8d8 7000 	ldr.w	r7, [r8]
 800bb08:	f7f5 f878 	bl	8000bfc <stGetCounter>
    if (device_attached &&
 800bb0c:	f24c 334f 	movw	r3, #49999	; 0xc34f
 800bb10:	1bc0      	subs	r0, r0, r7
 800bb12:	4298      	cmp	r0, r3
 800bb14:	d9ee      	bls.n	800baf4 <usb_host_thread+0xb8>
      usb_error_count++;
 800bb16:	490a      	ldr	r1, [pc, #40]	; (800bb40 <usb_host_thread+0x104>)
  reset_requested = true;
 800bb18:	2201      	movs	r2, #1
      usb_error_count++;
 800bb1a:	680b      	ldr	r3, [r1, #0]
 800bb1c:	4413      	add	r3, r2
 800bb1e:	600b      	str	r3, [r1, #0]
  reset_requested = true;
 800bb20:	702a      	strb	r2, [r5, #0]
}
 800bb22:	e7e7      	b.n	800baf4 <usb_host_thread+0xb8>
 800bb24:	24000c20 	.word	0x24000c20
 800bb28:	08015440 	.word	0x08015440
 800bb2c:	24004d8c 	.word	0x24004d8c
 800bb30:	24004d88 	.word	0x24004d88
 800bb34:	24004884 	.word	0x24004884
 800bb38:	24004d84 	.word	0x24004d84
 800bb3c:	24004d90 	.word	0x24004d90
 800bb40:	24004d94 	.word	0x24004d94
 800bb44:	2400487c 	.word	0x2400487c
 800bb48:	24004d80 	.word	0x24004d80
 800bb4c:	24004880 	.word	0x24004880

0800bb50 <usb_host_midi_init>:
  if (host_initialized)
 800bb50:	4b0f      	ldr	r3, [pc, #60]	; (800bb90 <usb_host_midi_init+0x40>)
{
 800bb52:	b510      	push	{r4, lr}
  if (host_initialized)
 800bb54:	781c      	ldrb	r4, [r3, #0]
{
 800bb56:	b082      	sub	sp, #8
  if (host_initialized)
 800bb58:	b9c4      	cbnz	r4, 800bb8c <usb_host_midi_init+0x3c>
  host_initialized = true;
 800bb5a:	2201      	movs	r2, #1
 800bb5c:	701a      	strb	r2, [r3, #0]
  USBH_static_mem_reset();
 800bb5e:	f7ff fe87 	bl	800b870 <USBH_static_mem_reset>
  usb_host_fifo_reset();
 800bb62:	f7ff fe77 	bl	800b854 <usb_host_fifo_reset>
 800bb66:	2330      	movs	r3, #48	; 0x30
 800bb68:	f383 8811 	msr	BASEPRI, r3
 800bb6c:	f7f5 f846 	bl	8000bfc <stGetCounter>
 800bb70:	f384 8811 	msr	BASEPRI, r4
  last_activity = chVTGetSystemTime();
 800bb74:	4b07      	ldr	r3, [pc, #28]	; (800bb94 <usb_host_midi_init+0x44>)
 800bb76:	6018      	str	r0, [r3, #0]
  usb_host_restart();
 800bb78:	f7ff fee0 	bl	800b93c <usb_host_restart>
  usb_host_thread_ref = chThdCreateStatic(usb_host_wa, sizeof(usb_host_wa),
 800bb7c:	4b06      	ldr	r3, [pc, #24]	; (800bb98 <usb_host_midi_init+0x48>)
 800bb7e:	2282      	movs	r2, #130	; 0x82
 800bb80:	f44f 611e 	mov.w	r1, #2528	; 0x9e0
 800bb84:	4805      	ldr	r0, [pc, #20]	; (800bb9c <usb_host_midi_init+0x4c>)
 800bb86:	9400      	str	r4, [sp, #0]
 800bb88:	f7fa fc8e 	bl	80064a8 <chThdCreateStatic>
}
 800bb8c:	b002      	add	sp, #8
 800bb8e:	bd10      	pop	{r4, pc}
 800bb90:	24004d7c 	.word	0x24004d7c
 800bb94:	24004d80 	.word	0x24004d80
 800bb98:	0800ba3d 	.word	0x0800ba3d
 800bb9c:	24004da0 	.word	0x24004da0

0800bba0 <HAL_HCD_MspInit>:

void HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  if (hhcd->Instance == USB_OTG_FS)
 800bba0:	4b25      	ldr	r3, [pc, #148]	; (800bc38 <HAL_HCD_MspInit+0x98>)
 800bba2:	6802      	ldr	r2, [r0, #0]
{
 800bba4:	b530      	push	{r4, r5, lr}
  if (hhcd->Instance == USB_OTG_FS)
 800bba6:	429a      	cmp	r2, r3
{
 800bba8:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800bbaa:	f04f 0400 	mov.w	r4, #0
 800bbae:	e9cd 4403 	strd	r4, r4, [sp, #12]
 800bbb2:	e9cd 4405 	strd	r4, r4, [sp, #20]
 800bbb6:	9407      	str	r4, [sp, #28]
  if (hhcd->Instance == USB_OTG_FS)
 800bbb8:	d001      	beq.n	800bbbe <HAL_HCD_MspInit+0x1e>
    HAL_NVIC_SetPriority(OTG_FS_IRQn, USBH_OTG_FS_IRQ_PRIO, 0);
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);

    HAL_PWREx_EnableUSBVoltageDetector();
  }
}
 800bbba:	b009      	add	sp, #36	; 0x24
 800bbbc:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800bbbe:	4b1f      	ldr	r3, [pc, #124]	; (800bc3c <HAL_HCD_MspInit+0x9c>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bbc0:	2002      	movs	r0, #2
    GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
 800bbc2:	f44f 55c0 	mov.w	r5, #6144	; 0x1800
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800bbc6:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800bbc8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800bbcc:	f042 0201 	orr.w	r2, r2, #1
 800bbd0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800bbd4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800bbd8:	f002 0201 	and.w	r2, r2, #1
 800bbdc:	9200      	str	r2, [sp, #0]
 800bbde:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800bbe0:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 800bbe4:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800bbe8:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
 800bbec:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 800bbf0:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 800bbf4:	9201      	str	r2, [sp, #4]
 800bbf6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bbf8:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 800bbfc:	4302      	orrs	r2, r0
 800bbfe:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800bc02:	2203      	movs	r2, #3
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bc04:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bc08:	9004      	str	r0, [sp, #16]
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bc0a:	4003      	ands	r3, r0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800bc0c:	480c      	ldr	r0, [pc, #48]	; (800bc40 <HAL_HCD_MspInit+0xa0>)
    GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
 800bc0e:	9503      	str	r5, [sp, #12]
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bc10:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 800bc12:	230a      	movs	r3, #10
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bc14:	9d02      	ldr	r5, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 800bc16:	e9cd 2306 	strd	r2, r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800bc1a:	f001 fc4b 	bl	800d4b4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(OTG_FS_IRQn, USBH_OTG_FS_IRQ_PRIO, 0);
 800bc1e:	4622      	mov	r2, r4
 800bc20:	2106      	movs	r1, #6
 800bc22:	2065      	movs	r0, #101	; 0x65
 800bc24:	f001 fefe 	bl	800da24 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 800bc28:	2065      	movs	r0, #101	; 0x65
 800bc2a:	f001 ff39 	bl	800daa0 <HAL_NVIC_EnableIRQ>
    HAL_PWREx_EnableUSBVoltageDetector();
 800bc2e:	f001 fd99 	bl	800d764 <HAL_PWREx_EnableUSBVoltageDetector>
}
 800bc32:	b009      	add	sp, #36	; 0x24
 800bc34:	bd30      	pop	{r4, r5, pc}
 800bc36:	bf00      	nop
 800bc38:	40080000 	.word	0x40080000
 800bc3c:	58024400 	.word	0x58024400
 800bc40:	58020000 	.word	0x58020000

0800bc44 <USBH_LL_Init>:
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11 | GPIO_PIN_12);
  }
}

USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
 800bc44:	b510      	push	{r4, lr}
  hhcd->Init.dev_endpoints = 8U;
 800bc46:	4a14      	ldr	r2, [pc, #80]	; (800bc98 <USBH_LL_Init+0x54>)
  hhcd->Init.lpm_enable = DISABLE;
 800bc48:	2300      	movs	r3, #0
  phost->pData = &hhcd_USB_OTG_FS;
 800bc4a:	4c14      	ldr	r4, [pc, #80]	; (800bc9c <USBH_LL_Init+0x58>)
  hhcd->Instance = USB_OTG_FS;
 800bc4c:	4914      	ldr	r1, [pc, #80]	; (800bca0 <USBH_LL_Init+0x5c>)
  hhcd->Init.dev_endpoints = 8U;
 800bc4e:	6062      	str	r2, [r4, #4]
  hhcd->Init.ep0_mps = 64U;
 800bc50:	4a14      	ldr	r2, [pc, #80]	; (800bca4 <USBH_LL_Init+0x60>)
  phost->pData = &hhcd_USB_OTG_FS;
 800bc52:	f8c0 44f0 	str.w	r4, [r0, #1264]	; 0x4f0
  hhcd_USB_OTG_FS.pData = phost;
 800bc56:	f8c4 03dc 	str.w	r0, [r4, #988]	; 0x3dc

  MX_USB_OTG_FS_HCD_Init(&hhcd_USB_OTG_FS);

  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 800bc5a:	4620      	mov	r0, r4
  hhcd->Init.lpm_enable = DISABLE;
 800bc5c:	60e3      	str	r3, [r4, #12]
  hhcd->Init.ep0_mps = 64U;
 800bc5e:	60a2      	str	r2, [r4, #8]
  hhcd->Instance = USB_OTG_FS;
 800bc60:	6021      	str	r1, [r4, #0]
  hhcd->Init.use_external_vbus = DISABLE;
 800bc62:	7423      	strb	r3, [r4, #16]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 800bc64:	f001 fdf2 	bl	800d84c <HAL_HCD_Init>
 800bc68:	b9a0      	cbnz	r0, 800bc94 <USBH_LL_Init+0x50>
    return USBH_FAIL;
  }

  /* ---- USB OTG FS FIFO CONFIGURATION (Direct register access, HAL H7 safe) ---- */

  USB_OTG_GlobalTypeDef *USBx = hhcd_USB_OTG_FS.Instance;
 800bc6a:	6823      	ldr	r3, [r4, #0]

  /* Rx FIFO size (in 32-bit words) */
  USBx->GRXFSIZ = 0x80U;

  /* Non-periodic Tx FIFO (EP0 / Control) */
  USBx->DIEPTXF0_HNPTXFSIZ = (0x40U << 16) | 0U;
 800bc6c:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  USBx->GRXFSIZ = 0x80U;
 800bc70:	2480      	movs	r4, #128	; 0x80

  /* Host periodic Tx FIFO */
  USBx->HPTXFSIZ = (0x80U << 16) | 0x40U;
 800bc72:	490d      	ldr	r1, [pc, #52]	; (800bca8 <USBH_LL_Init+0x64>)
  USBx->GRXFSIZ = 0x80U;
 800bc74:	625c      	str	r4, [r3, #36]	; 0x24
  USBx->DIEPTXF0_HNPTXFSIZ = (0x40U << 16) | 0U;
 800bc76:	629a      	str	r2, [r3, #40]	; 0x28

  /* Flush all Tx FIFOs */
  USBx->GRSTCTL = USB_OTG_GRSTCTL_TXFFLSH | (0x10U << 6);
 800bc78:	f44f 6284 	mov.w	r2, #1056	; 0x420
  USBx->HPTXFSIZ = (0x80U << 16) | 0x40U;
 800bc7c:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
  USBx->GRSTCTL = USB_OTG_GRSTCTL_TXFFLSH | (0x10U << 6);
 800bc80:	611a      	str	r2, [r3, #16]
  while (USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) {}
 800bc82:	691a      	ldr	r2, [r3, #16]
 800bc84:	0691      	lsls	r1, r2, #26
 800bc86:	d4fc      	bmi.n	800bc82 <USBH_LL_Init+0x3e>

  /* Flush Rx FIFO */
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800bc88:	2210      	movs	r2, #16
 800bc8a:	611a      	str	r2, [r3, #16]
  while (USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) {}
 800bc8c:	691a      	ldr	r2, [r3, #16]
 800bc8e:	06d2      	lsls	r2, r2, #27
 800bc90:	d4fc      	bmi.n	800bc8c <USBH_LL_Init+0x48>



  return USBH_OK;
}
 800bc92:	bd10      	pop	{r4, pc}
    return USBH_FAIL;
 800bc94:	2002      	movs	r0, #2
}
 800bc96:	bd10      	pop	{r4, pc}
 800bc98:	01000808 	.word	0x01000808
 800bc9c:	24005784 	.word	0x24005784
 800bca0:	40080000 	.word	0x40080000
 800bca4:	00010240 	.word	0x00010240
 800bca8:	00800040 	.word	0x00800040

0800bcac <USBH_LL_Start>:
  }
  return USBH_OK;
}

USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
 800bcac:	b508      	push	{r3, lr}
  (void)phost;
  if (HAL_HCD_Start(&hhcd_USB_OTG_FS) != HAL_OK)
 800bcae:	4804      	ldr	r0, [pc, #16]	; (800bcc0 <USBH_LL_Start+0x14>)
 800bcb0:	f001 fe78 	bl	800d9a4 <HAL_HCD_Start>
 800bcb4:	3800      	subs	r0, #0
 800bcb6:	bf18      	it	ne
 800bcb8:	2001      	movne	r0, #1
  {
    return USBH_FAIL;
  }
  return USBH_OK;
}
 800bcba:	0040      	lsls	r0, r0, #1
 800bcbc:	bd08      	pop	{r3, pc}
 800bcbe:	bf00      	nop
 800bcc0:	24005784 	.word	0x24005784

0800bcc4 <USBH_LL_Stop>:

USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
 800bcc4:	b508      	push	{r3, lr}
  (void)phost;
  if (HAL_HCD_Stop(&hhcd_USB_OTG_FS) != HAL_OK)
 800bcc6:	4804      	ldr	r0, [pc, #16]	; (800bcd8 <USBH_LL_Stop+0x14>)
 800bcc8:	f001 fe82 	bl	800d9d0 <HAL_HCD_Stop>
 800bccc:	3800      	subs	r0, #0
 800bcce:	bf18      	it	ne
 800bcd0:	2001      	movne	r0, #1
  {
    return USBH_FAIL;
  }
  return USBH_OK;
}
 800bcd2:	0040      	lsls	r0, r0, #1
 800bcd4:	bd08      	pop	{r3, pc}
 800bcd6:	bf00      	nop
 800bcd8:	24005784 	.word	0x24005784

0800bcdc <USBH_LL_GetSpeed>:

USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
 800bcdc:	b508      	push	{r3, lr}
  uint32_t speed = HAL_HCD_GetCurrentSpeed((HCD_HandleTypeDef *)phost->pData);
 800bcde:	f8d0 04f0 	ldr.w	r0, [r0, #1264]	; 0x4f0
 800bce2:	f001 fe9b 	bl	800da1c <HAL_HCD_GetCurrentSpeed>
  if (speed == HCD_DEVICE_SPEED_LOW)
  {
    return USBH_SPEED_LOW;
 800bce6:	2802      	cmp	r0, #2
  }
  return USBH_SPEED_FULL;
}
 800bce8:	bf14      	ite	ne
 800bcea:	2001      	movne	r0, #1
 800bcec:	2002      	moveq	r0, #2
 800bcee:	bd08      	pop	{r3, pc}

0800bcf0 <USBH_LL_ResetPort>:

USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
  port_reset_count++;
 800bcf0:	4a06      	ldr	r2, [pc, #24]	; (800bd0c <USBH_LL_ResetPort+0x1c>)
  if (HAL_HCD_ResetPort((HCD_HandleTypeDef *)phost->pData) != HAL_OK)
 800bcf2:	f8d0 04f0 	ldr.w	r0, [r0, #1264]	; 0x4f0
{
 800bcf6:	b508      	push	{r3, lr}
  port_reset_count++;
 800bcf8:	6813      	ldr	r3, [r2, #0]
 800bcfa:	3301      	adds	r3, #1
 800bcfc:	6013      	str	r3, [r2, #0]
  if (HAL_HCD_ResetPort((HCD_HandleTypeDef *)phost->pData) != HAL_OK)
 800bcfe:	f001 fe7b 	bl	800d9f8 <HAL_HCD_ResetPort>
 800bd02:	3800      	subs	r0, #0
 800bd04:	bf18      	it	ne
 800bd06:	2001      	movne	r0, #1
  {
    return USBH_FAIL;
  }
  return USBH_OK;
}
 800bd08:	0040      	lsls	r0, r0, #1
 800bd0a:	bd08      	pop	{r3, pc}
 800bd0c:	24005b64 	.word	0x24005b64

0800bd10 <USBH_LL_GetLastXferSize>:

uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return HAL_HCD_HC_GetXferCount((HCD_HandleTypeDef *)phost->pData, pipe);
 800bd10:	f8d0 04f0 	ldr.w	r0, [r0, #1264]	; 0x4f0
 800bd14:	f001 be7c 	b.w	800da10 <HAL_HCD_HC_GetXferCount>

0800bd18 <USBH_LL_DriverVBUS>:
}

USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
 800bd18:	b508      	push	{r3, lr}
  (void)phost;

  if (state == 0U)
 800bd1a:	b921      	cbnz	r1, 800bd26 <USBH_LL_DriverVBUS+0xe>
  {
    /* Nominally "turn off" VBUS.
     * On this board, VBUS is always powered and there is no control GPIO,
     * so we only give some time for the bus to settle.
     */
    chThdSleepMilliseconds(5);
 800bd1c:	2032      	movs	r0, #50	; 0x32
 800bd1e:	f7fa fc71 	bl	8006604 <chThdSleep>
     */
    chThdSleepMilliseconds(100);
  }

  return USBH_OK;
}
 800bd22:	2000      	movs	r0, #0
 800bd24:	bd08      	pop	{r3, pc}
    chThdSleepMilliseconds(100);
 800bd26:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800bd2a:	f7fa fc6b 	bl	8006604 <chThdSleep>
}
 800bd2e:	2000      	movs	r0, #0
 800bd30:	bd08      	pop	{r3, pc}
 800bd32:	bf00      	nop

0800bd34 <USBH_LL_OpenPipe>:

USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe,
                                    uint8_t epnum, uint8_t dev_address,
                                    uint8_t speed, uint8_t ep_type,
                                    uint16_t mps)
{
 800bd34:	b510      	push	{r4, lr}
 800bd36:	b084      	sub	sp, #16
  if (HAL_HCD_HC_Init((HCD_HandleTypeDef *)phost->pData, pipe, epnum,
 800bd38:	f8d0 04f0 	ldr.w	r0, [r0, #1264]	; 0x4f0
{
 800bd3c:	f89d 4018 	ldrb.w	r4, [sp, #24]
  if (HAL_HCD_HC_Init((HCD_HandleTypeDef *)phost->pData, pipe, epnum,
 800bd40:	9400      	str	r4, [sp, #0]
{
 800bd42:	f89d 401c 	ldrb.w	r4, [sp, #28]
  if (HAL_HCD_HC_Init((HCD_HandleTypeDef *)phost->pData, pipe, epnum,
 800bd46:	9401      	str	r4, [sp, #4]
{
 800bd48:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  if (HAL_HCD_HC_Init((HCD_HandleTypeDef *)phost->pData, pipe, epnum,
 800bd4c:	9402      	str	r4, [sp, #8]
 800bd4e:	f001 fd11 	bl	800d774 <HAL_HCD_HC_Init>
 800bd52:	3800      	subs	r0, #0
 800bd54:	bf18      	it	ne
 800bd56:	2001      	movne	r0, #1
                      dev_address, speed, ep_type, mps) != HAL_OK)
  {
    return USBH_FAIL;
  }
  return USBH_OK;
}
 800bd58:	0040      	lsls	r0, r0, #1
 800bd5a:	b004      	add	sp, #16
 800bd5c:	bd10      	pop	{r4, pc}
 800bd5e:	bf00      	nop

0800bd60 <USBH_LL_ClosePipe>:

USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 800bd60:	b508      	push	{r3, lr}
  if (HAL_HCD_HC_Halt((HCD_HandleTypeDef *)phost->pData, pipe) != HAL_OK)
 800bd62:	f8d0 04f0 	ldr.w	r0, [r0, #1264]	; 0x4f0
 800bd66:	f001 fd5d 	bl	800d824 <HAL_HCD_HC_Halt>
 800bd6a:	3800      	subs	r0, #0
 800bd6c:	bf18      	it	ne
 800bd6e:	2001      	movne	r0, #1
  {
    return USBH_FAIL;
  }
  return USBH_OK;
}
 800bd70:	0040      	lsls	r0, r0, #1
 800bd72:	bd08      	pop	{r3, pc}

0800bd74 <USBH_LL_SubmitURB>:

USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe,
                                     uint8_t direction, uint8_t ep_type,
                                     uint8_t token, uint8_t *pbuff,
                                     uint16_t length, uint8_t do_ping)
{
 800bd74:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bd78:	b085      	sub	sp, #20
 800bd7a:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
 800bd7e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800bd80:	f8bd 7038 	ldrh.w	r7, [sp, #56]	; 0x38
 800bd84:	f89d 803c 	ldrb.w	r8, [sp, #60]	; 0x3c
  /* Maintient la cohérence D-Cache pour les buffers URB avant soumission. */
  if (direction == 0U)
 800bd88:	bb72      	cbnz	r2, 800bde8 <USBH_LL_SubmitURB+0x74>
  if ((address == NULL) || (length == 0U))
 800bd8a:	b1f5      	cbz	r5, 800bdca <USBH_LL_SubmitURB+0x56>
 800bd8c:	b1ef      	cbz	r7, 800bdca <USBH_LL_SubmitURB+0x56>
  uint32_t aligned_length = (uint32_t)((((uintptr_t)address + length + cache_line_size - 1U) &
 800bd8e:	f105 0e1f 	add.w	lr, r5, #31
  uintptr_t aligned_addr = ((uintptr_t)address) & ~(cache_line_size - 1U);
 800bd92:	f025 041f 	bic.w	r4, r5, #31
  uint32_t aligned_length = (uint32_t)((((uintptr_t)address + length + cache_line_size - 1U) &
 800bd96:	44be      	add	lr, r7
 800bd98:	f02e 0e1f 	bic.w	lr, lr, #31
 800bd9c:	ebae 0e04 	sub.w	lr, lr, r4
  __ASM volatile ("dsb 0xF":::"memory");
 800bda0:	f3bf 8f4f 	dsb	sy
    uint32_t op_addr = (uint32_t) addr;
     int32_t linesize = 32;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */

    __DSB();

    while (op_size > 0) {
 800bda4:	f1be 0f00 	cmp.w	lr, #0
 800bda8:	dd0b      	ble.n	800bdc2 <USBH_LL_SubmitURB+0x4e>
 800bdaa:	44a6      	add	lr, r4
 800bdac:	f104 0c20 	add.w	ip, r4, #32
      SCB->DCCMVAC = op_addr;
 800bdb0:	f8df 907c 	ldr.w	r9, [pc, #124]	; 800be30 <USBH_LL_SubmitURB+0xbc>
    while (op_size > 0) {
 800bdb4:	45f4      	cmp	ip, lr
      SCB->DCCMVAC = op_addr;
 800bdb6:	f8c9 4268 	str.w	r4, [r9, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 800bdba:	4664      	mov	r4, ip
    while (op_size > 0) {
 800bdbc:	f10c 0c20 	add.w	ip, ip, #32
 800bdc0:	d1f8      	bne.n	800bdb4 <USBH_LL_SubmitURB+0x40>
 800bdc2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800bdc6:	f3bf 8f6f 	isb	sy
  else
  {
    usbh_dcache_invalidate(pbuff, length);
  }

  if (HAL_HCD_HC_SubmitRequest((HCD_HandleTypeDef *)phost->pData, pipe,
 800bdca:	e9cd 7802 	strd	r7, r8, [sp, #8]
 800bdce:	9501      	str	r5, [sp, #4]
 800bdd0:	f8d0 04f0 	ldr.w	r0, [r0, #1264]	; 0x4f0
 800bdd4:	9600      	str	r6, [sp, #0]
 800bdd6:	f001 fd75 	bl	800d8c4 <HAL_HCD_HC_SubmitRequest>
 800bdda:	3800      	subs	r0, #0
 800bddc:	bf18      	it	ne
 800bdde:	2001      	movne	r0, #1
                               do_ping) != HAL_OK)
  {
    return USBH_FAIL;
  }
  return USBH_OK;
}
 800bde0:	0040      	lsls	r0, r0, #1
 800bde2:	b005      	add	sp, #20
 800bde4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if ((address == NULL) || (length == 0U))
 800bde8:	2d00      	cmp	r5, #0
 800bdea:	d0ee      	beq.n	800bdca <USBH_LL_SubmitURB+0x56>
 800bdec:	2f00      	cmp	r7, #0
 800bdee:	d0ec      	beq.n	800bdca <USBH_LL_SubmitURB+0x56>
  uint32_t aligned_length = (uint32_t)((((uintptr_t)address + length + cache_line_size - 1U) &
 800bdf0:	f105 0e1f 	add.w	lr, r5, #31
  uintptr_t aligned_addr = ((uintptr_t)address) & ~(cache_line_size - 1U);
 800bdf4:	f025 041f 	bic.w	r4, r5, #31
  uint32_t aligned_length = (uint32_t)((((uintptr_t)address + length + cache_line_size - 1U) &
 800bdf8:	44be      	add	lr, r7
 800bdfa:	f02e 0e1f 	bic.w	lr, lr, #31
 800bdfe:	ebae 0e04 	sub.w	lr, lr, r4
  __ASM volatile ("dsb 0xF":::"memory");
 800be02:	f3bf 8f4f 	dsb	sy
    while (op_size > 0) {
 800be06:	f1be 0f00 	cmp.w	lr, #0
 800be0a:	ddda      	ble.n	800bdc2 <USBH_LL_SubmitURB+0x4e>
 800be0c:	44a6      	add	lr, r4
 800be0e:	f104 0c20 	add.w	ip, r4, #32
      SCB->DCIMVAC = op_addr;
 800be12:	f8df 901c 	ldr.w	r9, [pc, #28]	; 800be30 <USBH_LL_SubmitURB+0xbc>
    while (op_size > 0) {
 800be16:	45e6      	cmp	lr, ip
      SCB->DCIMVAC = op_addr;
 800be18:	f8c9 425c 	str.w	r4, [r9, #604]	; 0x25c
      op_addr += (uint32_t)linesize;
 800be1c:	4664      	mov	r4, ip
    while (op_size > 0) {
 800be1e:	f10c 0c20 	add.w	ip, ip, #32
 800be22:	d1f8      	bne.n	800be16 <USBH_LL_SubmitURB+0xa2>
 800be24:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800be28:	f3bf 8f6f 	isb	sy
 800be2c:	e7cd      	b.n	800bdca <USBH_LL_SubmitURB+0x56>
 800be2e:	bf00      	nop
 800be30:	e000ed00 	.word	0xe000ed00

0800be34 <USBH_LL_GetURBState>:

USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 800be34:	b538      	push	{r3, r4, r5, lr}
  HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)phost->pData;
 800be36:	f8d0 54f0 	ldr.w	r5, [r0, #1264]	; 0x4f0
{
 800be3a:	460c      	mov	r4, r1
  HCD_URBStateTypeDef urb_state = HAL_HCD_HC_GetURBState(hhcd, pipe);
 800be3c:	4628      	mov	r0, r5
 800be3e:	f001 fddf 	bl	800da00 <HAL_HCD_HC_GetURBState>

  if ((urb_state == URB_DONE) && (hhcd->hc[pipe].ep_is_in != 0U))
 800be42:	2801      	cmp	r0, #1
 800be44:	d003      	beq.n	800be4e <USBH_LL_GetURBState+0x1a>
 800be46:	2806      	cmp	r0, #6
 800be48:	bf28      	it	cs
 800be4a:	2004      	movcs	r0, #4
  case URB_STALL:
    return USBH_URB_STALL;
  default:
    return USBH_URB_ERROR;
  }
}
 800be4c:	bd38      	pop	{r3, r4, r5, pc}
  if ((urb_state == URB_DONE) && (hhcd->hc[pipe].ep_is_in != 0U))
 800be4e:	ebc4 1104 	rsb	r1, r4, r4, lsl #4
 800be52:	eb05 0581 	add.w	r5, r5, r1, lsl #2
 800be56:	7deb      	ldrb	r3, [r5, #23]
 800be58:	2b00      	cmp	r3, #0
 800be5a:	d0f7      	beq.n	800be4c <USBH_LL_GetURBState+0x18>
    usbh_dcache_invalidate((uint8_t *)hhcd->hc[pipe].xfer_buff, hhcd->hc[pipe].xfer_len);
 800be5c:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 800be5e:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  if ((address == NULL) || (length == 0U))
 800be60:	2c00      	cmp	r4, #0
 800be62:	d0f3      	beq.n	800be4c <USBH_LL_GetURBState+0x18>
 800be64:	2a00      	cmp	r2, #0
 800be66:	d0f1      	beq.n	800be4c <USBH_LL_GetURBState+0x18>
  uint32_t aligned_length = (uint32_t)((((uintptr_t)address + length + cache_line_size - 1U) &
 800be68:	321f      	adds	r2, #31
  uintptr_t aligned_addr = ((uintptr_t)address) & ~(cache_line_size - 1U);
 800be6a:	f024 011f 	bic.w	r1, r4, #31
  uint32_t aligned_length = (uint32_t)((((uintptr_t)address + length + cache_line_size - 1U) &
 800be6e:	4422      	add	r2, r4
 800be70:	f022 021f 	bic.w	r2, r2, #31
 800be74:	1a52      	subs	r2, r2, r1
  __ASM volatile ("dsb 0xF":::"memory");
 800be76:	f3bf 8f4f 	dsb	sy
 800be7a:	2a00      	cmp	r2, #0
 800be7c:	dd0a      	ble.n	800be94 <USBH_LL_GetURBState+0x60>
 800be7e:	f101 0320 	add.w	r3, r1, #32
 800be82:	440a      	add	r2, r1
      SCB->DCIMVAC = op_addr;
 800be84:	4c06      	ldr	r4, [pc, #24]	; (800bea0 <USBH_LL_GetURBState+0x6c>)
    while (op_size > 0) {
 800be86:	4293      	cmp	r3, r2
      SCB->DCIMVAC = op_addr;
 800be88:	f8c4 125c 	str.w	r1, [r4, #604]	; 0x25c
      op_addr += (uint32_t)linesize;
 800be8c:	4619      	mov	r1, r3
    while (op_size > 0) {
 800be8e:	f103 0320 	add.w	r3, r3, #32
 800be92:	d1f8      	bne.n	800be86 <USBH_LL_GetURBState+0x52>
 800be94:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800be98:	f3bf 8f6f 	isb	sy
}
 800be9c:	bd38      	pop	{r3, r4, r5, pc}
 800be9e:	bf00      	nop
 800bea0:	e000ed00 	.word	0xe000ed00

0800bea4 <USBH_LL_SetToggle>:

USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
  HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)phost->pData;
  if ((phost->Pipes[pipe] & 0x80U) == 0U)
 800bea4:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)phost->pData;
 800bea8:	f8d0 34f0 	ldr.w	r3, [r0, #1264]	; 0x4f0
  {
    hhcd->hc[pipe].toggle_out = toggle;
 800beac:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
  if ((phost->Pipes[pipe] & 0x80U) == 0U)
 800beb0:	f8dc 04a4 	ldr.w	r0, [ip, #1188]	; 0x4a4
    hhcd->hc[pipe].toggle_out = toggle;
 800beb4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  if ((phost->Pipes[pipe] & 0x80U) == 0U)
 800beb8:	0601      	lsls	r1, r0, #24
  else
  {
    hhcd->hc[pipe].toggle_in = toggle;
  }
  return USBH_OK;
}
 800beba:	f04f 0000 	mov.w	r0, #0
    hhcd->hc[pipe].toggle_out = toggle;
 800bebe:	bf54      	ite	pl
 800bec0:	f883 203d 	strbpl.w	r2, [r3, #61]	; 0x3d
    hhcd->hc[pipe].toggle_in = toggle;
 800bec4:	f883 203c 	strbmi.w	r2, [r3, #60]	; 0x3c
}
 800bec8:	4770      	bx	lr
 800beca:	bf00      	nop

0800becc <USBH_Delay>:
{
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
}

void USBH_Delay(uint32_t Delay)
{
 800becc:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(Delay);
 800bece:	f242 7210 	movw	r2, #10000	; 0x2710
 800bed2:	f240 33e7 	movw	r3, #999	; 0x3e7
 800bed6:	2100      	movs	r1, #0
 800bed8:	fbe0 3102 	umlal	r3, r1, r0, r2
 800bedc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800bee0:	4618      	mov	r0, r3
 800bee2:	2300      	movs	r3, #0
 800bee4:	f7f4 fab8 	bl	8000458 <__aeabi_uldivmod>
}
 800bee8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdSleepMilliseconds(Delay);
 800beec:	f7fa bb8a 	b.w	8006604 <chThdSleep>

0800bef0 <DeInitStateMachine.isra.0>:
  * @brief  DeInitStateMachine
  *         De-Initialize the Host state machine.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
 800bef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t i;

  /* Clear Pipes flags*/
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
  {
    phost->Pipes[i] = 0U;
 800bef2:	2740      	movs	r7, #64	; 0x40
 800bef4:	2100      	movs	r1, #0
static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
 800bef6:	4604      	mov	r4, r0
    phost->Pipes[i] = 0U;
 800bef8:	f200 40a4 	addw	r0, r0, #1188	; 0x4a4
 800befc:	463a      	mov	r2, r7
  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
  {
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
 800befe:	460d      	mov	r5, r1
  phost->device.speed = (uint8_t)USBH_SPEED_FULL;
  phost->device.RstCnt = 0U;
  phost->device.EnumCnt = 0U;

  /* Reset the device struct */
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 800bf00:	f44f 7600 	mov.w	r6, #512	; 0x200
    phost->Pipes[i] = 0U;
 800bf04:	f002 fc6e 	bl	800e7e4 <memset>
  phost->RequestState = CMD_SEND;
 800bf08:	2301      	movs	r3, #1
  phost->device.address = USBH_ADDRESS_DEFAULT;
 800bf0a:	f44f 7280 	mov.w	r2, #256	; 0x100
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 800bf0e:	4629      	mov	r1, r5
  phost->gState = HOST_IDLE;
 800bf10:	7025      	strb	r5, [r4, #0]
  phost->RequestState = CMD_SEND;
 800bf12:	70a3      	strb	r3, [r4, #2]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 800bf14:	f104 001c 	add.w	r0, r4, #28
  phost->Control.state = CTRL_SETUP;
 800bf18:	8323      	strh	r3, [r4, #24]
  phost->device.address = USBH_ADDRESS_DEFAULT;
 800bf1a:	f8c4 241c 	str.w	r2, [r4, #1052]	; 0x41c
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 800bf1e:	4632      	mov	r2, r6
  phost->EnumState = ENUM_IDLE;
 800bf20:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
 800bf22:	f8c4 54e4 	str.w	r5, [r4, #1252]	; 0x4e4
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800bf26:	71a7      	strb	r7, [r4, #6]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 800bf28:	f002 fc5c 	bl	800e7e4 <memset>
  USBH_memset(&phost->device.Data, 0, sizeof(phost->device.Data));
 800bf2c:	4632      	mov	r2, r6
 800bf2e:	4629      	mov	r1, r5
 800bf30:	f504 7007 	add.w	r0, r4, #540	; 0x21c
 800bf34:	f002 fc56 	bl	800e7e4 <memset>
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 800bf38:	4629      	mov	r1, r5
 800bf3a:	f504 6087 	add.w	r0, r4, #1080	; 0x438
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 800bf3e:	f8c4 5426 	str.w	r5, [r4, #1062]	; 0x426
 800bf42:	f8c4 542a 	str.w	r5, [r4, #1066]	; 0x42a
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 800bf46:	225e      	movs	r2, #94	; 0x5e
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 800bf48:	f8c4 542e 	str.w	r5, [r4, #1070]	; 0x42e
 800bf4c:	f8c4 5432 	str.w	r5, [r4, #1074]	; 0x432
 800bf50:	f8a4 5436 	strh.w	r5, [r4, #1078]	; 0x436

  return USBH_OK;
}
 800bf54:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 800bf58:	f002 bc44 	b.w	800e7e4 <memset>

0800bf5c <USBH_Init>:
{
 800bf5c:	b570      	push	{r4, r5, r6, lr}
  if (phost == NULL)
 800bf5e:	b1d0      	cbz	r0, 800bf96 <USBH_Init+0x3a>
  phost->pActiveClass = NULL;
 800bf60:	2500      	movs	r5, #0
 800bf62:	4604      	mov	r4, r0
 800bf64:	460e      	mov	r6, r1
  phost->id = id;
 800bf66:	f880 24ec 	strb.w	r2, [r0, #1260]	; 0x4ec
  phost->pActiveClass = NULL;
 800bf6a:	f8c0 549c 	str.w	r5, [r0, #1180]	; 0x49c
  phost->ClassNumber = 0U;
 800bf6e:	f8c0 54a0 	str.w	r5, [r0, #1184]	; 0x4a0
  (void)DeInitStateMachine(phost);
 800bf72:	f7ff ffbd 	bl	800bef0 <DeInitStateMachine.isra.0>
  phost->device.PortEnabled = 0U;
 800bf76:	f884 5423 	strb.w	r5, [r4, #1059]	; 0x423
  phost->device.is_connected = 0U;
 800bf7a:	f884 5420 	strb.w	r5, [r4, #1056]	; 0x420
  phost->device.is_disconnected = 0U;
 800bf7e:	f884 5421 	strb.w	r5, [r4, #1057]	; 0x421
  phost->device.is_ReEnumerated = 0U;
 800bf82:	f884 5422 	strb.w	r5, [r4, #1058]	; 0x422
  if (pUsrFunc != NULL)
 800bf86:	b10e      	cbz	r6, 800bf8c <USBH_Init+0x30>
    phost->pUser = pUsrFunc;
 800bf88:	f8c4 64f4 	str.w	r6, [r4, #1268]	; 0x4f4
  (void)USBH_LL_Init(phost);
 800bf8c:	4620      	mov	r0, r4
 800bf8e:	f7ff fe59 	bl	800bc44 <USBH_LL_Init>
  return USBH_OK;
 800bf92:	2000      	movs	r0, #0
}
 800bf94:	bd70      	pop	{r4, r5, r6, pc}
    USBH_ErrLog("Invalid Host handle");
 800bf96:	4805      	ldr	r0, [pc, #20]	; (800bfac <USBH_Init+0x50>)
 800bf98:	f002 fbd8 	bl	800e74c <printf>
 800bf9c:	4804      	ldr	r0, [pc, #16]	; (800bfb0 <USBH_Init+0x54>)
 800bf9e:	f002 fbd5 	bl	800e74c <printf>
 800bfa2:	200a      	movs	r0, #10
 800bfa4:	f002 fbe6 	bl	800e774 <putchar>
    return USBH_FAIL;
 800bfa8:	2002      	movs	r0, #2
}
 800bfaa:	bd70      	pop	{r4, r5, r6, pc}
 800bfac:	0801540c 	.word	0x0801540c
 800bfb0:	0801544c 	.word	0x0801544c

0800bfb4 <USBH_DeInit>:
{
 800bfb4:	b510      	push	{r4, lr}
 800bfb6:	4604      	mov	r4, r0
  (void)DeInitStateMachine(phost);
 800bfb8:	f7ff ff9a 	bl	800bef0 <DeInitStateMachine.isra.0>
  phost->device.PortEnabled = 0U;
 800bfbc:	2300      	movs	r3, #0
  if (phost->pData != NULL)
 800bfbe:	f8d4 24f0 	ldr.w	r2, [r4, #1264]	; 0x4f0
  phost->device.PortEnabled = 0U;
 800bfc2:	f884 3423 	strb.w	r3, [r4, #1059]	; 0x423
  phost->device.EnumCnt = 0U;
 800bfc6:	f8a4 341e 	strh.w	r3, [r4, #1054]	; 0x41e
  phost->device.is_connected = 0U;
 800bfca:	f884 3420 	strb.w	r3, [r4, #1056]	; 0x420
  phost->device.is_disconnected = 0U;
 800bfce:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
  phost->device.is_ReEnumerated = 0U;
 800bfd2:	f884 3422 	strb.w	r3, [r4, #1058]	; 0x422
  if (phost->pData != NULL)
 800bfd6:	b112      	cbz	r2, 800bfde <USBH_DeInit+0x2a>
    (void)USBH_LL_Stop(phost);
 800bfd8:	4620      	mov	r0, r4
 800bfda:	f7ff fe73 	bl	800bcc4 <USBH_LL_Stop>
}
 800bfde:	2000      	movs	r0, #0
 800bfe0:	bd10      	pop	{r4, pc}
 800bfe2:	bf00      	nop

0800bfe4 <USBH_RegisterClass>:
  * @param  phost : Host Handle
  * @param  pclass: Class handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
 800bfe4:	b508      	push	{r3, lr}
  USBH_StatusTypeDef status = USBH_OK;

  if (pclass != NULL)
 800bfe6:	b1a1      	cbz	r1, 800c012 <USBH_RegisterClass+0x2e>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
 800bfe8:	4603      	mov	r3, r0
 800bfea:	f8d0 04a0 	ldr.w	r0, [r0, #1184]	; 0x4a0
 800bfee:	b928      	cbnz	r0, 800bffc <USBH_RegisterClass+0x18>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
 800bff0:	2201      	movs	r2, #1
 800bff2:	f8c3 1498 	str.w	r1, [r3, #1176]	; 0x498
 800bff6:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
  }

  return status;
}
 800bffa:	bd08      	pop	{r3, pc}
      USBH_ErrLog("Max Class Number reached");
 800bffc:	480a      	ldr	r0, [pc, #40]	; (800c028 <USBH_RegisterClass+0x44>)
 800bffe:	f002 fba5 	bl	800e74c <printf>
 800c002:	480a      	ldr	r0, [pc, #40]	; (800c02c <USBH_RegisterClass+0x48>)
 800c004:	f002 fba2 	bl	800e74c <printf>
 800c008:	200a      	movs	r0, #10
 800c00a:	f002 fbb3 	bl	800e774 <putchar>
      status = USBH_FAIL;
 800c00e:	2002      	movs	r0, #2
}
 800c010:	bd08      	pop	{r3, pc}
    USBH_ErrLog("Invalid Class handle");
 800c012:	4805      	ldr	r0, [pc, #20]	; (800c028 <USBH_RegisterClass+0x44>)
 800c014:	f002 fb9a 	bl	800e74c <printf>
 800c018:	4805      	ldr	r0, [pc, #20]	; (800c030 <USBH_RegisterClass+0x4c>)
 800c01a:	f002 fb97 	bl	800e74c <printf>
 800c01e:	200a      	movs	r0, #10
 800c020:	f002 fba8 	bl	800e774 <putchar>
    status = USBH_FAIL;
 800c024:	2002      	movs	r0, #2
}
 800c026:	bd08      	pop	{r3, pc}
 800c028:	0801540c 	.word	0x0801540c
 800c02c:	08015460 	.word	0x08015460
 800c030:	0801547c 	.word	0x0801547c

0800c034 <USBH_SelectInterface>:
  * @param  phost: Host Handle
  * @param  interface: Interface number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
 800c034:	b538      	push	{r3, r4, r5, lr}
  USBH_StatusTypeDef status = USBH_OK;

  if (interface < phost->device.CfgDesc.bNumInterfaces)
 800c036:	f890 343c 	ldrb.w	r3, [r0, #1084]	; 0x43c
 800c03a:	428b      	cmp	r3, r1
 800c03c:	d926      	bls.n	800c08c <USBH_SelectInterface+0x58>
  {
    phost->device.current_interface = interface;
 800c03e:	4604      	mov	r4, r0
    USBH_UsrLog("Switching to Interface (#%d)", interface);
 800c040:	4818      	ldr	r0, [pc, #96]	; (800c0a4 <USBH_SelectInterface+0x70>)
 800c042:	460d      	mov	r5, r1
    phost->device.current_interface = interface;
 800c044:	f884 1424 	strb.w	r1, [r4, #1060]	; 0x424
    USBH_UsrLog("Switching to Interface (#%d)", interface);
 800c048:	f002 fb80 	bl	800e74c <printf>
 800c04c:	200a      	movs	r0, #10
 800c04e:	f002 fb91 	bl	800e774 <putchar>
    USBH_UsrLog("Class    : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass);
 800c052:	232a      	movs	r3, #42	; 0x2a
 800c054:	4814      	ldr	r0, [pc, #80]	; (800c0a8 <USBH_SelectInterface+0x74>)
 800c056:	fb03 4405 	mla	r4, r3, r5, r4
 800c05a:	f894 1447 	ldrb.w	r1, [r4, #1095]	; 0x447
 800c05e:	f002 fb75 	bl	800e74c <printf>
 800c062:	200a      	movs	r0, #10
 800c064:	f002 fb86 	bl	800e774 <putchar>
    USBH_UsrLog("SubClass : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass);
 800c068:	f894 1448 	ldrb.w	r1, [r4, #1096]	; 0x448
 800c06c:	480f      	ldr	r0, [pc, #60]	; (800c0ac <USBH_SelectInterface+0x78>)
 800c06e:	f002 fb6d 	bl	800e74c <printf>
 800c072:	200a      	movs	r0, #10
 800c074:	f002 fb7e 	bl	800e774 <putchar>
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
 800c078:	f894 1449 	ldrb.w	r1, [r4, #1097]	; 0x449
 800c07c:	480c      	ldr	r0, [pc, #48]	; (800c0b0 <USBH_SelectInterface+0x7c>)
 800c07e:	f002 fb65 	bl	800e74c <printf>
 800c082:	200a      	movs	r0, #10
 800c084:	f002 fb76 	bl	800e774 <putchar>
  USBH_StatusTypeDef status = USBH_OK;
 800c088:	2000      	movs	r0, #0
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
  }

  return status;
}
 800c08a:	bd38      	pop	{r3, r4, r5, pc}
    USBH_ErrLog("Cannot Select This Interface.");
 800c08c:	4809      	ldr	r0, [pc, #36]	; (800c0b4 <USBH_SelectInterface+0x80>)
 800c08e:	f002 fb5d 	bl	800e74c <printf>
 800c092:	4809      	ldr	r0, [pc, #36]	; (800c0b8 <USBH_SelectInterface+0x84>)
 800c094:	f002 fb5a 	bl	800e74c <printf>
 800c098:	200a      	movs	r0, #10
 800c09a:	f002 fb6b 	bl	800e774 <putchar>
    status = USBH_FAIL;
 800c09e:	2002      	movs	r0, #2
}
 800c0a0:	bd38      	pop	{r3, r4, r5, pc}
 800c0a2:	bf00      	nop
 800c0a4:	08015494 	.word	0x08015494
 800c0a8:	080154b4 	.word	0x080154b4
 800c0ac:	080154c4 	.word	0x080154c4
 800c0b0:	080154d4 	.word	0x080154d4
 800c0b4:	0801540c 	.word	0x0801540c
 800c0b8:	080154e4 	.word	0x080154e4

0800c0bc <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
 800c0bc:	b530      	push	{r4, r5, lr}
  pcfg = &phost->device.CfgDesc;

  while (if_ix < USBH_MAX_NUM_INTERFACES)
  {
    pif = &pcfg->Itf_Desc[if_ix];
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800c0be:	f1a1 05ff 	sub.w	r5, r1, #255	; 0xff
 800c0c2:	2400      	movs	r4, #0
 800c0c4:	fab5 f585 	clz	r5, r5
 800c0c8:	096d      	lsrs	r5, r5, #5
 800c0ca:	f890 e447 	ldrb.w	lr, [r0, #1095]	; 0x447
 800c0ce:	fa5f fc84 	uxtb.w	ip, r4
 800c0d2:	458e      	cmp	lr, r1
 800c0d4:	d006      	beq.n	800c0e4 <USBH_FindInterface+0x28>
 800c0d6:	b92d      	cbnz	r5, 800c0e4 <USBH_FindInterface+0x28>
  while (if_ix < USBH_MAX_NUM_INTERFACES)
 800c0d8:	302a      	adds	r0, #42	; 0x2a
 800c0da:	b194      	cbz	r4, 800c102 <USBH_FindInterface+0x46>
    {
      return  if_ix;
    }
    if_ix++;
  }
  return 0xFFU;
 800c0dc:	f04f 0cff 	mov.w	ip, #255	; 0xff
}
 800c0e0:	4660      	mov	r0, ip
 800c0e2:	bd30      	pop	{r4, r5, pc}
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800c0e4:	f890 e448 	ldrb.w	lr, [r0, #1096]	; 0x448
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800c0e8:	4596      	cmp	lr, r2
 800c0ea:	d001      	beq.n	800c0f0 <USBH_FindInterface+0x34>
 800c0ec:	2aff      	cmp	r2, #255	; 0xff
 800c0ee:	d1f3      	bne.n	800c0d8 <USBH_FindInterface+0x1c>
 800c0f0:	f890 e449 	ldrb.w	lr, [r0, #1097]	; 0x449
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800c0f4:	459e      	cmp	lr, r3
 800c0f6:	d0f3      	beq.n	800c0e0 <USBH_FindInterface+0x24>
 800c0f8:	2bff      	cmp	r3, #255	; 0xff
 800c0fa:	d0f1      	beq.n	800c0e0 <USBH_FindInterface+0x24>
  while (if_ix < USBH_MAX_NUM_INTERFACES)
 800c0fc:	302a      	adds	r0, #42	; 0x2a
 800c0fe:	2c00      	cmp	r4, #0
 800c100:	d1ec      	bne.n	800c0dc <USBH_FindInterface+0x20>
 800c102:	2401      	movs	r4, #1
 800c104:	e7e1      	b.n	800c0ca <USBH_FindInterface+0xe>
 800c106:	bf00      	nop

0800c108 <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Start(USBH_HandleTypeDef *phost)
{
 800c108:	b510      	push	{r4, lr}
 800c10a:	4604      	mov	r4, r0
  /* Start the low level driver  */
  (void)USBH_LL_Start(phost);
 800c10c:	f7ff fdce 	bl	800bcac <USBH_LL_Start>

  /* Activate VBUS on the port */
  (void)USBH_LL_DriverVBUS(phost, TRUE);
 800c110:	2101      	movs	r1, #1
 800c112:	4620      	mov	r0, r4
 800c114:	f7ff fe00 	bl	800bd18 <USBH_LL_DriverVBUS>

  return USBH_OK;
}
 800c118:	2000      	movs	r0, #0
 800c11a:	bd10      	pop	{r4, pc}

0800c11c <USBH_Stop>:
  *         Stop the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Stop(USBH_HandleTypeDef *phost)
{
 800c11c:	b510      	push	{r4, lr}
 800c11e:	4604      	mov	r4, r0
  /* DeActivate VBUS on the port */
  (void)USBH_LL_DriverVBUS(phost, FALSE);
 800c120:	2100      	movs	r1, #0
 800c122:	f7ff fdf9 	bl	800bd18 <USBH_LL_DriverVBUS>

  /* Stop and cleanup the low level driver  */
  (void)USBH_LL_Stop(phost);
 800c126:	4620      	mov	r0, r4
 800c128:	f7ff fdcc 	bl	800bcc4 <USBH_LL_Stop>

  /* Free Control Pipes */
  (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c12c:	7921      	ldrb	r1, [r4, #4]
 800c12e:	4620      	mov	r0, r4
 800c130:	f000 ff9c 	bl	800d06c <USBH_FreePipe>
  (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c134:	7961      	ldrb	r1, [r4, #5]
 800c136:	4620      	mov	r0, r4
 800c138:	f000 ff98 	bl	800d06c <USBH_FreePipe>

  return USBH_OK;
}
 800c13c:	2000      	movs	r0, #0
 800c13e:	bd10      	pop	{r4, pc}

0800c140 <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Process(USBH_HandleTypeDef *phost)
{
 800c140:	b570      	push	{r4, r5, r6, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 800c142:	2302      	movs	r3, #2
{
 800c144:	b086      	sub	sp, #24
 800c146:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 800c148:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if ((phost->device.is_disconnected == 1U)
 800c14c:	f890 3421 	ldrb.w	r3, [r0, #1057]	; 0x421
 800c150:	2b01      	cmp	r3, #1
 800c152:	d014      	beq.n	800c17e <USBH_Process+0x3e>
      || (phost->device.is_ReEnumerated == 1U))
 800c154:	f890 3422 	ldrb.w	r3, [r0, #1058]	; 0x422
 800c158:	2b01      	cmp	r3, #1
 800c15a:	d010      	beq.n	800c17e <USBH_Process+0x3e>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
  }

  switch (phost->gState)
 800c15c:	7823      	ldrb	r3, [r4, #0]
 800c15e:	2b0b      	cmp	r3, #11
 800c160:	d846      	bhi.n	800c1f0 <USBH_Process+0xb0>
 800c162:	e8df f013 	tbh	[pc, r3, lsl #1]
 800c166:	0050      	.short	0x0050
 800c168:	000f0068 	.word	0x000f0068
 800c16c:	0045007f 	.word	0x0045007f
 800c170:	00b100a3 	.word	0x00b100a3
 800c174:	00da00cf 	.word	0x00da00cf
 800c178:	00f300eb 	.word	0x00f300eb
 800c17c:	0048      	.short	0x0048
    phost->gState = HOST_DEV_DISCONNECTED;
 800c17e:	2303      	movs	r3, #3
 800c180:	7023      	strb	r3, [r4, #0]
 800c182:	e7eb      	b.n	800c15c <USBH_Process+0x1c>
#endif /* (USBH_USE_OS == 1U) */
      break;

    case HOST_DEV_ATTACHED :

      if (phost->pUser != NULL)
 800c184:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
 800c188:	b113      	cbz	r3, 800c190 <USBH_Process+0x50>
      {
        phost->pUser(phost, HOST_USER_CONNECTION);
 800c18a:	2104      	movs	r1, #4
 800c18c:	4620      	mov	r0, r4
 800c18e:	4798      	blx	r3
      }

      /* Wait for 100 ms after Reset */
      USBH_Delay(100U);
 800c190:	2064      	movs	r0, #100	; 0x64

      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c192:	2500      	movs	r5, #0
      USBH_Delay(100U);
 800c194:	f7ff fe9a 	bl	800becc <USBH_Delay>
      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 800c198:	4620      	mov	r0, r4
 800c19a:	f7ff fd9f 	bl	800bcdc <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
 800c19e:	2305      	movs	r3, #5
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800c1a0:	4629      	mov	r1, r5
      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 800c1a2:	f884 041d 	strb.w	r0, [r4, #1053]	; 0x41d
      phost->gState = HOST_ENUMERATION;
 800c1a6:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800c1a8:	4620      	mov	r0, r4
 800c1aa:	f000 ff41 	bl	800d030 <USBH_AllocPipe>
 800c1ae:	4603      	mov	r3, r0
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800c1b0:	2180      	movs	r1, #128	; 0x80
 800c1b2:	4620      	mov	r0, r4
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800c1b4:	7163      	strb	r3, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800c1b6:	f000 ff3b 	bl	800d030 <USBH_AllocPipe>
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c1ba:	79a2      	ldrb	r2, [r4, #6]
 800c1bc:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800c1c0:	4601      	mov	r1, r0
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c1c2:	e9cd 5201 	strd	r5, r2, [sp, #4]
 800c1c6:	9300      	str	r3, [sp, #0]
 800c1c8:	2280      	movs	r2, #128	; 0x80
 800c1ca:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800c1ce:	7120      	strb	r0, [r4, #4]
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c1d0:	4620      	mov	r0, r4
 800c1d2:	f000 ff17 	bl	800d004 <USBH_OpenPipe>
                          phost->device.address, phost->device.speed,
                          USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 800c1d6:	79a2      	ldrb	r2, [r4, #6]
 800c1d8:	f894 141d 	ldrb.w	r1, [r4, #1053]	; 0x41d
 800c1dc:	4620      	mov	r0, r4
 800c1de:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 800c1e2:	9100      	str	r1, [sp, #0]
 800c1e4:	e9cd 5201 	strd	r5, r2, [sp, #4]
 800c1e8:	462a      	mov	r2, r5
 800c1ea:	7961      	ldrb	r1, [r4, #5]
 800c1ec:	f000 ff0a 	bl	800d004 <USBH_OpenPipe>
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
 800c1f0:	2000      	movs	r0, #0
 800c1f2:	b006      	add	sp, #24
 800c1f4:	bd70      	pop	{r4, r5, r6, pc}
      if (phost->pActiveClass != NULL)
 800c1f6:	f8d4 349c 	ldr.w	r3, [r4, #1180]	; 0x49c
 800c1fa:	2b00      	cmp	r3, #0
 800c1fc:	d0f8      	beq.n	800c1f0 <USBH_Process+0xb0>
        phost->pActiveClass->BgndProcess(phost);
 800c1fe:	695b      	ldr	r3, [r3, #20]
 800c200:	4620      	mov	r0, r4
 800c202:	4798      	blx	r3
 800c204:	e7f4      	b.n	800c1f0 <USBH_Process+0xb0>
      if ((phost->device.is_connected) != 0U)
 800c206:	f894 3420 	ldrb.w	r3, [r4, #1056]	; 0x420
 800c20a:	2b00      	cmp	r3, #0
 800c20c:	d0f0      	beq.n	800c1f0 <USBH_Process+0xb0>
        USBH_UsrLog("USB Device Connected");
 800c20e:	48bc      	ldr	r0, [pc, #752]	; (800c500 <USBH_Process+0x3c0>)
 800c210:	f002 fa9c 	bl	800e74c <printf>
 800c214:	200a      	movs	r0, #10
 800c216:	f002 faad 	bl	800e774 <putchar>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 800c21a:	2301      	movs	r3, #1
        USBH_Delay(200U);
 800c21c:	20c8      	movs	r0, #200	; 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 800c21e:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
 800c220:	f7ff fe54 	bl	800becc <USBH_Delay>
        (void)USBH_LL_ResetPort(phost);
 800c224:	4620      	mov	r0, r4
 800c226:	f7ff fd63 	bl	800bcf0 <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
 800c22a:	2300      	movs	r3, #0
 800c22c:	f884 341c 	strb.w	r3, [r4, #1052]	; 0x41c
        phost->Timeout = 0U;
 800c230:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
 800c234:	e7dc      	b.n	800c1f0 <USBH_Process+0xb0>
      if (phost->device.PortEnabled == 1U)
 800c236:	f894 3423 	ldrb.w	r3, [r4, #1059]	; 0x423
 800c23a:	2b01      	cmp	r3, #1
 800c23c:	f000 81ef 	beq.w	800c61e <USBH_Process+0x4de>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 800c240:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
 800c244:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800c248:	f240 80a8 	bls.w	800c39c <USBH_Process+0x25c>
          phost->device.RstCnt++;
 800c24c:	f894 341f 	ldrb.w	r3, [r4, #1055]	; 0x41f
 800c250:	3301      	adds	r3, #1
 800c252:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
 800c254:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
 800c256:	f884 341f 	strb.w	r3, [r4, #1055]	; 0x41f
          if (phost->device.RstCnt > 3U)
 800c25a:	f200 81ec 	bhi.w	800c636 <USBH_Process+0x4f6>
            phost->gState = HOST_IDLE;
 800c25e:	2300      	movs	r3, #0
 800c260:	7023      	strb	r3, [r4, #0]
 800c262:	e7c5      	b.n	800c1f0 <USBH_Process+0xb0>
      phost->device.is_disconnected = 0U;
 800c264:	2500      	movs	r5, #0
      if (phost->pActiveClass != NULL)
 800c266:	f8d4 349c 	ldr.w	r3, [r4, #1180]	; 0x49c
      phost->device.is_disconnected = 0U;
 800c26a:	f884 5421 	strb.w	r5, [r4, #1057]	; 0x421
      if (phost->pActiveClass != NULL)
 800c26e:	b123      	cbz	r3, 800c27a <USBH_Process+0x13a>
        phost->pActiveClass->DeInit(phost);
 800c270:	68db      	ldr	r3, [r3, #12]
 800c272:	4620      	mov	r0, r4
 800c274:	4798      	blx	r3
        phost->pActiveClass = NULL;
 800c276:	f8c4 549c 	str.w	r5, [r4, #1180]	; 0x49c
      (void)DeInitStateMachine(phost);
 800c27a:	4620      	mov	r0, r4
 800c27c:	f7ff fe38 	bl	800bef0 <DeInitStateMachine.isra.0>
      if (phost->pUser != NULL)
 800c280:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
 800c284:	b113      	cbz	r3, 800c28c <USBH_Process+0x14c>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 800c286:	2105      	movs	r1, #5
 800c288:	4620      	mov	r0, r4
 800c28a:	4798      	blx	r3
      USBH_UsrLog("USB Device disconnected");
 800c28c:	489d      	ldr	r0, [pc, #628]	; (800c504 <USBH_Process+0x3c4>)
 800c28e:	f002 fa5d 	bl	800e74c <printf>
 800c292:	200a      	movs	r0, #10
 800c294:	f002 fa6e 	bl	800e774 <putchar>
      if (phost->device.is_ReEnumerated == 1U)
 800c298:	f894 3422 	ldrb.w	r3, [r4, #1058]	; 0x422
 800c29c:	2b01      	cmp	r3, #1
 800c29e:	b2dd      	uxtb	r5, r3
 800c2a0:	f000 8189 	beq.w	800c5b6 <USBH_Process+0x476>
        (void)USBH_LL_Start(phost);
 800c2a4:	4620      	mov	r0, r4
 800c2a6:	f7ff fd01 	bl	800bcac <USBH_LL_Start>
  return USBH_OK;
 800c2aa:	e7a1      	b.n	800c1f0 <USBH_Process+0xb0>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
 800c2ac:	7865      	ldrb	r5, [r4, #1]
 800c2ae:	2d07      	cmp	r5, #7
 800c2b0:	f200 809a 	bhi.w	800c3e8 <USBH_Process+0x2a8>
 800c2b4:	e8df f015 	tbh	[pc, r5, lsl #1]
 800c2b8:	015a00e4 	.word	0x015a00e4
 800c2bc:	0118013a 	.word	0x0118013a
 800c2c0:	00cb010c 	.word	0x00cb010c
 800c2c4:	008500b2 	.word	0x008500b2
      if (phost->pActiveClass != NULL)
 800c2c8:	f8d4 349c 	ldr.w	r3, [r4, #1180]	; 0x49c
 800c2cc:	2b00      	cmp	r3, #0
 800c2ce:	f000 81bb 	beq.w	800c648 <USBH_Process+0x508>
        status = phost->pActiveClass->Requests(phost);
 800c2d2:	691b      	ldr	r3, [r3, #16]
 800c2d4:	4620      	mov	r0, r4
 800c2d6:	4798      	blx	r3
 800c2d8:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 800c2dc:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c2e0:	2b00      	cmp	r3, #0
 800c2e2:	d058      	beq.n	800c396 <USBH_Process+0x256>
        else if (status == USBH_FAIL)
 800c2e4:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c2e8:	2b02      	cmp	r3, #2
 800c2ea:	d181      	bne.n	800c1f0 <USBH_Process+0xb0>
          phost->gState = HOST_ABORT_STATE;
 800c2ec:	230d      	movs	r3, #13
          USBH_ErrLog("Device not responding Please Unplug.");
 800c2ee:	4886      	ldr	r0, [pc, #536]	; (800c508 <USBH_Process+0x3c8>)
          phost->gState = HOST_ABORT_STATE;
 800c2f0:	7023      	strb	r3, [r4, #0]
          USBH_ErrLog("Device not responding Please Unplug.");
 800c2f2:	f002 fa2b 	bl	800e74c <printf>
 800c2f6:	4885      	ldr	r0, [pc, #532]	; (800c50c <USBH_Process+0x3cc>)
 800c2f8:	f002 fa28 	bl	800e74c <printf>
 800c2fc:	200a      	movs	r0, #10
 800c2fe:	f002 fa39 	bl	800e774 <putchar>
 800c302:	e775      	b.n	800c1f0 <USBH_Process+0xb0>
      if (phost->pUser != NULL)
 800c304:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
 800c308:	2b00      	cmp	r3, #0
 800c30a:	f43f af71 	beq.w	800c1f0 <USBH_Process+0xb0>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 800c30e:	2101      	movs	r1, #1
 800c310:	4620      	mov	r0, r4
 800c312:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 800c314:	2308      	movs	r3, #8
 800c316:	7023      	strb	r3, [r4, #0]
 800c318:	e76a      	b.n	800c1f0 <USBH_Process+0xb0>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 800c31a:	f894 143d 	ldrb.w	r1, [r4, #1085]	; 0x43d
 800c31e:	4620      	mov	r0, r4
 800c320:	f000 fd56 	bl	800cdd0 <USBH_SetCfg>
 800c324:	2800      	cmp	r0, #0
 800c326:	f47f af63 	bne.w	800c1f0 <USBH_Process+0xb0>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 800c32a:	2309      	movs	r3, #9
        USBH_UsrLog("Default configuration set.");
 800c32c:	4878      	ldr	r0, [pc, #480]	; (800c510 <USBH_Process+0x3d0>)
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 800c32e:	7023      	strb	r3, [r4, #0]
        USBH_UsrLog("Default configuration set.");
 800c330:	f002 fa0c 	bl	800e74c <printf>
 800c334:	200a      	movs	r0, #10
 800c336:	f002 fa1d 	bl	800e774 <putchar>
 800c33a:	e759      	b.n	800c1f0 <USBH_Process+0xb0>
      if (((phost->device.CfgDesc.bmAttributes) & (1U << 5)) != 0U)
 800c33c:	f894 343f 	ldrb.w	r3, [r4, #1087]	; 0x43f
 800c340:	069b      	lsls	r3, r3, #26
 800c342:	f100 8143 	bmi.w	800c5cc <USBH_Process+0x48c>
          phost->gState = HOST_CHECK_CLASS;
 800c346:	230a      	movs	r3, #10
 800c348:	7023      	strb	r3, [r4, #0]
 800c34a:	e751      	b.n	800c1f0 <USBH_Process+0xb0>
      if (phost->ClassNumber == 0U)
 800c34c:	f8d4 34a0 	ldr.w	r3, [r4, #1184]	; 0x4a0
 800c350:	2b00      	cmp	r3, #0
 800c352:	f000 8151 	beq.w	800c5f8 <USBH_Process+0x4b8>
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 800c356:	f8d4 3498 	ldr.w	r3, [r4, #1176]	; 0x498
 800c35a:	f894 2447 	ldrb.w	r2, [r4, #1095]	; 0x447
 800c35e:	7919      	ldrb	r1, [r3, #4]
 800c360:	4291      	cmp	r1, r2
 800c362:	d122      	bne.n	800c3aa <USBH_Process+0x26a>
 800c364:	f8c4 349c 	str.w	r3, [r4, #1180]	; 0x49c
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 800c368:	4620      	mov	r0, r4
 800c36a:	689b      	ldr	r3, [r3, #8]
 800c36c:	4798      	blx	r3
 800c36e:	2800      	cmp	r0, #0
 800c370:	f040 8149 	bne.w	800c606 <USBH_Process+0x4c6>
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 800c374:	f8d4 349c 	ldr.w	r3, [r4, #1180]	; 0x49c
            phost->gState = HOST_CLASS_REQUEST;
 800c378:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 800c37a:	4866      	ldr	r0, [pc, #408]	; (800c514 <USBH_Process+0x3d4>)
            phost->gState = HOST_CLASS_REQUEST;
 800c37c:	7022      	strb	r2, [r4, #0]
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 800c37e:	6819      	ldr	r1, [r3, #0]
 800c380:	f002 f9e4 	bl	800e74c <printf>
 800c384:	200a      	movs	r0, #10
 800c386:	f002 f9f5 	bl	800e774 <putchar>
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 800c38a:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
 800c38e:	2103      	movs	r1, #3
 800c390:	4620      	mov	r0, r4
 800c392:	4798      	blx	r3
 800c394:	e72c      	b.n	800c1f0 <USBH_Process+0xb0>
          phost->gState = HOST_CLASS;
 800c396:	230b      	movs	r3, #11
 800c398:	7023      	strb	r3, [r4, #0]
 800c39a:	e729      	b.n	800c1f0 <USBH_Process+0xb0>
          phost->Timeout += 10U;
 800c39c:	330a      	adds	r3, #10
          USBH_Delay(10U);
 800c39e:	200a      	movs	r0, #10
          phost->Timeout += 10U;
 800c3a0:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
          USBH_Delay(10U);
 800c3a4:	f7ff fd92 	bl	800becc <USBH_Delay>
 800c3a8:	e722      	b.n	800c1f0 <USBH_Process+0xb0>
 800c3aa:	2200      	movs	r2, #0
          phost->gState = HOST_ABORT_STATE;
 800c3ac:	230d      	movs	r3, #13
          USBH_UsrLog("No registered class for this device.");
 800c3ae:	485a      	ldr	r0, [pc, #360]	; (800c518 <USBH_Process+0x3d8>)
 800c3b0:	f8c4 249c 	str.w	r2, [r4, #1180]	; 0x49c
          phost->gState = HOST_ABORT_STATE;
 800c3b4:	7023      	strb	r3, [r4, #0]
          USBH_UsrLog("No registered class for this device.");
 800c3b6:	f002 f9c9 	bl	800e74c <printf>
 800c3ba:	200a      	movs	r0, #10
 800c3bc:	f002 f9da 	bl	800e774 <putchar>
 800c3c0:	e716      	b.n	800c1f0 <USBH_Process+0xb0>
#endif /* (USBH_USE_OS == 1U) */
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 800c3c2:	f894 1436 	ldrb.w	r1, [r4, #1078]	; 0x436
 800c3c6:	2900      	cmp	r1, #0
 800c3c8:	f000 8176 	beq.w	800c6b8 <USBH_Process+0x578>
      {
        /* Check that Serial number string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
                                        phost->device.Data, 0xFFU);
 800c3cc:	f504 7607 	add.w	r6, r4, #540	; 0x21c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 800c3d0:	23ff      	movs	r3, #255	; 0xff
 800c3d2:	4620      	mov	r0, r4
 800c3d4:	4632      	mov	r2, r6
 800c3d6:	f000 fd6d 	bl	800ceb4 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 800c3da:	4605      	mov	r5, r0
 800c3dc:	2800      	cmp	r0, #0
 800c3de:	f000 81c9 	beq.w	800c774 <USBH_Process+0x634>
        {
          /* User callback for Serial number string */
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
          Status = USBH_OK;
        }
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c3e2:	2803      	cmp	r0, #3
 800c3e4:	f000 8168 	beq.w	800c6b8 <USBH_Process+0x578>
  switch (phost->EnumState)
 800c3e8:	2501      	movs	r5, #1
      status = USBH_HandleEnum(phost);
 800c3ea:	f88d 5017 	strb.w	r5, [sp, #23]
      if (status == USBH_OK)
 800c3ee:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c3f2:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 800c3f6:	2b00      	cmp	r3, #0
 800c3f8:	f47f aefa 	bne.w	800c1f0 <USBH_Process+0xb0>
        USBH_UsrLog("Enumeration done.");
 800c3fc:	4847      	ldr	r0, [pc, #284]	; (800c51c <USBH_Process+0x3dc>)
 800c3fe:	f002 f9a5 	bl	800e74c <printf>
 800c402:	200a      	movs	r0, #10
 800c404:	f002 f9b6 	bl	800e774 <putchar>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800c408:	f894 3437 	ldrb.w	r3, [r4, #1079]	; 0x437
        phost->device.current_interface = 0U;
 800c40c:	f884 5424 	strb.w	r5, [r4, #1060]	; 0x424
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800c410:	2b01      	cmp	r3, #1
 800c412:	f000 8148 	beq.w	800c6a6 <USBH_Process+0x566>
          phost->gState = HOST_INPUT;
 800c416:	2307      	movs	r3, #7
 800c418:	7023      	strb	r3, [r4, #0]
 800c41a:	e6e9      	b.n	800c1f0 <USBH_Process+0xb0>
      if (phost->device.DevDesc.iProduct != 0U)
 800c41c:	f894 1435 	ldrb.w	r1, [r4, #1077]	; 0x435
 800c420:	b159      	cbz	r1, 800c43a <USBH_Process+0x2fa>
                                        phost->device.Data, 0xFFU);
 800c422:	f504 7507 	add.w	r5, r4, #540	; 0x21c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 800c426:	23ff      	movs	r3, #255	; 0xff
 800c428:	4620      	mov	r0, r4
 800c42a:	462a      	mov	r2, r5
 800c42c:	f000 fd42 	bl	800ceb4 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 800c430:	2800      	cmp	r0, #0
 800c432:	f000 81a7 	beq.w	800c784 <USBH_Process+0x644>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c436:	2803      	cmp	r0, #3
 800c438:	d1d6      	bne.n	800c3e8 <USBH_Process+0x2a8>
          USBH_UsrLog("Product : N/A");
 800c43a:	4839      	ldr	r0, [pc, #228]	; (800c520 <USBH_Process+0x3e0>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c43c:	2501      	movs	r5, #1
          USBH_UsrLog("Product : N/A");
 800c43e:	f002 f985 	bl	800e74c <printf>
 800c442:	200a      	movs	r0, #10
 800c444:	f002 f996 	bl	800e774 <putchar>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c448:	2307      	movs	r3, #7
 800c44a:	7063      	strb	r3, [r4, #1]
 800c44c:	e7cd      	b.n	800c3ea <USBH_Process+0x2aa>
      if (phost->device.DevDesc.iManufacturer != 0U)
 800c44e:	f894 1434 	ldrb.w	r1, [r4, #1076]	; 0x434
 800c452:	b159      	cbz	r1, 800c46c <USBH_Process+0x32c>
                                        phost->device.Data, 0xFFU);
 800c454:	f504 7507 	add.w	r5, r4, #540	; 0x21c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 800c458:	23ff      	movs	r3, #255	; 0xff
 800c45a:	4620      	mov	r0, r4
 800c45c:	462a      	mov	r2, r5
 800c45e:	f000 fd29 	bl	800ceb4 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 800c462:	2800      	cmp	r0, #0
 800c464:	f000 817b 	beq.w	800c75e <USBH_Process+0x61e>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c468:	2803      	cmp	r0, #3
 800c46a:	d1bd      	bne.n	800c3e8 <USBH_Process+0x2a8>
          USBH_UsrLog("Manufacturer : N/A");
 800c46c:	482d      	ldr	r0, [pc, #180]	; (800c524 <USBH_Process+0x3e4>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c46e:	2501      	movs	r5, #1
          USBH_UsrLog("Manufacturer : N/A");
 800c470:	f002 f96c 	bl	800e74c <printf>
 800c474:	200a      	movs	r0, #10
 800c476:	f002 f97d 	bl	800e774 <putchar>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c47a:	2306      	movs	r3, #6
 800c47c:	7063      	strb	r3, [r4, #1]
 800c47e:	e7b4      	b.n	800c3ea <USBH_Process+0x2aa>
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 800c480:	2108      	movs	r1, #8
 800c482:	4620      	mov	r0, r4
 800c484:	f000 fa92 	bl	800c9ac <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 800c488:	4606      	mov	r6, r0
 800c48a:	2800      	cmp	r0, #0
 800c48c:	f000 8146 	beq.w	800c71c <USBH_Process+0x5dc>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c490:	2803      	cmp	r0, #3
 800c492:	d1a9      	bne.n	800c3e8 <USBH_Process+0x2a8>
        USBH_ErrLog("Control error: Get Device Descriptor request failed");
 800c494:	481c      	ldr	r0, [pc, #112]	; (800c508 <USBH_Process+0x3c8>)
 800c496:	f002 f959 	bl	800e74c <printf>
 800c49a:	4823      	ldr	r0, [pc, #140]	; (800c528 <USBH_Process+0x3e8>)
 800c49c:	f002 f956 	bl	800e74c <printf>
 800c4a0:	200a      	movs	r0, #10
 800c4a2:	f002 f967 	bl	800e774 <putchar>
        phost->device.EnumCnt++;
 800c4a6:	f894 341e 	ldrb.w	r3, [r4, #1054]	; 0x41e
 800c4aa:	3301      	adds	r3, #1
 800c4ac:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 800c4ae:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800c4b0:	f884 341e 	strb.w	r3, [r4, #1054]	; 0x41e
        if (phost->device.EnumCnt > 3U)
 800c4b4:	f200 8150 	bhi.w	800c758 <USBH_Process+0x618>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c4b8:	7961      	ldrb	r1, [r4, #5]
 800c4ba:	4620      	mov	r0, r4
 800c4bc:	f000 fdd6 	bl	800d06c <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c4c0:	7921      	ldrb	r1, [r4, #4]
 800c4c2:	4620      	mov	r0, r4
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c4c4:	2501      	movs	r5, #1
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c4c6:	f000 fdd1 	bl	800d06c <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 800c4ca:	2300      	movs	r3, #0
 800c4cc:	7023      	strb	r3, [r4, #0]
 800c4ce:	e78c      	b.n	800c3ea <USBH_Process+0x2aa>
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 800c4d0:	f8b4 143a 	ldrh.w	r1, [r4, #1082]	; 0x43a
 800c4d4:	4620      	mov	r0, r4
 800c4d6:	f000 fb03 	bl	800cae0 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 800c4da:	2800      	cmp	r0, #0
 800c4dc:	f040 80c0 	bne.w	800c660 <USBH_Process+0x520>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800c4e0:	2305      	movs	r3, #5
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c4e2:	2501      	movs	r5, #1
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800c4e4:	7063      	strb	r3, [r4, #1]
 800c4e6:	e780      	b.n	800c3ea <USBH_Process+0x2aa>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 800c4e8:	2109      	movs	r1, #9
 800c4ea:	4620      	mov	r0, r4
 800c4ec:	f000 faf8 	bl	800cae0 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 800c4f0:	2800      	cmp	r0, #0
 800c4f2:	f040 80b5 	bne.w	800c660 <USBH_Process+0x520>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 800c4f6:	2304      	movs	r3, #4
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c4f8:	2501      	movs	r5, #1
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 800c4fa:	7063      	strb	r3, [r4, #1]
 800c4fc:	e775      	b.n	800c3ea <USBH_Process+0x2aa>
 800c4fe:	bf00      	nop
 800c500:	08015504 	.word	0x08015504
 800c504:	0801588c 	.word	0x0801588c
 800c508:	0801540c 	.word	0x0801540c
 800c50c:	0801584c 	.word	0x0801584c
 800c510:	08015768 	.word	0x08015768
 800c514:	08015818 	.word	0x08015818
 800c518:	080157f0 	.word	0x080157f0
 800c51c:	0801572c 	.word	0x0801572c
 800c520:	080156f4 	.word	0x080156f4
 800c524:	080156d0 	.word	0x080156d0
 800c528:	08015564 	.word	0x08015564
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 800c52c:	2101      	movs	r1, #1
 800c52e:	4620      	mov	r0, r4
 800c530:	f000 fc26 	bl	800cd80 <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
 800c534:	4606      	mov	r6, r0
 800c536:	2800      	cmp	r0, #0
 800c538:	f000 80c6 	beq.w	800c6c8 <USBH_Process+0x588>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c53c:	2803      	cmp	r0, #3
 800c53e:	f47f af53 	bne.w	800c3e8 <USBH_Process+0x2a8>
        USBH_ErrLog("Control error: Device Set Address request failed");
 800c542:	489c      	ldr	r0, [pc, #624]	; (800c7b4 <USBH_Process+0x674>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c544:	2501      	movs	r5, #1
        USBH_ErrLog("Control error: Device Set Address request failed");
 800c546:	f002 f901 	bl	800e74c <printf>
 800c54a:	489b      	ldr	r0, [pc, #620]	; (800c7b8 <USBH_Process+0x678>)
 800c54c:	f002 f8fe 	bl	800e74c <printf>
 800c550:	200a      	movs	r0, #10
 800c552:	f002 f90f 	bl	800e774 <putchar>
        USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 800c556:	4899      	ldr	r0, [pc, #612]	; (800c7bc <USBH_Process+0x67c>)
 800c558:	f002 f8f8 	bl	800e74c <printf>
 800c55c:	200a      	movs	r0, #10
 800c55e:	f002 f909 	bl	800e774 <putchar>
        phost->gState = HOST_ABORT_STATE;
 800c562:	220d      	movs	r2, #13
        phost->EnumState = ENUM_IDLE;
 800c564:	2300      	movs	r3, #0
        phost->gState = HOST_ABORT_STATE;
 800c566:	7022      	strb	r2, [r4, #0]
        phost->EnumState = ENUM_IDLE;
 800c568:	7063      	strb	r3, [r4, #1]
 800c56a:	e73e      	b.n	800c3ea <USBH_Process+0x2aa>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 800c56c:	2112      	movs	r1, #18
 800c56e:	4620      	mov	r0, r4
 800c570:	f000 fa1c 	bl	800c9ac <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 800c574:	2800      	cmp	r0, #0
 800c576:	f000 80dc 	beq.w	800c732 <USBH_Process+0x5f2>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c57a:	2803      	cmp	r0, #3
 800c57c:	f47f af34 	bne.w	800c3e8 <USBH_Process+0x2a8>
        USBH_ErrLog("Control error: Get Full Device Descriptor request failed");
 800c580:	488c      	ldr	r0, [pc, #560]	; (800c7b4 <USBH_Process+0x674>)
 800c582:	f002 f8e3 	bl	800e74c <printf>
 800c586:	488e      	ldr	r0, [pc, #568]	; (800c7c0 <USBH_Process+0x680>)
 800c588:	f002 f8e0 	bl	800e74c <printf>
 800c58c:	200a      	movs	r0, #10
 800c58e:	f002 f8f1 	bl	800e774 <putchar>
        phost->device.EnumCnt++;
 800c592:	f894 341e 	ldrb.w	r3, [r4, #1054]	; 0x41e
 800c596:	3301      	adds	r3, #1
 800c598:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 800c59a:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800c59c:	f884 341e 	strb.w	r3, [r4, #1054]	; 0x41e
        if (phost->device.EnumCnt > 3U)
 800c5a0:	f240 80fb 	bls.w	800c79a <USBH_Process+0x65a>
          USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 800c5a4:	4885      	ldr	r0, [pc, #532]	; (800c7bc <USBH_Process+0x67c>)
 800c5a6:	f002 f8d1 	bl	800e74c <printf>
 800c5aa:	200a      	movs	r0, #10
 800c5ac:	f002 f8e2 	bl	800e774 <putchar>
          phost->gState = HOST_ABORT_STATE;
 800c5b0:	230d      	movs	r3, #13
 800c5b2:	7023      	strb	r3, [r4, #0]
 800c5b4:	e719      	b.n	800c3ea <USBH_Process+0x2aa>
        phost->device.is_ReEnumerated = 0U;
 800c5b6:	2300      	movs	r3, #0
  (void)USBH_LL_Start(phost);
 800c5b8:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
 800c5ba:	f884 3422 	strb.w	r3, [r4, #1058]	; 0x422
  (void)USBH_LL_Start(phost);
 800c5be:	f7ff fb75 	bl	800bcac <USBH_LL_Start>
  (void)USBH_LL_DriverVBUS(phost, TRUE);
 800c5c2:	4629      	mov	r1, r5
 800c5c4:	4620      	mov	r0, r4
 800c5c6:	f7ff fba7 	bl	800bd18 <USBH_LL_DriverVBUS>
  return USBH_OK;
 800c5ca:	e611      	b.n	800c1f0 <USBH_Process+0xb0>
        status = USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP);
 800c5cc:	2101      	movs	r1, #1
 800c5ce:	4620      	mov	r0, r4
 800c5d0:	f000 fc26 	bl	800ce20 <USBH_SetFeature>
 800c5d4:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 800c5d8:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c5dc:	2b00      	cmp	r3, #0
 800c5de:	d060      	beq.n	800c6a2 <USBH_Process+0x562>
        else if (status == USBH_NOT_SUPPORTED)
 800c5e0:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800c5e4:	2b03      	cmp	r3, #3
 800c5e6:	f47f ae03 	bne.w	800c1f0 <USBH_Process+0xb0>
          USBH_UsrLog("Remote wakeup not supported by the device");
 800c5ea:	4876      	ldr	r0, [pc, #472]	; (800c7c4 <USBH_Process+0x684>)
 800c5ec:	f002 f8ae 	bl	800e74c <printf>
 800c5f0:	200a      	movs	r0, #10
 800c5f2:	f002 f8bf 	bl	800e774 <putchar>
 800c5f6:	e6a6      	b.n	800c346 <USBH_Process+0x206>
        USBH_UsrLog("No Class has been registered.");
 800c5f8:	4873      	ldr	r0, [pc, #460]	; (800c7c8 <USBH_Process+0x688>)
 800c5fa:	f002 f8a7 	bl	800e74c <printf>
 800c5fe:	200a      	movs	r0, #10
 800c600:	f002 f8b8 	bl	800e774 <putchar>
 800c604:	e5f4      	b.n	800c1f0 <USBH_Process+0xb0>
            USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
 800c606:	f8d4 349c 	ldr.w	r3, [r4, #1180]	; 0x49c
            phost->gState = HOST_ABORT_STATE;
 800c60a:	220d      	movs	r2, #13
            USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
 800c60c:	486f      	ldr	r0, [pc, #444]	; (800c7cc <USBH_Process+0x68c>)
            phost->gState = HOST_ABORT_STATE;
 800c60e:	7022      	strb	r2, [r4, #0]
            USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
 800c610:	6819      	ldr	r1, [r3, #0]
 800c612:	f002 f89b 	bl	800e74c <printf>
 800c616:	200a      	movs	r0, #10
 800c618:	f002 f8ac 	bl	800e774 <putchar>
 800c61c:	e5e8      	b.n	800c1f0 <USBH_Process+0xb0>
        USBH_UsrLog("USB Device Reset Completed");
 800c61e:	486c      	ldr	r0, [pc, #432]	; (800c7d0 <USBH_Process+0x690>)
 800c620:	f002 f894 	bl	800e74c <printf>
 800c624:	200a      	movs	r0, #10
 800c626:	f002 f8a5 	bl	800e774 <putchar>
        phost->device.RstCnt = 0U;
 800c62a:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
 800c62c:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
 800c62e:	f884 241f 	strb.w	r2, [r4, #1055]	; 0x41f
        phost->gState = HOST_DEV_ATTACHED;
 800c632:	7023      	strb	r3, [r4, #0]
 800c634:	e5dc      	b.n	800c1f0 <USBH_Process+0xb0>
            USBH_UsrLog("USB Reset Failed, Please unplug the Device.");
 800c636:	4867      	ldr	r0, [pc, #412]	; (800c7d4 <USBH_Process+0x694>)
 800c638:	f002 f888 	bl	800e74c <printf>
 800c63c:	200a      	movs	r0, #10
 800c63e:	f002 f899 	bl	800e774 <putchar>
            phost->gState = HOST_ABORT_STATE;
 800c642:	230d      	movs	r3, #13
 800c644:	7023      	strb	r3, [r4, #0]
 800c646:	e5d3      	b.n	800c1f0 <USBH_Process+0xb0>
        phost->gState = HOST_ABORT_STATE;
 800c648:	230d      	movs	r3, #13
        USBH_ErrLog("Invalid Class Driver.");
 800c64a:	485a      	ldr	r0, [pc, #360]	; (800c7b4 <USBH_Process+0x674>)
        phost->gState = HOST_ABORT_STATE;
 800c64c:	7023      	strb	r3, [r4, #0]
        USBH_ErrLog("Invalid Class Driver.");
 800c64e:	f002 f87d 	bl	800e74c <printf>
 800c652:	4861      	ldr	r0, [pc, #388]	; (800c7d8 <USBH_Process+0x698>)
 800c654:	f002 f87a 	bl	800e74c <printf>
 800c658:	200a      	movs	r0, #10
 800c65a:	f002 f88b 	bl	800e774 <putchar>
 800c65e:	e5c7      	b.n	800c1f0 <USBH_Process+0xb0>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c660:	2803      	cmp	r0, #3
 800c662:	f47f aec1 	bne.w	800c3e8 <USBH_Process+0x2a8>
        USBH_ErrLog("Control error: Get Device configuration descriptor request failed");
 800c666:	4853      	ldr	r0, [pc, #332]	; (800c7b4 <USBH_Process+0x674>)
 800c668:	f002 f870 	bl	800e74c <printf>
 800c66c:	485b      	ldr	r0, [pc, #364]	; (800c7dc <USBH_Process+0x69c>)
 800c66e:	f002 f86d 	bl	800e74c <printf>
 800c672:	200a      	movs	r0, #10
 800c674:	f002 f87e 	bl	800e774 <putchar>
        phost->device.EnumCnt++;
 800c678:	f894 341e 	ldrb.w	r3, [r4, #1054]	; 0x41e
 800c67c:	3301      	adds	r3, #1
 800c67e:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 800c680:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800c682:	f884 341e 	strb.w	r3, [r4, #1054]	; 0x41e
        if (phost->device.EnumCnt > 3U)
 800c686:	d867      	bhi.n	800c758 <USBH_Process+0x618>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c688:	7961      	ldrb	r1, [r4, #5]
 800c68a:	4620      	mov	r0, r4
 800c68c:	f000 fcee 	bl	800d06c <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c690:	7921      	ldrb	r1, [r4, #4]
 800c692:	4620      	mov	r0, r4
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c694:	2501      	movs	r5, #1
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c696:	f000 fce9 	bl	800d06c <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c69a:	2300      	movs	r3, #0
 800c69c:	7063      	strb	r3, [r4, #1]
          phost->gState = HOST_IDLE;
 800c69e:	7023      	strb	r3, [r4, #0]
 800c6a0:	e6a3      	b.n	800c3ea <USBH_Process+0x2aa>
          USBH_UsrLog("Device remote wakeup enabled");
 800c6a2:	484f      	ldr	r0, [pc, #316]	; (800c7e0 <USBH_Process+0x6a0>)
 800c6a4:	e7a2      	b.n	800c5ec <USBH_Process+0x4ac>
          USBH_UsrLog("This device has only 1 configuration.");
 800c6a6:	484f      	ldr	r0, [pc, #316]	; (800c7e4 <USBH_Process+0x6a4>)
 800c6a8:	f002 f850 	bl	800e74c <printf>
 800c6ac:	200a      	movs	r0, #10
 800c6ae:	f002 f861 	bl	800e774 <putchar>
          phost->gState = HOST_SET_CONFIGURATION;
 800c6b2:	2308      	movs	r3, #8
 800c6b4:	7023      	strb	r3, [r4, #0]
 800c6b6:	e59b      	b.n	800c1f0 <USBH_Process+0xb0>
        {
          USBH_UsrLog("Serial Number : N/A");
 800c6b8:	484b      	ldr	r0, [pc, #300]	; (800c7e8 <USBH_Process+0x6a8>)
          Status = USBH_OK;
 800c6ba:	2500      	movs	r5, #0
          USBH_UsrLog("Serial Number : N/A");
 800c6bc:	f002 f846 	bl	800e74c <printf>
 800c6c0:	200a      	movs	r0, #10
 800c6c2:	f002 f857 	bl	800e774 <putchar>
          Status = USBH_OK;
 800c6c6:	e690      	b.n	800c3ea <USBH_Process+0x2aa>
        phost->device.address = USBH_DEVICE_ADDRESS;
 800c6c8:	2501      	movs	r5, #1
        USBH_Delay(2U);
 800c6ca:	2002      	movs	r0, #2
 800c6cc:	f7ff fbfe 	bl	800becc <USBH_Delay>
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
 800c6d0:	4846      	ldr	r0, [pc, #280]	; (800c7ec <USBH_Process+0x6ac>)
 800c6d2:	4629      	mov	r1, r5
        phost->device.address = USBH_DEVICE_ADDRESS;
 800c6d4:	f884 541c 	strb.w	r5, [r4, #1052]	; 0x41c
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
 800c6d8:	f002 f838 	bl	800e74c <printf>
 800c6dc:	200a      	movs	r0, #10
 800c6de:	f002 f849 	bl	800e774 <putchar>
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800c6e2:	79a1      	ldrb	r1, [r4, #6]
 800c6e4:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
        phost->EnumState = ENUM_GET_CFG_DESC;
 800c6e8:	2203      	movs	r2, #3
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800c6ea:	9102      	str	r1, [sp, #8]
        phost->EnumState = ENUM_GET_CFG_DESC;
 800c6ec:	7062      	strb	r2, [r4, #1]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800c6ee:	e9cd 3600 	strd	r3, r6, [sp]
 800c6f2:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 800c6f6:	2280      	movs	r2, #128	; 0x80
 800c6f8:	7921      	ldrb	r1, [r4, #4]
 800c6fa:	4620      	mov	r0, r4
 800c6fc:	f000 fc82 	bl	800d004 <USBH_OpenPipe>
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c700:	79a1      	ldrb	r1, [r4, #6]
 800c702:	f894 341d 	ldrb.w	r3, [r4, #1053]	; 0x41d
 800c706:	4632      	mov	r2, r6
 800c708:	9601      	str	r6, [sp, #4]
 800c70a:	4620      	mov	r0, r4
 800c70c:	9102      	str	r1, [sp, #8]
 800c70e:	9300      	str	r3, [sp, #0]
 800c710:	f894 341c 	ldrb.w	r3, [r4, #1052]	; 0x41c
 800c714:	7961      	ldrb	r1, [r4, #5]
 800c716:	f000 fc75 	bl	800d004 <USBH_OpenPipe>
 800c71a:	e666      	b.n	800c3ea <USBH_Process+0x2aa>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 800c71c:	f894 342d 	ldrb.w	r3, [r4, #1069]	; 0x42d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 800c720:	2501      	movs	r5, #1
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800c722:	f894 241d 	ldrb.w	r2, [r4, #1053]	; 0x41d
 800c726:	9001      	str	r0, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 800c728:	71a3      	strb	r3, [r4, #6]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 800c72a:	7065      	strb	r5, [r4, #1]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800c72c:	9302      	str	r3, [sp, #8]
 800c72e:	9200      	str	r2, [sp, #0]
 800c730:	e7df      	b.n	800c6f2 <USBH_Process+0x5b2>
        USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct);
 800c732:	f8b4 1430 	ldrh.w	r1, [r4, #1072]	; 0x430
 800c736:	482e      	ldr	r0, [pc, #184]	; (800c7f0 <USBH_Process+0x6b0>)
 800c738:	f002 f808 	bl	800e74c <printf>
 800c73c:	200a      	movs	r0, #10
 800c73e:	f002 f819 	bl	800e774 <putchar>
        USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor);
 800c742:	f8b4 142e 	ldrh.w	r1, [r4, #1070]	; 0x42e
 800c746:	482b      	ldr	r0, [pc, #172]	; (800c7f4 <USBH_Process+0x6b4>)
 800c748:	f002 f800 	bl	800e74c <printf>
 800c74c:	200a      	movs	r0, #10
 800c74e:	f002 f811 	bl	800e774 <putchar>
        phost->EnumState = ENUM_SET_ADDR;
 800c752:	2302      	movs	r3, #2
 800c754:	7063      	strb	r3, [r4, #1]
 800c756:	e648      	b.n	800c3ea <USBH_Process+0x2aa>
          USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 800c758:	4818      	ldr	r0, [pc, #96]	; (800c7bc <USBH_Process+0x67c>)
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c75a:	2501      	movs	r5, #1
 800c75c:	e723      	b.n	800c5a6 <USBH_Process+0x466>
          USBH_UsrLog("Manufacturer : %s", (char *)(void *)phost->device.Data);
 800c75e:	4629      	mov	r1, r5
 800c760:	4825      	ldr	r0, [pc, #148]	; (800c7f8 <USBH_Process+0x6b8>)
 800c762:	f001 fff3 	bl	800e74c <printf>
 800c766:	200a      	movs	r0, #10
 800c768:	f002 f804 	bl	800e774 <putchar>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c76c:	2306      	movs	r3, #6
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c76e:	2501      	movs	r5, #1
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c770:	7063      	strb	r3, [r4, #1]
 800c772:	e63a      	b.n	800c3ea <USBH_Process+0x2aa>
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
 800c774:	4631      	mov	r1, r6
 800c776:	4821      	ldr	r0, [pc, #132]	; (800c7fc <USBH_Process+0x6bc>)
 800c778:	f001 ffe8 	bl	800e74c <printf>
 800c77c:	200a      	movs	r0, #10
 800c77e:	f001 fff9 	bl	800e774 <putchar>
          Status = USBH_OK;
 800c782:	e632      	b.n	800c3ea <USBH_Process+0x2aa>
          USBH_UsrLog("Product : %s", (char *)(void *)phost->device.Data);
 800c784:	4629      	mov	r1, r5
 800c786:	481e      	ldr	r0, [pc, #120]	; (800c800 <USBH_Process+0x6c0>)
 800c788:	f001 ffe0 	bl	800e74c <printf>
 800c78c:	200a      	movs	r0, #10
 800c78e:	f001 fff1 	bl	800e774 <putchar>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c792:	2307      	movs	r3, #7
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c794:	2501      	movs	r5, #1
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c796:	7063      	strb	r3, [r4, #1]
 800c798:	e627      	b.n	800c3ea <USBH_Process+0x2aa>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c79a:	7961      	ldrb	r1, [r4, #5]
 800c79c:	4620      	mov	r0, r4
 800c79e:	f000 fc65 	bl	800d06c <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c7a2:	7921      	ldrb	r1, [r4, #4]
 800c7a4:	4620      	mov	r0, r4
 800c7a6:	f000 fc61 	bl	800d06c <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c7aa:	2300      	movs	r3, #0
 800c7ac:	7063      	strb	r3, [r4, #1]
          phost->gState = HOST_IDLE;
 800c7ae:	7023      	strb	r3, [r4, #0]
 800c7b0:	e61b      	b.n	800c3ea <USBH_Process+0x2aa>
 800c7b2:	bf00      	nop
 800c7b4:	0801540c 	.word	0x0801540c
 800c7b8:	08015644 	.word	0x08015644
 800c7bc:	08015598 	.word	0x08015598
 800c7c0:	080155f0 	.word	0x080155f0
 800c7c4:	080157a4 	.word	0x080157a4
 800c7c8:	080157d0 	.word	0x080157d0
 800c7cc:	0801582c 	.word	0x0801582c
 800c7d0:	0801551c 	.word	0x0801551c
 800c7d4:	08015538 	.word	0x08015538
 800c7d8:	08015874 	.word	0x08015874
 800c7dc:	08015678 	.word	0x08015678
 800c7e0:	08015784 	.word	0x08015784
 800c7e4:	08015740 	.word	0x08015740
 800c7e8:	08015718 	.word	0x08015718
 800c7ec:	0801562c 	.word	0x0801562c
 800c7f0:	080155d8 	.word	0x080155d8
 800c7f4:	080155e4 	.word	0x080155e4
 800c7f8:	080156bc 	.word	0x080156bc
 800c7fc:	08015704 	.word	0x08015704
 800c800:	080156e4 	.word	0x080156e4

0800c804 <USBH_HandleControl>:
  *         Handles the USB control transfer state machine
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_HandleControl(USBH_HandleTypeDef *phost)
{
 800c804:	b570      	push	{r4, r5, r6, lr}
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
 800c806:	7e05      	ldrb	r5, [r0, #24]
{
 800c808:	b082      	sub	sp, #8
 800c80a:	4604      	mov	r4, r0
  switch (phost->Control.state)
 800c80c:	1e6b      	subs	r3, r5, #1
 800c80e:	2b0a      	cmp	r3, #10
 800c810:	d866      	bhi.n	800c8e0 <USBH_HandleControl+0xdc>
 800c812:	e8df f003 	tbb	[pc, r3]
 800c816:	1c14      	.short	0x1c14
 800c818:	7669852b 	.word	0x7669852b
 800c81c:	5c4f4438 	.word	0x5c4f4438
 800c820:	06          	.byte	0x06
 800c821:	00          	.byte	0x00
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800c822:	7e43      	ldrb	r3, [r0, #25]
 800c824:	3301      	adds	r3, #1
 800c826:	b2db      	uxtb	r3, r3
 800c828:	2b02      	cmp	r3, #2
 800c82a:	7643      	strb	r3, [r0, #25]
 800c82c:	f200 8092 	bhi.w	800c954 <USBH_HandleControl+0x150>
      {
        /* Do the transmission again, starting from SETUP Packet */
        phost->Control.state = CTRL_SETUP;
 800c830:	2301      	movs	r3, #1
  USBH_StatusTypeDef status = USBH_BUSY;
 800c832:	461d      	mov	r5, r3
        phost->Control.state = CTRL_SETUP;
 800c834:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 800c836:	7083      	strb	r3, [r0, #2]
    default:
      break;
  }

  return status;
}
 800c838:	4628      	mov	r0, r5
 800c83a:	b002      	add	sp, #8
 800c83c:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800c83e:	7942      	ldrb	r2, [r0, #5]
 800c840:	f100 0110 	add.w	r1, r0, #16
 800c844:	f000 fb7a 	bl	800cf3c <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800c848:	2302      	movs	r3, #2
 800c84a:	7623      	strb	r3, [r4, #24]
      break;
 800c84c:	e7f4      	b.n	800c838 <USBH_HandleControl+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800c84e:	7941      	ldrb	r1, [r0, #5]
 800c850:	f7ff faf0 	bl	800be34 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800c854:	2801      	cmp	r0, #1
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800c856:	4605      	mov	r5, r0
      if (URB_Status == USBH_URB_DONE)
 800c858:	f000 8096 	beq.w	800c988 <USBH_HandleControl+0x184>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800c85c:	2804      	cmp	r0, #4
 800c85e:	d001      	beq.n	800c864 <USBH_HandleControl+0x60>
 800c860:	2802      	cmp	r0, #2
 800c862:	d13d      	bne.n	800c8e0 <USBH_HandleControl+0xdc>
          phost->Control.state = CTRL_ERROR;
 800c864:	230b      	movs	r3, #11
  USBH_StatusTypeDef status = USBH_BUSY;
 800c866:	2501      	movs	r5, #1
          phost->Control.state = CTRL_ERROR;
 800c868:	7623      	strb	r3, [r4, #24]
 800c86a:	e7e5      	b.n	800c838 <USBH_HandleControl+0x34>
      phost->Control.timer = (uint16_t)phost->Timer;
 800c86c:	f8d0 04e4 	ldr.w	r0, [r0, #1252]	; 0x4e4
  USBH_StatusTypeDef status = USBH_BUSY;
 800c870:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800c872:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 800c874:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800c876:	4620      	mov	r0, r4
 800c878:	89a2      	ldrh	r2, [r4, #12]
 800c87a:	68a1      	ldr	r1, [r4, #8]
 800c87c:	f000 fb88 	bl	800cf90 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 800c880:	2304      	movs	r3, #4
 800c882:	7623      	strb	r3, [r4, #24]
      break;
 800c884:	e7d8      	b.n	800c838 <USBH_HandleControl+0x34>
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800c886:	2200      	movs	r2, #0
 800c888:	7903      	ldrb	r3, [r0, #4]
  USBH_StatusTypeDef status = USBH_BUSY;
 800c88a:	2501      	movs	r5, #1
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800c88c:	4611      	mov	r1, r2
 800c88e:	f000 fb7f 	bl	800cf90 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800c892:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800c896:	2308      	movs	r3, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 800c898:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800c89a:	7623      	strb	r3, [r4, #24]
      break;
 800c89c:	e7cc      	b.n	800c838 <USBH_HandleControl+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800c89e:	7901      	ldrb	r1, [r0, #4]
 800c8a0:	f7ff fac8 	bl	800be34 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800c8a4:	2801      	cmp	r0, #1
 800c8a6:	d049      	beq.n	800c93c <USBH_HandleControl+0x138>
      else if (URB_Status == USBH_URB_ERROR)
 800c8a8:	2804      	cmp	r0, #4
 800c8aa:	d0db      	beq.n	800c864 <USBH_HandleControl+0x60>
        if (URB_Status == USBH_URB_STALL)
 800c8ac:	2805      	cmp	r0, #5
 800c8ae:	d117      	bne.n	800c8e0 <USBH_HandleControl+0xdc>
          status = USBH_NOT_SUPPORTED;
 800c8b0:	2503      	movs	r5, #3
 800c8b2:	e7c1      	b.n	800c838 <USBH_HandleControl+0x34>
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 800c8b4:	2200      	movs	r2, #0
 800c8b6:	2501      	movs	r5, #1
 800c8b8:	7943      	ldrb	r3, [r0, #5]
 800c8ba:	4611      	mov	r1, r2
 800c8bc:	9500      	str	r5, [sp, #0]
 800c8be:	f000 fb4d 	bl	800cf5c <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800c8c2:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800c8c6:	230a      	movs	r3, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 800c8c8:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800c8ca:	7623      	strb	r3, [r4, #24]
      break;
 800c8cc:	e7b4      	b.n	800c838 <USBH_HandleControl+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800c8ce:	7941      	ldrb	r1, [r0, #5]
 800c8d0:	f7ff fab0 	bl	800be34 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800c8d4:	2801      	cmp	r0, #1
 800c8d6:	d031      	beq.n	800c93c <USBH_HandleControl+0x138>
      else if (URB_Status == USBH_URB_NOTREADY)
 800c8d8:	2802      	cmp	r0, #2
 800c8da:	d02b      	beq.n	800c934 <USBH_HandleControl+0x130>
        if (URB_Status == USBH_URB_ERROR)
 800c8dc:	2804      	cmp	r0, #4
 800c8de:	d0c1      	beq.n	800c864 <USBH_HandleControl+0x60>
  switch (phost->Control.state)
 800c8e0:	2501      	movs	r5, #1
}
 800c8e2:	4628      	mov	r0, r5
 800c8e4:	b002      	add	sp, #8
 800c8e6:	bd70      	pop	{r4, r5, r6, pc}
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800c8e8:	2501      	movs	r5, #1
 800c8ea:	7943      	ldrb	r3, [r0, #5]
 800c8ec:	8982      	ldrh	r2, [r0, #12]
 800c8ee:	6881      	ldr	r1, [r0, #8]
 800c8f0:	9500      	str	r5, [sp, #0]
 800c8f2:	f000 fb33 	bl	800cf5c <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800c8f6:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800c8fa:	2306      	movs	r3, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 800c8fc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800c8fe:	7623      	strb	r3, [r4, #24]
      break;
 800c900:	e79a      	b.n	800c838 <USBH_HandleControl+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800c902:	7941      	ldrb	r1, [r0, #5]
 800c904:	f7ff fa96 	bl	800be34 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800c908:	2801      	cmp	r0, #1
 800c90a:	d01f      	beq.n	800c94c <USBH_HandleControl+0x148>
      else if (URB_Status == USBH_URB_STALL)
 800c90c:	2805      	cmp	r0, #5
 800c90e:	d019      	beq.n	800c944 <USBH_HandleControl+0x140>
      else if (URB_Status == USBH_URB_NOTREADY)
 800c910:	2802      	cmp	r0, #2
 800c912:	d03f      	beq.n	800c994 <USBH_HandleControl+0x190>
        if (URB_Status == USBH_URB_ERROR)
 800c914:	2804      	cmp	r0, #4
 800c916:	d1e3      	bne.n	800c8e0 <USBH_HandleControl+0xdc>
          phost->Control.state = CTRL_ERROR;
 800c918:	230b      	movs	r3, #11
          status = USBH_FAIL;
 800c91a:	2502      	movs	r5, #2
          phost->Control.state = CTRL_ERROR;
 800c91c:	7623      	strb	r3, [r4, #24]
          status = USBH_FAIL;
 800c91e:	e78b      	b.n	800c838 <USBH_HandleControl+0x34>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800c920:	7901      	ldrb	r1, [r0, #4]
 800c922:	f7ff fa87 	bl	800be34 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800c926:	2801      	cmp	r0, #1
 800c928:	d004      	beq.n	800c934 <USBH_HandleControl+0x130>
      else if (URB_Status == USBH_URB_STALL)
 800c92a:	2805      	cmp	r0, #5
 800c92c:	d1d6      	bne.n	800c8dc <USBH_HandleControl+0xd8>
 800c92e:	e7bf      	b.n	800c8b0 <USBH_HandleControl+0xac>
          if (direction == USB_D2H)
 800c930:	061b      	lsls	r3, r3, #24
 800c932:	d50b      	bpl.n	800c94c <USBH_HandleControl+0x148>
            phost->Control.state = CTRL_STATUS_OUT;
 800c934:	2309      	movs	r3, #9
  USBH_StatusTypeDef status = USBH_BUSY;
 800c936:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_OUT;
 800c938:	7623      	strb	r3, [r4, #24]
 800c93a:	e77d      	b.n	800c838 <USBH_HandleControl+0x34>
        phost->Control.state = CTRL_COMPLETE;
 800c93c:	230d      	movs	r3, #13
        status = USBH_OK;
 800c93e:	2500      	movs	r5, #0
        phost->Control.state = CTRL_COMPLETE;
 800c940:	7623      	strb	r3, [r4, #24]
        status = USBH_OK;
 800c942:	e779      	b.n	800c838 <USBH_HandleControl+0x34>
        phost->Control.state = CTRL_STALLED;
 800c944:	230c      	movs	r3, #12
        status = USBH_NOT_SUPPORTED;
 800c946:	2503      	movs	r5, #3
        phost->Control.state = CTRL_STALLED;
 800c948:	7623      	strb	r3, [r4, #24]
        status = USBH_NOT_SUPPORTED;
 800c94a:	e775      	b.n	800c838 <USBH_HandleControl+0x34>
            phost->Control.state = CTRL_STATUS_IN;
 800c94c:	2307      	movs	r3, #7
  USBH_StatusTypeDef status = USBH_BUSY;
 800c94e:	2501      	movs	r5, #1
            phost->Control.state = CTRL_STATUS_IN;
 800c950:	7623      	strb	r3, [r4, #24]
 800c952:	e771      	b.n	800c838 <USBH_HandleControl+0x34>
        phost->Control.errorcount = 0U;
 800c954:	2600      	movs	r6, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800c956:	f8d0 34f4 	ldr.w	r3, [r0, #1268]	; 0x4f4
 800c95a:	2106      	movs	r1, #6
        status = USBH_FAIL;
 800c95c:	2502      	movs	r5, #2
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800c95e:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 800c960:	4810      	ldr	r0, [pc, #64]	; (800c9a4 <USBH_HandleControl+0x1a0>)
        phost->Control.errorcount = 0U;
 800c962:	7666      	strb	r6, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 800c964:	f001 fef2 	bl	800e74c <printf>
 800c968:	480f      	ldr	r0, [pc, #60]	; (800c9a8 <USBH_HandleControl+0x1a4>)
 800c96a:	f001 feef 	bl	800e74c <printf>
 800c96e:	200a      	movs	r0, #10
 800c970:	f001 ff00 	bl	800e774 <putchar>
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c974:	7961      	ldrb	r1, [r4, #5]
 800c976:	4620      	mov	r0, r4
 800c978:	f000 fb78 	bl	800d06c <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c97c:	7921      	ldrb	r1, [r4, #4]
 800c97e:	4620      	mov	r0, r4
 800c980:	f000 fb74 	bl	800d06c <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800c984:	7026      	strb	r6, [r4, #0]
        status = USBH_FAIL;
 800c986:	e757      	b.n	800c838 <USBH_HandleControl+0x34>
        if (phost->Control.setup.b.wLength.w != 0U)
 800c988:	8ae2      	ldrh	r2, [r4, #22]
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 800c98a:	7c23      	ldrb	r3, [r4, #16]
        if (phost->Control.setup.b.wLength.w != 0U)
 800c98c:	2a00      	cmp	r2, #0
 800c98e:	d0cf      	beq.n	800c930 <USBH_HandleControl+0x12c>
          if (direction == USB_D2H)
 800c990:	061a      	lsls	r2, r3, #24
 800c992:	d403      	bmi.n	800c99c <USBH_HandleControl+0x198>
            phost->Control.state = CTRL_DATA_OUT;
 800c994:	2305      	movs	r3, #5
  USBH_StatusTypeDef status = USBH_BUSY;
 800c996:	2501      	movs	r5, #1
            phost->Control.state = CTRL_DATA_OUT;
 800c998:	7623      	strb	r3, [r4, #24]
 800c99a:	e74d      	b.n	800c838 <USBH_HandleControl+0x34>
            phost->Control.state = CTRL_DATA_IN;
 800c99c:	2303      	movs	r3, #3
 800c99e:	7623      	strb	r3, [r4, #24]
 800c9a0:	e74a      	b.n	800c838 <USBH_HandleControl+0x34>
 800c9a2:	bf00      	nop
 800c9a4:	0801540c 	.word	0x0801540c
 800c9a8:	080158a4 	.word	0x080158a4

0800c9ac <USBH_Get_DevDesc>:
  if (length > sizeof(phost->device.Data))
 800c9ac:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
{
 800c9b0:	b538      	push	{r3, r4, r5, lr}
  if (length > sizeof(phost->device.Data))
 800c9b2:	d86b      	bhi.n	800ca8c <USBH_Get_DevDesc+0xe0>
  if (phost->RequestState == CMD_SEND)
 800c9b4:	7883      	ldrb	r3, [r0, #2]
 800c9b6:	460d      	mov	r5, r1
 800c9b8:	4604      	mov	r4, r0
 800c9ba:	2b01      	cmp	r3, #1
 800c9bc:	d00f      	beq.n	800c9de <USBH_Get_DevDesc+0x32>
  switch (phost->RequestState)
 800c9be:	2b02      	cmp	r3, #2
 800c9c0:	d10a      	bne.n	800c9d8 <USBH_Get_DevDesc+0x2c>
      status = USBH_HandleControl(phost);
 800c9c2:	f7ff ff1f 	bl	800c804 <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800c9c6:	4603      	mov	r3, r0
 800c9c8:	b1b8      	cbz	r0, 800c9fa <USBH_Get_DevDesc+0x4e>
 800c9ca:	2803      	cmp	r0, #3
 800c9cc:	d015      	beq.n	800c9fa <USBH_Get_DevDesc+0x4e>
      else if (status == USBH_FAIL)
 800c9ce:	2802      	cmp	r0, #2
 800c9d0:	d103      	bne.n	800c9da <USBH_Get_DevDesc+0x2e>
        phost->RequestState = CMD_SEND;
 800c9d2:	2201      	movs	r2, #1
 800c9d4:	70a2      	strb	r2, [r4, #2]
  if (status == USBH_OK)
 800c9d6:	e000      	b.n	800c9da <USBH_Get_DevDesc+0x2e>
  switch (phost->RequestState)
 800c9d8:	2301      	movs	r3, #1
}
 800c9da:	4618      	mov	r0, r3
 800c9dc:	bd38      	pop	{r3, r4, r5, pc}
      phost->Control.setup.b.wIndex.w = 0U;
 800c9de:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800c9e0:	483b      	ldr	r0, [pc, #236]	; (800cad0 <USBH_Get_DevDesc+0x124>)
    phost->Control.setup.b.wLength.w = length;
 800c9e2:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
 800c9e4:	81a1      	strh	r1, [r4, #12]
      phost->RequestState = CMD_WAIT;
 800c9e6:	2102      	movs	r1, #2
      phost->Control.setup.b.wIndex.w = 0U;
 800c9e8:	82a2      	strh	r2, [r4, #20]
                              USB_DESC_DEVICE, phost->device.Data, length);
 800c9ea:	f504 7207 	add.w	r2, r4, #540	; 0x21c
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800c9ee:	6120      	str	r0, [r4, #16]
}
 800c9f0:	4618      	mov	r0, r3
      phost->Control.state = CTRL_SETUP;
 800c9f2:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 800c9f4:	70a1      	strb	r1, [r4, #2]
      phost->Control.buff = buff;
 800c9f6:	60a2      	str	r2, [r4, #8]
}
 800c9f8:	bd38      	pop	{r3, r4, r5, pc}
        phost->RequestState = CMD_SEND;
 800c9fa:	2101      	movs	r1, #1
        phost->Control.state = CTRL_IDLE;
 800c9fc:	2200      	movs	r2, #0
        phost->RequestState = CMD_SEND;
 800c9fe:	70a1      	strb	r1, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800ca00:	7622      	strb	r2, [r4, #24]
  if (status == USBH_OK)
 800ca02:	2b00      	cmp	r3, #0
 800ca04:	d1e9      	bne.n	800c9da <USBH_Get_DevDesc+0x2e>
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1U);
 800ca06:	f894 221d 	ldrb.w	r2, [r4, #541]	; 0x21d
  dev_desc->bLength            = *(uint8_t *)(buf +  0U);
 800ca0a:	f894 121c 	ldrb.w	r1, [r4, #540]	; 0x21c
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1U);
 800ca0e:	f884 2427 	strb.w	r2, [r4, #1063]	; 0x427
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4U);
 800ca12:	f894 2220 	ldrb.w	r2, [r4, #544]	; 0x220
  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 800ca16:	f894 041d 	ldrb.w	r0, [r4, #1053]	; 0x41d
  dev_desc->bLength            = *(uint8_t *)(buf +  0U);
 800ca1a:	f884 1426 	strb.w	r1, [r4, #1062]	; 0x426
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4U);
 800ca1e:	f884 242a 	strb.w	r2, [r4, #1066]	; 0x42a
  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 800ca22:	2801      	cmp	r0, #1
  dev_desc->bcdUSB             = LE16(buf +  2U);
 800ca24:	f8b4 121e 	ldrh.w	r1, [r4, #542]	; 0x21e
  dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6U);
 800ca28:	f894 2222 	ldrb.w	r2, [r4, #546]	; 0x222
  dev_desc->bcdUSB             = LE16(buf +  2U);
 800ca2c:	f8a4 1428 	strh.w	r1, [r4, #1064]	; 0x428
  dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6U);
 800ca30:	f884 242c 	strb.w	r2, [r4, #1068]	; 0x42c
  dev_desc->bDeviceSubClass    = *(uint8_t *)(buf +  5U);
 800ca34:	f894 1221 	ldrb.w	r1, [r4, #545]	; 0x221
  dev_desc->bMaxPacketSize     = *(uint8_t *)(buf +  7U);
 800ca38:	f894 2223 	ldrb.w	r2, [r4, #547]	; 0x223
  dev_desc->bDeviceSubClass    = *(uint8_t *)(buf +  5U);
 800ca3c:	f884 142b 	strb.w	r1, [r4, #1067]	; 0x42b
  dev_desc->bMaxPacketSize     = *(uint8_t *)(buf +  7U);
 800ca40:	f884 242d 	strb.w	r2, [r4, #1069]	; 0x42d
  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 800ca44:	d92e      	bls.n	800caa4 <USBH_Get_DevDesc+0xf8>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 800ca46:	2802      	cmp	r0, #2
 800ca48:	d03f      	beq.n	800caca <USBH_Get_DevDesc+0x11e>
    status = USBH_NOT_SUPPORTED;
 800ca4a:	2303      	movs	r3, #3
  if (length > 8U)
 800ca4c:	2d08      	cmp	r5, #8
 800ca4e:	d9c4      	bls.n	800c9da <USBH_Get_DevDesc+0x2e>
    dev_desc->idProduct          = LE16(buf + 10U);
 800ca50:	f8b4 2226 	ldrh.w	r2, [r4, #550]	; 0x226
    dev_desc->idVendor           = LE16(buf +  8U);
 800ca54:	f8b4 0224 	ldrh.w	r0, [r4, #548]	; 0x224
    dev_desc->bcdDevice          = LE16(buf + 12U);
 800ca58:	f8b4 1228 	ldrh.w	r1, [r4, #552]	; 0x228
    dev_desc->idProduct          = LE16(buf + 10U);
 800ca5c:	f8a4 2430 	strh.w	r2, [r4, #1072]	; 0x430
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14U);
 800ca60:	f894 222a 	ldrb.w	r2, [r4, #554]	; 0x22a
    dev_desc->idVendor           = LE16(buf +  8U);
 800ca64:	f8a4 042e 	strh.w	r0, [r4, #1070]	; 0x42e
    dev_desc->bcdDevice          = LE16(buf + 12U);
 800ca68:	f8a4 1432 	strh.w	r1, [r4, #1074]	; 0x432
    dev_desc->iProduct           = *(uint8_t *)(buf + 15U);
 800ca6c:	f894 022b 	ldrb.w	r0, [r4, #555]	; 0x22b
    dev_desc->iSerialNumber      = *(uint8_t *)(buf + 16U);
 800ca70:	f894 122c 	ldrb.w	r1, [r4, #556]	; 0x22c
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14U);
 800ca74:	f884 2434 	strb.w	r2, [r4, #1076]	; 0x434
    dev_desc->bNumConfigurations = *(uint8_t *)(buf + 17U);
 800ca78:	f894 222d 	ldrb.w	r2, [r4, #557]	; 0x22d
    dev_desc->iProduct           = *(uint8_t *)(buf + 15U);
 800ca7c:	f884 0435 	strb.w	r0, [r4, #1077]	; 0x435
}
 800ca80:	4618      	mov	r0, r3
    dev_desc->iSerialNumber      = *(uint8_t *)(buf + 16U);
 800ca82:	f884 1436 	strb.w	r1, [r4, #1078]	; 0x436
    dev_desc->bNumConfigurations = *(uint8_t *)(buf + 17U);
 800ca86:	f884 2437 	strb.w	r2, [r4, #1079]	; 0x437
}
 800ca8a:	bd38      	pop	{r3, r4, r5, pc}
    USBH_ErrLog("Control error: Get Device Descriptor failed, data buffer size issue");
 800ca8c:	4811      	ldr	r0, [pc, #68]	; (800cad4 <USBH_Get_DevDesc+0x128>)
 800ca8e:	f001 fe5d 	bl	800e74c <printf>
 800ca92:	4811      	ldr	r0, [pc, #68]	; (800cad8 <USBH_Get_DevDesc+0x12c>)
 800ca94:	f001 fe5a 	bl	800e74c <printf>
 800ca98:	200a      	movs	r0, #10
 800ca9a:	f001 fe6b 	bl	800e774 <putchar>
    return USBH_NOT_SUPPORTED;
 800ca9e:	2303      	movs	r3, #3
}
 800caa0:	4618      	mov	r0, r3
 800caa2:	bd38      	pop	{r3, r4, r5, pc}
    switch (dev_desc->bMaxPacketSize)
 800caa4:	2a20      	cmp	r2, #32
 800caa6:	d805      	bhi.n	800cab4 <USBH_Get_DevDesc+0x108>
 800caa8:	2a07      	cmp	r2, #7
 800caaa:	d806      	bhi.n	800caba <USBH_Get_DevDesc+0x10e>
      dev_desc->bMaxPacketSize = 8U;
 800caac:	2208      	movs	r2, #8
 800caae:	f884 242d 	strb.w	r2, [r4, #1069]	; 0x42d
 800cab2:	e7cb      	b.n	800ca4c <USBH_Get_DevDesc+0xa0>
    switch (dev_desc->bMaxPacketSize)
 800cab4:	2a40      	cmp	r2, #64	; 0x40
 800cab6:	d1f9      	bne.n	800caac <USBH_Get_DevDesc+0x100>
 800cab8:	e7c8      	b.n	800ca4c <USBH_Get_DevDesc+0xa0>
 800caba:	3a08      	subs	r2, #8
 800cabc:	4907      	ldr	r1, [pc, #28]	; (800cadc <USBH_Get_DevDesc+0x130>)
 800cabe:	b2d2      	uxtb	r2, r2
 800cac0:	fa21 f202 	lsr.w	r2, r1, r2
 800cac4:	07d2      	lsls	r2, r2, #31
 800cac6:	d5f1      	bpl.n	800caac <USBH_Get_DevDesc+0x100>
 800cac8:	e7c0      	b.n	800ca4c <USBH_Get_DevDesc+0xa0>
    if (dev_desc->bMaxPacketSize != 8U)
 800caca:	2a08      	cmp	r2, #8
 800cacc:	d1ee      	bne.n	800caac <USBH_Get_DevDesc+0x100>
 800cace:	e7bd      	b.n	800ca4c <USBH_Get_DevDesc+0xa0>
 800cad0:	01000680 	.word	0x01000680
 800cad4:	0801540c 	.word	0x0801540c
 800cad8:	080158cc 	.word	0x080158cc
 800cadc:	01000101 	.word	0x01000101

0800cae0 <USBH_Get_CfgDesc>:
  if (length > sizeof(phost->device.CfgDesc_Raw))
 800cae0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
{
 800cae4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cae8:	b085      	sub	sp, #20
  if (length > sizeof(phost->device.CfgDesc_Raw))
 800caea:	d86c      	bhi.n	800cbc6 <USBH_Get_CfgDesc+0xe6>
  if (phost->RequestState == CMD_SEND)
 800caec:	7882      	ldrb	r2, [r0, #2]
 800caee:	4604      	mov	r4, r0
 800caf0:	460e      	mov	r6, r1
 800caf2:	f100 051c 	add.w	r5, r0, #28
 800caf6:	2a01      	cmp	r2, #1
 800caf8:	d011      	beq.n	800cb1e <USBH_Get_CfgDesc+0x3e>
  switch (phost->RequestState)
 800cafa:	2a02      	cmp	r2, #2
 800cafc:	d10a      	bne.n	800cb14 <USBH_Get_CfgDesc+0x34>
      status = USBH_HandleControl(phost);
 800cafe:	f7ff fe81 	bl	800c804 <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800cb02:	4602      	mov	r2, r0
 800cb04:	b1c8      	cbz	r0, 800cb3a <USBH_Get_CfgDesc+0x5a>
 800cb06:	2803      	cmp	r0, #3
 800cb08:	d017      	beq.n	800cb3a <USBH_Get_CfgDesc+0x5a>
      else if (status == USBH_FAIL)
 800cb0a:	2802      	cmp	r0, #2
 800cb0c:	d103      	bne.n	800cb16 <USBH_Get_CfgDesc+0x36>
        phost->RequestState = CMD_SEND;
 800cb0e:	2301      	movs	r3, #1
 800cb10:	70a3      	strb	r3, [r4, #2]
  if (status == USBH_OK)
 800cb12:	e000      	b.n	800cb16 <USBH_Get_CfgDesc+0x36>
  switch (phost->RequestState)
 800cb14:	2201      	movs	r2, #1
}
 800cb16:	4610      	mov	r0, r2
 800cb18:	b005      	add	sp, #20
 800cb1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800cb1e:	4895      	ldr	r0, [pc, #596]	; (800cd74 <USBH_Get_CfgDesc+0x294>)
      phost->RequestState = CMD_WAIT;
 800cb20:	2302      	movs	r3, #2
    phost->Control.setup.b.wLength.w = length;
 800cb22:	82e1      	strh	r1, [r4, #22]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800cb24:	6120      	str	r0, [r4, #16]
      phost->Control.setup.b.wIndex.w = 0U;
 800cb26:	2000      	movs	r0, #0
      phost->Control.buff = buff;
 800cb28:	60a5      	str	r5, [r4, #8]
      phost->Control.setup.b.wIndex.w = 0U;
 800cb2a:	82a0      	strh	r0, [r4, #20]
}
 800cb2c:	4610      	mov	r0, r2
      phost->Control.length = length;
 800cb2e:	81a1      	strh	r1, [r4, #12]
      phost->Control.state = CTRL_SETUP;
 800cb30:	7622      	strb	r2, [r4, #24]
      phost->RequestState = CMD_WAIT;
 800cb32:	70a3      	strb	r3, [r4, #2]
}
 800cb34:	b005      	add	sp, #20
 800cb36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        phost->RequestState = CMD_SEND;
 800cb3a:	2301      	movs	r3, #1
 800cb3c:	70a3      	strb	r3, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800cb3e:	2300      	movs	r3, #0
 800cb40:	7623      	strb	r3, [r4, #24]
  if (status == USBH_OK)
 800cb42:	2a00      	cmp	r2, #0
 800cb44:	d1e7      	bne.n	800cb16 <USBH_Get_CfgDesc+0x36>
  if (pdesc->bLength != USB_CONFIGURATION_DESC_SIZE)
 800cb46:	7f23      	ldrb	r3, [r4, #28]
 800cb48:	2b09      	cmp	r3, #9
 800cb4a:	d001      	beq.n	800cb50 <USBH_Get_CfgDesc+0x70>
    pdesc->bLength = USB_CONFIGURATION_DESC_SIZE;
 800cb4c:	2309      	movs	r3, #9
 800cb4e:	7723      	strb	r3, [r4, #28]
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 800cb50:	8be1      	ldrh	r1, [r4, #30]
  cfg_desc->bLength             = *(uint8_t *)(buf + 0U);
 800cb52:	2309      	movs	r3, #9
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 800cb54:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  cfg_desc->bLength             = *(uint8_t *)(buf + 0U);
 800cb58:	f884 3438 	strb.w	r3, [r4, #1080]	; 0x438
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 800cb5c:	bf28      	it	cs
 800cb5e:	f44f 7100 	movcs.w	r1, #512	; 0x200
  if (length > USB_CONFIGURATION_DESC_SIZE)
 800cb62:	429e      	cmp	r6, r3
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 800cb64:	468a      	mov	sl, r1
 800cb66:	f8a4 143a 	strh.w	r1, [r4, #1082]	; 0x43a
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1U);
 800cb6a:	7f61      	ldrb	r1, [r4, #29]
 800cb6c:	f884 1439 	strb.w	r1, [r4, #1081]	; 0x439
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4U);
 800cb70:	f894 1020 	ldrb.w	r1, [r4, #32]
 800cb74:	9100      	str	r1, [sp, #0]
 800cb76:	f884 143c 	strb.w	r1, [r4, #1084]	; 0x43c
  cfg_desc->bConfigurationValue = *(uint8_t *)(buf + 5U);
 800cb7a:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
 800cb7e:	f884 143d 	strb.w	r1, [r4, #1085]	; 0x43d
  cfg_desc->iConfiguration      = *(uint8_t *)(buf + 6U);
 800cb82:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
 800cb86:	f884 143e 	strb.w	r1, [r4, #1086]	; 0x43e
  cfg_desc->bmAttributes        = *(uint8_t *)(buf + 7U);
 800cb8a:	f894 1023 	ldrb.w	r1, [r4, #35]	; 0x23
 800cb8e:	f884 143f 	strb.w	r1, [r4, #1087]	; 0x43f
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8U);
 800cb92:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
 800cb96:	f884 1440 	strb.w	r1, [r4, #1088]	; 0x440
  if (length > USB_CONFIGURATION_DESC_SIZE)
 800cb9a:	d9bc      	bls.n	800cb16 <USBH_Get_CfgDesc+0x36>
  USBH_StatusTypeDef           status = USBH_OK;
 800cb9c:	f04f 0b00 	mov.w	fp, #0
 800cba0:	46a0      	mov	r8, r4
  if (length > USB_CONFIGURATION_DESC_SIZE)
 800cba2:	46d9      	mov	r9, fp
 800cba4:	fa5f f189 	uxtb.w	r1, r9
 800cba8:	e008      	b.n	800cbbc <USBH_Get_CfgDesc+0xdc>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800cbaa:	459a      	cmp	sl, r3
 800cbac:	d919      	bls.n	800cbe2 <USBH_Get_CfgDesc+0x102>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800cbae:	782a      	ldrb	r2, [r5, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 800cbb0:	4415      	add	r5, r2
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800cbb2:	4413      	add	r3, r2
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 800cbb4:	786a      	ldrb	r2, [r5, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800cbb6:	b29b      	uxth	r3, r3
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 800cbb8:	2a04      	cmp	r2, #4
 800cbba:	d01a      	beq.n	800cbf2 <USBH_Get_CfgDesc+0x112>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800cbbc:	f1b9 0f02 	cmp.w	r9, #2
 800cbc0:	d1f3      	bne.n	800cbaa <USBH_Get_CfgDesc+0xca>
 800cbc2:	465a      	mov	r2, fp
 800cbc4:	e7a7      	b.n	800cb16 <USBH_Get_CfgDesc+0x36>
    USBH_ErrLog("Control error: Get configuration Descriptor failed, data buffer size issue");
 800cbc6:	486c      	ldr	r0, [pc, #432]	; (800cd78 <USBH_Get_CfgDesc+0x298>)
 800cbc8:	f001 fdc0 	bl	800e74c <printf>
 800cbcc:	486b      	ldr	r0, [pc, #428]	; (800cd7c <USBH_Get_CfgDesc+0x29c>)
 800cbce:	f001 fdbd 	bl	800e74c <printf>
 800cbd2:	200a      	movs	r0, #10
 800cbd4:	f001 fdce 	bl	800e774 <putchar>
    return USBH_NOT_SUPPORTED;
 800cbd8:	2203      	movs	r2, #3
}
 800cbda:	4610      	mov	r0, r2
 800cbdc:	b005      	add	sp, #20
 800cbde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (if_ix < MIN(cfg_desc->bNumInterfaces, (uint8_t)USBH_MAX_NUM_INTERFACES))
 800cbe2:	9b00      	ldr	r3, [sp, #0]
 800cbe4:	2b02      	cmp	r3, #2
 800cbe6:	bf28      	it	cs
 800cbe8:	2302      	movcs	r3, #2
 800cbea:	428b      	cmp	r3, r1
 800cbec:	d9e9      	bls.n	800cbc2 <USBH_Get_CfgDesc+0xe2>
          return USBH_NOT_SUPPORTED;
 800cbee:	2203      	movs	r2, #3
 800cbf0:	e791      	b.n	800cb16 <USBH_Get_CfgDesc+0x36>
        if (pdesc->bLength != USB_INTERFACE_DESC_SIZE)
 800cbf2:	782a      	ldrb	r2, [r5, #0]
 800cbf4:	2a09      	cmp	r2, #9
 800cbf6:	d002      	beq.n	800cbfe <USBH_Get_CfgDesc+0x11e>
          pdesc->bLength = USB_INTERFACE_DESC_SIZE;
 800cbf8:	f04f 0209 	mov.w	r2, #9
 800cbfc:	702a      	strb	r2, [r5, #0]
  if_descriptor->bLength            = *(uint8_t *)(buf + 0U);
 800cbfe:	f04f 0209 	mov.w	r2, #9
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 800cc02:	202a      	movs	r0, #42	; 0x2a
  if_descriptor->bLength            = *(uint8_t *)(buf + 0U);
 800cc04:	f888 2442 	strb.w	r2, [r8, #1090]	; 0x442
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1U);
 800cc08:	786a      	ldrb	r2, [r5, #1]
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 800cc0a:	fb00 f009 	mul.w	r0, r0, r9
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1U);
 800cc0e:	f888 2443 	strb.w	r2, [r8, #1091]	; 0x443
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2U);
 800cc12:	78aa      	ldrb	r2, [r5, #2]
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 800cc14:	9001      	str	r0, [sp, #4]
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2U);
 800cc16:	f888 2444 	strb.w	r2, [r8, #1092]	; 0x444
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3U);
 800cc1a:	78ea      	ldrb	r2, [r5, #3]
 800cc1c:	f888 2445 	strb.w	r2, [r8, #1093]	; 0x445
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4U);
 800cc20:	7929      	ldrb	r1, [r5, #4]
 800cc22:	f888 1446 	strb.w	r1, [r8, #1094]	; 0x446
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5U);
 800cc26:	f895 e005 	ldrb.w	lr, [r5, #5]
 800cc2a:	f888 e447 	strb.w	lr, [r8, #1095]	; 0x447
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6U);
 800cc2e:	79aa      	ldrb	r2, [r5, #6]
 800cc30:	f888 2448 	strb.w	r2, [r8, #1096]	; 0x448
                ((pif->bInterfaceSubClass == 0x02U) || (pif->bInterfaceSubClass == 0x03U)))
 800cc34:	3a02      	subs	r2, #2
            if ((pif->bInterfaceClass == 0x01U) &&
 800cc36:	b2d2      	uxtb	r2, r2
 800cc38:	9202      	str	r2, [sp, #8]
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7U);
 800cc3a:	79ea      	ldrb	r2, [r5, #7]
 800cc3c:	9203      	str	r2, [sp, #12]
 800cc3e:	f888 2449 	strb.w	r2, [r8, #1097]	; 0x449
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8U);
 800cc42:	7a2a      	ldrb	r2, [r5, #8]
 800cc44:	f888 244a 	strb.w	r2, [r8, #1098]	; 0x44a
        ep_ix = 0U;
 800cc48:	2200      	movs	r2, #0
        while ((ep_ix < USBH_MAX_NUM_ENDPOINTS) && (ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800cc4a:	4291      	cmp	r1, r2
 800cc4c:	d94d      	bls.n	800ccea <USBH_Get_CfgDesc+0x20a>
 800cc4e:	459a      	cmp	sl, r3
 800cc50:	d9cd      	bls.n	800cbee <USBH_Get_CfgDesc+0x10e>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800cc52:	7828      	ldrb	r0, [r5, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 800cc54:	4405      	add	r5, r0
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800cc56:	4418      	add	r0, r3
 800cc58:	b283      	uxth	r3, r0
          if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 800cc5a:	7868      	ldrb	r0, [r5, #1]
 800cc5c:	2805      	cmp	r0, #5
 800cc5e:	d1f4      	bne.n	800cc4a <USBH_Get_CfgDesc+0x16a>
            if ((pif->bInterfaceClass == 0x01U) &&
 800cc60:	f1be 0f01 	cmp.w	lr, #1
 800cc64:	d046      	beq.n	800ccf4 <USBH_Get_CfgDesc+0x214>
              pdesc->bLength = USB_ENDPOINT_DESC_SIZE;
 800cc66:	f04f 0007 	mov.w	r0, #7
 800cc6a:	2607      	movs	r6, #7
 800cc6c:	7028      	strb	r0, [r5, #0]
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 800cc6e:	3201      	adds	r2, #1
 800cc70:	9801      	ldr	r0, [sp, #4]
 800cc72:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 800cc76:	4420      	add	r0, r4
 800cc78:	f880 6444 	strb.w	r6, [r0, #1092]	; 0x444
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1U);
 800cc7c:	786e      	ldrb	r6, [r5, #1]
 800cc7e:	f880 6445 	strb.w	r6, [r0, #1093]	; 0x445
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2U);
 800cc82:	78ae      	ldrb	r6, [r5, #2]
 800cc84:	f880 6446 	strb.w	r6, [r0, #1094]	; 0x446
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3U);
 800cc88:	78ee      	ldrb	r6, [r5, #3]
 800cc8a:	f880 6447 	strb.w	r6, [r0, #1095]	; 0x447
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4U);
 800cc8e:	88af      	ldrh	r7, [r5, #4]
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 800cc90:	f107 3cff 	add.w	ip, r7, #4294967295
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4U);
 800cc94:	f8a0 7448 	strh.w	r7, [r0, #1096]	; 0x448
    status = USBH_NOT_SUPPORTED;
 800cc98:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6U);
 800cc9c:	f895 c006 	ldrb.w	ip, [r5, #6]
 800cca0:	f880 c44a 	strb.w	ip, [r0, #1098]	; 0x44a
    status = USBH_NOT_SUPPORTED;
 800cca4:	bf38      	it	cc
 800cca6:	f04f 0b00 	movcc.w	fp, #0
  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 800ccaa:	f894 041d 	ldrb.w	r0, [r4, #1053]	; 0x41d
    status = USBH_NOT_SUPPORTED;
 800ccae:	bf28      	it	cs
 800ccb0:	f04f 0b03 	movcs.w	fp, #3
  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 800ccb4:	b970      	cbnz	r0, 800ccd4 <USBH_Get_CfgDesc+0x1f4>
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK)
 800ccb6:	f006 0003 	and.w	r0, r6, #3
 800ccba:	2802      	cmp	r0, #2
 800ccbc:	d035      	beq.n	800cd2a <USBH_Get_CfgDesc+0x24a>
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 800ccbe:	b338      	cbz	r0, 800cd10 <USBH_Get_CfgDesc+0x230>
    else if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC) ||
 800ccc0:	07f6      	lsls	r6, r6, #31
 800ccc2:	d50b      	bpl.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 800ccc4:	f10c 3cff 	add.w	ip, ip, #4294967295
        status = USBH_NOT_SUPPORTED;
 800ccc8:	f1bc 0f0f 	cmp.w	ip, #15
 800cccc:	bf88      	it	hi
 800ccce:	f04f 0b03 	movhi.w	fp, #3
 800ccd2:	e005      	b.n	800cce0 <USBH_Get_CfgDesc+0x200>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_FULL)
 800ccd4:	2801      	cmp	r0, #1
 800ccd6:	d02e      	beq.n	800cd36 <USBH_Get_CfgDesc+0x256>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 800ccd8:	2802      	cmp	r0, #2
 800ccda:	d01e      	beq.n	800cd1a <USBH_Get_CfgDesc+0x23a>
        status = USBH_NOT_SUPPORTED;
 800ccdc:	f04f 0b03 	mov.w	fp, #3
            ep_ix++;
 800cce0:	b2d2      	uxtb	r2, r2
        while ((ep_ix < USBH_MAX_NUM_ENDPOINTS) && (ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800cce2:	2a04      	cmp	r2, #4
 800cce4:	d1b1      	bne.n	800cc4a <USBH_Get_CfgDesc+0x16a>
        if (ep_ix < pif->bNumEndpoints)
 800cce6:	2904      	cmp	r1, #4
 800cce8:	d881      	bhi.n	800cbee <USBH_Get_CfgDesc+0x10e>
        if_ix++;
 800ccea:	f109 0901 	add.w	r9, r9, #1
 800ccee:	f108 082a 	add.w	r8, r8, #42	; 0x2a
 800ccf2:	e757      	b.n	800cba4 <USBH_Get_CfgDesc+0xc4>
            if ((pif->bInterfaceClass == 0x01U) &&
 800ccf4:	9802      	ldr	r0, [sp, #8]
 800ccf6:	2801      	cmp	r0, #1
 800ccf8:	d8b5      	bhi.n	800cc66 <USBH_Get_CfgDesc+0x186>
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800ccfa:	9803      	ldr	r0, [sp, #12]
 800ccfc:	782e      	ldrb	r6, [r5, #0]
 800ccfe:	2800      	cmp	r0, #0
 800cd00:	d1b5      	bne.n	800cc6e <USBH_Get_CfgDesc+0x18e>
 800cd02:	2e09      	cmp	r6, #9
 800cd04:	d0b3      	beq.n	800cc6e <USBH_Get_CfgDesc+0x18e>
                pdesc->bLength = 0x09U;
 800cd06:	f04f 0009 	mov.w	r0, #9
 800cd0a:	2609      	movs	r6, #9
 800cd0c:	7028      	strb	r0, [r5, #0]
 800cd0e:	e7ae      	b.n	800cc6e <USBH_Get_CfgDesc+0x18e>
        status = USBH_NOT_SUPPORTED;
 800cd10:	2f41      	cmp	r7, #65	; 0x41
 800cd12:	bf28      	it	cs
 800cd14:	f04f 0b03 	movcs.w	fp, #3
 800cd18:	e7e2      	b.n	800cce0 <USBH_Get_CfgDesc+0x200>
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 800cd1a:	f016 0603 	ands.w	r6, r6, #3
 800cd1e:	d118      	bne.n	800cd52 <USBH_Get_CfgDesc+0x272>
        status = USBH_NOT_SUPPORTED;
 800cd20:	2f08      	cmp	r7, #8
 800cd22:	bf18      	it	ne
 800cd24:	f04f 0b03 	movne.w	fp, #3
 800cd28:	e7da      	b.n	800cce0 <USBH_Get_CfgDesc+0x200>
 800cd2a:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
 800cd2e:	bf88      	it	hi
 800cd30:	f04f 0b03 	movhi.w	fp, #3
 800cd34:	e7d4      	b.n	800cce0 <USBH_Get_CfgDesc+0x200>
    if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK) ||
 800cd36:	07f0      	lsls	r0, r6, #31
 800cd38:	d5ea      	bpl.n	800cd10 <USBH_Get_CfgDesc+0x230>
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC)
 800cd3a:	f006 0603 	and.w	r6, r6, #3
 800cd3e:	2e01      	cmp	r6, #1
 800cd40:	d00f      	beq.n	800cd62 <USBH_Get_CfgDesc+0x282>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 1023U))
 800cd42:	f240 30ff 	movw	r0, #1023	; 0x3ff
 800cd46:	4287      	cmp	r7, r0
 800cd48:	d8c8      	bhi.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 8U))
 800cd4a:	f1bc 0f00 	cmp.w	ip, #0
 800cd4e:	d1c7      	bne.n	800cce0 <USBH_Get_CfgDesc+0x200>
 800cd50:	e7c4      	b.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_INTR)
 800cd52:	2e03      	cmp	r6, #3
 800cd54:	d1c2      	bne.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 8U))
 800cd56:	2f08      	cmp	r7, #8
 800cd58:	d8c0      	bhi.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
 800cd5a:	f1bc 0f00 	cmp.w	ip, #0
 800cd5e:	d1bf      	bne.n	800cce0 <USBH_Get_CfgDesc+0x200>
 800cd60:	e7bc      	b.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
      if ((ep_descriptor->bInterval == 0U) ||
 800cd62:	f10c 3cff 	add.w	ip, ip, #4294967295
          (ep_descriptor->bInterval > 0x10U) ||
 800cd66:	f1bc 0f0f 	cmp.w	ip, #15
 800cd6a:	d8b7      	bhi.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
 800cd6c:	2f40      	cmp	r7, #64	; 0x40
 800cd6e:	d9b7      	bls.n	800cce0 <USBH_Get_CfgDesc+0x200>
 800cd70:	e7b4      	b.n	800ccdc <USBH_Get_CfgDesc+0x1fc>
 800cd72:	bf00      	nop
 800cd74:	02000680 	.word	0x02000680
 800cd78:	0801540c 	.word	0x0801540c
 800cd7c:	08015910 	.word	0x08015910

0800cd80 <USBH_SetAddress>:
{
 800cd80:	b510      	push	{r4, lr}
  if (phost->RequestState == CMD_SEND)
 800cd82:	7883      	ldrb	r3, [r0, #2]
{
 800cd84:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 800cd86:	2b01      	cmp	r3, #1
 800cd88:	d00f      	beq.n	800cdaa <USBH_SetAddress+0x2a>
  switch (phost->RequestState)
 800cd8a:	2b02      	cmp	r3, #2
 800cd8c:	d10a      	bne.n	800cda4 <USBH_SetAddress+0x24>
      status = USBH_HandleControl(phost);
 800cd8e:	f7ff fd39 	bl	800c804 <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800cd92:	4603      	mov	r3, r0
 800cd94:	b1b0      	cbz	r0, 800cdc4 <USBH_SetAddress+0x44>
 800cd96:	2803      	cmp	r0, #3
 800cd98:	d014      	beq.n	800cdc4 <USBH_SetAddress+0x44>
      else if (status == USBH_FAIL)
 800cd9a:	2802      	cmp	r0, #2
 800cd9c:	d103      	bne.n	800cda6 <USBH_SetAddress+0x26>
        phost->RequestState = CMD_SEND;
 800cd9e:	2201      	movs	r2, #1
 800cda0:	70a2      	strb	r2, [r4, #2]
 800cda2:	e000      	b.n	800cda6 <USBH_SetAddress+0x26>
  switch (phost->RequestState)
 800cda4:	2301      	movs	r3, #1
}
 800cda6:	4618      	mov	r0, r3
 800cda8:	bd10      	pop	{r4, pc}
      phost->Control.buff = buff;
 800cdaa:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 800cdac:	f44f 60a0 	mov.w	r0, #1280	; 0x500
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 800cdb0:	8261      	strh	r1, [r4, #18]
      phost->RequestState = CMD_WAIT;
 800cdb2:	2102      	movs	r1, #2
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 800cdb4:	8220      	strh	r0, [r4, #16]
}
 800cdb6:	4618      	mov	r0, r3
      phost->Control.buff = buff;
 800cdb8:	60a2      	str	r2, [r4, #8]
      phost->Control.length = length;
 800cdba:	81a2      	strh	r2, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 800cdbc:	6162      	str	r2, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 800cdbe:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 800cdc0:	70a1      	strb	r1, [r4, #2]
}
 800cdc2:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 800cdc4:	2101      	movs	r1, #1
        phost->Control.state = CTRL_IDLE;
 800cdc6:	2200      	movs	r2, #0
}
 800cdc8:	4618      	mov	r0, r3
        phost->RequestState = CMD_SEND;
 800cdca:	70a1      	strb	r1, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800cdcc:	7622      	strb	r2, [r4, #24]
}
 800cdce:	bd10      	pop	{r4, pc}

0800cdd0 <USBH_SetCfg>:
{
 800cdd0:	b510      	push	{r4, lr}
  if (phost->RequestState == CMD_SEND)
 800cdd2:	7883      	ldrb	r3, [r0, #2]
{
 800cdd4:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 800cdd6:	2b01      	cmp	r3, #1
 800cdd8:	d00f      	beq.n	800cdfa <USBH_SetCfg+0x2a>
  switch (phost->RequestState)
 800cdda:	2b02      	cmp	r3, #2
 800cddc:	d10a      	bne.n	800cdf4 <USBH_SetCfg+0x24>
      status = USBH_HandleControl(phost);
 800cdde:	f7ff fd11 	bl	800c804 <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800cde2:	4603      	mov	r3, r0
 800cde4:	b1b0      	cbz	r0, 800ce14 <USBH_SetCfg+0x44>
 800cde6:	2803      	cmp	r0, #3
 800cde8:	d014      	beq.n	800ce14 <USBH_SetCfg+0x44>
      else if (status == USBH_FAIL)
 800cdea:	2802      	cmp	r0, #2
 800cdec:	d103      	bne.n	800cdf6 <USBH_SetCfg+0x26>
        phost->RequestState = CMD_SEND;
 800cdee:	2201      	movs	r2, #1
 800cdf0:	70a2      	strb	r2, [r4, #2]
 800cdf2:	e000      	b.n	800cdf6 <USBH_SetCfg+0x26>
  switch (phost->RequestState)
 800cdf4:	2301      	movs	r3, #1
}
 800cdf6:	4618      	mov	r0, r3
 800cdf8:	bd10      	pop	{r4, pc}
      phost->Control.buff = buff;
 800cdfa:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800cdfc:	f44f 6010 	mov.w	r0, #2304	; 0x900
    phost->Control.setup.b.wValue.w = cfg_idx;
 800ce00:	8261      	strh	r1, [r4, #18]
      phost->RequestState = CMD_WAIT;
 800ce02:	2102      	movs	r1, #2
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800ce04:	8220      	strh	r0, [r4, #16]
}
 800ce06:	4618      	mov	r0, r3
      phost->Control.buff = buff;
 800ce08:	60a2      	str	r2, [r4, #8]
      phost->Control.length = length;
 800ce0a:	81a2      	strh	r2, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 800ce0c:	6162      	str	r2, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 800ce0e:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 800ce10:	70a1      	strb	r1, [r4, #2]
}
 800ce12:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 800ce14:	2101      	movs	r1, #1
        phost->Control.state = CTRL_IDLE;
 800ce16:	2200      	movs	r2, #0
}
 800ce18:	4618      	mov	r0, r3
        phost->RequestState = CMD_SEND;
 800ce1a:	70a1      	strb	r1, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800ce1c:	7622      	strb	r2, [r4, #24]
}
 800ce1e:	bd10      	pop	{r4, pc}

0800ce20 <USBH_SetFeature>:
{
 800ce20:	b510      	push	{r4, lr}
  if (phost->RequestState == CMD_SEND)
 800ce22:	7883      	ldrb	r3, [r0, #2]
{
 800ce24:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 800ce26:	2b01      	cmp	r3, #1
 800ce28:	d00f      	beq.n	800ce4a <USBH_SetFeature+0x2a>
  switch (phost->RequestState)
 800ce2a:	2b02      	cmp	r3, #2
 800ce2c:	d10a      	bne.n	800ce44 <USBH_SetFeature+0x24>
      status = USBH_HandleControl(phost);
 800ce2e:	f7ff fce9 	bl	800c804 <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800ce32:	4603      	mov	r3, r0
 800ce34:	b1b0      	cbz	r0, 800ce64 <USBH_SetFeature+0x44>
 800ce36:	2803      	cmp	r0, #3
 800ce38:	d014      	beq.n	800ce64 <USBH_SetFeature+0x44>
      else if (status == USBH_FAIL)
 800ce3a:	2802      	cmp	r0, #2
 800ce3c:	d103      	bne.n	800ce46 <USBH_SetFeature+0x26>
        phost->RequestState = CMD_SEND;
 800ce3e:	2201      	movs	r2, #1
 800ce40:	70a2      	strb	r2, [r4, #2]
 800ce42:	e000      	b.n	800ce46 <USBH_SetFeature+0x26>
  switch (phost->RequestState)
 800ce44:	2301      	movs	r3, #1
}
 800ce46:	4618      	mov	r0, r3
 800ce48:	bd10      	pop	{r4, pc}
      phost->Control.buff = buff;
 800ce4a:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800ce4c:	f44f 7040 	mov.w	r0, #768	; 0x300
    phost->Control.setup.b.wValue.w = wValue;
 800ce50:	8261      	strh	r1, [r4, #18]
      phost->RequestState = CMD_WAIT;
 800ce52:	2102      	movs	r1, #2
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800ce54:	8220      	strh	r0, [r4, #16]
}
 800ce56:	4618      	mov	r0, r3
      phost->Control.buff = buff;
 800ce58:	60a2      	str	r2, [r4, #8]
      phost->Control.length = length;
 800ce5a:	81a2      	strh	r2, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 800ce5c:	6162      	str	r2, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 800ce5e:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 800ce60:	70a1      	strb	r1, [r4, #2]
}
 800ce62:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 800ce64:	2101      	movs	r1, #1
        phost->Control.state = CTRL_IDLE;
 800ce66:	2200      	movs	r2, #0
}
 800ce68:	4618      	mov	r0, r3
        phost->RequestState = CMD_SEND;
 800ce6a:	70a1      	strb	r1, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800ce6c:	7622      	strb	r2, [r4, #24]
}
 800ce6e:	bd10      	pop	{r4, pc}

0800ce70 <USBH_CtlReq>:
{
 800ce70:	b510      	push	{r4, lr}
  switch (phost->RequestState)
 800ce72:	7883      	ldrb	r3, [r0, #2]
{
 800ce74:	4604      	mov	r4, r0
  switch (phost->RequestState)
 800ce76:	2b01      	cmp	r3, #1
 800ce78:	d00f      	beq.n	800ce9a <USBH_CtlReq+0x2a>
 800ce7a:	2b02      	cmp	r3, #2
 800ce7c:	d10a      	bne.n	800ce94 <USBH_CtlReq+0x24>
      status = USBH_HandleControl(phost);
 800ce7e:	f7ff fcc1 	bl	800c804 <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800ce82:	4603      	mov	r3, r0
 800ce84:	b180      	cbz	r0, 800cea8 <USBH_CtlReq+0x38>
 800ce86:	2803      	cmp	r0, #3
 800ce88:	d00e      	beq.n	800cea8 <USBH_CtlReq+0x38>
      else if (status == USBH_FAIL)
 800ce8a:	2802      	cmp	r0, #2
 800ce8c:	d103      	bne.n	800ce96 <USBH_CtlReq+0x26>
        phost->RequestState = CMD_SEND;
 800ce8e:	2201      	movs	r2, #1
 800ce90:	70a2      	strb	r2, [r4, #2]
 800ce92:	e000      	b.n	800ce96 <USBH_CtlReq+0x26>
  switch (phost->RequestState)
 800ce94:	2301      	movs	r3, #1
}
 800ce96:	4618      	mov	r0, r3
 800ce98:	bd10      	pop	{r4, pc}
      phost->RequestState = CMD_WAIT;
 800ce9a:	2002      	movs	r0, #2
      phost->Control.buff = buff;
 800ce9c:	60a1      	str	r1, [r4, #8]
      phost->Control.length = length;
 800ce9e:	81a2      	strh	r2, [r4, #12]
      phost->RequestState = CMD_WAIT;
 800cea0:	70a0      	strb	r0, [r4, #2]
}
 800cea2:	4618      	mov	r0, r3
      phost->Control.state = CTRL_SETUP;
 800cea4:	7623      	strb	r3, [r4, #24]
}
 800cea6:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 800cea8:	2101      	movs	r1, #1
        phost->Control.state = CTRL_IDLE;
 800ceaa:	2200      	movs	r2, #0
}
 800ceac:	4618      	mov	r0, r3
        phost->RequestState = CMD_SEND;
 800ceae:	70a1      	strb	r1, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800ceb0:	7622      	strb	r2, [r4, #24]
}
 800ceb2:	bd10      	pop	{r4, pc}

0800ceb4 <USBH_Get_StringDesc>:
  if ((length > sizeof(phost->device.Data)) || (buff == NULL))
 800ceb4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
{
 800ceb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((length > sizeof(phost->device.Data)) || (buff == NULL))
 800ceba:	d830      	bhi.n	800cf1e <USBH_Get_StringDesc+0x6a>
 800cebc:	4615      	mov	r5, r2
 800cebe:	b372      	cbz	r2, 800cf1e <USBH_Get_StringDesc+0x6a>
 800cec0:	461e      	mov	r6, r3
  if (phost->RequestState == CMD_SEND)
 800cec2:	7883      	ldrb	r3, [r0, #2]
 800cec4:	4604      	mov	r4, r0
                              phost->device.Data, length);
 800cec6:	f500 7707 	add.w	r7, r0, #540	; 0x21c
  if (phost->RequestState == CMD_SEND)
 800ceca:	2b01      	cmp	r3, #1
 800cecc:	d109      	bne.n	800cee2 <USBH_Get_StringDesc+0x2e>
  status = USBH_GetDescriptor(phost,
 800cece:	f441 7340 	orr.w	r3, r1, #768	; 0x300
    phost->Control.setup.b.wLength.w = length;
 800ced2:	82c6      	strh	r6, [r0, #22]
    phost->Control.setup.b.wValue.w = value_idx;
 800ced4:	8243      	strh	r3, [r0, #18]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 800ced6:	f240 4309 	movw	r3, #1033	; 0x409
 800ceda:	8283      	strh	r3, [r0, #20]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800cedc:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 800cee0:	8203      	strh	r3, [r0, #16]
  return USBH_CtlReq(phost, buff, length);
 800cee2:	4632      	mov	r2, r6
 800cee4:	4639      	mov	r1, r7
 800cee6:	4620      	mov	r0, r4
 800cee8:	f7ff ffc2 	bl	800ce70 <USBH_CtlReq>
  if (status == USBH_OK)
 800ceec:	b100      	cbz	r0, 800cef0 <USBH_Get_StringDesc+0x3c>
}
 800ceee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (psrc[1] == USB_DESC_TYPE_STRING)
 800cef0:	f894 321d 	ldrb.w	r3, [r4, #541]	; 0x21d
 800cef4:	2b03      	cmp	r3, #3
 800cef6:	d1fa      	bne.n	800ceee <USBH_Get_StringDesc+0x3a>
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 800cef8:	f894 321c 	ldrb.w	r3, [r4, #540]	; 0x21c
 800cefc:	3b02      	subs	r3, #2
 800cefe:	42b3      	cmp	r3, r6
 800cf00:	bf28      	it	cs
 800cf02:	4633      	movcs	r3, r6
 800cf04:	b299      	uxth	r1, r3
    for (idx = 0U; idx < strlength; idx += 2U)
 800cf06:	b13b      	cbz	r3, 800cf18 <USBH_Get_StringDesc+0x64>
 800cf08:	4603      	mov	r3, r0
      *pdest =  psrc[idx];
 800cf0a:	3302      	adds	r3, #2
 800cf0c:	b29b      	uxth	r3, r3
 800cf0e:	5cfa      	ldrb	r2, [r7, r3]
    for (idx = 0U; idx < strlength; idx += 2U)
 800cf10:	428b      	cmp	r3, r1
      *pdest =  psrc[idx];
 800cf12:	f805 2b01 	strb.w	r2, [r5], #1
    for (idx = 0U; idx < strlength; idx += 2U)
 800cf16:	d3f8      	bcc.n	800cf0a <USBH_Get_StringDesc+0x56>
    *pdest = 0U; /* mark end of string */
 800cf18:	2300      	movs	r3, #0
 800cf1a:	702b      	strb	r3, [r5, #0]
}
 800cf1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USBH_ErrLog("Control error: Get String Descriptor failed, data buffer size issue");
 800cf1e:	4805      	ldr	r0, [pc, #20]	; (800cf34 <USBH_Get_StringDesc+0x80>)
 800cf20:	f001 fc14 	bl	800e74c <printf>
 800cf24:	4804      	ldr	r0, [pc, #16]	; (800cf38 <USBH_Get_StringDesc+0x84>)
 800cf26:	f001 fc11 	bl	800e74c <printf>
 800cf2a:	200a      	movs	r0, #10
 800cf2c:	f001 fc22 	bl	800e774 <putchar>
    return USBH_NOT_SUPPORTED;
 800cf30:	2003      	movs	r0, #3
}
 800cf32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cf34:	0801540c 	.word	0x0801540c
 800cf38:	0801595c 	.word	0x0801595c

0800cf3c <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 800cf3c:	b530      	push	{r4, r5, lr}

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cf3e:	2400      	movs	r4, #0
{
 800cf40:	b085      	sub	sp, #20
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cf42:	2508      	movs	r5, #8
 800cf44:	9101      	str	r1, [sp, #4]
 800cf46:	4623      	mov	r3, r4
 800cf48:	4611      	mov	r1, r2
 800cf4a:	9403      	str	r4, [sp, #12]
 800cf4c:	4622      	mov	r2, r4
 800cf4e:	9502      	str	r5, [sp, #8]
 800cf50:	9400      	str	r4, [sp, #0]
 800cf52:	f7fe ff0f 	bl	800bd74 <USBH_LL_SubmitURB>
                          USBH_PID_SETUP,       /* Type setup       */
                          buff,                 /* data buffer      */
                          USBH_SETUP_PKT_SIZE,  /* data length      */
                          0U);
  return USBH_OK;
}
 800cf56:	4620      	mov	r0, r4
 800cf58:	b005      	add	sp, #20
 800cf5a:	bd30      	pop	{r4, r5, pc}

0800cf5c <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 800cf5c:	b510      	push	{r4, lr}
 800cf5e:	460c      	mov	r4, r1
 800cf60:	b084      	sub	sp, #16
 800cf62:	4619      	mov	r1, r3
  if (phost->device.speed != USBH_SPEED_HIGH)
 800cf64:	f890 341d 	ldrb.w	r3, [r0, #1053]	; 0x41d
  {
    do_ping = 0U;
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cf68:	e9cd 4201 	strd	r4, r2, [sp, #4]
    do_ping = 0U;
 800cf6c:	2b00      	cmp	r3, #0
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cf6e:	f04f 0401 	mov.w	r4, #1
 800cf72:	f04f 0300 	mov.w	r3, #0
 800cf76:	9400      	str	r4, [sp, #0]
{
 800cf78:	f89d 4018 	ldrb.w	r4, [sp, #24]
    do_ping = 0U;
 800cf7c:	bf18      	it	ne
 800cf7e:	461c      	movne	r4, r3
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cf80:	461a      	mov	r2, r3
 800cf82:	9403      	str	r4, [sp, #12]
 800cf84:	f7fe fef6 	bl	800bd74 <USBH_LL_SubmitURB>
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
 800cf88:	2000      	movs	r0, #0
 800cf8a:	b004      	add	sp, #16
 800cf8c:	bd10      	pop	{r4, pc}
 800cf8e:	bf00      	nop

0800cf90 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 800cf90:	b530      	push	{r4, r5, lr}
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cf92:	2400      	movs	r4, #0
{
 800cf94:	b085      	sub	sp, #20
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cf96:	2501      	movs	r5, #1
 800cf98:	9101      	str	r1, [sp, #4]
 800cf9a:	4619      	mov	r1, r3
 800cf9c:	9202      	str	r2, [sp, #8]
 800cf9e:	4623      	mov	r3, r4
 800cfa0:	462a      	mov	r2, r5
 800cfa2:	9403      	str	r4, [sp, #12]
 800cfa4:	9500      	str	r5, [sp, #0]
 800cfa6:	f7fe fee5 	bl	800bd74 <USBH_LL_SubmitURB>
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;

}
 800cfaa:	4620      	mov	r0, r4
 800cfac:	b005      	add	sp, #20
 800cfae:	bd30      	pop	{r4, r5, pc}

0800cfb0 <USBH_BulkSendData>:
USBH_StatusTypeDef USBH_BulkSendData(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint16_t length,
                                     uint8_t pipe_num,
                                     uint8_t do_ping)
{
 800cfb0:	b510      	push	{r4, lr}
 800cfb2:	460c      	mov	r4, r1
 800cfb4:	b084      	sub	sp, #16
 800cfb6:	4619      	mov	r1, r3
  if (phost->device.speed != USBH_SPEED_HIGH)
 800cfb8:	f890 341d 	ldrb.w	r3, [r0, #1053]	; 0x41d
  {
    do_ping = 0U;
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cfbc:	e9cd 4201 	strd	r4, r2, [sp, #4]
    do_ping = 0U;
 800cfc0:	2b00      	cmp	r3, #0
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cfc2:	f04f 0200 	mov.w	r2, #0
 800cfc6:	f04f 0401 	mov.w	r4, #1
 800cfca:	f04f 0302 	mov.w	r3, #2
 800cfce:	9400      	str	r4, [sp, #0]
{
 800cfd0:	f89d 4018 	ldrb.w	r4, [sp, #24]
    do_ping = 0U;
 800cfd4:	bf18      	it	ne
 800cfd6:	4614      	movne	r4, r2
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cfd8:	9403      	str	r4, [sp, #12]
 800cfda:	f7fe fecb 	bl	800bd74 <USBH_LL_SubmitURB>
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/
  return USBH_OK;
}
 800cfde:	2000      	movs	r0, #0
 800cfe0:	b004      	add	sp, #16
 800cfe2:	bd10      	pop	{r4, pc}

0800cfe4 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
 800cfe4:	b530      	push	{r4, r5, lr}
 800cfe6:	b085      	sub	sp, #20
 800cfe8:	460d      	mov	r5, r1
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800cfea:	2400      	movs	r4, #0
 800cfec:	4619      	mov	r1, r3
 800cfee:	9202      	str	r2, [sp, #8]
 800cff0:	2201      	movs	r2, #1
 800cff2:	2302      	movs	r3, #2
 800cff4:	9403      	str	r4, [sp, #12]
 800cff6:	e9cd 2500 	strd	r2, r5, [sp]
 800cffa:	f7fe febb 	bl	800bd74 <USBH_LL_SubmitURB>
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;
}
 800cffe:	4620      	mov	r0, r4
 800d000:	b005      	add	sp, #20
 800d002:	bd30      	pop	{r4, r5, pc}

0800d004 <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 800d004:	b510      	push	{r4, lr}
 800d006:	b084      	sub	sp, #16
 800d008:	f89d 4018 	ldrb.w	r4, [sp, #24]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800d00c:	9400      	str	r4, [sp, #0]
{
 800d00e:	f89d 401c 	ldrb.w	r4, [sp, #28]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800d012:	9401      	str	r4, [sp, #4]
{
 800d014:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800d018:	9402      	str	r4, [sp, #8]
 800d01a:	f7fe fe8b 	bl	800bd34 <USBH_LL_OpenPipe>

  return USBH_OK;
}
 800d01e:	2000      	movs	r0, #0
 800d020:	b004      	add	sp, #16
 800d022:	bd10      	pop	{r4, pc}

0800d024 <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
 800d024:	b508      	push	{r3, lr}
  (void)USBH_LL_ClosePipe(phost, pipe_num);
 800d026:	f7fe fe9b 	bl	800bd60 <USBH_LL_ClosePipe>

  return USBH_OK;
}
 800d02a:	2000      	movs	r0, #0
 800d02c:	bd08      	pop	{r3, pc}
 800d02e:	bf00      	nop

0800d030 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
 800d030:	2300      	movs	r3, #0
  */
static uint16_t USBH_GetFreePipe(USBH_HandleTypeDef *phost)
{
  uint8_t idx = 0U;

  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800d032:	f500 6294 	add.w	r2, r0, #1184	; 0x4a0
{
 800d036:	b410      	push	{r4}
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 800d038:	f852 4f04 	ldr.w	r4, [r2, #4]!
 800d03c:	fa5f fc83 	uxtb.w	ip, r3
 800d040:	0424      	lsls	r4, r4, #16
 800d042:	d508      	bpl.n	800d056 <USBH_AllocPipe+0x26>
  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800d044:	3301      	adds	r3, #1
 800d046:	2b10      	cmp	r3, #16
 800d048:	d1f6      	bne.n	800d038 <USBH_AllocPipe+0x8>
 800d04a:	f04f 0cff 	mov.w	ip, #255	; 0xff
}
 800d04e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d052:	4660      	mov	r0, ip
 800d054:	4770      	bx	lr
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 800d056:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800d05a:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
}
 800d05e:	f85d 4b04 	ldr.w	r4, [sp], #4
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 800d062:	f8c0 14a4 	str.w	r1, [r0, #1188]	; 0x4a4
}
 800d066:	4660      	mov	r0, ip
 800d068:	4770      	bx	lr
 800d06a:	bf00      	nop

0800d06c <USBH_FreePipe>:
  if (idx < USBH_MAX_PIPES_NBR)
 800d06c:	290f      	cmp	r1, #15
 800d06e:	d807      	bhi.n	800d080 <USBH_FreePipe+0x14>
    phost->Pipes[idx] &= 0x7FFFU;
 800d070:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800d074:	f8d1 34a4 	ldr.w	r3, [r1, #1188]	; 0x4a4
 800d078:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800d07c:	f8c1 34a4 	str.w	r3, [r1, #1188]	; 0x4a4
}
 800d080:	2000      	movs	r0, #0
 800d082:	4770      	bx	lr

0800d084 <USBH_MIDI_ClassRequest>:

static USBH_StatusTypeDef USBH_MIDI_ClassRequest(USBH_HandleTypeDef *phost)
{
  (void)phost;
  return USBH_OK;
}
 800d084:	2000      	movs	r0, #0
 800d086:	4770      	bx	lr

0800d088 <USBH_MIDI_Process>:

static USBH_StatusTypeDef USBH_MIDI_Process(USBH_HandleTypeDef *phost)
{
  MIDI_HandleTypeDef *handle = (MIDI_HandleTypeDef *)phost->pActiveClass->pData;
 800d088:	f8d0 349c 	ldr.w	r3, [r0, #1180]	; 0x49c
{
 800d08c:	b570      	push	{r4, r5, r6, lr}
  MIDI_HandleTypeDef *handle = (MIDI_HandleTypeDef *)phost->pActiveClass->pData;
 800d08e:	69dc      	ldr	r4, [r3, #28]
{
 800d090:	b082      	sub	sp, #8

  if (handle == NULL)
 800d092:	2c00      	cmp	r4, #0
 800d094:	d059      	beq.n	800d14a <USBH_MIDI_Process+0xc2>
  {
    return USBH_FAIL;
  }

  if (phost->gState != HOST_CLASS)
 800d096:	7803      	ldrb	r3, [r0, #0]
 800d098:	4605      	mov	r5, r0
 800d09a:	2b0b      	cmp	r3, #11
 800d09c:	d002      	beq.n	800d0a4 <USBH_MIDI_Process+0x1c>
  {
    return USBH_OK;
 800d09e:	2000      	movs	r0, #0

  MIDI_ProcessReception(phost, handle);
  MIDI_ProcessTransmission(phost, handle);

  return USBH_OK;
}
 800d0a0:	b002      	add	sp, #8
 800d0a2:	bd70      	pop	{r4, r5, r6, pc}

static void MIDI_ProcessReception(USBH_HandleTypeDef *phost, MIDI_HandleTypeDef *MIDI_Handle)
{
  if (MIDI_Handle->in_state == MIDI_PIPE_STATE_IDLE)
 800d0a4:	7a63      	ldrb	r3, [r4, #9]
 800d0a6:	2b00      	cmp	r3, #0
 800d0a8:	d041      	beq.n	800d12e <USBH_MIDI_Process+0xa6>
      MIDI_Handle->in_state = MIDI_PIPE_STATE_BUSY;
    }
    return;
  }

  USBH_URBStateTypeDef urb_state = USBH_LL_GetURBState(phost, MIDI_Handle->InPipe);
 800d0aa:	7821      	ldrb	r1, [r4, #0]
 800d0ac:	f7fe fec2 	bl	800be34 <USBH_LL_GetURBState>

  if (urb_state == USBH_URB_DONE)
 800d0b0:	2801      	cmp	r0, #1
 800d0b2:	d05d      	beq.n	800d170 <USBH_MIDI_Process+0xe8>
                            &MIDI_Handle->rx_overflow);
      offset += USBH_MIDI_EVENT_SIZE;
    }
    MIDI_Handle->in_state = MIDI_PIPE_STATE_IDLE;
  }
  else if ((urb_state == USBH_URB_ERROR) || (urb_state == USBH_URB_STALL))
 800d0b4:	1f03      	subs	r3, r0, #4
 800d0b6:	b2db      	uxtb	r3, r3
 800d0b8:	2b01      	cmp	r3, #1
 800d0ba:	d943      	bls.n	800d144 <USBH_MIDI_Process+0xbc>
  {
    MIDI_Handle->in_state = MIDI_PIPE_STATE_IDLE;
  }
  else if (urb_state == USBH_URB_NOTREADY)
 800d0bc:	2802      	cmp	r0, #2
 800d0be:	d041      	beq.n	800d144 <USBH_MIDI_Process+0xbc>
  }
}

static void MIDI_ProcessTransmission(USBH_HandleTypeDef *phost, MIDI_HandleTypeDef *MIDI_Handle)
{
  if (MIDI_Handle->out_state == MIDI_PIPE_STATE_IDLE)
 800d0c0:	7aa2      	ldrb	r2, [r4, #10]
 800d0c2:	2a00      	cmp	r2, #0
 800d0c4:	d144      	bne.n	800d150 <USBH_MIDI_Process+0xc8>
  {
    uint16_t available = (uint16_t)((MIDI_Handle->tx_head + USBH_MIDI_TX_QUEUE_SIZE - MIDI_Handle->tx_tail) % USBH_MIDI_TX_QUEUE_SIZE);
 800d0c6:	f8b4 14a4 	ldrh.w	r1, [r4, #1188]	; 0x4a4
 800d0ca:	f8b4 34a6 	ldrh.w	r3, [r4, #1190]	; 0x4a6
 800d0ce:	1ac8      	subs	r0, r1, r3
    if (available == 0U)
 800d0d0:	0640      	lsls	r0, r0, #25
 800d0d2:	d0e4      	beq.n	800d09e <USBH_MIDI_Process+0x16>
    {
      return;
    }

    uint16_t to_send = 0U;
    while ((to_send + USBH_MIDI_EVENT_SIZE) <= MIDI_Handle->OutEpSize &&
 800d0d4:	88e0      	ldrh	r0, [r4, #6]
 800d0d6:	2803      	cmp	r0, #3
 800d0d8:	d812      	bhi.n	800d100 <USBH_MIDI_Process+0x78>
 800d0da:	e7e0      	b.n	800d09e <USBH_MIDI_Process+0x16>
 800d0dc:	f854 302e 	ldr.w	r3, [r4, lr, lsl #2]
           MIDI_Handle->tx_tail != MIDI_Handle->tx_head)
    {
      memcpy(&MIDI_Handle->out_packet[to_send],
             MIDI_Handle->tx_buffer[MIDI_Handle->tx_tail], USBH_MIDI_EVENT_SIZE);
      MIDI_Handle->tx_tail = (uint16_t)((MIDI_Handle->tx_tail + 1U) % USBH_MIDI_TX_QUEUE_SIZE);
      to_send += USBH_MIDI_EVENT_SIZE;
 800d0e0:	b282      	uxth	r2, r0
      memcpy(&MIDI_Handle->out_packet[to_send],
 800d0e2:	f8cc 3060 	str.w	r3, [ip, #96]	; 0x60
    while ((to_send + USBH_MIDI_EVENT_SIZE) <= MIDI_Handle->OutEpSize &&
 800d0e6:	1d10      	adds	r0, r2, #4
      MIDI_Handle->tx_tail = (uint16_t)((MIDI_Handle->tx_tail + 1U) % USBH_MIDI_TX_QUEUE_SIZE);
 800d0e8:	f8b4 34a6 	ldrh.w	r3, [r4, #1190]	; 0x4a6
    while ((to_send + USBH_MIDI_EVENT_SIZE) <= MIDI_Handle->OutEpSize &&
 800d0ec:	88e1      	ldrh	r1, [r4, #6]
      MIDI_Handle->tx_tail = (uint16_t)((MIDI_Handle->tx_tail + 1U) % USBH_MIDI_TX_QUEUE_SIZE);
 800d0ee:	3301      	adds	r3, #1
    while ((to_send + USBH_MIDI_EVENT_SIZE) <= MIDI_Handle->OutEpSize &&
 800d0f0:	4288      	cmp	r0, r1
      MIDI_Handle->tx_tail = (uint16_t)((MIDI_Handle->tx_tail + 1U) % USBH_MIDI_TX_QUEUE_SIZE);
 800d0f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800d0f6:	f8a4 34a6 	strh.w	r3, [r4, #1190]	; 0x4a6
    while ((to_send + USBH_MIDI_EVENT_SIZE) <= MIDI_Handle->OutEpSize &&
 800d0fa:	d809      	bhi.n	800d110 <USBH_MIDI_Process+0x88>
           MIDI_Handle->tx_tail != MIDI_Handle->tx_head)
 800d0fc:	f8b4 14a4 	ldrh.w	r1, [r4, #1188]	; 0x4a4
    while ((to_send + USBH_MIDI_EVENT_SIZE) <= MIDI_Handle->OutEpSize &&
 800d100:	428b      	cmp	r3, r1
             MIDI_Handle->tx_buffer[MIDI_Handle->tx_tail], USBH_MIDI_EVENT_SIZE);
 800d102:	f103 0ea8 	add.w	lr, r3, #168	; 0xa8
      memcpy(&MIDI_Handle->out_packet[to_send],
 800d106:	eb04 0c02 	add.w	ip, r4, r2
      to_send += USBH_MIDI_EVENT_SIZE;
 800d10a:	f102 0004 	add.w	r0, r2, #4
    while ((to_send + USBH_MIDI_EVENT_SIZE) <= MIDI_Handle->OutEpSize &&
 800d10e:	d1e5      	bne.n	800d0dc <USBH_MIDI_Process+0x54>
    }

    if (to_send > 0U)
 800d110:	2a00      	cmp	r2, #0
 800d112:	d0c4      	beq.n	800d09e <USBH_MIDI_Process+0x16>
    {
      if (USBH_BulkSendData(phost, MIDI_Handle->out_packet, to_send,
 800d114:	2100      	movs	r1, #0
 800d116:	7863      	ldrb	r3, [r4, #1]
 800d118:	4628      	mov	r0, r5
 800d11a:	9100      	str	r1, [sp, #0]
 800d11c:	f104 0160 	add.w	r1, r4, #96	; 0x60
 800d120:	f7ff ff46 	bl	800cfb0 <USBH_BulkSendData>
 800d124:	2800      	cmp	r0, #0
 800d126:	d1ba      	bne.n	800d09e <USBH_MIDI_Process+0x16>
                            MIDI_Handle->OutPipe, 0U) == USBH_OK)
      {
        MIDI_Handle->out_state = MIDI_PIPE_STATE_BUSY;
 800d128:	2301      	movs	r3, #1
 800d12a:	72a3      	strb	r3, [r4, #10]
 800d12c:	e7b8      	b.n	800d0a0 <USBH_MIDI_Process+0x18>
    if (USBH_BulkReceiveData(phost, MIDI_Handle->in_packet, MIDI_Handle->InEpSize,
 800d12e:	7823      	ldrb	r3, [r4, #0]
 800d130:	f104 0120 	add.w	r1, r4, #32
 800d134:	88a2      	ldrh	r2, [r4, #4]
 800d136:	f7ff ff55 	bl	800cfe4 <USBH_BulkReceiveData>
 800d13a:	2800      	cmp	r0, #0
 800d13c:	d1c0      	bne.n	800d0c0 <USBH_MIDI_Process+0x38>
      MIDI_Handle->in_state = MIDI_PIPE_STATE_BUSY;
 800d13e:	2301      	movs	r3, #1
 800d140:	7263      	strb	r3, [r4, #9]
 800d142:	e7bd      	b.n	800d0c0 <USBH_MIDI_Process+0x38>
    MIDI_Handle->in_state = MIDI_PIPE_STATE_IDLE;
 800d144:	2300      	movs	r3, #0
 800d146:	7263      	strb	r3, [r4, #9]
 800d148:	e7ba      	b.n	800d0c0 <USBH_MIDI_Process+0x38>
    return USBH_FAIL;
 800d14a:	2002      	movs	r0, #2
}
 800d14c:	b002      	add	sp, #8
 800d14e:	bd70      	pop	{r4, r5, r6, pc}
      }
    }
    return;
  }

  USBH_URBStateTypeDef urb_state = USBH_LL_GetURBState(phost, MIDI_Handle->OutPipe);
 800d150:	7861      	ldrb	r1, [r4, #1]
 800d152:	4628      	mov	r0, r5
 800d154:	f7fe fe6e 	bl	800be34 <USBH_LL_GetURBState>

  if (urb_state == USBH_URB_DONE)
 800d158:	2801      	cmp	r0, #1
 800d15a:	d005      	beq.n	800d168 <USBH_MIDI_Process+0xe0>
  {
    MIDI_Handle->out_state = MIDI_PIPE_STATE_IDLE;
  }
  else if ((urb_state == USBH_URB_ERROR) || (urb_state == USBH_URB_STALL))
 800d15c:	1f03      	subs	r3, r0, #4
 800d15e:	b2db      	uxtb	r3, r3
 800d160:	2b01      	cmp	r3, #1
 800d162:	d901      	bls.n	800d168 <USBH_MIDI_Process+0xe0>
  {
    MIDI_Handle->out_state = MIDI_PIPE_STATE_IDLE;
  }
  else if (urb_state == USBH_URB_NOTREADY)
 800d164:	2802      	cmp	r0, #2
 800d166:	d19a      	bne.n	800d09e <USBH_MIDI_Process+0x16>
  {
    MIDI_Handle->out_state = MIDI_PIPE_STATE_IDLE;
 800d168:	2300      	movs	r3, #0
  return USBH_OK;
 800d16a:	4618      	mov	r0, r3
    MIDI_Handle->out_state = MIDI_PIPE_STATE_IDLE;
 800d16c:	72a3      	strb	r3, [r4, #10]
 800d16e:	e797      	b.n	800d0a0 <USBH_MIDI_Process+0x18>
    uint32_t packet_size = USBH_LL_GetLastXferSize(phost, MIDI_Handle->InPipe);
 800d170:	7821      	ldrb	r1, [r4, #0]
 800d172:	4628      	mov	r0, r5
 800d174:	f7fe fdcc 	bl	800bd10 <USBH_LL_GetLastXferSize>
    while ((offset + USBH_MIDI_EVENT_SIZE) <= packet_size)
 800d178:	2803      	cmp	r0, #3
 800d17a:	d9e3      	bls.n	800d144 <USBH_MIDI_Process+0xbc>
      (void)MIDI_BufferPush(MIDI_Handle->rx_buffer, USBH_MIDI_RX_QUEUE_SIZE,
 800d17c:	f104 06a0 	add.w	r6, r4, #160	; 0xa0
 800d180:	2204      	movs	r2, #4
 800d182:	f104 0e1c 	add.w	lr, r4, #28
 800d186:	e008      	b.n	800d19a <USBH_MIDI_Process+0x112>
 800d188:	f85e c002 	ldr.w	ip, [lr, r2]
  if (next == *tail)
  {
    (*overflow)++;
    return false;
  }
  memcpy(buffer[*head], packet, USBH_MIDI_EVENT_SIZE);
 800d18c:	f846 c021 	str.w	ip, [r6, r1, lsl #2]
  *head = next;
 800d190:	f8a4 34a0 	strh.w	r3, [r4, #1184]	; 0x4a0
    while ((offset + USBH_MIDI_EVENT_SIZE) <= packet_size)
 800d194:	3204      	adds	r2, #4
 800d196:	4290      	cmp	r0, r2
 800d198:	d3d4      	bcc.n	800d144 <USBH_MIDI_Process+0xbc>
  uint16_t next = (uint16_t)((*head + 1U) % size);
 800d19a:	f8b4 14a0 	ldrh.w	r1, [r4, #1184]	; 0x4a0
  if (next == *tail)
 800d19e:	f8b4 c4a2 	ldrh.w	ip, [r4, #1186]	; 0x4a2
  uint16_t next = (uint16_t)((*head + 1U) % size);
 800d1a2:	1c4b      	adds	r3, r1, #1
 800d1a4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  if (next == *tail)
 800d1a8:	459c      	cmp	ip, r3
 800d1aa:	d1ed      	bne.n	800d188 <USBH_MIDI_Process+0x100>
    (*overflow)++;
 800d1ac:	f8d4 34a8 	ldr.w	r3, [r4, #1192]	; 0x4a8
 800d1b0:	3301      	adds	r3, #1
 800d1b2:	f8c4 34a8 	str.w	r3, [r4, #1192]	; 0x4a8
    return false;
 800d1b6:	e7ed      	b.n	800d194 <USBH_MIDI_Process+0x10c>

0800d1b8 <USBH_MIDI_InterfaceInit>:
{
 800d1b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d1bc:	f04f 0900 	mov.w	r9, #0
 800d1c0:	b084      	sub	sp, #16
  interface = USBH_FindInterface(phost, USB_AUDIO_CLASS,
 800d1c2:	2203      	movs	r2, #3
 800d1c4:	2101      	movs	r1, #1
 800d1c6:	464b      	mov	r3, r9
{
 800d1c8:	4606      	mov	r6, r0
  interface = USBH_FindInterface(phost, USB_AUDIO_CLASS,
 800d1ca:	f7fe ff77 	bl	800c0bc <USBH_FindInterface>
  if (interface == 0xFFU)
 800d1ce:	28ff      	cmp	r0, #255	; 0xff
 800d1d0:	f000 80bf 	beq.w	800d352 <USBH_MIDI_InterfaceInit+0x19a>
  if (itf_desc->bNumEndpoints < 2U)
 800d1d4:	252a      	movs	r5, #42	; 0x2a
 800d1d6:	4604      	mov	r4, r0
 800d1d8:	fb05 6500 	mla	r5, r5, r0, r6
 800d1dc:	f895 3446 	ldrb.w	r3, [r5, #1094]	; 0x446
 800d1e0:	2b01      	cmp	r3, #1
 800d1e2:	f240 80a9 	bls.w	800d338 <USBH_MIDI_InterfaceInit+0x180>
  USBH_SelectInterface(phost, interface);
 800d1e6:	4601      	mov	r1, r0
 800d1e8:	4630      	mov	r0, r6
 800d1ea:	f7fe ff23 	bl	800c034 <USBH_SelectInterface>
  for (uint8_t idx = 0U; idx < itf_desc->bNumEndpoints; idx++)
 800d1ee:	f895 3446 	ldrb.w	r3, [r5, #1094]	; 0x446
  MIDI_Handle.interface = interface;
 800d1f2:	4d5a      	ldr	r5, [pc, #360]	; (800d35c <USBH_MIDI_InterfaceInit+0x1a4>)
 800d1f4:	722c      	strb	r4, [r5, #8]
  MIDI_Handle.InEp = 0U;
 800d1f6:	f8a5 9002 	strh.w	r9, [r5, #2]
  MIDI_Handle.InEpSize = 0U;
 800d1fa:	f8c5 9004 	str.w	r9, [r5, #4]
  for (uint8_t idx = 0U; idx < itf_desc->bNumEndpoints; idx++)
 800d1fe:	2b00      	cmp	r3, #0
 800d200:	f000 808d 	beq.w	800d31e <USBH_MIDI_InterfaceInit+0x166>
 800d204:	b222      	sxth	r2, r4
 800d206:	3b01      	subs	r3, #1
 800d208:	f106 0108 	add.w	r1, r6, #8
 800d20c:	46c8      	mov	r8, r9
 800d20e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800d212:	464f      	mov	r7, r9
 800d214:	b2db      	uxtb	r3, r3
 800d216:	46ca      	mov	sl, r9
 800d218:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 800d21c:	464c      	mov	r4, r9
 800d21e:	46cc      	mov	ip, r9
 800d220:	eb01 0142 	add.w	r1, r1, r2, lsl #1
 800d224:	eb06 0242 	add.w	r2, r6, r2, lsl #1
 800d228:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 800d22c:	e002      	b.n	800d234 <USBH_MIDI_InterfaceInit+0x7c>
 800d22e:	3208      	adds	r2, #8
 800d230:	4291      	cmp	r1, r2
 800d232:	d012      	beq.n	800d25a <USBH_MIDI_InterfaceInit+0xa2>
    if ((ep_desc->bmAttributes & 0x03U) == USB_EP_TYPE_BULK)
 800d234:	f892 344f 	ldrb.w	r3, [r2, #1103]	; 0x44f
 800d238:	f003 0303 	and.w	r3, r3, #3
 800d23c:	2b02      	cmp	r3, #2
 800d23e:	d1f6      	bne.n	800d22e <USBH_MIDI_InterfaceInit+0x76>
      if ((ep_desc->bEndpointAddress & 0x80U) == 0x80U)
 800d240:	f992 044e 	ldrsb.w	r0, [r2, #1102]	; 0x44e
 800d244:	f892 344e 	ldrb.w	r3, [r2, #1102]	; 0x44e
 800d248:	2800      	cmp	r0, #0
 800d24a:	db62      	blt.n	800d312 <USBH_MIDI_InterfaceInit+0x15a>
        MIDI_Handle.OutEpSize = ep_desc->wMaxPacketSize;
 800d24c:	f8b2 a450 	ldrh.w	sl, [r2, #1104]	; 0x450
  for (uint8_t idx = 0U; idx < itf_desc->bNumEndpoints; idx++)
 800d250:	3208      	adds	r2, #8
        MIDI_Handle.OutEpSize = ep_desc->wMaxPacketSize;
 800d252:	461f      	mov	r7, r3
 800d254:	2401      	movs	r4, #1
  for (uint8_t idx = 0U; idx < itf_desc->bNumEndpoints; idx++)
 800d256:	4291      	cmp	r1, r2
 800d258:	d1ec      	bne.n	800d234 <USBH_MIDI_InterfaceInit+0x7c>
 800d25a:	b114      	cbz	r4, 800d262 <USBH_MIDI_InterfaceInit+0xaa>
 800d25c:	f8a5 a006 	strh.w	sl, [r5, #6]
 800d260:	70ef      	strb	r7, [r5, #3]
 800d262:	f1bc 0f00 	cmp.w	ip, #0
 800d266:	d05a      	beq.n	800d31e <USBH_MIDI_InterfaceInit+0x166>
  if ((MIDI_Handle.InEp == 0U) || (MIDI_Handle.OutEp == 0U))
 800d268:	78eb      	ldrb	r3, [r5, #3]
 800d26a:	f8a5 8004 	strh.w	r8, [r5, #4]
 800d26e:	f885 9002 	strb.w	r9, [r5, #2]
 800d272:	2b00      	cmp	r3, #0
 800d274:	d053      	beq.n	800d31e <USBH_MIDI_InterfaceInit+0x166>
  MIDI_Handle.InPipe = USBH_AllocPipe(phost, MIDI_Handle.InEp);
 800d276:	4649      	mov	r1, r9
 800d278:	4630      	mov	r0, r6
 800d27a:	f7ff fed9 	bl	800d030 <USBH_AllocPipe>
 800d27e:	4603      	mov	r3, r0
  MIDI_Handle.OutPipe = USBH_AllocPipe(phost, MIDI_Handle.OutEp);
 800d280:	78e9      	ldrb	r1, [r5, #3]
 800d282:	4630      	mov	r0, r6
  USBH_OpenPipe(phost, MIDI_Handle.InPipe, MIDI_Handle.InEp,
 800d284:	2402      	movs	r4, #2
  MIDI_Handle.InPipe = USBH_AllocPipe(phost, MIDI_Handle.InEp);
 800d286:	702b      	strb	r3, [r5, #0]
  MIDI_Handle.OutPipe = USBH_AllocPipe(phost, MIDI_Handle.OutEp);
 800d288:	f7ff fed2 	bl	800d030 <USBH_AllocPipe>
  USBH_OpenPipe(phost, MIDI_Handle.InPipe, MIDI_Handle.InEp,
 800d28c:	88ab      	ldrh	r3, [r5, #4]
 800d28e:	9302      	str	r3, [sp, #8]
  MIDI_Handle.OutPipe = USBH_AllocPipe(phost, MIDI_Handle.OutEp);
 800d290:	7068      	strb	r0, [r5, #1]
  USBH_OpenPipe(phost, MIDI_Handle.InPipe, MIDI_Handle.InEp,
 800d292:	4630      	mov	r0, r6
 800d294:	9401      	str	r4, [sp, #4]
 800d296:	f896 241d 	ldrb.w	r2, [r6, #1053]	; 0x41d
 800d29a:	f896 341c 	ldrb.w	r3, [r6, #1052]	; 0x41c
 800d29e:	9200      	str	r2, [sp, #0]
 800d2a0:	78aa      	ldrb	r2, [r5, #2]
 800d2a2:	7829      	ldrb	r1, [r5, #0]
 800d2a4:	f7ff feae 	bl	800d004 <USBH_OpenPipe>
  USBH_OpenPipe(phost, MIDI_Handle.OutPipe, MIDI_Handle.OutEp,
 800d2a8:	88eb      	ldrh	r3, [r5, #6]
 800d2aa:	f896 141d 	ldrb.w	r1, [r6, #1053]	; 0x41d
 800d2ae:	4630      	mov	r0, r6
 800d2b0:	e9cd 4301 	strd	r4, r3, [sp, #4]
 800d2b4:	f896 341c 	ldrb.w	r3, [r6, #1052]	; 0x41c
  MIDI_Handle.in_state = MIDI_PIPE_STATE_IDLE;
 800d2b8:	2400      	movs	r4, #0
  USBH_OpenPipe(phost, MIDI_Handle.OutPipe, MIDI_Handle.OutEp,
 800d2ba:	78ea      	ldrb	r2, [r5, #3]
 800d2bc:	9100      	str	r1, [sp, #0]
 800d2be:	7869      	ldrb	r1, [r5, #1]
 800d2c0:	f7ff fea0 	bl	800d004 <USBH_OpenPipe>
  USBH_LL_SetToggle(phost, MIDI_Handle.InPipe, 0U);
 800d2c4:	7829      	ldrb	r1, [r5, #0]
 800d2c6:	2200      	movs	r2, #0
 800d2c8:	4630      	mov	r0, r6
 800d2ca:	f7fe fdeb 	bl	800bea4 <USBH_LL_SetToggle>
  USBH_LL_SetToggle(phost, MIDI_Handle.OutPipe, 0U);
 800d2ce:	7869      	ldrb	r1, [r5, #1]
 800d2d0:	2200      	movs	r2, #0
 800d2d2:	4630      	mov	r0, r6
 800d2d4:	f7fe fde6 	bl	800bea4 <USBH_LL_SetToggle>
  memset(MIDI_Handle->rx_buffer, 0, sizeof(MIDI_Handle->rx_buffer));
 800d2d8:	4621      	mov	r1, r4
 800d2da:	f44f 7200 	mov.w	r2, #512	; 0x200
  MIDI_Handle->rx_head = MIDI_Handle->rx_tail = 0U;
 800d2de:	f8c5 44a0 	str.w	r4, [r5, #1184]	; 0x4a0
  MIDI_Handle->tx_head = MIDI_Handle->tx_tail = 0U;
 800d2e2:	f8c5 44a4 	str.w	r4, [r5, #1188]	; 0x4a4
  memset(MIDI_Handle->rx_buffer, 0, sizeof(MIDI_Handle->rx_buffer));
 800d2e6:	481e      	ldr	r0, [pc, #120]	; (800d360 <USBH_MIDI_InterfaceInit+0x1a8>)
  MIDI_Handle.in_state = MIDI_PIPE_STATE_IDLE;
 800d2e8:	726c      	strb	r4, [r5, #9]
  MIDI_Handle.out_state = MIDI_PIPE_STATE_IDLE;
 800d2ea:	72ac      	strb	r4, [r5, #10]
  MIDI_Handle->rx_overflow = 0U;
 800d2ec:	f8c5 44a8 	str.w	r4, [r5, #1192]	; 0x4a8
  MIDI_Handle->tx_overflow = 0U;
 800d2f0:	f8c5 44ac 	str.w	r4, [r5, #1196]	; 0x4ac
  memset(MIDI_Handle->rx_buffer, 0, sizeof(MIDI_Handle->rx_buffer));
 800d2f4:	f001 fa76 	bl	800e7e4 <memset>
  memset(MIDI_Handle->tx_buffer, 0, sizeof(MIDI_Handle->tx_buffer));
 800d2f8:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d2fc:	4621      	mov	r1, r4
 800d2fe:	4819      	ldr	r0, [pc, #100]	; (800d364 <USBH_MIDI_InterfaceInit+0x1ac>)
 800d300:	f001 fa70 	bl	800e7e4 <memset>
  phost->pActiveClass->pData = &MIDI_Handle;
 800d304:	f8d6 349c 	ldr.w	r3, [r6, #1180]	; 0x49c
  return USBH_OK;
 800d308:	4620      	mov	r0, r4
  phost->pActiveClass->pData = &MIDI_Handle;
 800d30a:	61dd      	str	r5, [r3, #28]
}
 800d30c:	b004      	add	sp, #16
 800d30e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MIDI_Handle.InEpSize = ep_desc->wMaxPacketSize;
 800d312:	f8b2 8450 	ldrh.w	r8, [r2, #1104]	; 0x450
 800d316:	4699      	mov	r9, r3
 800d318:	f04f 0c01 	mov.w	ip, #1
 800d31c:	e787      	b.n	800d22e <USBH_MIDI_InterfaceInit+0x76>
    USBH_ErrLog("MIDI bulk endpoints not found");
 800d31e:	4812      	ldr	r0, [pc, #72]	; (800d368 <USBH_MIDI_InterfaceInit+0x1b0>)
 800d320:	f001 fa14 	bl	800e74c <printf>
 800d324:	4811      	ldr	r0, [pc, #68]	; (800d36c <USBH_MIDI_InterfaceInit+0x1b4>)
 800d326:	f001 fa11 	bl	800e74c <printf>
 800d32a:	200a      	movs	r0, #10
 800d32c:	f001 fa22 	bl	800e774 <putchar>
    return USBH_FAIL;
 800d330:	2002      	movs	r0, #2
}
 800d332:	b004      	add	sp, #16
 800d334:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    USBH_ErrLog("MIDI interface endpoints missing");
 800d338:	480b      	ldr	r0, [pc, #44]	; (800d368 <USBH_MIDI_InterfaceInit+0x1b0>)
 800d33a:	f001 fa07 	bl	800e74c <printf>
 800d33e:	480c      	ldr	r0, [pc, #48]	; (800d370 <USBH_MIDI_InterfaceInit+0x1b8>)
 800d340:	f001 fa04 	bl	800e74c <printf>
 800d344:	200a      	movs	r0, #10
 800d346:	f001 fa15 	bl	800e774 <putchar>
    return USBH_FAIL;
 800d34a:	2002      	movs	r0, #2
}
 800d34c:	b004      	add	sp, #16
 800d34e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return USBH_FAIL;
 800d352:	2002      	movs	r0, #2
}
 800d354:	b004      	add	sp, #16
 800d356:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d35a:	bf00      	nop
 800d35c:	24005b80 	.word	0x24005b80
 800d360:	24005c20 	.word	0x24005c20
 800d364:	24005e20 	.word	0x24005e20
 800d368:	0801540c 	.word	0x0801540c
 800d36c:	080159c4 	.word	0x080159c4
 800d370:	080159a0 	.word	0x080159a0

0800d374 <USBH_MIDI_InterfaceDeInit>:
{
 800d374:	b570      	push	{r4, r5, r6, lr}
  if (MIDI_Handle.InPipe != 0U)
 800d376:	4d1a      	ldr	r5, [pc, #104]	; (800d3e0 <USBH_MIDI_InterfaceDeInit+0x6c>)
{
 800d378:	4606      	mov	r6, r0
  if (MIDI_Handle.InPipe != 0U)
 800d37a:	7829      	ldrb	r1, [r5, #0]
 800d37c:	b9d9      	cbnz	r1, 800d3b6 <USBH_MIDI_InterfaceDeInit+0x42>
  if (MIDI_Handle.OutPipe != 0U)
 800d37e:	7869      	ldrb	r1, [r5, #1]
 800d380:	bb21      	cbnz	r1, 800d3cc <USBH_MIDI_InterfaceDeInit+0x58>
  MIDI_Handle->rx_head = MIDI_Handle->rx_tail = 0U;
 800d382:	2400      	movs	r4, #0
  memset(MIDI_Handle->rx_buffer, 0, sizeof(MIDI_Handle->rx_buffer));
 800d384:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d388:	4816      	ldr	r0, [pc, #88]	; (800d3e4 <USBH_MIDI_InterfaceDeInit+0x70>)
 800d38a:	4621      	mov	r1, r4
  MIDI_Handle->rx_head = MIDI_Handle->rx_tail = 0U;
 800d38c:	f8c5 44a0 	str.w	r4, [r5, #1184]	; 0x4a0
  MIDI_Handle->tx_head = MIDI_Handle->tx_tail = 0U;
 800d390:	f8c5 44a4 	str.w	r4, [r5, #1188]	; 0x4a4
  MIDI_Handle->rx_overflow = 0U;
 800d394:	f8c5 44a8 	str.w	r4, [r5, #1192]	; 0x4a8
  MIDI_Handle->tx_overflow = 0U;
 800d398:	f8c5 44ac 	str.w	r4, [r5, #1196]	; 0x4ac
  memset(MIDI_Handle->rx_buffer, 0, sizeof(MIDI_Handle->rx_buffer));
 800d39c:	f001 fa22 	bl	800e7e4 <memset>
  memset(MIDI_Handle->tx_buffer, 0, sizeof(MIDI_Handle->tx_buffer));
 800d3a0:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d3a4:	4621      	mov	r1, r4
 800d3a6:	4810      	ldr	r0, [pc, #64]	; (800d3e8 <USBH_MIDI_InterfaceDeInit+0x74>)
 800d3a8:	f001 fa1c 	bl	800e7e4 <memset>
  phost->pActiveClass->pData = NULL;
 800d3ac:	f8d6 349c 	ldr.w	r3, [r6, #1180]	; 0x49c
}
 800d3b0:	4620      	mov	r0, r4
  phost->pActiveClass->pData = NULL;
 800d3b2:	61dc      	str	r4, [r3, #28]
}
 800d3b4:	bd70      	pop	{r4, r5, r6, pc}
    USBH_ClosePipe(phost, MIDI_Handle.InPipe);
 800d3b6:	f7ff fe35 	bl	800d024 <USBH_ClosePipe>
    USBH_FreePipe(phost, MIDI_Handle.InPipe);
 800d3ba:	7829      	ldrb	r1, [r5, #0]
 800d3bc:	4630      	mov	r0, r6
 800d3be:	f7ff fe55 	bl	800d06c <USBH_FreePipe>
    MIDI_Handle.InPipe = 0U;
 800d3c2:	2300      	movs	r3, #0
  if (MIDI_Handle.OutPipe != 0U)
 800d3c4:	7869      	ldrb	r1, [r5, #1]
    MIDI_Handle.InPipe = 0U;
 800d3c6:	702b      	strb	r3, [r5, #0]
  if (MIDI_Handle.OutPipe != 0U)
 800d3c8:	2900      	cmp	r1, #0
 800d3ca:	d0da      	beq.n	800d382 <USBH_MIDI_InterfaceDeInit+0xe>
    USBH_ClosePipe(phost, MIDI_Handle.OutPipe);
 800d3cc:	4630      	mov	r0, r6
 800d3ce:	f7ff fe29 	bl	800d024 <USBH_ClosePipe>
    USBH_FreePipe(phost, MIDI_Handle.OutPipe);
 800d3d2:	7869      	ldrb	r1, [r5, #1]
 800d3d4:	4630      	mov	r0, r6
 800d3d6:	f7ff fe49 	bl	800d06c <USBH_FreePipe>
    MIDI_Handle.OutPipe = 0U;
 800d3da:	2300      	movs	r3, #0
 800d3dc:	706b      	strb	r3, [r5, #1]
 800d3de:	e7d0      	b.n	800d382 <USBH_MIDI_InterfaceDeInit+0xe>
 800d3e0:	24005b80 	.word	0x24005b80
 800d3e4:	24005c20 	.word	0x24005c20
 800d3e8:	24005e20 	.word	0x24005e20

0800d3ec <USBH_MIDI_IsReady>:
  return (phost->gState == HOST_CLASS) && (phost->pActiveClass == &USBH_MIDI_Class);
 800d3ec:	7803      	ldrb	r3, [r0, #0]
 800d3ee:	2b0b      	cmp	r3, #11
 800d3f0:	d001      	beq.n	800d3f6 <USBH_MIDI_IsReady+0xa>
 800d3f2:	2000      	movs	r0, #0
}
 800d3f4:	4770      	bx	lr
  return (phost->gState == HOST_CLASS) && (phost->pActiveClass == &USBH_MIDI_Class);
 800d3f6:	4b04      	ldr	r3, [pc, #16]	; (800d408 <USBH_MIDI_IsReady+0x1c>)
 800d3f8:	f8d0 049c 	ldr.w	r0, [r0, #1180]	; 0x49c
 800d3fc:	1ac0      	subs	r0, r0, r3
 800d3fe:	fab0 f080 	clz	r0, r0
 800d402:	0940      	lsrs	r0, r0, #5
 800d404:	4770      	bx	lr
 800d406:	bf00      	nop
 800d408:	2400001c 	.word	0x2400001c

0800d40c <USBH_MIDI_ReadEvent>:
  if ((phost == NULL) || (packet4 == NULL) || (phost->pActiveClass != &USBH_MIDI_Class))
 800d40c:	2900      	cmp	r1, #0
 800d40e:	bf18      	it	ne
 800d410:	2800      	cmpne	r0, #0
 800d412:	bf0c      	ite	eq
 800d414:	2301      	moveq	r3, #1
 800d416:	2300      	movne	r3, #0
 800d418:	d021      	beq.n	800d45e <USBH_MIDI_ReadEvent+0x52>
 800d41a:	f8d0 249c 	ldr.w	r2, [r0, #1180]	; 0x49c
{
 800d41e:	b410      	push	{r4}
  if ((phost == NULL) || (packet4 == NULL) || (phost->pActiveClass != &USBH_MIDI_Class))
 800d420:	4c10      	ldr	r4, [pc, #64]	; (800d464 <USBH_MIDI_ReadEvent+0x58>)
 800d422:	42a2      	cmp	r2, r4
 800d424:	d003      	beq.n	800d42e <USBH_MIDI_ReadEvent+0x22>
}
 800d426:	4618      	mov	r0, r3
 800d428:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d42c:	4770      	bx	lr
  MIDI_HandleTypeDef *handle = (MIDI_HandleTypeDef *)phost->pActiveClass->pData;
 800d42e:	69d2      	ldr	r2, [r2, #28]
}

static bool MIDI_BufferPop(uint8_t buffer[][USBH_MIDI_EVENT_SIZE], uint16_t size,
                           uint16_t *head, uint16_t *tail, uint8_t *packet)
{
  if (*tail == *head)
 800d430:	f8b2 04a2 	ldrh.w	r0, [r2, #1186]	; 0x4a2
  return MIDI_BufferPop(handle->rx_buffer, USBH_MIDI_RX_QUEUE_SIZE,
 800d434:	f102 0ca0 	add.w	ip, r2, #160	; 0xa0
  if (*tail == *head)
 800d438:	f8b2 44a0 	ldrh.w	r4, [r2, #1184]	; 0x4a0
 800d43c:	4284      	cmp	r4, r0
 800d43e:	d0f2      	beq.n	800d426 <USBH_MIDI_ReadEvent+0x1a>
  {
    return false;
  }
  memcpy(packet, buffer[*tail], USBH_MIDI_EVENT_SIZE);
 800d440:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
  *tail = (uint16_t)((*tail + 1U) % size);
  return true;
 800d444:	2301      	movs	r3, #1
  memcpy(packet, buffer[*tail], USBH_MIDI_EVENT_SIZE);
 800d446:	6008      	str	r0, [r1, #0]
}
 800d448:	4618      	mov	r0, r3
  *tail = (uint16_t)((*tail + 1U) % size);
 800d44a:	f8b2 14a2 	ldrh.w	r1, [r2, #1186]	; 0x4a2
}
 800d44e:	f85d 4b04 	ldr.w	r4, [sp], #4
  *tail = (uint16_t)((*tail + 1U) % size);
 800d452:	4419      	add	r1, r3
 800d454:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800d458:	f8a2 14a2 	strh.w	r1, [r2, #1186]	; 0x4a2
}
 800d45c:	4770      	bx	lr
    return false;
 800d45e:	2300      	movs	r3, #0
}
 800d460:	4618      	mov	r0, r3
 800d462:	4770      	bx	lr
 800d464:	2400001c 	.word	0x2400001c

0800d468 <USBH_MIDI_GetTxOverflow>:
  if ((phost == NULL) || (phost->pActiveClass != &USBH_MIDI_Class))
 800d468:	b128      	cbz	r0, 800d476 <USBH_MIDI_GetTxOverflow+0xe>
 800d46a:	4a05      	ldr	r2, [pc, #20]	; (800d480 <USBH_MIDI_GetTxOverflow+0x18>)
 800d46c:	f8d0 349c 	ldr.w	r3, [r0, #1180]	; 0x49c
 800d470:	4293      	cmp	r3, r2
 800d472:	d001      	beq.n	800d478 <USBH_MIDI_GetTxOverflow+0x10>
    return 0U;
 800d474:	2000      	movs	r0, #0
}
 800d476:	4770      	bx	lr
  return handle->tx_overflow;
 800d478:	69db      	ldr	r3, [r3, #28]
 800d47a:	f8d3 04ac 	ldr.w	r0, [r3, #1196]	; 0x4ac
 800d47e:	4770      	bx	lr
 800d480:	2400001c 	.word	0x2400001c

0800d484 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800d484:	4b01      	ldr	r3, [pc, #4]	; (800d48c <HAL_GetTick+0x8>)
 800d486:	6818      	ldr	r0, [r3, #0]
}
 800d488:	4770      	bx	lr
 800d48a:	bf00      	nop
 800d48c:	24006040 	.word	0x24006040

0800d490 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800d490:	b538      	push	{r3, r4, r5, lr}
 800d492:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800d494:	f7ff fff6 	bl	800d484 <HAL_GetTick>
 800d498:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800d49a:	1c63      	adds	r3, r4, #1
 800d49c:	d002      	beq.n	800d4a4 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800d49e:	4b04      	ldr	r3, [pc, #16]	; (800d4b0 <HAL_Delay+0x20>)
 800d4a0:	781b      	ldrb	r3, [r3, #0]
 800d4a2:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800d4a4:	f7ff ffee 	bl	800d484 <HAL_GetTick>
 800d4a8:	1b43      	subs	r3, r0, r5
 800d4aa:	42a3      	cmp	r3, r4
 800d4ac:	d3fa      	bcc.n	800d4a4 <HAL_Delay+0x14>
  {
  }
}
 800d4ae:	bd38      	pop	{r3, r4, r5, pc}
 800d4b0:	2400003c 	.word	0x2400003c

0800d4b4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
 800d4b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800d4b8:	680c      	ldr	r4, [r1, #0]
{
 800d4ba:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800d4bc:	2c00      	cmp	r4, #0
 800d4be:	f000 80bb 	beq.w	800d638 <HAL_GPIO_Init+0x184>
 800d4c2:	2200      	movs	r2, #0
  uint32_t position = 0x00U;
 800d4c4:	4613      	mov	r3, r2
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 800d4c6:	2501      	movs	r5, #1
 800d4c8:	409d      	lsls	r5, r3

    if (iocurrent != 0x00U)
 800d4ca:	ea15 0c04 	ands.w	ip, r5, r4
 800d4ce:	f000 80ad 	beq.w	800d62c <HAL_GPIO_Init+0x178>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800d4d2:	684e      	ldr	r6, [r1, #4]
 800d4d4:	f006 0803 	and.w	r8, r6, #3
 800d4d8:	f108 3eff 	add.w	lr, r8, #4294967295
 800d4dc:	f1be 0f01 	cmp.w	lr, #1
 800d4e0:	f240 80ad 	bls.w	800d63e <HAL_GPIO_Init+0x18a>
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
        GPIOx->OTYPER = temp;
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
 800d4e4:	f1b8 0f03 	cmp.w	r8, #3
 800d4e8:	f040 80eb 	bne.w	800d6c2 <HAL_GPIO_Init+0x20e>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
 800d4ec:	688d      	ldr	r5, [r1, #8]
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800d4ee:	fa08 f802 	lsl.w	r8, r8, r2
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
 800d4f2:	2d01      	cmp	r5, #1
 800d4f4:	d007      	beq.n	800d506 <HAL_GPIO_Init+0x52>
      temp = GPIOx->PUPDR;
 800d4f6:	f8d0 e00c 	ldr.w	lr, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800d4fa:	4095      	lsls	r5, r2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800d4fc:	ea2e 0e08 	bic.w	lr, lr, r8
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800d500:	ea45 050e 	orr.w	r5, r5, lr
      GPIOx->PUPDR = temp;
 800d504:	60c5      	str	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800d506:	ea6f 0e08 	mvn.w	lr, r8
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800d50a:	6805      	ldr	r5, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800d50c:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800d510:	ea05 050e 	and.w	r5, r5, lr
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800d514:	ea48 0505 	orr.w	r5, r8, r5
      GPIOx->MODER = temp;
 800d518:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800d51a:	f000 8087 	beq.w	800d62c <HAL_GPIO_Init+0x178>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d51e:	4f88      	ldr	r7, [pc, #544]	; (800d740 <HAL_GPIO_Init+0x28c>)
 800d520:	f023 0803 	bic.w	r8, r3, #3

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800d524:	f003 0903 	and.w	r9, r3, #3
 800d528:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d52c:	f8d7 50f4 	ldr.w	r5, [r7, #244]	; 0xf4
 800d530:	f108 48b0 	add.w	r8, r8, #1476395008	; 0x58000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800d534:	ea4f 0989 	mov.w	r9, r9, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d538:	f045 0502 	orr.w	r5, r5, #2
 800d53c:	f508 6880 	add.w	r8, r8, #1024	; 0x400
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800d540:	fa0e fe09 	lsl.w	lr, lr, r9
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d544:	f8c7 50f4 	str.w	r5, [r7, #244]	; 0xf4
 800d548:	f8d7 50f4 	ldr.w	r5, [r7, #244]	; 0xf4
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800d54c:	f5a7 4788 	sub.w	r7, r7, #17408	; 0x4400
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d550:	f005 0502 	and.w	r5, r5, #2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800d554:	42b8      	cmp	r0, r7
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d556:	9501      	str	r5, [sp, #4]
 800d558:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 800d55a:	f8d8 5008 	ldr.w	r5, [r8, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800d55e:	ea25 050e 	bic.w	r5, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800d562:	d02e      	beq.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d564:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 800d568:	42b8      	cmp	r0, r7
 800d56a:	f000 80b8 	beq.w	800d6de <HAL_GPIO_Init+0x22a>
 800d56e:	4f75      	ldr	r7, [pc, #468]	; (800d744 <HAL_GPIO_Init+0x290>)
 800d570:	42b8      	cmp	r0, r7
 800d572:	f000 80bb 	beq.w	800d6ec <HAL_GPIO_Init+0x238>
 800d576:	4f74      	ldr	r7, [pc, #464]	; (800d748 <HAL_GPIO_Init+0x294>)
 800d578:	42b8      	cmp	r0, r7
 800d57a:	f000 80a9 	beq.w	800d6d0 <HAL_GPIO_Init+0x21c>
 800d57e:	4f73      	ldr	r7, [pc, #460]	; (800d74c <HAL_GPIO_Init+0x298>)
 800d580:	42b8      	cmp	r0, r7
 800d582:	f000 80c1 	beq.w	800d708 <HAL_GPIO_Init+0x254>
 800d586:	4f72      	ldr	r7, [pc, #456]	; (800d750 <HAL_GPIO_Init+0x29c>)
 800d588:	42b8      	cmp	r0, r7
 800d58a:	f000 80c4 	beq.w	800d716 <HAL_GPIO_Init+0x262>
 800d58e:	4f71      	ldr	r7, [pc, #452]	; (800d754 <HAL_GPIO_Init+0x2a0>)
 800d590:	42b8      	cmp	r0, r7
 800d592:	f000 80b2 	beq.w	800d6fa <HAL_GPIO_Init+0x246>
 800d596:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 800d758 <HAL_GPIO_Init+0x2a4>
 800d59a:	4570      	cmp	r0, lr
 800d59c:	f000 80c2 	beq.w	800d724 <HAL_GPIO_Init+0x270>
 800d5a0:	f8df e1b8 	ldr.w	lr, [pc, #440]	; 800d75c <HAL_GPIO_Init+0x2a8>
 800d5a4:	4570      	cmp	r0, lr
 800d5a6:	f000 80c4 	beq.w	800d732 <HAL_GPIO_Init+0x27e>
 800d5aa:	f8df e1b4 	ldr.w	lr, [pc, #436]	; 800d760 <HAL_GPIO_Init+0x2ac>
 800d5ae:	4570      	cmp	r0, lr
 800d5b0:	bf0c      	ite	eq
 800d5b2:	f04f 0e09 	moveq.w	lr, #9
 800d5b6:	f04f 0e0a 	movne.w	lr, #10
 800d5ba:	fa0e fe09 	lsl.w	lr, lr, r9
 800d5be:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 800d5c2:	f8c8 5008 	str.w	r5, [r8, #8]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800d5c6:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800d5ca:	02f7      	lsls	r7, r6, #11
        temp &= ~(iocurrent);
 800d5cc:	ea6f 0e0c 	mvn.w	lr, ip
        temp = EXTI->RTSR1;
 800d5d0:	682d      	ldr	r5, [r5, #0]
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 800d5d2:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 800d5d6:	bf54      	ite	pl
 800d5d8:	ea0e 0505 	andpl.w	r5, lr, r5
          temp |= iocurrent;
 800d5dc:	ea4c 0505 	orrmi.w	r5, ip, r5

        temp = EXTI->FTSR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800d5e0:	02b7      	lsls	r7, r6, #10
        EXTI->RTSR1 = temp;
 800d5e2:	f8c8 5000 	str.w	r5, [r8]
        temp = EXTI->FTSR1;
 800d5e6:	f8d8 5004 	ldr.w	r5, [r8, #4]
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 800d5ea:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 800d5ee:	bf54      	ite	pl
 800d5f0:	ea0e 0505 	andpl.w	r5, lr, r5
          temp |= iocurrent;
 800d5f4:	ea4c 0505 	orrmi.w	r5, ip, r5

        temp = EXTI_CurrentCPU->EMR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800d5f8:	03b7      	lsls	r7, r6, #14
        EXTI->FTSR1 = temp;
 800d5fa:	f8c8 5004 	str.w	r5, [r8, #4]
        temp = EXTI_CurrentCPU->EMR1;
 800d5fe:	f8d8 5084 	ldr.w	r5, [r8, #132]	; 0x84
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;
 800d602:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 800d606:	bf54      	ite	pl
 800d608:	ea0e 0505 	andpl.w	r5, lr, r5
          temp |= iocurrent;
 800d60c:	ea4c 0505 	orrmi.w	r5, ip, r5

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800d610:	03f6      	lsls	r6, r6, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
 800d612:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
        EXTI_CurrentCPU->EMR1 = temp;
 800d616:	f8c8 5084 	str.w	r5, [r8, #132]	; 0x84
        temp = EXTI_CurrentCPU->IMR1;
 800d61a:	f8d8 5080 	ldr.w	r5, [r8, #128]	; 0x80
        temp &= ~(iocurrent);
 800d61e:	bf54      	ite	pl
 800d620:	ea0e 0505 	andpl.w	r5, lr, r5
          temp |= iocurrent;
 800d624:	ea4c 0505 	orrmi.w	r5, ip, r5
        EXTI_CurrentCPU->IMR1 = temp;
 800d628:	f8c6 5080 	str.w	r5, [r6, #128]	; 0x80
      }
    }

    position++;
 800d62c:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800d62e:	3202      	adds	r2, #2
 800d630:	fa34 f503 	lsrs.w	r5, r4, r3
 800d634:	f47f af47 	bne.w	800d4c6 <HAL_GPIO_Init+0x12>
  }
}
 800d638:	b003      	add	sp, #12
 800d63a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800d63e:	f04f 0e03 	mov.w	lr, #3
        temp = GPIOx->OSPEEDR;
 800d642:	f8d0 a008 	ldr.w	sl, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800d646:	68cf      	ldr	r7, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800d648:	fa0e fe02 	lsl.w	lr, lr, r2
        temp |= (GPIO_Init->Speed << (position * 2U));
 800d64c:	fa07 f902 	lsl.w	r9, r7, r2
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800d650:	ea2a 0a0e 	bic.w	sl, sl, lr
 800d654:	ea6f 0e0e 	mvn.w	lr, lr
        temp |= (GPIO_Init->Speed << (position * 2U));
 800d658:	ea49 090a 	orr.w	r9, r9, sl
        GPIOx->OSPEEDR = temp;
 800d65c:	f8c0 9008 	str.w	r9, [r0, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800d660:	f3c6 1900 	ubfx	r9, r6, #4, #1
        temp = GPIOx->OTYPER;
 800d664:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800d668:	fa09 f903 	lsl.w	r9, r9, r3
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800d66c:	ea2a 0505 	bic.w	r5, sl, r5
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800d670:	ea49 0505 	orr.w	r5, r9, r5
        GPIOx->OTYPER = temp;
 800d674:	6045      	str	r5, [r0, #4]
      temp = GPIOx->PUPDR;
 800d676:	68c5      	ldr	r5, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800d678:	f1b8 0f02 	cmp.w	r8, #2
 800d67c:	fa08 f802 	lsl.w	r8, r8, r2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800d680:	ea05 090e 	and.w	r9, r5, lr
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800d684:	688d      	ldr	r5, [r1, #8]
 800d686:	fa05 f502 	lsl.w	r5, r5, r2
 800d68a:	ea45 0509 	orr.w	r5, r5, r9
      GPIOx->PUPDR = temp;
 800d68e:	60c5      	str	r5, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800d690:	f47f af3b 	bne.w	800d50a <HAL_GPIO_Init+0x56>
        temp = GPIOx->AFR[position >> 3U];
 800d694:	ea4f 09d3 	mov.w	r9, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800d698:	f003 0b07 	and.w	fp, r3, #7
 800d69c:	250f      	movs	r5, #15
 800d69e:	eb00 0989 	add.w	r9, r0, r9, lsl #2
 800d6a2:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = GPIOx->AFR[position >> 3U];
 800d6a6:	f8d9 a020 	ldr.w	sl, [r9, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800d6aa:	fa05 f50b 	lsl.w	r5, r5, fp
 800d6ae:	ea2a 0a05 	bic.w	sl, sl, r5
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800d6b2:	690d      	ldr	r5, [r1, #16]
 800d6b4:	fa05 f50b 	lsl.w	r5, r5, fp
 800d6b8:	ea45 050a 	orr.w	r5, r5, sl
        GPIOx->AFR[position >> 3U] = temp;
 800d6bc:	f8c9 5020 	str.w	r5, [r9, #32]
 800d6c0:	e723      	b.n	800d50a <HAL_GPIO_Init+0x56>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800d6c2:	f04f 0e03 	mov.w	lr, #3
 800d6c6:	fa0e fe02 	lsl.w	lr, lr, r2
 800d6ca:	ea6f 0e0e 	mvn.w	lr, lr
 800d6ce:	e7d2      	b.n	800d676 <HAL_GPIO_Init+0x1c2>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800d6d0:	f04f 0e03 	mov.w	lr, #3
 800d6d4:	fa0e fe09 	lsl.w	lr, lr, r9
 800d6d8:	ea45 050e 	orr.w	r5, r5, lr
 800d6dc:	e771      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d6de:	f04f 0e01 	mov.w	lr, #1
 800d6e2:	fa0e fe09 	lsl.w	lr, lr, r9
 800d6e6:	ea45 050e 	orr.w	r5, r5, lr
 800d6ea:	e76a      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d6ec:	f04f 0e02 	mov.w	lr, #2
 800d6f0:	fa0e fe09 	lsl.w	lr, lr, r9
 800d6f4:	ea45 050e 	orr.w	r5, r5, lr
 800d6f8:	e763      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d6fa:	f04f 0e06 	mov.w	lr, #6
 800d6fe:	fa0e fe09 	lsl.w	lr, lr, r9
 800d702:	ea45 050e 	orr.w	r5, r5, lr
 800d706:	e75c      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d708:	f04f 0e04 	mov.w	lr, #4
 800d70c:	fa0e fe09 	lsl.w	lr, lr, r9
 800d710:	ea45 050e 	orr.w	r5, r5, lr
 800d714:	e755      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d716:	f04f 0e05 	mov.w	lr, #5
 800d71a:	fa0e fe09 	lsl.w	lr, lr, r9
 800d71e:	ea45 050e 	orr.w	r5, r5, lr
 800d722:	e74e      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d724:	f04f 0e07 	mov.w	lr, #7
 800d728:	fa0e fe09 	lsl.w	lr, lr, r9
 800d72c:	ea45 050e 	orr.w	r5, r5, lr
 800d730:	e747      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d732:	f04f 0e08 	mov.w	lr, #8
 800d736:	fa0e fe09 	lsl.w	lr, lr, r9
 800d73a:	ea45 050e 	orr.w	r5, r5, lr
 800d73e:	e740      	b.n	800d5c2 <HAL_GPIO_Init+0x10e>
 800d740:	58024400 	.word	0x58024400
 800d744:	58020800 	.word	0x58020800
 800d748:	58020c00 	.word	0x58020c00
 800d74c:	58021000 	.word	0x58021000
 800d750:	58021400 	.word	0x58021400
 800d754:	58021800 	.word	0x58021800
 800d758:	58021c00 	.word	0x58021c00
 800d75c:	58022000 	.word	0x58022000
 800d760:	58022400 	.word	0x58022400

0800d764 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 800d764:	4a02      	ldr	r2, [pc, #8]	; (800d770 <HAL_PWREx_EnableUSBVoltageDetector+0xc>)
 800d766:	68d3      	ldr	r3, [r2, #12]
 800d768:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800d76c:	60d3      	str	r3, [r2, #12]
}
 800d76e:	4770      	bx	lr
 800d770:	58024800 	.word	0x58024800

0800d774 <HAL_HCD_HC_Init>:
  *          This parameter can be a value from 0 to32K
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd, uint8_t ch_num, uint8_t epnum,
                                  uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 800d774:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d778:	469a      	mov	sl, r3
  HAL_StatusTypeDef status;
  uint32_t HostCoreSpeed;
  uint32_t HCcharMps = mps;

  __HAL_LOCK(hhcd);
 800d77a:	f890 33d4 	ldrb.w	r3, [r0, #980]	; 0x3d4
{
 800d77e:	b084      	sub	sp, #16
  __HAL_LOCK(hhcd);
 800d780:	2b01      	cmp	r3, #1
{
 800d782:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
 800d786:	f89d 6034 	ldrb.w	r6, [sp, #52]	; 0x34
 800d78a:	f8bd 8038 	ldrh.w	r8, [sp, #56]	; 0x38
  __HAL_LOCK(hhcd);
 800d78e:	d044      	beq.n	800d81a <HAL_HCD_HC_Init+0xa6>
  hhcd->hc[ch_num].do_ping = 0U;
  hhcd->hc[ch_num].dev_addr = dev_address;
 800d790:	ebc1 1c01 	rsb	ip, r1, r1, lsl #4
  hhcd->hc[ch_num].do_ping = 0U;
 800d794:	2300      	movs	r3, #0
 800d796:	4691      	mov	r9, r2
  __HAL_LOCK(hhcd);
 800d798:	2201      	movs	r2, #1
  hhcd->hc[ch_num].dev_addr = dev_address;
 800d79a:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 800d79e:	4604      	mov	r4, r0
  __HAL_LOCK(hhcd);
 800d7a0:	f880 23d4 	strb.w	r2, [r0, #980]	; 0x3d4
  hhcd->hc[ch_num].dev_addr = dev_address;
 800d7a4:	460d      	mov	r5, r1
  hhcd->hc[ch_num].do_ping = 0U;
 800d7a6:	f88c 3019 	strb.w	r3, [ip, #25]
  *         This parameter can be a value from 1 to 15
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_ClearHubInfo(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  hhcd->hc[ch_num].do_ssplit = 0U;
 800d7aa:	f8ac 301a 	strh.w	r3, [ip, #26]
  hhcd->hc[ch_num].do_csplit = 0U;
  hhcd->hc[ch_num].hub_addr = 0U;
  hhcd->hc[ch_num].hub_port_nbr = 0U;
 800d7ae:	f8ac 3024 	strh.w	r3, [ip, #36]	; 0x24
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 800d7b2:	f009 037f 	and.w	r3, r9, #127	; 0x7f
  hhcd->hc[ch_num].ch_num = ch_num;
 800d7b6:	f88c 1015 	strb.w	r1, [ip, #21]
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 800d7ba:	f88c 3016 	strb.w	r3, [ip, #22]
  if ((epnum & 0x80U) == 0x80U)
 800d7be:	ea4f 13d9 	mov.w	r3, r9, lsr #7
  hhcd->hc[ch_num].dev_addr = dev_address;
 800d7c2:	f88c a014 	strb.w	sl, [ip, #20]
  hhcd->hc[ch_num].ep_type = ep_type;
 800d7c6:	f88c 6026 	strb.w	r6, [ip, #38]	; 0x26
  if ((epnum & 0x80U) == 0x80U)
 800d7ca:	f88c 3017 	strb.w	r3, [ip, #23]
  HostCoreSpeed = USB_GetHostSpeed(hhcd->Instance);
 800d7ce:	6800      	ldr	r0, [r0, #0]
 800d7d0:	f000 fb7c 	bl	800decc <USB_GetHostSpeed>
  if (ep_type == EP_TYPE_ISOC)
 800d7d4:	2e01      	cmp	r6, #1
  hhcd->hc[ch_num].dev_addr = dev_address;
 800d7d6:	ea4f 1105 	mov.w	r1, r5, lsl #4
  if (ep_type == EP_TYPE_ISOC)
 800d7da:	d014      	beq.n	800d806 <HAL_HCD_HC_Init+0x92>
  hhcd->hc[ch_num].speed = speed;
 800d7dc:	1b48      	subs	r0, r1, r5
  status =  USB_HC_Init(hhcd->Instance, ch_num, epnum,
 800d7de:	4653      	mov	r3, sl
 800d7e0:	464a      	mov	r2, r9
 800d7e2:	4629      	mov	r1, r5
  hhcd->hc[ch_num].speed = speed;
 800d7e4:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 800d7e8:	7607      	strb	r7, [r0, #24]
  hhcd->hc[ch_num].max_packet = (uint16_t)HCcharMps;
 800d7ea:	f8a0 8028 	strh.w	r8, [r0, #40]	; 0x28
  status =  USB_HC_Init(hhcd->Instance, ch_num, epnum,
 800d7ee:	9700      	str	r7, [sp, #0]
 800d7f0:	e9cd 6801 	strd	r6, r8, [sp, #4]
 800d7f4:	6820      	ldr	r0, [r4, #0]
 800d7f6:	f000 fb75 	bl	800dee4 <USB_HC_Init>
  __HAL_UNLOCK(hhcd);
 800d7fa:	2300      	movs	r3, #0
 800d7fc:	f884 33d4 	strb.w	r3, [r4, #980]	; 0x3d4
}
 800d800:	b004      	add	sp, #16
 800d802:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((speed == HCD_DEVICE_SPEED_FULL) && (HostCoreSpeed == HPRT0_PRTSPD_HIGH_SPEED))
 800d806:	2f01      	cmp	r7, #1
 800d808:	d1e8      	bne.n	800d7dc <HAL_HCD_HC_Init+0x68>
 800d80a:	2800      	cmp	r0, #0
 800d80c:	d1e6      	bne.n	800d7dc <HAL_HCD_HC_Init+0x68>
  hhcd->hc[ch_num].max_packet = (uint16_t)HCcharMps;
 800d80e:	f1b8 0fbc 	cmp.w	r8, #188	; 0xbc
 800d812:	bf28      	it	cs
 800d814:	f04f 08bc 	movcs.w	r8, #188	; 0xbc
 800d818:	e7e0      	b.n	800d7dc <HAL_HCD_HC_Init+0x68>
  __HAL_LOCK(hhcd);
 800d81a:	2002      	movs	r0, #2
}
 800d81c:	b004      	add	sp, #16
 800d81e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d822:	bf00      	nop

0800d824 <HAL_HCD_HC_Halt>:
  __HAL_LOCK(hhcd);
 800d824:	f890 33d4 	ldrb.w	r3, [r0, #980]	; 0x3d4
 800d828:	2b01      	cmp	r3, #1
 800d82a:	d00c      	beq.n	800d846 <HAL_HCD_HC_Halt+0x22>
 800d82c:	2301      	movs	r3, #1
{
 800d82e:	b510      	push	{r4, lr}
 800d830:	4604      	mov	r4, r0
  (void)USB_HC_Halt(hhcd->Instance, ch_num);
 800d832:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 800d834:	f884 33d4 	strb.w	r3, [r4, #980]	; 0x3d4
  (void)USB_HC_Halt(hhcd->Instance, ch_num);
 800d838:	f000 fd66 	bl	800e308 <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
 800d83c:	2300      	movs	r3, #0
  return status;
 800d83e:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 800d840:	f884 33d4 	strb.w	r3, [r4, #980]	; 0x3d4
}
 800d844:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 800d846:	2002      	movs	r0, #2
}
 800d848:	4770      	bx	lr
 800d84a:	bf00      	nop

0800d84c <HAL_HCD_Init>:
  if (hhcd == NULL)
 800d84c:	2800      	cmp	r0, #0
 800d84e:	d037      	beq.n	800d8c0 <HAL_HCD_Init+0x74>
{
 800d850:	b530      	push	{r4, r5, lr}
  if (hhcd->State == HAL_HCD_STATE_RESET)
 800d852:	f890 33d5 	ldrb.w	r3, [r0, #981]	; 0x3d5
{
 800d856:	b083      	sub	sp, #12
 800d858:	4604      	mov	r4, r0
  if (hhcd->State == HAL_HCD_STATE_RESET)
 800d85a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800d85e:	b353      	cbz	r3, 800d8b6 <HAL_HCD_Init+0x6a>
  hhcd->State = HAL_HCD_STATE_BUSY;
 800d860:	2303      	movs	r3, #3
  __HAL_HCD_DISABLE(hhcd);
 800d862:	6820      	ldr	r0, [r4, #0]
  if (USB_CoreInit(hhcd->Instance, hhcd->Init) != HAL_OK)
 800d864:	1d25      	adds	r5, r4, #4
  hhcd->State = HAL_HCD_STATE_BUSY;
 800d866:	f884 33d5 	strb.w	r3, [r4, #981]	; 0x3d5
  __HAL_HCD_DISABLE(hhcd);
 800d86a:	f000 f9f7 	bl	800dc5c <USB_DisableGlobalInt>
  if (USB_CoreInit(hhcd->Instance, hhcd->Init) != HAL_OK)
 800d86e:	7c23      	ldrb	r3, [r4, #16]
 800d870:	f88d 3000 	strb.w	r3, [sp]
 800d874:	6820      	ldr	r0, [r4, #0]
 800d876:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
 800d87a:	f000 f995 	bl	800dba8 <USB_CoreInit>
 800d87e:	b128      	cbz	r0, 800d88c <HAL_HCD_Init+0x40>
    hhcd->State = HAL_HCD_STATE_ERROR;
 800d880:	2302      	movs	r3, #2
    return HAL_ERROR;
 800d882:	2001      	movs	r0, #1
    hhcd->State = HAL_HCD_STATE_ERROR;
 800d884:	f884 33d5 	strb.w	r3, [r4, #981]	; 0x3d5
}
 800d888:	b003      	add	sp, #12
 800d88a:	bd30      	pop	{r4, r5, pc}
  if (USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE) != HAL_OK)
 800d88c:	2101      	movs	r1, #1
 800d88e:	6820      	ldr	r0, [r4, #0]
 800d890:	f000 f9ec 	bl	800dc6c <USB_SetCurrentMode>
 800d894:	2800      	cmp	r0, #0
 800d896:	d1f3      	bne.n	800d880 <HAL_HCD_Init+0x34>
  if (USB_HostInit(hhcd->Instance, hhcd->Init) != HAL_OK)
 800d898:	7c20      	ldrb	r0, [r4, #16]
 800d89a:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
 800d89e:	f88d 0000 	strb.w	r0, [sp]
 800d8a2:	6820      	ldr	r0, [r4, #0]
 800d8a4:	f000 fa66 	bl	800dd74 <USB_HostInit>
 800d8a8:	2800      	cmp	r0, #0
 800d8aa:	d1e9      	bne.n	800d880 <HAL_HCD_Init+0x34>
  hhcd->State = HAL_HCD_STATE_READY;
 800d8ac:	2301      	movs	r3, #1
 800d8ae:	f884 33d5 	strb.w	r3, [r4, #981]	; 0x3d5
}
 800d8b2:	b003      	add	sp, #12
 800d8b4:	bd30      	pop	{r4, r5, pc}
    hhcd->Lock = HAL_UNLOCKED;
 800d8b6:	f880 23d4 	strb.w	r2, [r0, #980]	; 0x3d4
    HAL_HCD_MspInit(hhcd);
 800d8ba:	f7fe f971 	bl	800bba0 <HAL_HCD_MspInit>
 800d8be:	e7cf      	b.n	800d860 <HAL_HCD_Init+0x14>
    return HAL_ERROR;
 800d8c0:	2001      	movs	r0, #1
}
 800d8c2:	4770      	bx	lr

0800d8c4 <HAL_HCD_HC_SubmitRequest>:
{
 800d8c4:	b5f0      	push	{r4, r5, r6, r7, lr}
  hhcd->hc[ch_num].ep_is_in = direction;
 800d8c6:	ebc1 1e01 	rsb	lr, r1, r1, lsl #4
{
 800d8ca:	f89d 4014 	ldrb.w	r4, [sp, #20]
 800d8ce:	9e06      	ldr	r6, [sp, #24]
  hhcd->hc[ch_num].ep_is_in = direction;
 800d8d0:	ea4f 1c01 	mov.w	ip, r1, lsl #4
 800d8d4:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
{
 800d8d8:	f8bd 501c 	ldrh.w	r5, [sp, #28]
 800d8dc:	f89d 7020 	ldrb.w	r7, [sp, #32]
  hhcd->hc[ch_num].ep_is_in = direction;
 800d8e0:	f88e 2017 	strb.w	r2, [lr, #23]
  hhcd->hc[ch_num].ep_type  = ep_type;
 800d8e4:	f88e 3026 	strb.w	r3, [lr, #38]	; 0x26
  if (token == 0U)
 800d8e8:	b9fc      	cbnz	r4, 800d92a <HAL_HCD_HC_SubmitRequest+0x66>
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 800d8ea:	2403      	movs	r4, #3
  switch (ep_type)
 800d8ec:	2b02      	cmp	r3, #2
    hhcd->hc[ch_num].do_ping = do_ping;
 800d8ee:	f88e 7019 	strb.w	r7, [lr, #25]
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 800d8f2:	f88e 402a 	strb.w	r4, [lr, #42]	; 0x2a
  switch (ep_type)
 800d8f6:	d021      	beq.n	800d93c <HAL_HCD_HC_SubmitRequest+0x78>
 800d8f8:	42a3      	cmp	r3, r4
 800d8fa:	d01f      	beq.n	800d93c <HAL_HCD_HC_SubmitRequest+0x78>
 800d8fc:	2b01      	cmp	r3, #1
 800d8fe:	d029      	beq.n	800d954 <HAL_HCD_HC_SubmitRequest+0x90>
  hhcd->hc[ch_num].xfer_buff = pbuff;
 800d900:	ebac 0301 	sub.w	r3, ip, r1
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800d904:	243c      	movs	r4, #60	; 0x3c
  hhcd->hc[ch_num].xfer_count = 0U;
 800d906:	2200      	movs	r2, #0
  hhcd->hc[ch_num].xfer_buff = pbuff;
 800d908:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  hhcd->hc[ch_num].ch_num = ch_num;
 800d90c:	7559      	strb	r1, [r3, #21]
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800d90e:	fb04 0101 	mla	r1, r4, r1, r0
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 800d912:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  hhcd->hc[ch_num].xfer_buff = pbuff;
 800d916:	62de      	str	r6, [r3, #44]	; 0x2c
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800d918:	3114      	adds	r1, #20
  hhcd->hc[ch_num].xfer_len  = length;
 800d91a:	e9c3 520d 	strd	r5, r2, [r3, #52]	; 0x34
}
 800d91e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800d922:	7982      	ldrb	r2, [r0, #6]
 800d924:	6800      	ldr	r0, [r0, #0]
 800d926:	f000 bb7d 	b.w	800e024 <USB_HC_StartXfer>
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800d92a:	2702      	movs	r7, #2
 800d92c:	f88e 702a 	strb.w	r7, [lr, #42]	; 0x2a
  switch (ep_type)
 800d930:	2b03      	cmp	r3, #3
 800d932:	d8e5      	bhi.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
 800d934:	e8df f003 	tbb	[pc, r3]
 800d938:	02020e1e 	.word	0x02020e1e
        if (hhcd->hc[ch_num].toggle_out == 0U)
 800d93c:	ebac 0301 	sub.w	r3, ip, r1
 800d940:	eb00 0383 	add.w	r3, r0, r3, lsl #2
      if (direction == 0U)
 800d944:	b972      	cbnz	r2, 800d964 <HAL_HCD_HC_SubmitRequest+0xa0>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 800d946:	f893 403d 	ldrb.w	r4, [r3, #61]	; 0x3d
 800d94a:	b144      	cbz	r4, 800d95e <HAL_HCD_HC_SubmitRequest+0x9a>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800d94c:	2202      	movs	r2, #2
 800d94e:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 800d952:	e7d5      	b.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 800d954:	ebac 0301 	sub.w	r3, ip, r1
 800d958:	2200      	movs	r2, #0
 800d95a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800d95e:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
      break;
 800d962:	e7cd      	b.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 800d964:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 800d968:	2a00      	cmp	r2, #0
 800d96a:	d0f8      	beq.n	800d95e <HAL_HCD_HC_SubmitRequest+0x9a>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800d96c:	2202      	movs	r2, #2
 800d96e:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 800d972:	e7c5      	b.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
      if (token == 1U) /* send data */
 800d974:	2c01      	cmp	r4, #1
 800d976:	d1c3      	bne.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
            hhcd->hc[ch_num].toggle_out = 1U;
 800d978:	ebac 0301 	sub.w	r3, ip, r1
 800d97c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
        if (direction == 0U)
 800d980:	b91a      	cbnz	r2, 800d98a <HAL_HCD_HC_SubmitRequest+0xc6>
          if (length == 0U)
 800d982:	b955      	cbnz	r5, 800d99a <HAL_HCD_HC_SubmitRequest+0xd6>
            hhcd->hc[ch_num].toggle_out = 1U;
 800d984:	f883 403d 	strb.w	r4, [r3, #61]	; 0x3d
          if (hhcd->hc[ch_num].toggle_out == 0U)
 800d988:	e7ba      	b.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
          if (hhcd->hc[ch_num].do_ssplit == 1U)
 800d98a:	7e9a      	ldrb	r2, [r3, #26]
 800d98c:	2a01      	cmp	r2, #1
 800d98e:	d1b7      	bne.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
            if (hhcd->hc[ch_num].toggle_in == 0U)
 800d990:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 800d994:	2a00      	cmp	r2, #0
 800d996:	d1b3      	bne.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>
 800d998:	e7e1      	b.n	800d95e <HAL_HCD_HC_SubmitRequest+0x9a>
          if (hhcd->hc[ch_num].toggle_out == 0U)
 800d99a:	f893 403d 	ldrb.w	r4, [r3, #61]	; 0x3d
 800d99e:	2c00      	cmp	r4, #0
 800d9a0:	d0dd      	beq.n	800d95e <HAL_HCD_HC_SubmitRequest+0x9a>
 800d9a2:	e7ad      	b.n	800d900 <HAL_HCD_HC_SubmitRequest+0x3c>

0800d9a4 <HAL_HCD_Start>:
  __HAL_LOCK(hhcd);
 800d9a4:	f890 33d4 	ldrb.w	r3, [r0, #980]	; 0x3d4
 800d9a8:	2b01      	cmp	r3, #1
 800d9aa:	d00f      	beq.n	800d9cc <HAL_HCD_Start+0x28>
 800d9ac:	2101      	movs	r1, #1
{
 800d9ae:	b510      	push	{r4, lr}
 800d9b0:	4604      	mov	r4, r0
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 800d9b2:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 800d9b4:	f884 13d4 	strb.w	r1, [r4, #980]	; 0x3d4
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 800d9b8:	f000 fa60 	bl	800de7c <USB_DriveVbus>
  __HAL_HCD_ENABLE(hhcd);
 800d9bc:	6820      	ldr	r0, [r4, #0]
 800d9be:	f000 f945 	bl	800dc4c <USB_EnableGlobalInt>
  __HAL_UNLOCK(hhcd);
 800d9c2:	2300      	movs	r3, #0
  return HAL_OK;
 800d9c4:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 800d9c6:	f884 33d4 	strb.w	r3, [r4, #980]	; 0x3d4
}
 800d9ca:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 800d9cc:	2002      	movs	r0, #2
}
 800d9ce:	4770      	bx	lr

0800d9d0 <HAL_HCD_Stop>:
  __HAL_LOCK(hhcd);
 800d9d0:	f890 33d4 	ldrb.w	r3, [r0, #980]	; 0x3d4
 800d9d4:	2b01      	cmp	r3, #1
 800d9d6:	d00c      	beq.n	800d9f2 <HAL_HCD_Stop+0x22>
 800d9d8:	2301      	movs	r3, #1
{
 800d9da:	b510      	push	{r4, lr}
 800d9dc:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
 800d9de:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 800d9e0:	f884 33d4 	strb.w	r3, [r4, #980]	; 0x3d4
  (void)USB_StopHost(hhcd->Instance);
 800d9e4:	f000 fd0a 	bl	800e3fc <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 800d9e8:	2300      	movs	r3, #0
  return HAL_OK;
 800d9ea:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 800d9ec:	f884 33d4 	strb.w	r3, [r4, #980]	; 0x3d4
}
 800d9f0:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 800d9f2:	2002      	movs	r0, #2
}
 800d9f4:	4770      	bx	lr
 800d9f6:	bf00      	nop

0800d9f8 <HAL_HCD_ResetPort>:
  return (USB_ResetPort(hhcd->Instance));
 800d9f8:	6800      	ldr	r0, [r0, #0]
 800d9fa:	f000 ba1f 	b.w	800de3c <USB_ResetPort>
 800d9fe:	bf00      	nop

0800da00 <HAL_HCD_HC_GetURBState>:
  return hhcd->hc[chnum].urb_state;
 800da00:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 800da04:	eb00 0081 	add.w	r0, r0, r1, lsl #2
}
 800da08:	f890 004c 	ldrb.w	r0, [r0, #76]	; 0x4c
 800da0c:	4770      	bx	lr
 800da0e:	bf00      	nop

0800da10 <HAL_HCD_HC_GetXferCount>:
  return hhcd->hc[chnum].xfer_count;
 800da10:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 800da14:	eb00 0081 	add.w	r0, r0, r1, lsl #2
}
 800da18:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800da1a:	4770      	bx	lr

0800da1c <HAL_HCD_GetCurrentSpeed>:
  return (USB_GetHostSpeed(hhcd->Instance));
 800da1c:	6800      	ldr	r0, [r0, #0]
 800da1e:	f000 ba55 	b.w	800decc <USB_GetHostSpeed>
 800da22:	bf00      	nop

0800da24 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800da24:	4b1b      	ldr	r3, [pc, #108]	; (800da94 <HAL_NVIC_SetPriority+0x70>)
 800da26:	68db      	ldr	r3, [r3, #12]
 800da28:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800da2c:	b500      	push	{lr}
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800da2e:	f1c3 0e07 	rsb	lr, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800da32:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800da36:	f1be 0f04 	cmp.w	lr, #4
 800da3a:	bf28      	it	cs
 800da3c:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800da40:	f1bc 0f06 	cmp.w	ip, #6
 800da44:	d91a      	bls.n	800da7c <HAL_NVIC_SetPriority+0x58>
 800da46:	3b03      	subs	r3, #3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800da48:	f04f 3cff 	mov.w	ip, #4294967295
 800da4c:	fa0c fc03 	lsl.w	ip, ip, r3
 800da50:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800da54:	f04f 3cff 	mov.w	ip, #4294967295
  if ((int32_t)(IRQn) >= 0)
 800da58:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800da5a:	fa0c fc0e 	lsl.w	ip, ip, lr
 800da5e:	ea21 010c 	bic.w	r1, r1, ip
 800da62:	fa01 f103 	lsl.w	r1, r1, r3
 800da66:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 800da6a:	db0a      	blt.n	800da82 <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800da6c:	0109      	lsls	r1, r1, #4
 800da6e:	4b0a      	ldr	r3, [pc, #40]	; (800da98 <HAL_NVIC_SetPriority+0x74>)
 800da70:	b2c9      	uxtb	r1, r1
 800da72:	4403      	add	r3, r0
 800da74:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800da78:	f85d fb04 	ldr.w	pc, [sp], #4
 800da7c:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800da7e:	4613      	mov	r3, r2
 800da80:	e7e8      	b.n	800da54 <HAL_NVIC_SetPriority+0x30>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800da82:	f000 000f 	and.w	r0, r0, #15
 800da86:	0109      	lsls	r1, r1, #4
 800da88:	4b04      	ldr	r3, [pc, #16]	; (800da9c <HAL_NVIC_SetPriority+0x78>)
 800da8a:	b2c9      	uxtb	r1, r1
 800da8c:	4403      	add	r3, r0
 800da8e:	7619      	strb	r1, [r3, #24]
 800da90:	f85d fb04 	ldr.w	pc, [sp], #4
 800da94:	e000ed00 	.word	0xe000ed00
 800da98:	e000e100 	.word	0xe000e100
 800da9c:	e000ecfc 	.word	0xe000ecfc

0800daa0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800daa0:	2800      	cmp	r0, #0
 800daa2:	db07      	blt.n	800dab4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800daa4:	f000 011f 	and.w	r1, r0, #31
 800daa8:	2301      	movs	r3, #1
 800daaa:	0940      	lsrs	r0, r0, #5
 800daac:	4a02      	ldr	r2, [pc, #8]	; (800dab8 <HAL_NVIC_EnableIRQ+0x18>)
 800daae:	408b      	lsls	r3, r1
 800dab0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800dab4:	4770      	bx	lr
 800dab6:	bf00      	nop
 800dab8:	e000e100 	.word	0xe000e100

0800dabc <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 800dabc:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800dac0:	4b04      	ldr	r3, [pc, #16]	; (800dad4 <HAL_MPU_Disable+0x18>)

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 800dac2:	2100      	movs	r1, #0
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800dac4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800dac6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800daca:	625a      	str	r2, [r3, #36]	; 0x24
  MPU->CTRL = 0;
 800dacc:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
}
 800dad0:	4770      	bx	lr
 800dad2:	bf00      	nop
 800dad4:	e000ed00 	.word	0xe000ed00

0800dad8 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 800dad8:	4b06      	ldr	r3, [pc, #24]	; (800daf4 <HAL_MPU_Enable+0x1c>)
 800dada:	f040 0001 	orr.w	r0, r0, #1
 800dade:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800dae2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800dae4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800dae8:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 800daea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800daee:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 800daf2:	4770      	bx	lr
 800daf4:	e000ed00 	.word	0xe000ed00

0800daf8 <HAL_MPU_ConfigRegion>:
  assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
  assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
  assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 800daf8:	4a16      	ldr	r2, [pc, #88]	; (800db54 <HAL_MPU_ConfigRegion+0x5c>)
 800dafa:	7843      	ldrb	r3, [r0, #1]
 800dafc:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

  /* Disable the Region */
  CLEAR_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 800db00:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
 800db04:	f023 0301 	bic.w	r3, r3, #1
 800db08:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0

  /* Apply configuration */
  MPU->RBAR = MPU_Init->BaseAddress;
 800db0c:	6843      	ldr	r3, [r0, #4]
 800db0e:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
              ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 800db12:	7ac3      	ldrb	r3, [r0, #11]
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800db14:	f890 c00c 	ldrb.w	ip, [r0, #12]
              ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 800db18:	061b      	lsls	r3, r3, #24
              ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
              ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
              ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
              ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
              ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 800db1a:	7801      	ldrb	r1, [r0, #0]
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800db1c:	ea43 730c 	orr.w	r3, r3, ip, lsl #28
              ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 800db20:	f890 c00a 	ldrb.w	ip, [r0, #10]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800db24:	430b      	orrs	r3, r1
              ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 800db26:	7b41      	ldrb	r1, [r0, #13]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800db28:	ea43 43cc 	orr.w	r3, r3, ip, lsl #19
              ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 800db2c:	f890 c00e 	ldrb.w	ip, [r0, #14]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800db30:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
              ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 800db34:	7bc1      	ldrb	r1, [r0, #15]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800db36:	ea43 434c 	orr.w	r3, r3, ip, lsl #17
              ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 800db3a:	f890 c009 	ldrb.w	ip, [r0, #9]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800db3e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800db42:	7a01      	ldrb	r1, [r0, #8]
 800db44:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
 800db48:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800db4c:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
}
 800db50:	4770      	bx	lr
 800db52:	bf00      	nop
 800db54:	e000ed00 	.word	0xe000ed00

0800db58 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 800db58:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800db5a:	2300      	movs	r3, #0
 800db5c:	9301      	str	r3, [sp, #4]
 800db5e:	e002      	b.n	800db66 <USB_CoreReset+0xe>

    if (count > HAL_USB_TIMEOUT)
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800db60:	6903      	ldr	r3, [r0, #16]
 800db62:	2b00      	cmp	r3, #0
 800db64:	db09      	blt.n	800db7a <USB_CoreReset+0x22>
    count++;
 800db66:	9b01      	ldr	r3, [sp, #4]
 800db68:	3301      	adds	r3, #1
 800db6a:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 800db6c:	9b01      	ldr	r3, [sp, #4]
 800db6e:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 800db72:	d9f5      	bls.n	800db60 <USB_CoreReset+0x8>
      return HAL_TIMEOUT;
 800db74:	2003      	movs	r0, #3
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);

  return HAL_OK;
}
 800db76:	b002      	add	sp, #8
 800db78:	4770      	bx	lr
  count = 0U;
 800db7a:	2300      	movs	r3, #0
 800db7c:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800db7e:	6903      	ldr	r3, [r0, #16]
 800db80:	f043 0301 	orr.w	r3, r3, #1
 800db84:	6103      	str	r3, [r0, #16]
 800db86:	e003      	b.n	800db90 <USB_CoreReset+0x38>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800db88:	6903      	ldr	r3, [r0, #16]
 800db8a:	f013 0301 	ands.w	r3, r3, #1
 800db8e:	d007      	beq.n	800dba0 <USB_CoreReset+0x48>
    count++;
 800db90:	9b01      	ldr	r3, [sp, #4]
 800db92:	3301      	adds	r3, #1
 800db94:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 800db96:	9b01      	ldr	r3, [sp, #4]
 800db98:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 800db9c:	d9f4      	bls.n	800db88 <USB_CoreReset+0x30>
 800db9e:	e7e9      	b.n	800db74 <USB_CoreReset+0x1c>
  return HAL_OK;
 800dba0:	4618      	mov	r0, r3
}
 800dba2:	b002      	add	sp, #8
 800dba4:	4770      	bx	lr
 800dba6:	bf00      	nop

0800dba8 <USB_CoreInit>:
{
 800dba8:	b084      	sub	sp, #16
 800dbaa:	b510      	push	{r4, lr}
 800dbac:	f10d 0c0c 	add.w	ip, sp, #12
 800dbb0:	4604      	mov	r4, r0
 800dbb2:	e88c 000e 	stmia.w	ip, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800dbb6:	f89d 3011 	ldrb.w	r3, [sp, #17]
 800dbba:	2b01      	cmp	r3, #1
 800dbbc:	d12b      	bne.n	800dc16 <USB_CoreInit+0x6e>
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800dbbe:	6b82      	ldr	r2, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800dbc0:	f1a3 1342 	sub.w	r3, r3, #4325442	; 0x420042
    if (cfg.use_external_vbus == 1U)
 800dbc4:	f89d 1018 	ldrb.w	r1, [sp, #24]
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800dbc8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    if (cfg.use_external_vbus == 1U)
 800dbcc:	2901      	cmp	r1, #1
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800dbce:	6382      	str	r2, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800dbd0:	68c2      	ldr	r2, [r0, #12]
 800dbd2:	ea03 0302 	and.w	r3, r3, r2
 800dbd6:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800dbd8:	68c3      	ldr	r3, [r0, #12]
 800dbda:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800dbde:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 800dbe0:	d02c      	beq.n	800dc3c <USB_CoreInit+0x94>
    ret = USB_CoreReset(USBx);
 800dbe2:	4620      	mov	r0, r4
 800dbe4:	f7ff ffb8 	bl	800db58 <USB_CoreReset>
  if (cfg.dma_enable == 1U)
 800dbe8:	f89d 300e 	ldrb.w	r3, [sp, #14]
 800dbec:	2b01      	cmp	r3, #1
 800dbee:	d10e      	bne.n	800dc0e <USB_CoreInit+0x66>
    USBx->GDFIFOCFG &= ~(0xFFFFU << 16);
 800dbf0:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    USBx->GDFIFOCFG |= 0x3EEU << 16;
 800dbf2:	4b15      	ldr	r3, [pc, #84]	; (800dc48 <USB_CoreInit+0xa0>)
    USBx->GDFIFOCFG &= ~(0xFFFFU << 16);
 800dbf4:	b292      	uxth	r2, r2
 800dbf6:	65e2      	str	r2, [r4, #92]	; 0x5c
    USBx->GDFIFOCFG |= 0x3EEU << 16;
 800dbf8:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800dbfa:	4313      	orrs	r3, r2
 800dbfc:	65e3      	str	r3, [r4, #92]	; 0x5c
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800dbfe:	68a3      	ldr	r3, [r4, #8]
 800dc00:	f043 0306 	orr.w	r3, r3, #6
 800dc04:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800dc06:	68a3      	ldr	r3, [r4, #8]
 800dc08:	f043 0320 	orr.w	r3, r3, #32
 800dc0c:	60a3      	str	r3, [r4, #8]
}
 800dc0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800dc12:	b004      	add	sp, #16
 800dc14:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800dc16:	68c3      	ldr	r3, [r0, #12]
 800dc18:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800dc1c:	60c3      	str	r3, [r0, #12]
    ret = USB_CoreReset(USBx);
 800dc1e:	f7ff ff9b 	bl	800db58 <USB_CoreReset>
    if (cfg.battery_charging_enable == 0U)
 800dc22:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800dc26:	b923      	cbnz	r3, 800dc32 <USB_CoreInit+0x8a>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800dc28:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800dc2a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800dc2e:	63a3      	str	r3, [r4, #56]	; 0x38
 800dc30:	e7da      	b.n	800dbe8 <USB_CoreInit+0x40>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800dc32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800dc34:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800dc38:	63a3      	str	r3, [r4, #56]	; 0x38
 800dc3a:	e7d5      	b.n	800dbe8 <USB_CoreInit+0x40>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800dc3c:	68c3      	ldr	r3, [r0, #12]
 800dc3e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800dc42:	60c3      	str	r3, [r0, #12]
 800dc44:	e7cd      	b.n	800dbe2 <USB_CoreInit+0x3a>
 800dc46:	bf00      	nop
 800dc48:	03ee0000 	.word	0x03ee0000

0800dc4c <USB_EnableGlobalInt>:
{
 800dc4c:	4603      	mov	r3, r0
}
 800dc4e:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800dc50:	689a      	ldr	r2, [r3, #8]
 800dc52:	f042 0201 	orr.w	r2, r2, #1
 800dc56:	609a      	str	r2, [r3, #8]
}
 800dc58:	4770      	bx	lr
 800dc5a:	bf00      	nop

0800dc5c <USB_DisableGlobalInt>:
{
 800dc5c:	4603      	mov	r3, r0
}
 800dc5e:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800dc60:	689a      	ldr	r2, [r3, #8]
 800dc62:	f022 0201 	bic.w	r2, r2, #1
 800dc66:	609a      	str	r2, [r3, #8]
}
 800dc68:	4770      	bx	lr
 800dc6a:	bf00      	nop

0800dc6c <USB_SetCurrentMode>:
{
 800dc6c:	b538      	push	{r3, r4, r5, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800dc6e:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 800dc70:	2901      	cmp	r1, #1
{
 800dc72:	4605      	mov	r5, r0
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800dc74:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800dc78:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 800dc7a:	d017      	beq.n	800dcac <USB_SetCurrentMode+0x40>
  else if (mode == USB_DEVICE_MODE)
 800dc7c:	b9a1      	cbnz	r1, 800dca8 <USB_SetCurrentMode+0x3c>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 800dc7e:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 800dc80:	460c      	mov	r4, r1
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 800dc82:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800dc86:	60c3      	str	r3, [r0, #12]
 800dc88:	e001      	b.n	800dc8e <USB_SetCurrentMode+0x22>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 800dc8a:	2cc8      	cmp	r4, #200	; 0xc8
 800dc8c:	d00c      	beq.n	800dca8 <USB_SetCurrentMode+0x3c>
      HAL_Delay(10U);
 800dc8e:	200a      	movs	r0, #10
      ms += 10U;
 800dc90:	4404      	add	r4, r0
      HAL_Delay(10U);
 800dc92:	f7ff fbfd 	bl	800d490 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 800dc96:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 800dc98:	07db      	lsls	r3, r3, #31
 800dc9a:	d4f6      	bmi.n	800dc8a <USB_SetCurrentMode+0x1e>
    return HAL_ERROR;
 800dc9c:	f1a4 00c8 	sub.w	r0, r4, #200	; 0xc8
 800dca0:	fab0 f080 	clz	r0, r0
 800dca4:	0940      	lsrs	r0, r0, #5
}
 800dca6:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800dca8:	2001      	movs	r0, #1
}
 800dcaa:	bd38      	pop	{r3, r4, r5, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 800dcac:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 800dcae:	2400      	movs	r4, #0
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 800dcb0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800dcb4:	60c3      	str	r3, [r0, #12]
 800dcb6:	e001      	b.n	800dcbc <USB_SetCurrentMode+0x50>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 800dcb8:	2cc8      	cmp	r4, #200	; 0xc8
 800dcba:	d0f5      	beq.n	800dca8 <USB_SetCurrentMode+0x3c>
      HAL_Delay(10U);
 800dcbc:	200a      	movs	r0, #10
      ms += 10U;
 800dcbe:	4404      	add	r4, r0
      HAL_Delay(10U);
 800dcc0:	f7ff fbe6 	bl	800d490 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 800dcc4:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 800dcc6:	07da      	lsls	r2, r3, #31
 800dcc8:	d5f6      	bpl.n	800dcb8 <USB_SetCurrentMode+0x4c>
    return HAL_ERROR;
 800dcca:	f1a4 00c8 	sub.w	r0, r4, #200	; 0xc8
 800dcce:	fab0 f080 	clz	r0, r0
 800dcd2:	0940      	lsrs	r0, r0, #5
 800dcd4:	e7e7      	b.n	800dca6 <USB_SetCurrentMode+0x3a>
 800dcd6:	bf00      	nop

0800dcd8 <USB_FlushTxFifo>:
{
 800dcd8:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800dcda:	2300      	movs	r3, #0
 800dcdc:	9301      	str	r3, [sp, #4]
 800dcde:	e002      	b.n	800dce6 <USB_FlushTxFifo+0xe>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800dce0:	6903      	ldr	r3, [r0, #16]
 800dce2:	2b00      	cmp	r3, #0
 800dce4:	db09      	blt.n	800dcfa <USB_FlushTxFifo+0x22>
    count++;
 800dce6:	9b01      	ldr	r3, [sp, #4]
 800dce8:	3301      	adds	r3, #1
 800dcea:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 800dcec:	9b01      	ldr	r3, [sp, #4]
 800dcee:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 800dcf2:	d9f5      	bls.n	800dce0 <USB_FlushTxFifo+0x8>
      return HAL_TIMEOUT;
 800dcf4:	2003      	movs	r0, #3
}
 800dcf6:	b002      	add	sp, #8
 800dcf8:	4770      	bx	lr
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800dcfa:	0189      	lsls	r1, r1, #6
  count = 0U;
 800dcfc:	2300      	movs	r3, #0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800dcfe:	f041 0120 	orr.w	r1, r1, #32
  count = 0U;
 800dd02:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800dd04:	6101      	str	r1, [r0, #16]
 800dd06:	e003      	b.n	800dd10 <USB_FlushTxFifo+0x38>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800dd08:	6903      	ldr	r3, [r0, #16]
 800dd0a:	f013 0320 	ands.w	r3, r3, #32
 800dd0e:	d007      	beq.n	800dd20 <USB_FlushTxFifo+0x48>
    count++;
 800dd10:	9b01      	ldr	r3, [sp, #4]
 800dd12:	3301      	adds	r3, #1
 800dd14:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 800dd16:	9b01      	ldr	r3, [sp, #4]
 800dd18:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 800dd1c:	d9f4      	bls.n	800dd08 <USB_FlushTxFifo+0x30>
 800dd1e:	e7e9      	b.n	800dcf4 <USB_FlushTxFifo+0x1c>
  return HAL_OK;
 800dd20:	4618      	mov	r0, r3
}
 800dd22:	b002      	add	sp, #8
 800dd24:	4770      	bx	lr
 800dd26:	bf00      	nop

0800dd28 <USB_FlushRxFifo>:
{
 800dd28:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800dd2a:	2300      	movs	r3, #0
 800dd2c:	9301      	str	r3, [sp, #4]
 800dd2e:	e002      	b.n	800dd36 <USB_FlushRxFifo+0xe>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800dd30:	6903      	ldr	r3, [r0, #16]
 800dd32:	2b00      	cmp	r3, #0
 800dd34:	db09      	blt.n	800dd4a <USB_FlushRxFifo+0x22>
    count++;
 800dd36:	9b01      	ldr	r3, [sp, #4]
 800dd38:	3301      	adds	r3, #1
 800dd3a:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 800dd3c:	9b01      	ldr	r3, [sp, #4]
 800dd3e:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 800dd42:	d9f5      	bls.n	800dd30 <USB_FlushRxFifo+0x8>
      return HAL_TIMEOUT;
 800dd44:	2003      	movs	r0, #3
}
 800dd46:	b002      	add	sp, #8
 800dd48:	4770      	bx	lr
  count = 0U;
 800dd4a:	2200      	movs	r2, #0
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800dd4c:	2310      	movs	r3, #16
  count = 0U;
 800dd4e:	9201      	str	r2, [sp, #4]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800dd50:	6103      	str	r3, [r0, #16]
 800dd52:	e003      	b.n	800dd5c <USB_FlushRxFifo+0x34>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800dd54:	6903      	ldr	r3, [r0, #16]
 800dd56:	f013 0310 	ands.w	r3, r3, #16
 800dd5a:	d007      	beq.n	800dd6c <USB_FlushRxFifo+0x44>
    count++;
 800dd5c:	9b01      	ldr	r3, [sp, #4]
 800dd5e:	3301      	adds	r3, #1
 800dd60:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 800dd62:	9b01      	ldr	r3, [sp, #4]
 800dd64:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 800dd68:	d9f4      	bls.n	800dd54 <USB_FlushRxFifo+0x2c>
 800dd6a:	e7eb      	b.n	800dd44 <USB_FlushRxFifo+0x1c>
  return HAL_OK;
 800dd6c:	4618      	mov	r0, r3
}
 800dd6e:	b002      	add	sp, #8
 800dd70:	4770      	bx	lr
 800dd72:	bf00      	nop

0800dd74 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800dd74:	b084      	sub	sp, #16
 800dd76:	b570      	push	{r4, r5, r6, lr}
 800dd78:	ad05      	add	r5, sp, #20
 800dd7a:	4604      	mov	r4, r0
 800dd7c:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 800dd80:	2300      	movs	r3, #0
 800dd82:	f89d 5015 	ldrb.w	r5, [sp, #21]
 800dd86:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
 800dd8a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800dd8c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800dd90:	6383      	str	r3, [r0, #56]	; 0x38

  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
 800dd92:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800dd94:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800dd98:	6383      	str	r3, [r0, #56]	; 0x38


  if ((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) == 0U)
 800dd9a:	68c3      	ldr	r3, [r0, #12]
 800dd9c:	065b      	lsls	r3, r3, #25
 800dd9e:	d43f      	bmi.n	800de20 <USB_HostInit+0xac>
  {
    if (cfg.speed == USBH_FSLS_SPEED)
 800dda0:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800dda4:	2b01      	cmp	r3, #1
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 800dda6:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
    if (cfg.speed == USBH_FSLS_SPEED)
 800ddaa:	d03c      	beq.n	800de26 <USB_HostInit+0xb2>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 800ddac:	f023 0304 	bic.w	r3, r3, #4
 800ddb0:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  }

  /* Make sure the FIFOs are flushed. */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800ddb4:	2110      	movs	r1, #16
 800ddb6:	4620      	mov	r0, r4
 800ddb8:	f7ff ff8e 	bl	800dcd8 <USB_FlushTxFifo>
 800ddbc:	4601      	mov	r1, r0
  {
    ret = HAL_ERROR;
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 800ddbe:	4620      	mov	r0, r4
 800ddc0:	f7ff ffb2 	bl	800dd28 <USB_FlushRxFifo>
 800ddc4:	4308      	orrs	r0, r1
 800ddc6:	b2c0      	uxtb	r0, r0
  {
    ret = HAL_ERROR;
 800ddc8:	3800      	subs	r0, #0
 800ddca:	bf18      	it	ne
 800ddcc:	2001      	movne	r0, #1
  }

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 800ddce:	b15d      	cbz	r5, 800dde8 <USB_HostInit+0x74>
 800ddd0:	2200      	movs	r2, #0
 800ddd2:	f504 63a0 	add.w	r3, r4, #1280	; 0x500
  {
    USBx_HC(i)->HCINT = CLEAR_INTERRUPT_MASK;
 800ddd6:	f04f 36ff 	mov.w	r6, #4294967295
    USBx_HC(i)->HCINTMSK = 0U;
 800ddda:	4611      	mov	r1, r2
  for (i = 0U; i < cfg.Host_channels; i++)
 800dddc:	3201      	adds	r2, #1
    USBx_HC(i)->HCINT = CLEAR_INTERRUPT_MASK;
 800ddde:	609e      	str	r6, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 800dde0:	60d9      	str	r1, [r3, #12]
  for (i = 0U; i < cfg.Host_channels; i++)
 800dde2:	3320      	adds	r3, #32
 800dde4:	42aa      	cmp	r2, r5
 800dde6:	d1f9      	bne.n	800dddc <USB_HostInit+0x68>
  }

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 800dde8:	2200      	movs	r2, #0

  /* Clear any pending interrupts */
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 800ddea:	f04f 33ff 	mov.w	r3, #4294967295
  /* set Rx FIFO size */
  USBx->GRXFSIZ  = 0x200U;
 800ddee:	f44f 7100 	mov.w	r1, #512	; 0x200
  USBx->GINTMSK = 0U;
 800ddf2:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 800ddf4:	6163      	str	r3, [r4, #20]
  USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 800ddf6:	4b0e      	ldr	r3, [pc, #56]	; (800de30 <USB_HostInit+0xbc>)
  USBx->GRXFSIZ  = 0x200U;
 800ddf8:	6261      	str	r1, [r4, #36]	; 0x24
  USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 800ddfa:	4a0e      	ldr	r2, [pc, #56]	; (800de34 <USB_HostInit+0xc0>)
  USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 800ddfc:	62a3      	str	r3, [r4, #40]	; 0x28

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 800ddfe:	f89d 3016 	ldrb.w	r3, [sp, #22]
  USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 800de02:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
  if (cfg.dma_enable == 0U)
 800de06:	b91b      	cbnz	r3, 800de10 <USB_HostInit+0x9c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 800de08:	69a3      	ldr	r3, [r4, #24]
 800de0a:	f043 0310 	orr.w	r3, r3, #16
 800de0e:	61a3      	str	r3, [r4, #24]
  }

  /* Enable interrupts matching to the Host mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 800de10:	69a2      	ldr	r2, [r4, #24]
 800de12:	4b09      	ldr	r3, [pc, #36]	; (800de38 <USB_HostInit+0xc4>)
 800de14:	4313      	orrs	r3, r2
 800de16:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);

  return ret;
}
 800de18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800de1c:	b004      	add	sp, #16
 800de1e:	4770      	bx	lr
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 800de20:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
 800de24:	e7c2      	b.n	800ddac <USB_HostInit+0x38>
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 800de26:	f043 0304 	orr.w	r3, r3, #4
 800de2a:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
 800de2e:	e7c1      	b.n	800ddb4 <USB_HostInit+0x40>
 800de30:	01000200 	.word	0x01000200
 800de34:	00e00300 	.word	0x00e00300
 800de38:	a3200008 	.word	0xa3200008

0800de3c <USB_ResetPort>:
  * @retval HAL status
  * @note (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(const USB_OTG_GlobalTypeDef *USBx)
{
 800de3c:	b530      	push	{r4, r5, lr}
 800de3e:	4604      	mov	r4, r0
 800de40:	b083      	sub	sp, #12
  uint32_t USBx_BASE = (uint32_t)USBx;

  __IO uint32_t hprt0 = 0U;
 800de42:	2500      	movs	r5, #0

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
  HAL_Delay(100U);                                 /* See Note #1 */
 800de44:	2064      	movs	r0, #100	; 0x64
  __IO uint32_t hprt0 = 0U;
 800de46:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
 800de48:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 800de4c:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 800de4e:	9b01      	ldr	r3, [sp, #4]
 800de50:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800de54:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 800de56:	9b01      	ldr	r3, [sp, #4]
 800de58:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800de5c:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
 800de60:	f7ff fb16 	bl	800d490 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 800de64:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
 800de66:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 800de68:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800de6c:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(10U);
 800de70:	f7ff fb0e 	bl	800d490 <HAL_Delay>

  return HAL_OK;
}
 800de74:	4628      	mov	r0, r5
 800de76:	b003      	add	sp, #12
 800de78:	bd30      	pop	{r4, r5, pc}
 800de7a:	bf00      	nop

0800de7c <USB_DriveVbus>:
  *           0 : Deactivate VBUS
  *           1 : Activate VBUS
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DriveVbus(const USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 800de7c:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 800de7e:	2300      	movs	r3, #0
 800de80:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 800de82:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 800de86:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 800de88:	9b01      	ldr	r3, [sp, #4]
 800de8a:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800de8e:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 800de90:	9b01      	ldr	r3, [sp, #4]
 800de92:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 800de96:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 800de98:	d101      	bne.n	800de9e <USB_DriveVbus+0x22>
 800de9a:	2901      	cmp	r1, #1
 800de9c:	d00d      	beq.n	800deba <USB_DriveVbus+0x3e>
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 800de9e:	04db      	lsls	r3, r3, #19
 800dea0:	d500      	bpl.n	800dea4 <USB_DriveVbus+0x28>
 800dea2:	b111      	cbz	r1, 800deaa <USB_DriveVbus+0x2e>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
  }
  return HAL_OK;
}
 800dea4:	2000      	movs	r0, #0
 800dea6:	b002      	add	sp, #8
 800dea8:	4770      	bx	lr
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 800deaa:	9b01      	ldr	r3, [sp, #4]
 800deac:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800deb0:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
 800deb4:	2000      	movs	r0, #0
 800deb6:	b002      	add	sp, #8
 800deb8:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 800deba:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800debe:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
 800dec2:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 800dec4:	9b01      	ldr	r3, [sp, #4]
}
 800dec6:	b002      	add	sp, #8
 800dec8:	4770      	bx	lr
 800deca:	bf00      	nop

0800decc <USB_GetHostSpeed>:
  *            @arg HCD_DEVICE_SPEED_HIGH: High speed mode
  *            @arg HCD_DEVICE_SPEED_FULL: Full speed mode
  *            @arg HCD_DEVICE_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef const *USBx)
{
 800decc:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 800dece:	2300      	movs	r3, #0
 800ded0:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 800ded2:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 800ded6:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 800ded8:	9801      	ldr	r0, [sp, #4]
}
 800deda:	f3c0 4041 	ubfx	r0, r0, #17, #2
 800dede:	b002      	add	sp, #8
 800dee0:	4770      	bx	lr
 800dee2:	bf00      	nop

0800dee4 <USB_HC_Init>:
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
                              uint8_t epnum, uint8_t dev_address, uint8_t speed,
                              uint8_t ep_type, uint16_t mps)
{
 800dee4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800dee8:	b082      	sub	sp, #8
  uint32_t HCcharEpDir;
  uint32_t HCcharLowSpeed;
  uint32_t HostCoreSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 800deea:	eb00 1e41 	add.w	lr, r0, r1, lsl #5
{
 800deee:	4607      	mov	r7, r0
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 800def0:	f04f 30ff 	mov.w	r0, #4294967295
{
 800def4:	f89d 4024 	ldrb.w	r4, [sp, #36]	; 0x24
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 800def8:	f50e 68a0 	add.w	r8, lr, #1280	; 0x500
{
 800defc:	f89d 5020 	ldrb.w	r5, [sp, #32]
 800df00:	f8bd 6028 	ldrh.w	r6, [sp, #40]	; 0x28
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 800df04:	f8ce 0508 	str.w	r0, [lr, #1288]	; 0x508

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
 800df08:	2c03      	cmp	r4, #3
 800df0a:	f200 8086 	bhi.w	800e01a <USB_HC_Init+0x136>
 800df0e:	e8df f004 	tbb	[pc, r4]
 800df12:	6b02      	.short	0x6b02
 800df14:	1302      	.short	0x1302
                                            USB_OTG_HCINTMSK_TXERRM |
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_NAKM;

      if ((epnum & 0x80U) == 0x80U)
 800df16:	fa4f fc82 	sxtb.w	ip, r2
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800df1a:	f240 409d 	movw	r0, #1181	; 0x49d
      if ((epnum & 0x80U) == 0x80U)
 800df1e:	f1bc 0f00 	cmp.w	ip, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800df22:	f8c8 000c 	str.w	r0, [r8, #12]
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 800df26:	f8d8 000c 	ldr.w	r0, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 800df2a:	db70      	blt.n	800e00e <USB_HC_Init+0x12a>
      }
      else
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
 800df2c:	f040 0060 	orr.w	r0, r0, #96	; 0x60
 800df30:	f8c8 000c 	str.w	r0, [r8, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 800df34:	2000      	movs	r0, #0
 800df36:	e009      	b.n	800df4c <USB_HC_Init+0x68>
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 800df38:	fa4f fc82 	sxtb.w	ip, r2
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800df3c:	f240 609d 	movw	r0, #1693	; 0x69d
      if ((epnum & 0x80U) == 0x80U)
 800df40:	f1bc 0f00 	cmp.w	ip, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800df44:	f8c8 000c 	str.w	r0, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 800df48:	db5f      	blt.n	800e00a <USB_HC_Init+0x126>
  HAL_StatusTypeDef ret = HAL_OK;
 800df4a:	2000      	movs	r0, #0

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;

  /* Program the HCCHAR register */
  if ((epnum & 0x80U) == 0x80U)
 800df4c:	ea4f 7cdc 	mov.w	ip, ip, lsr #31
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) |
 800df50:	f3c6 060a 	ubfx	r6, r6, #0, #11
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800df54:	f001 010f 	and.w	r1, r1, #15
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 800df58:	02d2      	lsls	r2, r2, #11
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 800df5a:	ea46 36cc 	orr.w	r6, r6, ip, lsl #15
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 800df5e:	ea4f 5c83 	mov.w	ip, r3, lsl #22
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 800df62:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 800df66:	f00c 5cfe 	and.w	ip, ip, #532676608	; 0x1fc00000
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 800df6a:	ea46 030c 	orr.w	r3, r6, ip
  USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 800df6e:	2600      	movs	r6, #0
 800df70:	f8c8 6004 	str.w	r6, [r8, #4]
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 800df74:	f8d8 c00c 	ldr.w	ip, [r8, #12]
 800df78:	f04c 0c02 	orr.w	ip, ip, #2
 800df7c:	f8c8 c00c 	str.w	ip, [r8, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800df80:	f04f 0c01 	mov.w	ip, #1
 800df84:	fa0c f101 	lsl.w	r1, ip, r1
 800df88:	f8d7 c418 	ldr.w	ip, [r7, #1048]	; 0x418
 800df8c:	ea41 010c 	orr.w	r1, r1, ip
 800df90:	f8c7 1418 	str.w	r1, [r7, #1048]	; 0x418
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800df94:	69b9      	ldr	r1, [r7, #24]
 800df96:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800df9a:	61b9      	str	r1, [r7, #24]
  __IO uint32_t hprt0 = 0U;
 800df9c:	9601      	str	r6, [sp, #4]
  hprt0 = USBx_HPRT0;
 800df9e:	f8d7 1440 	ldr.w	r1, [r7, #1088]	; 0x440
 800dfa2:	9101      	str	r1, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 800dfa4:	9901      	ldr	r1, [sp, #4]
 800dfa6:	f3c1 4141 	ubfx	r1, r1, #17, #2
  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
 800dfaa:	3902      	subs	r1, #2
 800dfac:	bf18      	it	ne
 800dfae:	2101      	movne	r1, #1
 800dfb0:	2d02      	cmp	r5, #2
 800dfb2:	bf18      	it	ne
 800dfb4:	2100      	movne	r1, #0
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 800dfb6:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 800dfba:	04a1      	lsls	r1, r4, #18
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 800dfbc:	4313      	orrs	r3, r2

  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 800dfbe:	f004 02fd 	and.w	r2, r4, #253	; 0xfd
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 800dfc2:	f401 2140 	and.w	r1, r1, #786432	; 0xc0000
  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 800dfc6:	2a01      	cmp	r2, #1
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 800dfc8:	ea43 0301 	orr.w	r3, r3, r1
 800dfcc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 800dfd0:	f8ce 3500 	str.w	r3, [lr, #1280]	; 0x500
  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 800dfd4:	d105      	bne.n	800dfe2 <USB_HC_Init+0xfe>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 800dfd6:	f8de 3500 	ldr.w	r3, [lr, #1280]	; 0x500
 800dfda:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800dfde:	f8ce 3500 	str.w	r3, [lr, #1280]	; 0x500
  }

  return ret;
}
 800dfe2:	b002      	add	sp, #8
 800dfe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((epnum & 0x80U) == 0x80U)
 800dfe8:	fa4f fc82 	sxtb.w	ip, r2
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800dfec:	f240 2025 	movw	r0, #549	; 0x225
      if ((epnum & 0x80U) == 0x80U)
 800dff0:	f1bc 0f00 	cmp.w	ip, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800dff4:	f8c8 000c 	str.w	r0, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 800dff8:	daa7      	bge.n	800df4a <USB_HC_Init+0x66>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 800dffa:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800dffe:	f440 70c0 	orr.w	r0, r0, #384	; 0x180
 800e002:	f8c8 000c 	str.w	r0, [r8, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 800e006:	2000      	movs	r0, #0
 800e008:	e7a0      	b.n	800df4c <USB_HC_Init+0x68>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 800e00a:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800e00e:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 800e012:	f8c8 000c 	str.w	r0, [r8, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 800e016:	2000      	movs	r0, #0
 800e018:	e798      	b.n	800df4c <USB_HC_Init+0x68>
      if ((epnum & 0x80U) == 0x80U)
 800e01a:	fa4f fc82 	sxtb.w	ip, r2
      ret = HAL_ERROR;
 800e01e:	2001      	movs	r0, #1
 800e020:	e794      	b.n	800df4c <USB_HC_Init+0x68>
 800e022:	bf00      	nop

0800e024 <USB_HC_StartXfer>:
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = HC_MAX_PKT_CNT;

  /* in DMA mode host Core automatically issues ping in case of NYET/NAK */
  if (dma == 1U)
 800e024:	2a01      	cmp	r2, #1
{
 800e026:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e028:	b083      	sub	sp, #12
  uint32_t ch_num = (uint32_t)hc->ch_num;
 800e02a:	f891 c001 	ldrb.w	ip, [r1, #1]
  if (dma == 1U)
 800e02e:	f000 80a5 	beq.w	800e17c <USB_HC_StartXfer+0x158>
                                               USB_OTG_HCINTMSK_NAKM);
    }
  }
  else
  {
    if ((hc->speed == USBH_HS_SPEED) && (hc->do_ping == 1U))
 800e032:	888b      	ldrh	r3, [r1, #4]
 800e034:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800e038:	f000 80e6 	beq.w	800e208 <USB_HC_StartXfer+0x1e4>
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 800e03c:	eb00 134c 	add.w	r3, r0, ip, lsl #5
 800e040:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
      (void)USB_DoPing(USBx, hc->ch_num);
      return HAL_OK;
    }
  }

  if (hc->do_ssplit == 1U)
 800e044:	798e      	ldrb	r6, [r1, #6]
 800e046:	2e01      	cmp	r6, #1
 800e048:	f000 80a9 	beq.w	800e19e <USB_HC_StartXfer+0x17a>
    }
  }
  else
  {
    /* Compute the expected number of packets associated to the transfer */
    if (hc->xfer_len > 0U)
 800e04c:	6a0c      	ldr	r4, [r1, #32]
 800e04e:	2c00      	cmp	r4, #0
 800e050:	d142      	bne.n	800e0d8 <USB_HC_StartXfer+0xb4>

    /*
    * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of
    * max_packet size.
    */
    if (hc->ep_is_in != 0U)
 800e052:	78cd      	ldrb	r5, [r1, #3]
 800e054:	f44f 2e00 	mov.w	lr, #524288	; 0x80000
 800e058:	2701      	movs	r7, #1
 800e05a:	2d00      	cmp	r5, #0
 800e05c:	d04c      	beq.n	800e0f8 <USB_HC_StartXfer+0xd4>
    {
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800e05e:	8a8c      	ldrh	r4, [r1, #20]
 800e060:	fb07 f404 	mul.w	r4, r7, r4
 800e064:	61cc      	str	r4, [r1, #28]
      hc->XferSize = hc->xfer_len;
    }
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 800e066:	f3c4 0412 	ubfx	r4, r4, #0, #19
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800e06a:	ea44 0e0e 	orr.w	lr, r4, lr
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 800e06e:	7d8c      	ldrb	r4, [r1, #22]
 800e070:	0764      	lsls	r4, r4, #29
 800e072:	f004 44c0 	and.w	r4, r4, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800e076:	ea44 040e 	orr.w	r4, r4, lr
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 800e07a:	611c      	str	r4, [r3, #16]

  if (dma != 0U)
 800e07c:	b10a      	cbz	r2, 800e082 <USB_HC_StartXfer+0x5e>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 800e07e:	698c      	ldr	r4, [r1, #24]
 800e080:	615c      	str	r4, [r3, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 800e082:	f8d0 4408 	ldr.w	r4, [r0, #1032]	; 0x408
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;

  if (hc->do_ssplit == 1U)
 800e086:	2e01      	cmp	r6, #1
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800e088:	681f      	ldr	r7, [r3, #0]
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 800e08a:	ea6f 0404 	mvn.w	r4, r4
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800e08e:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 800e092:	ea4f 7444 	mov.w	r4, r4, lsl #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800e096:	601f      	str	r7, [r3, #0]
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 800e098:	f004 5400 	and.w	r4, r4, #536870912	; 0x20000000
 800e09c:	681f      	ldr	r7, [r3, #0]
 800e09e:	ea44 0407 	orr.w	r4, r4, r7
  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 800e0a2:	f500 6780 	add.w	r7, r0, #1024	; 0x400
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 800e0a6:	601c      	str	r4, [r3, #0]
  if (hc->do_ssplit == 1U)
 800e0a8:	d02a      	beq.n	800e100 <USB_HC_StartXfer+0xdc>
    }
  }
  else
  {
    /* Clear Hub Start Split transaction */
    USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 800e0aa:	2400      	movs	r4, #0
 800e0ac:	605c      	str	r4, [r3, #4]
  }

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 800e0ae:	681c      	ldr	r4, [r3, #0]
 800e0b0:	9401      	str	r4, [sp, #4]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800e0b2:	9c01      	ldr	r4, [sp, #4]
 800e0b4:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
 800e0b8:	9401      	str	r4, [sp, #4]

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 800e0ba:	2d00      	cmp	r5, #0
 800e0bc:	d045      	beq.n	800e14a <USB_HC_StartXfer+0x126>
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 800e0be:	9a01      	ldr	r2, [sp, #4]
 800e0c0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800e0c4:	9201      	str	r2, [sp, #4]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 800e0c6:	9a01      	ldr	r2, [sp, #4]
 800e0c8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800e0cc:	9201      	str	r2, [sp, #4]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 800e0ce:	9a01      	ldr	r2, [sp, #4]
 800e0d0:	601a      	str	r2, [r3, #0]
    /* Write packet into the Tx FIFO. */
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
  }

  return HAL_OK;
}
 800e0d2:	2000      	movs	r0, #0
 800e0d4:	b003      	add	sp, #12
 800e0d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 800e0d8:	8a8d      	ldrh	r5, [r1, #20]
 800e0da:	1e67      	subs	r7, r4, #1
 800e0dc:	442f      	add	r7, r5
 800e0de:	fbb7 f7f5 	udiv	r7, r7, r5
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800e0e2:	b2bf      	uxth	r7, r7
    if (hc->ep_is_in != 0U)
 800e0e4:	78cd      	ldrb	r5, [r1, #3]
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800e0e6:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
 800e0ea:	bf28      	it	cs
 800e0ec:	f44f 7780 	movcs.w	r7, #256	; 0x100
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800e0f0:	ea4f 4ec7 	mov.w	lr, r7, lsl #19
    if (hc->ep_is_in != 0U)
 800e0f4:	2d00      	cmp	r5, #0
 800e0f6:	d1b2      	bne.n	800e05e <USB_HC_StartXfer+0x3a>
      hc->XferSize = hc->xfer_len;
 800e0f8:	61cc      	str	r4, [r1, #28]
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 800e0fa:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800e0fe:	e7b4      	b.n	800e06a <USB_HC_StartXfer+0x46>
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 800e100:	7c4e      	ldrb	r6, [r1, #17]
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 800e102:	7c0c      	ldrb	r4, [r1, #16]
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 800e104:	ea44 14c6 	orr.w	r4, r4, r6, lsl #7
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 800e108:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 800e10c:	605c      	str	r4, [r3, #4]
    USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_ACKM |
 800e10e:	68dc      	ldr	r4, [r3, #12]
 800e110:	f044 0460 	orr.w	r4, r4, #96	; 0x60
 800e114:	60dc      	str	r4, [r3, #12]
    if ((hc->do_csplit == 1U) && (hc->ep_is_in == 0U))
 800e116:	79cc      	ldrb	r4, [r1, #7]
 800e118:	2c01      	cmp	r4, #1
 800e11a:	d14f      	bne.n	800e1bc <USB_HC_StartXfer+0x198>
 800e11c:	2d00      	cmp	r5, #0
 800e11e:	d15f      	bne.n	800e1e0 <USB_HC_StartXfer+0x1bc>
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 800e120:	685c      	ldr	r4, [r3, #4]
 800e122:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
 800e126:	605c      	str	r4, [r3, #4]
      USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET;
 800e128:	68dc      	ldr	r4, [r3, #12]
 800e12a:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 800e12e:	60dc      	str	r4, [r3, #12]
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 800e130:	7c8c      	ldrb	r4, [r1, #18]
 800e132:	f004 06fd 	and.w	r6, r4, #253	; 0xfd
 800e136:	2e01      	cmp	r6, #1
 800e138:	d1b9      	bne.n	800e0ae <USB_HC_StartXfer+0x8a>
    if ((hc->ep_type == EP_TYPE_ISOC) && (hc->ep_is_in == 0U))
 800e13a:	2c01      	cmp	r4, #1
 800e13c:	d043      	beq.n	800e1c6 <USB_HC_StartXfer+0x1a2>
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 800e13e:	681c      	ldr	r4, [r3, #0]
 800e140:	9401      	str	r4, [sp, #4]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800e142:	9c01      	ldr	r4, [sp, #4]
 800e144:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
 800e148:	9401      	str	r4, [sp, #4]
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 800e14a:	9c01      	ldr	r4, [sp, #4]
 800e14c:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
 800e150:	9401      	str	r4, [sp, #4]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 800e152:	9c01      	ldr	r4, [sp, #4]
 800e154:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 800e158:	9401      	str	r4, [sp, #4]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 800e15a:	9c01      	ldr	r4, [sp, #4]
 800e15c:	601c      	str	r4, [r3, #0]
  if (dma != 0U) /* dma mode */
 800e15e:	2a00      	cmp	r2, #0
 800e160:	d1b7      	bne.n	800e0d2 <USB_HC_StartXfer+0xae>
  if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U) && (hc->do_csplit == 0U))
 800e162:	6a0a      	ldr	r2, [r1, #32]
 800e164:	2a00      	cmp	r2, #0
 800e166:	d0b4      	beq.n	800e0d2 <USB_HC_StartXfer+0xae>
 800e168:	79cb      	ldrb	r3, [r1, #7]
 800e16a:	2b00      	cmp	r3, #0
 800e16c:	d1b1      	bne.n	800e0d2 <USB_HC_StartXfer+0xae>
    switch (hc->ep_type)
 800e16e:	7c8b      	ldrb	r3, [r1, #18]
 800e170:	2b03      	cmp	r3, #3
 800e172:	d864      	bhi.n	800e23e <USB_HC_StartXfer+0x21a>
 800e174:	e8df f003 	tbb	[pc, r3]
 800e178:	76587658 	.word	0x76587658
    if ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK))
 800e17c:	7c8b      	ldrb	r3, [r1, #18]
 800e17e:	f013 0ffd 	tst.w	r3, #253	; 0xfd
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 800e182:	eb00 134c 	add.w	r3, r0, ip, lsl #5
 800e186:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    if ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK))
 800e18a:	f47f af5b 	bne.w	800e044 <USB_HC_StartXfer+0x20>
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 800e18e:	68dc      	ldr	r4, [r3, #12]
 800e190:	f024 0470 	bic.w	r4, r4, #112	; 0x70
 800e194:	60dc      	str	r4, [r3, #12]
  if (hc->do_ssplit == 1U)
 800e196:	798e      	ldrb	r6, [r1, #6]
 800e198:	2e01      	cmp	r6, #1
 800e19a:	f47f af57 	bne.w	800e04c <USB_HC_StartXfer+0x28>
    if (hc->ep_is_in != 0U)
 800e19e:	78cd      	ldrb	r5, [r1, #3]
 800e1a0:	b9cd      	cbnz	r5, 800e1d6 <USB_HC_StartXfer+0x1b2>
      if (hc->ep_type == EP_TYPE_ISOC)
 800e1a2:	7c8c      	ldrb	r4, [r1, #18]
 800e1a4:	2c01      	cmp	r4, #1
        if (hc->xfer_len > ISO_SPLT_MPS)
 800e1a6:	6a0c      	ldr	r4, [r1, #32]
      if (hc->ep_type == EP_TYPE_ISOC)
 800e1a8:	d07c      	beq.n	800e2a4 <USB_HC_StartXfer+0x280>
        if ((dma == 1U) && (hc->xfer_len > hc->max_packet))
 800e1aa:	2a01      	cmp	r2, #1
 800e1ac:	f000 8087 	beq.w	800e2be <USB_HC_StartXfer+0x29a>
          hc->XferSize = hc->xfer_len;
 800e1b0:	61cc      	str	r4, [r1, #28]
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 800e1b2:	f44f 2e00 	mov.w	lr, #524288	; 0x80000
 800e1b6:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800e1ba:	e756      	b.n	800e06a <USB_HC_StartXfer+0x46>
    if ((hc->ep_type == EP_TYPE_ISOC) && (hc->ep_is_in == 0U))
 800e1bc:	7c8c      	ldrb	r4, [r1, #18]
 800e1be:	2c01      	cmp	r4, #1
 800e1c0:	f47f af75 	bne.w	800e0ae <USB_HC_StartXfer+0x8a>
 800e1c4:	b9cd      	cbnz	r5, 800e1fa <USB_HC_StartXfer+0x1d6>
      switch (hc->iso_splt_xactPos)
 800e1c6:	68cc      	ldr	r4, [r1, #12]
 800e1c8:	3c01      	subs	r4, #1
 800e1ca:	2c03      	cmp	r4, #3
 800e1cc:	d8b7      	bhi.n	800e13e <USB_HC_StartXfer+0x11a>
 800e1ce:	e8df f004 	tbb	[pc, r4]
 800e1d2:	5f64      	.short	0x5f64
 800e1d4:	555a      	.short	0x555a
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800e1d6:	8a8c      	ldrh	r4, [r1, #20]
 800e1d8:	f44f 2e00 	mov.w	lr, #524288	; 0x80000
 800e1dc:	61cc      	str	r4, [r1, #28]
 800e1de:	e744      	b.n	800e06a <USB_HC_StartXfer+0x46>
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 800e1e0:	7c8c      	ldrb	r4, [r1, #18]
 800e1e2:	f004 06fd 	and.w	r6, r4, #253	; 0xfd
 800e1e6:	2e01      	cmp	r6, #1
 800e1e8:	f47f af61 	bne.w	800e0ae <USB_HC_StartXfer+0x8a>
        (hc->do_csplit == 1U) && (hc->ep_is_in == 1U))
 800e1ec:	2d01      	cmp	r5, #1
 800e1ee:	f040 8084 	bne.w	800e2fa <USB_HC_StartXfer+0x2d6>
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 800e1f2:	685a      	ldr	r2, [r3, #4]
 800e1f4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800e1f8:	605a      	str	r2, [r3, #4]
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 800e1fa:	681a      	ldr	r2, [r3, #0]
 800e1fc:	9201      	str	r2, [sp, #4]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800e1fe:	9a01      	ldr	r2, [sp, #4]
 800e200:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 800e204:	9201      	str	r2, [sp, #4]
  if (hc->ep_is_in != 0U)
 800e206:	e75a      	b.n	800e0be <USB_HC_StartXfer+0x9a>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800e208:	eb00 1c4c 	add.w	ip, r0, ip, lsl #5
 800e20c:	4b3d      	ldr	r3, [pc, #244]	; (800e304 <USB_HC_StartXfer+0x2e0>)
}
 800e20e:	2000      	movs	r0, #0
  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800e210:	f8cc 3510 	str.w	r3, [ip, #1296]	; 0x510
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 800e214:	f8dc 3500 	ldr.w	r3, [ip, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800e218:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 800e21c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
 800e220:	f8cc 3500 	str.w	r3, [ip, #1280]	; 0x500
}
 800e224:	b003      	add	sp, #12
 800e226:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 800e228:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 800e22a:	1cd4      	adds	r4, r2, #3
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 800e22c:	b29b      	uxth	r3, r3
 800e22e:	f3c4 048f 	ubfx	r4, r4, #2, #16
 800e232:	429c      	cmp	r4, r3
 800e234:	d903      	bls.n	800e23e <USB_HC_StartXfer+0x21a>
          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 800e236:	6983      	ldr	r3, [r0, #24]
 800e238:	f043 0320 	orr.w	r3, r3, #32
 800e23c:	6183      	str	r3, [r0, #24]
    count32b = ((uint32_t)len + 3U) / 4U;
 800e23e:	b292      	uxth	r2, r2
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 800e240:	698b      	ldr	r3, [r1, #24]
    count32b = ((uint32_t)len + 3U) / 4U;
 800e242:	3203      	adds	r2, #3
    for (i = 0U; i < count32b; i++)
 800e244:	0892      	lsrs	r2, r2, #2
 800e246:	f43f af44 	beq.w	800e0d2 <USB_HC_StartXfer+0xae>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800e24a:	eb00 3c0c 	add.w	ip, r0, ip, lsl #12
 800e24e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800e252:	f50c 5c80 	add.w	ip, ip, #4096	; 0x1000
 800e256:	f853 1b04 	ldr.w	r1, [r3], #4
    for (i = 0U; i < count32b; i++)
 800e25a:	429a      	cmp	r2, r3
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800e25c:	f8cc 1000 	str.w	r1, [ip]
    for (i = 0U; i < count32b; i++)
 800e260:	d1f9      	bne.n	800e256 <USB_HC_StartXfer+0x232>
 800e262:	e736      	b.n	800e0d2 <USB_HC_StartXfer+0xae>
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 800e264:	693c      	ldr	r4, [r7, #16]
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 800e266:	1cd3      	adds	r3, r2, #3
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 800e268:	b2a4      	uxth	r4, r4
 800e26a:	f3c3 038f 	ubfx	r3, r3, #2, #16
 800e26e:	429c      	cmp	r4, r3
 800e270:	d2e5      	bcs.n	800e23e <USB_HC_StartXfer+0x21a>
          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 800e272:	6983      	ldr	r3, [r0, #24]
 800e274:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800e278:	6183      	str	r3, [r0, #24]
 800e27a:	e7e0      	b.n	800e23e <USB_HC_StartXfer+0x21a>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS;
 800e27c:	685c      	ldr	r4, [r3, #4]
 800e27e:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 800e282:	605c      	str	r4, [r3, #4]
          break;
 800e284:	e75b      	b.n	800e13e <USB_HC_StartXfer+0x11a>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_0;
 800e286:	685c      	ldr	r4, [r3, #4]
 800e288:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 800e28c:	605c      	str	r4, [r3, #4]
          break;
 800e28e:	e756      	b.n	800e13e <USB_HC_StartXfer+0x11a>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_Pos;
 800e290:	685c      	ldr	r4, [r3, #4]
 800e292:	f044 040e 	orr.w	r4, r4, #14
 800e296:	605c      	str	r4, [r3, #4]
          break;
 800e298:	e751      	b.n	800e13e <USB_HC_StartXfer+0x11a>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_1;
 800e29a:	685c      	ldr	r4, [r3, #4]
 800e29c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 800e2a0:	605c      	str	r4, [r3, #4]
          break;
 800e2a2:	e74c      	b.n	800e13e <USB_HC_StartXfer+0x11a>
        if (hc->xfer_len > ISO_SPLT_MPS)
 800e2a4:	2cbc      	cmp	r4, #188	; 0xbc
 800e2a6:	d918      	bls.n	800e2da <USB_HC_StartXfer+0x2b6>
          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 800e2a8:	68cc      	ldr	r4, [r1, #12]
 800e2aa:	1e67      	subs	r7, r4, #1
          hc->XferSize = hc->max_packet;
 800e2ac:	8a8c      	ldrh	r4, [r1, #20]
          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 800e2ae:	2f01      	cmp	r7, #1
          hc->xfer_len = hc->XferSize;
 800e2b0:	e9c1 4407 	strd	r4, r4, [r1, #28]
          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 800e2b4:	d91c      	bls.n	800e2f0 <USB_HC_StartXfer+0x2cc>
            hc->iso_splt_xactPos = HCSPLT_BEGIN;
 800e2b6:	f44f 2e00 	mov.w	lr, #524288	; 0x80000
 800e2ba:	60ce      	str	r6, [r1, #12]
 800e2bc:	e6d5      	b.n	800e06a <USB_HC_StartXfer+0x46>
        if ((dma == 1U) && (hc->xfer_len > hc->max_packet))
 800e2be:	8a8f      	ldrh	r7, [r1, #20]
 800e2c0:	42bc      	cmp	r4, r7
 800e2c2:	f67f af75 	bls.w	800e1b0 <USB_HC_StartXfer+0x18c>
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 800e2c6:	7d8c      	ldrb	r4, [r1, #22]
          hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800e2c8:	61cf      	str	r7, [r1, #28]
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800e2ca:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 800e2ce:	0764      	lsls	r4, r4, #29
 800e2d0:	f004 44c0 	and.w	r4, r4, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800e2d4:	433c      	orrs	r4, r7
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 800e2d6:	611c      	str	r4, [r3, #16]
  if (dma != 0U)
 800e2d8:	e6d1      	b.n	800e07e <USB_HC_StartXfer+0x5a>
          if ((hc->iso_splt_xactPos != HCSPLT_BEGIN) && (hc->iso_splt_xactPos != HCSPLT_MIDDLE))
 800e2da:	68cf      	ldr	r7, [r1, #12]
            hc->iso_splt_xactPos = HCSPLT_END;
 800e2dc:	f44f 2e00 	mov.w	lr, #524288	; 0x80000
          hc->XferSize = hc->xfer_len;
 800e2e0:	61cc      	str	r4, [r1, #28]
          if ((hc->iso_splt_xactPos != HCSPLT_BEGIN) && (hc->iso_splt_xactPos != HCSPLT_MIDDLE))
 800e2e2:	3f01      	subs	r7, #1
 800e2e4:	2f01      	cmp	r7, #1
            hc->iso_splt_xactPos = HCSPLT_FULL;
 800e2e6:	bf8c      	ite	hi
 800e2e8:	2704      	movhi	r7, #4
            hc->iso_splt_xactPos = HCSPLT_END;
 800e2ea:	2703      	movls	r7, #3
 800e2ec:	60cf      	str	r7, [r1, #12]
 800e2ee:	e6bc      	b.n	800e06a <USB_HC_StartXfer+0x46>
            hc->iso_splt_xactPos = HCSPLT_MIDDLE;
 800e2f0:	2702      	movs	r7, #2
 800e2f2:	f44f 2e00 	mov.w	lr, #524288	; 0x80000
 800e2f6:	60cf      	str	r7, [r1, #12]
 800e2f8:	e6b7      	b.n	800e06a <USB_HC_StartXfer+0x46>
    if ((hc->ep_type == EP_TYPE_ISOC) && (hc->ep_is_in == 0U))
 800e2fa:	2c01      	cmp	r4, #1
 800e2fc:	f47f aed7 	bne.w	800e0ae <USB_HC_StartXfer+0x8a>
 800e300:	e77b      	b.n	800e1fa <USB_HC_StartXfer+0x1d6>
 800e302:	bf00      	nop
 800e304:	80080000 	.word	0x80080000

0800e308 <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 800e308:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  __IO uint32_t count = 0U;
 800e30c:	2300      	movs	r3, #0
{
 800e30e:	b430      	push	{r4, r5}
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 800e310:	f501 6ca0 	add.w	ip, r1, #1280	; 0x500
{
 800e314:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800e316:	9301      	str	r3, [sp, #4]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 800e318:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
  uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;
 800e31c:	f8d1 5500 	ldr.w	r5, [r1, #1280]	; 0x500
  uint32_t SplitEna = (USBx_HC(hcnum)->HCSPLT & USB_OTG_HCSPLT_SPLITEN) >> 31;
 800e320:	f8dc 4004 	ldr.w	r4, [ip, #4]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 800e324:	0c9b      	lsrs	r3, r3, #18
  if ((((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) && (SplitEna == 0U)) &&
 800e326:	6882      	ldr	r2, [r0, #8]
 800e328:	0692      	lsls	r2, r2, #26
 800e32a:	d501      	bpl.n	800e330 <USB_HC_Halt+0x28>
 800e32c:	2c00      	cmp	r4, #0
 800e32e:	da28      	bge.n	800e382 <USB_HC_Halt+0x7a>
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 800e330:	07dc      	lsls	r4, r3, #31
 800e332:	d52a      	bpl.n	800e38a <USB_HC_Halt+0x82>
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 800e334:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 800e338:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800e33c:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 800e340:	f8d0 3410 	ldr.w	r3, [r0, #1040]	; 0x410
 800e344:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800e348:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 800e34c:	d143      	bne.n	800e3d6 <USB_HC_Halt+0xce>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800e34e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e352:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800e356:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 800e35a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800e35e:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
 800e362:	e003      	b.n	800e36c <USB_HC_Halt+0x64>
      } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800e364:	f8dc 3000 	ldr.w	r3, [ip]
 800e368:	2b00      	cmp	r3, #0
 800e36a:	da06      	bge.n	800e37a <USB_HC_Halt+0x72>
        count++;
 800e36c:	9b01      	ldr	r3, [sp, #4]
 800e36e:	3301      	adds	r3, #1
 800e370:	9301      	str	r3, [sp, #4]
        if (count > 1000U)
 800e372:	9b01      	ldr	r3, [sp, #4]
 800e374:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800e378:	d9f4      	bls.n	800e364 <USB_HC_Halt+0x5c>
}
 800e37a:	2000      	movs	r0, #0
 800e37c:	b002      	add	sp, #8
 800e37e:	bc30      	pop	{r4, r5}
 800e380:	4770      	bx	lr
  if ((((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) && (SplitEna == 0U)) &&
 800e382:	2d00      	cmp	r5, #0
 800e384:	daf9      	bge.n	800e37a <USB_HC_Halt+0x72>
      ((ChannelEna == 0U) || (((HcEpType == HCCHAR_ISOC) || (HcEpType == HCCHAR_INTR)))))
 800e386:	07da      	lsls	r2, r3, #31
 800e388:	d4f7      	bmi.n	800e37a <USB_HC_Halt+0x72>
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 800e38a:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 800e38e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800e392:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 800e396:	6883      	ldr	r3, [r0, #8]
 800e398:	069b      	lsls	r3, r3, #26
 800e39a:	d424      	bmi.n	800e3e6 <USB_HC_Halt+0xde>
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 800e39c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800e39e:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800e3a2:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 800e3a6:	d116      	bne.n	800e3d6 <USB_HC_Halt+0xce>
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800e3a8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e3ac:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800e3b0:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 800e3b4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800e3b8:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
 800e3bc:	e003      	b.n	800e3c6 <USB_HC_Halt+0xbe>
        } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800e3be:	f8dc 3000 	ldr.w	r3, [ip]
 800e3c2:	2b00      	cmp	r3, #0
 800e3c4:	dad9      	bge.n	800e37a <USB_HC_Halt+0x72>
          count++;
 800e3c6:	9b01      	ldr	r3, [sp, #4]
 800e3c8:	3301      	adds	r3, #1
 800e3ca:	9301      	str	r3, [sp, #4]
          if (count > 1000U)
 800e3cc:	9b01      	ldr	r3, [sp, #4]
 800e3ce:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800e3d2:	d9f4      	bls.n	800e3be <USB_HC_Halt+0xb6>
 800e3d4:	e7d1      	b.n	800e37a <USB_HC_Halt+0x72>
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800e3d6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
}
 800e3da:	2000      	movs	r0, #0
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800e3dc:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
 800e3e0:	b002      	add	sp, #8
 800e3e2:	bc30      	pop	{r4, r5}
 800e3e4:	4770      	bx	lr
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800e3e6:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
}
 800e3ea:	2000      	movs	r0, #0
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800e3ec:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800e3f0:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
 800e3f4:	b002      	add	sp, #8
 800e3f6:	bc30      	pop	{r4, r5}
 800e3f8:	4770      	bx	lr
 800e3fa:	bf00      	nop

0800e3fc <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 800e3fc:	b530      	push	{r4, r5, lr}
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t count = 0U;
 800e3fe:	2300      	movs	r3, #0
{
 800e400:	b083      	sub	sp, #12
 800e402:	4604      	mov	r4, r0
  uint32_t i;

  (void)USB_DisableGlobalInt(USBx);

  /* Flush USB FIFO */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800e404:	2110      	movs	r1, #16
  __IO uint32_t count = 0U;
 800e406:	9301      	str	r3, [sp, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800e408:	6883      	ldr	r3, [r0, #8]
 800e40a:	f023 0301 	bic.w	r3, r3, #1
 800e40e:	6083      	str	r3, [r0, #8]
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800e410:	f7ff fc62 	bl	800dcd8 <USB_FlushTxFifo>
 800e414:	4605      	mov	r5, r0
  {
    ret = HAL_ERROR;
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 800e416:	4620      	mov	r0, r4
 800e418:	f504 61e0 	add.w	r1, r4, #1792	; 0x700
 800e41c:	f7ff fc84 	bl	800dd28 <USB_FlushRxFifo>
 800e420:	4328      	orrs	r0, r5
 800e422:	f504 62a0 	add.w	r2, r4, #1280	; 0x500
 800e426:	b2c0      	uxtb	r0, r0
  {
    ret = HAL_ERROR;
 800e428:	4694      	mov	ip, r2
 800e42a:	3800      	subs	r0, #0
 800e42c:	bf18      	it	ne
 800e42e:	2001      	movne	r0, #1
  }

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 800e430:	f8dc 3000 	ldr.w	r3, [ip]
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800e434:	f023 2380 	bic.w	r3, r3, #2147516416	; 0x80008000
 800e438:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800e43c:	f84c 3b20 	str.w	r3, [ip], #32
  for (i = 0U; i <= 15U; i++)
 800e440:	458c      	cmp	ip, r1
 800e442:	d1f5      	bne.n	800e430 <USB_StopHost+0x34>
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 800e444:	6813      	ldr	r3, [r2, #0]
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800e446:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800e44a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    USBx_HC(i)->HCCHAR = value;
 800e44e:	6013      	str	r3, [r2, #0]
 800e450:	e002      	b.n	800e458 <USB_StopHost+0x5c>

      if (count > 1000U)
      {
        break;
      }
    } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800e452:	6813      	ldr	r3, [r2, #0]
 800e454:	2b00      	cmp	r3, #0
 800e456:	da06      	bge.n	800e466 <USB_StopHost+0x6a>
      count++;
 800e458:	9b01      	ldr	r3, [sp, #4]
 800e45a:	3301      	adds	r3, #1
 800e45c:	9301      	str	r3, [sp, #4]
      if (count > 1000U)
 800e45e:	9b01      	ldr	r3, [sp, #4]
 800e460:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800e464:	d9f5      	bls.n	800e452 <USB_StopHost+0x56>
  for (i = 0U; i <= 15U; i++)
 800e466:	3220      	adds	r2, #32
 800e468:	428a      	cmp	r2, r1
 800e46a:	d1eb      	bne.n	800e444 <USB_StopHost+0x48>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = CLEAR_INTERRUPT_MASK;
 800e46c:	f04f 33ff 	mov.w	r3, #4294967295
 800e470:	f8c4 3414 	str.w	r3, [r4, #1044]	; 0x414
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 800e474:	6163      	str	r3, [r4, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800e476:	68a3      	ldr	r3, [r4, #8]
 800e478:	f043 0301 	orr.w	r3, r3, #1
 800e47c:	60a3      	str	r3, [r4, #8]

  (void)USB_EnableGlobalInt(USBx);

  return ret;
}
 800e47e:	b003      	add	sp, #12
 800e480:	bd30      	pop	{r4, r5, pc}
 800e482:	bf00      	nop

0800e484 <__udivmoddi4>:
 800e484:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e488:	9e08      	ldr	r6, [sp, #32]
 800e48a:	460d      	mov	r5, r1
 800e48c:	4604      	mov	r4, r0
 800e48e:	460f      	mov	r7, r1
 800e490:	2b00      	cmp	r3, #0
 800e492:	d14a      	bne.n	800e52a <__udivmoddi4+0xa6>
 800e494:	428a      	cmp	r2, r1
 800e496:	4694      	mov	ip, r2
 800e498:	d965      	bls.n	800e566 <__udivmoddi4+0xe2>
 800e49a:	fab2 f382 	clz	r3, r2
 800e49e:	b143      	cbz	r3, 800e4b2 <__udivmoddi4+0x2e>
 800e4a0:	fa02 fc03 	lsl.w	ip, r2, r3
 800e4a4:	f1c3 0220 	rsb	r2, r3, #32
 800e4a8:	409f      	lsls	r7, r3
 800e4aa:	fa20 f202 	lsr.w	r2, r0, r2
 800e4ae:	4317      	orrs	r7, r2
 800e4b0:	409c      	lsls	r4, r3
 800e4b2:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 800e4b6:	fa1f f58c 	uxth.w	r5, ip
 800e4ba:	fbb7 f1fe 	udiv	r1, r7, lr
 800e4be:	0c22      	lsrs	r2, r4, #16
 800e4c0:	fb0e 7711 	mls	r7, lr, r1, r7
 800e4c4:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 800e4c8:	fb01 f005 	mul.w	r0, r1, r5
 800e4cc:	4290      	cmp	r0, r2
 800e4ce:	d90a      	bls.n	800e4e6 <__udivmoddi4+0x62>
 800e4d0:	eb1c 0202 	adds.w	r2, ip, r2
 800e4d4:	f101 37ff 	add.w	r7, r1, #4294967295
 800e4d8:	f080 811c 	bcs.w	800e714 <__udivmoddi4+0x290>
 800e4dc:	4290      	cmp	r0, r2
 800e4de:	f240 8119 	bls.w	800e714 <__udivmoddi4+0x290>
 800e4e2:	3902      	subs	r1, #2
 800e4e4:	4462      	add	r2, ip
 800e4e6:	1a12      	subs	r2, r2, r0
 800e4e8:	b2a4      	uxth	r4, r4
 800e4ea:	fbb2 f0fe 	udiv	r0, r2, lr
 800e4ee:	fb0e 2210 	mls	r2, lr, r0, r2
 800e4f2:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800e4f6:	fb00 f505 	mul.w	r5, r0, r5
 800e4fa:	42a5      	cmp	r5, r4
 800e4fc:	d90a      	bls.n	800e514 <__udivmoddi4+0x90>
 800e4fe:	eb1c 0404 	adds.w	r4, ip, r4
 800e502:	f100 32ff 	add.w	r2, r0, #4294967295
 800e506:	f080 8107 	bcs.w	800e718 <__udivmoddi4+0x294>
 800e50a:	42a5      	cmp	r5, r4
 800e50c:	f240 8104 	bls.w	800e718 <__udivmoddi4+0x294>
 800e510:	4464      	add	r4, ip
 800e512:	3802      	subs	r0, #2
 800e514:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 800e518:	1b64      	subs	r4, r4, r5
 800e51a:	2100      	movs	r1, #0
 800e51c:	b11e      	cbz	r6, 800e526 <__udivmoddi4+0xa2>
 800e51e:	40dc      	lsrs	r4, r3
 800e520:	2300      	movs	r3, #0
 800e522:	e9c6 4300 	strd	r4, r3, [r6]
 800e526:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e52a:	428b      	cmp	r3, r1
 800e52c:	d908      	bls.n	800e540 <__udivmoddi4+0xbc>
 800e52e:	2e00      	cmp	r6, #0
 800e530:	f000 80ed 	beq.w	800e70e <__udivmoddi4+0x28a>
 800e534:	2100      	movs	r1, #0
 800e536:	e9c6 0500 	strd	r0, r5, [r6]
 800e53a:	4608      	mov	r0, r1
 800e53c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e540:	fab3 f183 	clz	r1, r3
 800e544:	2900      	cmp	r1, #0
 800e546:	d149      	bne.n	800e5dc <__udivmoddi4+0x158>
 800e548:	42ab      	cmp	r3, r5
 800e54a:	d302      	bcc.n	800e552 <__udivmoddi4+0xce>
 800e54c:	4282      	cmp	r2, r0
 800e54e:	f200 80f8 	bhi.w	800e742 <__udivmoddi4+0x2be>
 800e552:	1a84      	subs	r4, r0, r2
 800e554:	eb65 0203 	sbc.w	r2, r5, r3
 800e558:	2001      	movs	r0, #1
 800e55a:	4617      	mov	r7, r2
 800e55c:	2e00      	cmp	r6, #0
 800e55e:	d0e2      	beq.n	800e526 <__udivmoddi4+0xa2>
 800e560:	e9c6 4700 	strd	r4, r7, [r6]
 800e564:	e7df      	b.n	800e526 <__udivmoddi4+0xa2>
 800e566:	b902      	cbnz	r2, 800e56a <__udivmoddi4+0xe6>
 800e568:	deff      	udf	#255	; 0xff
 800e56a:	fab2 f382 	clz	r3, r2
 800e56e:	2b00      	cmp	r3, #0
 800e570:	f040 8090 	bne.w	800e694 <__udivmoddi4+0x210>
 800e574:	1a8a      	subs	r2, r1, r2
 800e576:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800e57a:	fa1f fe8c 	uxth.w	lr, ip
 800e57e:	2101      	movs	r1, #1
 800e580:	fbb2 f5f7 	udiv	r5, r2, r7
 800e584:	fb07 2015 	mls	r0, r7, r5, r2
 800e588:	0c22      	lsrs	r2, r4, #16
 800e58a:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 800e58e:	fb0e f005 	mul.w	r0, lr, r5
 800e592:	4290      	cmp	r0, r2
 800e594:	d908      	bls.n	800e5a8 <__udivmoddi4+0x124>
 800e596:	eb1c 0202 	adds.w	r2, ip, r2
 800e59a:	f105 38ff 	add.w	r8, r5, #4294967295
 800e59e:	d202      	bcs.n	800e5a6 <__udivmoddi4+0x122>
 800e5a0:	4290      	cmp	r0, r2
 800e5a2:	f200 80cb 	bhi.w	800e73c <__udivmoddi4+0x2b8>
 800e5a6:	4645      	mov	r5, r8
 800e5a8:	1a12      	subs	r2, r2, r0
 800e5aa:	b2a4      	uxth	r4, r4
 800e5ac:	fbb2 f0f7 	udiv	r0, r2, r7
 800e5b0:	fb07 2210 	mls	r2, r7, r0, r2
 800e5b4:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800e5b8:	fb0e fe00 	mul.w	lr, lr, r0
 800e5bc:	45a6      	cmp	lr, r4
 800e5be:	d908      	bls.n	800e5d2 <__udivmoddi4+0x14e>
 800e5c0:	eb1c 0404 	adds.w	r4, ip, r4
 800e5c4:	f100 32ff 	add.w	r2, r0, #4294967295
 800e5c8:	d202      	bcs.n	800e5d0 <__udivmoddi4+0x14c>
 800e5ca:	45a6      	cmp	lr, r4
 800e5cc:	f200 80bb 	bhi.w	800e746 <__udivmoddi4+0x2c2>
 800e5d0:	4610      	mov	r0, r2
 800e5d2:	eba4 040e 	sub.w	r4, r4, lr
 800e5d6:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 800e5da:	e79f      	b.n	800e51c <__udivmoddi4+0x98>
 800e5dc:	f1c1 0720 	rsb	r7, r1, #32
 800e5e0:	408b      	lsls	r3, r1
 800e5e2:	fa22 fc07 	lsr.w	ip, r2, r7
 800e5e6:	ea4c 0c03 	orr.w	ip, ip, r3
 800e5ea:	fa05 f401 	lsl.w	r4, r5, r1
 800e5ee:	fa20 f307 	lsr.w	r3, r0, r7
 800e5f2:	40fd      	lsrs	r5, r7
 800e5f4:	ea4f 491c 	mov.w	r9, ip, lsr #16
 800e5f8:	4323      	orrs	r3, r4
 800e5fa:	fbb5 f8f9 	udiv	r8, r5, r9
 800e5fe:	fa1f fe8c 	uxth.w	lr, ip
 800e602:	fb09 5518 	mls	r5, r9, r8, r5
 800e606:	0c1c      	lsrs	r4, r3, #16
 800e608:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800e60c:	fb08 f50e 	mul.w	r5, r8, lr
 800e610:	42a5      	cmp	r5, r4
 800e612:	fa02 f201 	lsl.w	r2, r2, r1
 800e616:	fa00 f001 	lsl.w	r0, r0, r1
 800e61a:	d90b      	bls.n	800e634 <__udivmoddi4+0x1b0>
 800e61c:	eb1c 0404 	adds.w	r4, ip, r4
 800e620:	f108 3aff 	add.w	sl, r8, #4294967295
 800e624:	f080 8088 	bcs.w	800e738 <__udivmoddi4+0x2b4>
 800e628:	42a5      	cmp	r5, r4
 800e62a:	f240 8085 	bls.w	800e738 <__udivmoddi4+0x2b4>
 800e62e:	f1a8 0802 	sub.w	r8, r8, #2
 800e632:	4464      	add	r4, ip
 800e634:	1b64      	subs	r4, r4, r5
 800e636:	b29d      	uxth	r5, r3
 800e638:	fbb4 f3f9 	udiv	r3, r4, r9
 800e63c:	fb09 4413 	mls	r4, r9, r3, r4
 800e640:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 800e644:	fb03 fe0e 	mul.w	lr, r3, lr
 800e648:	45a6      	cmp	lr, r4
 800e64a:	d908      	bls.n	800e65e <__udivmoddi4+0x1da>
 800e64c:	eb1c 0404 	adds.w	r4, ip, r4
 800e650:	f103 35ff 	add.w	r5, r3, #4294967295
 800e654:	d26c      	bcs.n	800e730 <__udivmoddi4+0x2ac>
 800e656:	45a6      	cmp	lr, r4
 800e658:	d96a      	bls.n	800e730 <__udivmoddi4+0x2ac>
 800e65a:	3b02      	subs	r3, #2
 800e65c:	4464      	add	r4, ip
 800e65e:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800e662:	fba3 9502 	umull	r9, r5, r3, r2
 800e666:	eba4 040e 	sub.w	r4, r4, lr
 800e66a:	42ac      	cmp	r4, r5
 800e66c:	46c8      	mov	r8, r9
 800e66e:	46ae      	mov	lr, r5
 800e670:	d356      	bcc.n	800e720 <__udivmoddi4+0x29c>
 800e672:	d053      	beq.n	800e71c <__udivmoddi4+0x298>
 800e674:	b156      	cbz	r6, 800e68c <__udivmoddi4+0x208>
 800e676:	ebb0 0208 	subs.w	r2, r0, r8
 800e67a:	eb64 040e 	sbc.w	r4, r4, lr
 800e67e:	fa04 f707 	lsl.w	r7, r4, r7
 800e682:	40ca      	lsrs	r2, r1
 800e684:	40cc      	lsrs	r4, r1
 800e686:	4317      	orrs	r7, r2
 800e688:	e9c6 7400 	strd	r7, r4, [r6]
 800e68c:	4618      	mov	r0, r3
 800e68e:	2100      	movs	r1, #0
 800e690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e694:	f1c3 0120 	rsb	r1, r3, #32
 800e698:	fa02 fc03 	lsl.w	ip, r2, r3
 800e69c:	fa20 f201 	lsr.w	r2, r0, r1
 800e6a0:	fa25 f101 	lsr.w	r1, r5, r1
 800e6a4:	409d      	lsls	r5, r3
 800e6a6:	432a      	orrs	r2, r5
 800e6a8:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800e6ac:	fa1f fe8c 	uxth.w	lr, ip
 800e6b0:	fbb1 f0f7 	udiv	r0, r1, r7
 800e6b4:	fb07 1510 	mls	r5, r7, r0, r1
 800e6b8:	0c11      	lsrs	r1, r2, #16
 800e6ba:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 800e6be:	fb00 f50e 	mul.w	r5, r0, lr
 800e6c2:	428d      	cmp	r5, r1
 800e6c4:	fa04 f403 	lsl.w	r4, r4, r3
 800e6c8:	d908      	bls.n	800e6dc <__udivmoddi4+0x258>
 800e6ca:	eb1c 0101 	adds.w	r1, ip, r1
 800e6ce:	f100 38ff 	add.w	r8, r0, #4294967295
 800e6d2:	d22f      	bcs.n	800e734 <__udivmoddi4+0x2b0>
 800e6d4:	428d      	cmp	r5, r1
 800e6d6:	d92d      	bls.n	800e734 <__udivmoddi4+0x2b0>
 800e6d8:	3802      	subs	r0, #2
 800e6da:	4461      	add	r1, ip
 800e6dc:	1b49      	subs	r1, r1, r5
 800e6de:	b292      	uxth	r2, r2
 800e6e0:	fbb1 f5f7 	udiv	r5, r1, r7
 800e6e4:	fb07 1115 	mls	r1, r7, r5, r1
 800e6e8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800e6ec:	fb05 f10e 	mul.w	r1, r5, lr
 800e6f0:	4291      	cmp	r1, r2
 800e6f2:	d908      	bls.n	800e706 <__udivmoddi4+0x282>
 800e6f4:	eb1c 0202 	adds.w	r2, ip, r2
 800e6f8:	f105 38ff 	add.w	r8, r5, #4294967295
 800e6fc:	d216      	bcs.n	800e72c <__udivmoddi4+0x2a8>
 800e6fe:	4291      	cmp	r1, r2
 800e700:	d914      	bls.n	800e72c <__udivmoddi4+0x2a8>
 800e702:	3d02      	subs	r5, #2
 800e704:	4462      	add	r2, ip
 800e706:	1a52      	subs	r2, r2, r1
 800e708:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 800e70c:	e738      	b.n	800e580 <__udivmoddi4+0xfc>
 800e70e:	4631      	mov	r1, r6
 800e710:	4630      	mov	r0, r6
 800e712:	e708      	b.n	800e526 <__udivmoddi4+0xa2>
 800e714:	4639      	mov	r1, r7
 800e716:	e6e6      	b.n	800e4e6 <__udivmoddi4+0x62>
 800e718:	4610      	mov	r0, r2
 800e71a:	e6fb      	b.n	800e514 <__udivmoddi4+0x90>
 800e71c:	4548      	cmp	r0, r9
 800e71e:	d2a9      	bcs.n	800e674 <__udivmoddi4+0x1f0>
 800e720:	ebb9 0802 	subs.w	r8, r9, r2
 800e724:	eb65 0e0c 	sbc.w	lr, r5, ip
 800e728:	3b01      	subs	r3, #1
 800e72a:	e7a3      	b.n	800e674 <__udivmoddi4+0x1f0>
 800e72c:	4645      	mov	r5, r8
 800e72e:	e7ea      	b.n	800e706 <__udivmoddi4+0x282>
 800e730:	462b      	mov	r3, r5
 800e732:	e794      	b.n	800e65e <__udivmoddi4+0x1da>
 800e734:	4640      	mov	r0, r8
 800e736:	e7d1      	b.n	800e6dc <__udivmoddi4+0x258>
 800e738:	46d0      	mov	r8, sl
 800e73a:	e77b      	b.n	800e634 <__udivmoddi4+0x1b0>
 800e73c:	3d02      	subs	r5, #2
 800e73e:	4462      	add	r2, ip
 800e740:	e732      	b.n	800e5a8 <__udivmoddi4+0x124>
 800e742:	4608      	mov	r0, r1
 800e744:	e70a      	b.n	800e55c <__udivmoddi4+0xd8>
 800e746:	4464      	add	r4, ip
 800e748:	3802      	subs	r0, #2
 800e74a:	e742      	b.n	800e5d2 <__udivmoddi4+0x14e>

0800e74c <printf>:
 800e74c:	b40f      	push	{r0, r1, r2, r3}
 800e74e:	b500      	push	{lr}
 800e750:	4907      	ldr	r1, [pc, #28]	; (800e770 <printf+0x24>)
 800e752:	b083      	sub	sp, #12
 800e754:	ab04      	add	r3, sp, #16
 800e756:	6808      	ldr	r0, [r1, #0]
 800e758:	f853 2b04 	ldr.w	r2, [r3], #4
 800e75c:	6881      	ldr	r1, [r0, #8]
 800e75e:	9301      	str	r3, [sp, #4]
 800e760:	f000 f932 	bl	800e9c8 <_vfprintf_r>
 800e764:	b003      	add	sp, #12
 800e766:	f85d eb04 	ldr.w	lr, [sp], #4
 800e76a:	b004      	add	sp, #16
 800e76c:	4770      	bx	lr
 800e76e:	bf00      	nop
 800e770:	24000160 	.word	0x24000160

0800e774 <putchar>:
 800e774:	4b02      	ldr	r3, [pc, #8]	; (800e780 <putchar+0xc>)
 800e776:	4601      	mov	r1, r0
 800e778:	6818      	ldr	r0, [r3, #0]
 800e77a:	6882      	ldr	r2, [r0, #8]
 800e77c:	f003 babc 	b.w	8011cf8 <_putc_r>
 800e780:	24000160 	.word	0x24000160

0800e784 <memcmp>:
 800e784:	2a03      	cmp	r2, #3
 800e786:	b570      	push	{r4, r5, r6, lr}
 800e788:	d914      	bls.n	800e7b4 <memcmp+0x30>
 800e78a:	ea40 0301 	orr.w	r3, r0, r1
 800e78e:	079b      	lsls	r3, r3, #30
 800e790:	d122      	bne.n	800e7d8 <memcmp+0x54>
 800e792:	4604      	mov	r4, r0
 800e794:	460b      	mov	r3, r1
 800e796:	4619      	mov	r1, r3
 800e798:	4620      	mov	r0, r4
 800e79a:	680e      	ldr	r6, [r1, #0]
 800e79c:	6805      	ldr	r5, [r0, #0]
 800e79e:	42b5      	cmp	r5, r6
 800e7a0:	f104 0404 	add.w	r4, r4, #4
 800e7a4:	f103 0304 	add.w	r3, r3, #4
 800e7a8:	d116      	bne.n	800e7d8 <memcmp+0x54>
 800e7aa:	3a04      	subs	r2, #4
 800e7ac:	2a03      	cmp	r2, #3
 800e7ae:	4620      	mov	r0, r4
 800e7b0:	4619      	mov	r1, r3
 800e7b2:	d8f0      	bhi.n	800e796 <memcmp+0x12>
 800e7b4:	1e54      	subs	r4, r2, #1
 800e7b6:	b19a      	cbz	r2, 800e7e0 <memcmp+0x5c>
 800e7b8:	1e42      	subs	r2, r0, #1
 800e7ba:	3901      	subs	r1, #1
 800e7bc:	e001      	b.n	800e7c2 <memcmp+0x3e>
 800e7be:	18c3      	adds	r3, r0, r3
 800e7c0:	d00c      	beq.n	800e7dc <memcmp+0x58>
 800e7c2:	f812 ef01 	ldrb.w	lr, [r2, #1]!
 800e7c6:	f811 cf01 	ldrb.w	ip, [r1, #1]!
 800e7ca:	45e6      	cmp	lr, ip
 800e7cc:	eba4 0302 	sub.w	r3, r4, r2
 800e7d0:	d0f5      	beq.n	800e7be <memcmp+0x3a>
 800e7d2:	ebae 000c 	sub.w	r0, lr, ip
 800e7d6:	bd70      	pop	{r4, r5, r6, pc}
 800e7d8:	1e54      	subs	r4, r2, #1
 800e7da:	e7ed      	b.n	800e7b8 <memcmp+0x34>
 800e7dc:	4618      	mov	r0, r3
 800e7de:	bd70      	pop	{r4, r5, r6, pc}
 800e7e0:	4610      	mov	r0, r2
 800e7e2:	bd70      	pop	{r4, r5, r6, pc}

0800e7e4 <memset>:
 800e7e4:	0783      	lsls	r3, r0, #30
 800e7e6:	b530      	push	{r4, r5, lr}
 800e7e8:	d048      	beq.n	800e87c <memset+0x98>
 800e7ea:	1e54      	subs	r4, r2, #1
 800e7ec:	2a00      	cmp	r2, #0
 800e7ee:	d03f      	beq.n	800e870 <memset+0x8c>
 800e7f0:	b2ca      	uxtb	r2, r1
 800e7f2:	4603      	mov	r3, r0
 800e7f4:	e001      	b.n	800e7fa <memset+0x16>
 800e7f6:	3c01      	subs	r4, #1
 800e7f8:	d33a      	bcc.n	800e870 <memset+0x8c>
 800e7fa:	f803 2b01 	strb.w	r2, [r3], #1
 800e7fe:	079d      	lsls	r5, r3, #30
 800e800:	d1f9      	bne.n	800e7f6 <memset+0x12>
 800e802:	2c03      	cmp	r4, #3
 800e804:	d92d      	bls.n	800e862 <memset+0x7e>
 800e806:	b2cd      	uxtb	r5, r1
 800e808:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800e80c:	2c0f      	cmp	r4, #15
 800e80e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800e812:	d936      	bls.n	800e882 <memset+0x9e>
 800e814:	f1a4 0210 	sub.w	r2, r4, #16
 800e818:	f022 0c0f 	bic.w	ip, r2, #15
 800e81c:	f103 0e20 	add.w	lr, r3, #32
 800e820:	44e6      	add	lr, ip
 800e822:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 800e826:	f103 0210 	add.w	r2, r3, #16
 800e82a:	e942 5504 	strd	r5, r5, [r2, #-16]
 800e82e:	e942 5502 	strd	r5, r5, [r2, #-8]
 800e832:	3210      	adds	r2, #16
 800e834:	4572      	cmp	r2, lr
 800e836:	d1f8      	bne.n	800e82a <memset+0x46>
 800e838:	f10c 0201 	add.w	r2, ip, #1
 800e83c:	f014 0f0c 	tst.w	r4, #12
 800e840:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800e844:	f004 0c0f 	and.w	ip, r4, #15
 800e848:	d013      	beq.n	800e872 <memset+0x8e>
 800e84a:	f1ac 0304 	sub.w	r3, ip, #4
 800e84e:	f023 0303 	bic.w	r3, r3, #3
 800e852:	3304      	adds	r3, #4
 800e854:	4413      	add	r3, r2
 800e856:	f842 5b04 	str.w	r5, [r2], #4
 800e85a:	4293      	cmp	r3, r2
 800e85c:	d1fb      	bne.n	800e856 <memset+0x72>
 800e85e:	f00c 0403 	and.w	r4, ip, #3
 800e862:	b12c      	cbz	r4, 800e870 <memset+0x8c>
 800e864:	b2c9      	uxtb	r1, r1
 800e866:	441c      	add	r4, r3
 800e868:	f803 1b01 	strb.w	r1, [r3], #1
 800e86c:	429c      	cmp	r4, r3
 800e86e:	d1fb      	bne.n	800e868 <memset+0x84>
 800e870:	bd30      	pop	{r4, r5, pc}
 800e872:	4664      	mov	r4, ip
 800e874:	4613      	mov	r3, r2
 800e876:	2c00      	cmp	r4, #0
 800e878:	d1f4      	bne.n	800e864 <memset+0x80>
 800e87a:	e7f9      	b.n	800e870 <memset+0x8c>
 800e87c:	4603      	mov	r3, r0
 800e87e:	4614      	mov	r4, r2
 800e880:	e7bf      	b.n	800e802 <memset+0x1e>
 800e882:	461a      	mov	r2, r3
 800e884:	46a4      	mov	ip, r4
 800e886:	e7e0      	b.n	800e84a <memset+0x66>

0800e888 <strchr>:
 800e888:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
 800e88c:	4603      	mov	r3, r0
 800e88e:	d044      	beq.n	800e91a <strchr+0x92>
 800e890:	0782      	lsls	r2, r0, #30
 800e892:	d132      	bne.n	800e8fa <strchr+0x72>
 800e894:	b510      	push	{r4, lr}
 800e896:	6804      	ldr	r4, [r0, #0]
 800e898:	ea41 2e01 	orr.w	lr, r1, r1, lsl #8
 800e89c:	ea4e 4e0e 	orr.w	lr, lr, lr, lsl #16
 800e8a0:	ea8e 0204 	eor.w	r2, lr, r4
 800e8a4:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800e8a8:	ea23 0302 	bic.w	r3, r3, r2
 800e8ac:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 800e8b0:	ea22 0204 	bic.w	r2, r2, r4
 800e8b4:	4313      	orrs	r3, r2
 800e8b6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800e8ba:	d10f      	bne.n	800e8dc <strchr+0x54>
 800e8bc:	f850 4f04 	ldr.w	r4, [r0, #4]!
 800e8c0:	ea84 0c0e 	eor.w	ip, r4, lr
 800e8c4:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 800e8c8:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 800e8cc:	ea23 0304 	bic.w	r3, r3, r4
 800e8d0:	ea22 020c 	bic.w	r2, r2, ip
 800e8d4:	4313      	orrs	r3, r2
 800e8d6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800e8da:	d0ef      	beq.n	800e8bc <strchr+0x34>
 800e8dc:	7803      	ldrb	r3, [r0, #0]
 800e8de:	b923      	cbnz	r3, 800e8ea <strchr+0x62>
 800e8e0:	e036      	b.n	800e950 <strchr+0xc8>
 800e8e2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800e8e6:	2b00      	cmp	r3, #0
 800e8e8:	d032      	beq.n	800e950 <strchr+0xc8>
 800e8ea:	4299      	cmp	r1, r3
 800e8ec:	d1f9      	bne.n	800e8e2 <strchr+0x5a>
 800e8ee:	bd10      	pop	{r4, pc}
 800e8f0:	428a      	cmp	r2, r1
 800e8f2:	d011      	beq.n	800e918 <strchr+0x90>
 800e8f4:	079a      	lsls	r2, r3, #30
 800e8f6:	4618      	mov	r0, r3
 800e8f8:	d0cc      	beq.n	800e894 <strchr+0xc>
 800e8fa:	4618      	mov	r0, r3
 800e8fc:	f813 2b01 	ldrb.w	r2, [r3], #1
 800e900:	2a00      	cmp	r2, #0
 800e902:	d1f5      	bne.n	800e8f0 <strchr+0x68>
 800e904:	4610      	mov	r0, r2
 800e906:	4770      	bx	lr
 800e908:	0799      	lsls	r1, r3, #30
 800e90a:	4618      	mov	r0, r3
 800e90c:	d007      	beq.n	800e91e <strchr+0x96>
 800e90e:	4618      	mov	r0, r3
 800e910:	3301      	adds	r3, #1
 800e912:	7802      	ldrb	r2, [r0, #0]
 800e914:	2a00      	cmp	r2, #0
 800e916:	d1f7      	bne.n	800e908 <strchr+0x80>
 800e918:	4770      	bx	lr
 800e91a:	0782      	lsls	r2, r0, #30
 800e91c:	d1f7      	bne.n	800e90e <strchr+0x86>
 800e91e:	6802      	ldr	r2, [r0, #0]
 800e920:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800e924:	ea23 0302 	bic.w	r3, r3, r2
 800e928:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800e92c:	d108      	bne.n	800e940 <strchr+0xb8>
 800e92e:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800e932:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800e936:	ea23 0302 	bic.w	r3, r3, r2
 800e93a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800e93e:	d0f6      	beq.n	800e92e <strchr+0xa6>
 800e940:	7803      	ldrb	r3, [r0, #0]
 800e942:	2b00      	cmp	r3, #0
 800e944:	d0e8      	beq.n	800e918 <strchr+0x90>
 800e946:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800e94a:	2b00      	cmp	r3, #0
 800e94c:	d1fb      	bne.n	800e946 <strchr+0xbe>
 800e94e:	4770      	bx	lr
 800e950:	4618      	mov	r0, r3
 800e952:	bd10      	pop	{r4, pc}

0800e954 <strncpy>:
 800e954:	ea40 0301 	orr.w	r3, r0, r1
 800e958:	079b      	lsls	r3, r3, #30
 800e95a:	b530      	push	{r4, r5, lr}
 800e95c:	d101      	bne.n	800e962 <strncpy+0xe>
 800e95e:	2a03      	cmp	r2, #3
 800e960:	d80f      	bhi.n	800e982 <strncpy+0x2e>
 800e962:	4684      	mov	ip, r0
 800e964:	f101 3eff 	add.w	lr, r1, #4294967295
 800e968:	e007      	b.n	800e97a <strncpy+0x26>
 800e96a:	f81e 1f01 	ldrb.w	r1, [lr, #1]!
 800e96e:	f803 1b01 	strb.w	r1, [r3], #1
 800e972:	1e54      	subs	r4, r2, #1
 800e974:	b1c1      	cbz	r1, 800e9a8 <strncpy+0x54>
 800e976:	469c      	mov	ip, r3
 800e978:	4622      	mov	r2, r4
 800e97a:	4663      	mov	r3, ip
 800e97c:	2a00      	cmp	r2, #0
 800e97e:	d1f4      	bne.n	800e96a <strncpy+0x16>
 800e980:	bd30      	pop	{r4, r5, pc}
 800e982:	460b      	mov	r3, r1
 800e984:	4684      	mov	ip, r0
 800e986:	4619      	mov	r1, r3
 800e988:	f853 5b04 	ldr.w	r5, [r3], #4
 800e98c:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 800e990:	ea24 0405 	bic.w	r4, r4, r5
 800e994:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 800e998:	d1e4      	bne.n	800e964 <strncpy+0x10>
 800e99a:	3a04      	subs	r2, #4
 800e99c:	2a03      	cmp	r2, #3
 800e99e:	f84c 5b04 	str.w	r5, [ip], #4
 800e9a2:	4619      	mov	r1, r3
 800e9a4:	d8ef      	bhi.n	800e986 <strncpy+0x32>
 800e9a6:	e7dd      	b.n	800e964 <strncpy+0x10>
 800e9a8:	4494      	add	ip, r2
 800e9aa:	2c00      	cmp	r4, #0
 800e9ac:	d0e8      	beq.n	800e980 <strncpy+0x2c>
 800e9ae:	f803 1b01 	strb.w	r1, [r3], #1
 800e9b2:	4563      	cmp	r3, ip
 800e9b4:	d1fb      	bne.n	800e9ae <strncpy+0x5a>
 800e9b6:	bd30      	pop	{r4, r5, pc}

0800e9b8 <__errno>:
 800e9b8:	4b01      	ldr	r3, [pc, #4]	; (800e9c0 <__errno+0x8>)
 800e9ba:	6818      	ldr	r0, [r3, #0]
 800e9bc:	4770      	bx	lr
 800e9be:	bf00      	nop
 800e9c0:	24000160 	.word	0x24000160
 800e9c4:	00000000 	.word	0x00000000

0800e9c8 <_vfprintf_r>:
 800e9c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e9cc:	ed2d 8b08 	vpush	{d8-d11}
 800e9d0:	b0d1      	sub	sp, #324	; 0x144
 800e9d2:	ee0b 1a10 	vmov	s22, r1
 800e9d6:	461c      	mov	r4, r3
 800e9d8:	4617      	mov	r7, r2
 800e9da:	4683      	mov	fp, r0
 800e9dc:	f003 fbd8 	bl	8012190 <_localeconv_r>
 800e9e0:	6803      	ldr	r3, [r0, #0]
 800e9e2:	9311      	str	r3, [sp, #68]	; 0x44
 800e9e4:	4618      	mov	r0, r3
 800e9e6:	f7f1 ff6b 	bl	80008c0 <strlen>
 800e9ea:	f10d 0a80 	add.w	sl, sp, #128	; 0x80
 800e9ee:	9010      	str	r0, [sp, #64]	; 0x40
 800e9f0:	2208      	movs	r2, #8
 800e9f2:	2100      	movs	r1, #0
 800e9f4:	4650      	mov	r0, sl
 800e9f6:	9408      	str	r4, [sp, #32]
 800e9f8:	f7ff fef4 	bl	800e7e4 <memset>
 800e9fc:	f1bb 0f00 	cmp.w	fp, #0
 800ea00:	d004      	beq.n	800ea0c <_vfprintf_r+0x44>
 800ea02:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800ea06:	2b00      	cmp	r3, #0
 800ea08:	f001 805f 	beq.w	800faca <_vfprintf_r+0x1102>
 800ea0c:	ee1b 2a10 	vmov	r2, s22
 800ea10:	6e53      	ldr	r3, [r2, #100]	; 0x64
 800ea12:	07d8      	lsls	r0, r3, #31
 800ea14:	f140 816e 	bpl.w	800ecf4 <_vfprintf_r+0x32c>
 800ea18:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
 800ea1c:	b293      	uxth	r3, r2
 800ea1e:	049e      	lsls	r6, r3, #18
 800ea20:	d409      	bmi.n	800ea36 <_vfprintf_r+0x6e>
 800ea22:	ee1b 1a10 	vmov	r1, s22
 800ea26:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800ea2a:	818a      	strh	r2, [r1, #12]
 800ea2c:	b293      	uxth	r3, r2
 800ea2e:	6e4a      	ldr	r2, [r1, #100]	; 0x64
 800ea30:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800ea34:	664a      	str	r2, [r1, #100]	; 0x64
 800ea36:	071d      	lsls	r5, r3, #28
 800ea38:	f140 80cf 	bpl.w	800ebda <_vfprintf_r+0x212>
 800ea3c:	ee1b 2a10 	vmov	r2, s22
 800ea40:	6912      	ldr	r2, [r2, #16]
 800ea42:	2a00      	cmp	r2, #0
 800ea44:	f000 80c9 	beq.w	800ebda <_vfprintf_r+0x212>
 800ea48:	f003 021a 	and.w	r2, r3, #26
 800ea4c:	2a0a      	cmp	r2, #10
 800ea4e:	f000 80d4 	beq.w	800ebfa <_vfprintf_r+0x232>
 800ea52:	2300      	movs	r3, #0
 800ea54:	ed9f 8ba2 	vldr	d8, [pc, #648]	; 800ece0 <_vfprintf_r+0x318>
 800ea58:	ed9f 9ba3 	vldr	d9, [pc, #652]	; 800ece8 <_vfprintf_r+0x320>
 800ea5c:	e9cd 3325 	strd	r3, r3, [sp, #148]	; 0x94
 800ea60:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
 800ea64:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
 800ea68:	aa27      	add	r2, sp, #156	; 0x9c
 800ea6a:	930e      	str	r3, [sp, #56]	; 0x38
 800ea6c:	9224      	str	r2, [sp, #144]	; 0x90
 800ea6e:	4690      	mov	r8, r2
 800ea70:	9312      	str	r3, [sp, #72]	; 0x48
 800ea72:	9304      	str	r3, [sp, #16]
 800ea74:	46b9      	mov	r9, r7
 800ea76:	4b9e      	ldr	r3, [pc, #632]	; (800ecf0 <_vfprintf_r+0x328>)
 800ea78:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
 800ea7c:	f003 fb82 	bl	8012184 <__locale_mb_cur_max>
 800ea80:	464a      	mov	r2, r9
 800ea82:	4603      	mov	r3, r0
 800ea84:	a91c      	add	r1, sp, #112	; 0x70
 800ea86:	f8cd a000 	str.w	sl, [sp]
 800ea8a:	4658      	mov	r0, fp
 800ea8c:	47a0      	blx	r4
 800ea8e:	2800      	cmp	r0, #0
 800ea90:	f000 80d6 	beq.w	800ec40 <_vfprintf_r+0x278>
 800ea94:	f2c0 80cc 	blt.w	800ec30 <_vfprintf_r+0x268>
 800ea98:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800ea9a:	2a25      	cmp	r2, #37	; 0x25
 800ea9c:	4603      	mov	r3, r0
 800ea9e:	d001      	beq.n	800eaa4 <_vfprintf_r+0xdc>
 800eaa0:	4499      	add	r9, r3
 800eaa2:	e7e8      	b.n	800ea76 <_vfprintf_r+0xae>
 800eaa4:	ebb9 0607 	subs.w	r6, r9, r7
 800eaa8:	4605      	mov	r5, r0
 800eaaa:	f040 80cd 	bne.w	800ec48 <_vfprintf_r+0x280>
 800eaae:	2300      	movs	r3, #0
 800eab0:	f04f 32ff 	mov.w	r2, #4294967295
 800eab4:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
 800eab8:	461e      	mov	r6, r3
 800eaba:	9306      	str	r3, [sp, #24]
 800eabc:	f109 0901 	add.w	r9, r9, #1
 800eac0:	f899 3000 	ldrb.w	r3, [r9]
 800eac4:	9203      	str	r2, [sp, #12]
 800eac6:	242b      	movs	r4, #43	; 0x2b
 800eac8:	2520      	movs	r5, #32
 800eaca:	f109 0901 	add.w	r9, r9, #1
 800eace:	f1a3 0220 	sub.w	r2, r3, #32
 800ead2:	2a5a      	cmp	r2, #90	; 0x5a
 800ead4:	f200 811d 	bhi.w	800ed12 <_vfprintf_r+0x34a>
 800ead8:	e8df f012 	tbh	[pc, r2, lsl #1]
 800eadc:	011b02a4 	.word	0x011b02a4
 800eae0:	029f011b 	.word	0x029f011b
 800eae4:	011b011b 	.word	0x011b011b
 800eae8:	006a011b 	.word	0x006a011b
 800eaec:	011b011b 	.word	0x011b011b
 800eaf0:	027b0251 	.word	0x027b0251
 800eaf4:	025c011b 	.word	0x025c011b
 800eaf8:	011b0285 	.word	0x011b0285
 800eafc:	005b0280 	.word	0x005b0280
 800eb00:	005b005b 	.word	0x005b005b
 800eb04:	005b005b 	.word	0x005b005b
 800eb08:	005b005b 	.word	0x005b005b
 800eb0c:	005b005b 	.word	0x005b005b
 800eb10:	011b011b 	.word	0x011b011b
 800eb14:	011b011b 	.word	0x011b011b
 800eb18:	011b011b 	.word	0x011b011b
 800eb1c:	019f011b 	.word	0x019f011b
 800eb20:	01de011b 	.word	0x01de011b
 800eb24:	019f02f7 	.word	0x019f02f7
 800eb28:	019f019f 	.word	0x019f019f
 800eb2c:	011b011b 	.word	0x011b011b
 800eb30:	011b011b 	.word	0x011b011b
 800eb34:	011b02f2 	.word	0x011b02f2
 800eb38:	02ae011b 	.word	0x02ae011b
 800eb3c:	011b011b 	.word	0x011b011b
 800eb40:	01f8011b 	.word	0x01f8011b
 800eb44:	02df011b 	.word	0x02df011b
 800eb48:	011b011b 	.word	0x011b011b
 800eb4c:	011b0712 	.word	0x011b0712
 800eb50:	011b011b 	.word	0x011b011b
 800eb54:	011b011b 	.word	0x011b011b
 800eb58:	011b011b 	.word	0x011b011b
 800eb5c:	019f011b 	.word	0x019f011b
 800eb60:	01de011b 	.word	0x01de011b
 800eb64:	019f022b 	.word	0x019f022b
 800eb68:	019f019f 	.word	0x019f019f
 800eb6c:	022b026e 	.word	0x022b026e
 800eb70:	011b01d9 	.word	0x011b01d9
 800eb74:	011b0261 	.word	0x011b0261
 800eb78:	070b0320 	.word	0x070b0320
 800eb7c:	01d9030e 	.word	0x01d9030e
 800eb80:	01f8011b 	.word	0x01f8011b
 800eb84:	070e007c 	.word	0x070e007c
 800eb88:	011b011b 	.word	0x011b011b
 800eb8c:	011b06ea 	.word	0x011b06ea
 800eb90:	007c      	.short	0x007c
 800eb92:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800eb96:	2100      	movs	r1, #0
 800eb98:	f819 3b01 	ldrb.w	r3, [r9], #1
 800eb9c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 800eba0:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800eba4:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800eba8:	2a09      	cmp	r2, #9
 800ebaa:	d9f5      	bls.n	800eb98 <_vfprintf_r+0x1d0>
 800ebac:	9106      	str	r1, [sp, #24]
 800ebae:	e78e      	b.n	800eace <_vfprintf_r+0x106>
 800ebb0:	4658      	mov	r0, fp
 800ebb2:	f003 faed 	bl	8012190 <_localeconv_r>
 800ebb6:	6843      	ldr	r3, [r0, #4]
 800ebb8:	9315      	str	r3, [sp, #84]	; 0x54
 800ebba:	4618      	mov	r0, r3
 800ebbc:	f7f1 fe80 	bl	80008c0 <strlen>
 800ebc0:	9016      	str	r0, [sp, #88]	; 0x58
 800ebc2:	4658      	mov	r0, fp
 800ebc4:	f003 fae4 	bl	8012190 <_localeconv_r>
 800ebc8:	6883      	ldr	r3, [r0, #8]
 800ebca:	9313      	str	r3, [sp, #76]	; 0x4c
 800ebcc:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800ebce:	2b00      	cmp	r3, #0
 800ebd0:	f040 85f1 	bne.w	800f7b6 <_vfprintf_r+0xdee>
 800ebd4:	f899 3000 	ldrb.w	r3, [r9]
 800ebd8:	e777      	b.n	800eaca <_vfprintf_r+0x102>
 800ebda:	ee1b 1a10 	vmov	r1, s22
 800ebde:	4658      	mov	r0, fp
 800ebe0:	ee1b 5a10 	vmov	r5, s22
 800ebe4:	f003 f962 	bl	8011eac <__swsetup_r>
 800ebe8:	2800      	cmp	r0, #0
 800ebea:	f041 83bb 	bne.w	8010364 <_vfprintf_r+0x199c>
 800ebee:	89ab      	ldrh	r3, [r5, #12]
 800ebf0:	f003 021a 	and.w	r2, r3, #26
 800ebf4:	2a0a      	cmp	r2, #10
 800ebf6:	f47f af2c 	bne.w	800ea52 <_vfprintf_r+0x8a>
 800ebfa:	ee1b 1a10 	vmov	r1, s22
 800ebfe:	f9b1 200e 	ldrsh.w	r2, [r1, #14]
 800ec02:	2a00      	cmp	r2, #0
 800ec04:	f6ff af25 	blt.w	800ea52 <_vfprintf_r+0x8a>
 800ec08:	6e4a      	ldr	r2, [r1, #100]	; 0x64
 800ec0a:	07d2      	lsls	r2, r2, #31
 800ec0c:	d402      	bmi.n	800ec14 <_vfprintf_r+0x24c>
 800ec0e:	059e      	lsls	r6, r3, #22
 800ec10:	f141 81b9 	bpl.w	800ff86 <_vfprintf_r+0x15be>
 800ec14:	ee1b 1a10 	vmov	r1, s22
 800ec18:	4623      	mov	r3, r4
 800ec1a:	463a      	mov	r2, r7
 800ec1c:	4658      	mov	r0, fp
 800ec1e:	f001 fcbd 	bl	801059c <__sbprintf>
 800ec22:	9004      	str	r0, [sp, #16]
 800ec24:	9804      	ldr	r0, [sp, #16]
 800ec26:	b051      	add	sp, #324	; 0x144
 800ec28:	ecbd 8b08 	vpop	{d8-d11}
 800ec2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ec30:	2208      	movs	r2, #8
 800ec32:	2100      	movs	r1, #0
 800ec34:	4650      	mov	r0, sl
 800ec36:	f7ff fdd5 	bl	800e7e4 <memset>
 800ec3a:	2301      	movs	r3, #1
 800ec3c:	4499      	add	r9, r3
 800ec3e:	e71a      	b.n	800ea76 <_vfprintf_r+0xae>
 800ec40:	ebb9 0607 	subs.w	r6, r9, r7
 800ec44:	4605      	mov	r5, r0
 800ec46:	d011      	beq.n	800ec6c <_vfprintf_r+0x2a4>
 800ec48:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800ec4a:	4433      	add	r3, r6
 800ec4c:	9326      	str	r3, [sp, #152]	; 0x98
 800ec4e:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800ec50:	3301      	adds	r3, #1
 800ec52:	2b07      	cmp	r3, #7
 800ec54:	e9c8 7600 	strd	r7, r6, [r8]
 800ec58:	9325      	str	r3, [sp, #148]	; 0x94
 800ec5a:	dc12      	bgt.n	800ec82 <_vfprintf_r+0x2ba>
 800ec5c:	f108 0808 	add.w	r8, r8, #8
 800ec60:	9b04      	ldr	r3, [sp, #16]
 800ec62:	4433      	add	r3, r6
 800ec64:	9304      	str	r3, [sp, #16]
 800ec66:	2d00      	cmp	r5, #0
 800ec68:	f47f af21 	bne.w	800eaae <_vfprintf_r+0xe6>
 800ec6c:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800ec6e:	2b00      	cmp	r3, #0
 800ec70:	f041 816f 	bne.w	800ff52 <_vfprintf_r+0x158a>
 800ec74:	ee1b 3a10 	vmov	r3, s22
 800ec78:	2200      	movs	r2, #0
 800ec7a:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800ec7e:	9225      	str	r2, [sp, #148]	; 0x94
 800ec80:	e01c      	b.n	800ecbc <_vfprintf_r+0x2f4>
 800ec82:	ee1b 1a10 	vmov	r1, s22
 800ec86:	aa24      	add	r2, sp, #144	; 0x90
 800ec88:	4658      	mov	r0, fp
 800ec8a:	f001 fd03 	bl	8010694 <__sprint_r>
 800ec8e:	b988      	cbnz	r0, 800ecb4 <_vfprintf_r+0x2ec>
 800ec90:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800ec94:	e7e4      	b.n	800ec60 <_vfprintf_r+0x298>
 800ec96:	ee1b 1a10 	vmov	r1, s22
 800ec9a:	aa24      	add	r2, sp, #144	; 0x90
 800ec9c:	4658      	mov	r0, fp
 800ec9e:	f001 fcf9 	bl	8010694 <__sprint_r>
 800eca2:	2800      	cmp	r0, #0
 800eca4:	f000 80ad 	beq.w	800ee02 <_vfprintf_r+0x43a>
 800eca8:	9b07      	ldr	r3, [sp, #28]
 800ecaa:	b11b      	cbz	r3, 800ecb4 <_vfprintf_r+0x2ec>
 800ecac:	9907      	ldr	r1, [sp, #28]
 800ecae:	4658      	mov	r0, fp
 800ecb0:	f004 fa64 	bl	801317c <_free_r>
 800ecb4:	ee1b 3a10 	vmov	r3, s22
 800ecb8:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800ecbc:	ee1b 2a10 	vmov	r2, s22
 800ecc0:	6e52      	ldr	r2, [r2, #100]	; 0x64
 800ecc2:	f012 0f01 	tst.w	r2, #1
 800ecc6:	b29a      	uxth	r2, r3
 800ecc8:	f000 80d7 	beq.w	800ee7a <_vfprintf_r+0x4b2>
 800eccc:	0651      	lsls	r1, r2, #25
 800ecce:	f101 8352 	bmi.w	8010376 <_vfprintf_r+0x19ae>
 800ecd2:	9804      	ldr	r0, [sp, #16]
 800ecd4:	b051      	add	sp, #324	; 0x144
 800ecd6:	ecbd 8b08 	vpop	{d8-d11}
 800ecda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ecde:	bf00      	nop
	...
 800ece8:	ffffffff 	.word	0xffffffff
 800ecec:	7fefffff 	.word	0x7fefffff
 800ecf0:	24000170 	.word	0x24000170
 800ecf4:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
 800ecf8:	0591      	lsls	r1, r2, #22
 800ecfa:	b293      	uxth	r3, r2
 800ecfc:	f53f ae8f 	bmi.w	800ea1e <_vfprintf_r+0x56>
 800ed00:	ee1b 5a10 	vmov	r5, s22
 800ed04:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800ed06:	f003 fa9f 	bl	8012248 <__retarget_lock_acquire_recursive>
 800ed0a:	f9b5 200c 	ldrsh.w	r2, [r5, #12]
 800ed0e:	b293      	uxth	r3, r2
 800ed10:	e685      	b.n	800ea1e <_vfprintf_r+0x56>
 800ed12:	930b      	str	r3, [sp, #44]	; 0x2c
 800ed14:	2b00      	cmp	r3, #0
 800ed16:	d0a9      	beq.n	800ec6c <_vfprintf_r+0x2a4>
 800ed18:	2100      	movs	r1, #0
 800ed1a:	f88d 30dc 	strb.w	r3, [sp, #220]	; 0xdc
 800ed1e:	2301      	movs	r3, #1
 800ed20:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
 800ed24:	9302      	str	r3, [sp, #8]
 800ed26:	9107      	str	r1, [sp, #28]
 800ed28:	9305      	str	r3, [sp, #20]
 800ed2a:	9103      	str	r1, [sp, #12]
 800ed2c:	910d      	str	r1, [sp, #52]	; 0x34
 800ed2e:	910f      	str	r1, [sp, #60]	; 0x3c
 800ed30:	910c      	str	r1, [sp, #48]	; 0x30
 800ed32:	af37      	add	r7, sp, #220	; 0xdc
 800ed34:	f016 0302 	ands.w	r3, r6, #2
 800ed38:	9309      	str	r3, [sp, #36]	; 0x24
 800ed3a:	d002      	beq.n	800ed42 <_vfprintf_r+0x37a>
 800ed3c:	9b02      	ldr	r3, [sp, #8]
 800ed3e:	3302      	adds	r3, #2
 800ed40:	9302      	str	r3, [sp, #8]
 800ed42:	f016 0384 	ands.w	r3, r6, #132	; 0x84
 800ed46:	930a      	str	r3, [sp, #40]	; 0x28
 800ed48:	d105      	bne.n	800ed56 <_vfprintf_r+0x38e>
 800ed4a:	9b06      	ldr	r3, [sp, #24]
 800ed4c:	9a02      	ldr	r2, [sp, #8]
 800ed4e:	1a9c      	subs	r4, r3, r2
 800ed50:	2c00      	cmp	r4, #0
 800ed52:	f300 835b 	bgt.w	800f40c <_vfprintf_r+0xa44>
 800ed56:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800ed58:	b189      	cbz	r1, 800ed7e <_vfprintf_r+0x3b6>
 800ed5a:	9925      	ldr	r1, [sp, #148]	; 0x94
 800ed5c:	f10d 0067 	add.w	r0, sp, #103	; 0x67
 800ed60:	3101      	adds	r1, #1
 800ed62:	3201      	adds	r2, #1
 800ed64:	f8c8 0000 	str.w	r0, [r8]
 800ed68:	2907      	cmp	r1, #7
 800ed6a:	f04f 0001 	mov.w	r0, #1
 800ed6e:	9226      	str	r2, [sp, #152]	; 0x98
 800ed70:	9125      	str	r1, [sp, #148]	; 0x94
 800ed72:	f8c8 0004 	str.w	r0, [r8, #4]
 800ed76:	f300 8393 	bgt.w	800f4a0 <_vfprintf_r+0xad8>
 800ed7a:	f108 0808 	add.w	r8, r8, #8
 800ed7e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ed80:	b183      	cbz	r3, 800eda4 <_vfprintf_r+0x3dc>
 800ed82:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800ed84:	a91a      	add	r1, sp, #104	; 0x68
 800ed86:	3301      	adds	r3, #1
 800ed88:	3202      	adds	r2, #2
 800ed8a:	f8c8 1000 	str.w	r1, [r8]
 800ed8e:	2b07      	cmp	r3, #7
 800ed90:	f04f 0102 	mov.w	r1, #2
 800ed94:	9226      	str	r2, [sp, #152]	; 0x98
 800ed96:	9325      	str	r3, [sp, #148]	; 0x94
 800ed98:	f8c8 1004 	str.w	r1, [r8, #4]
 800ed9c:	f300 838d 	bgt.w	800f4ba <_vfprintf_r+0xaf2>
 800eda0:	f108 0808 	add.w	r8, r8, #8
 800eda4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800eda6:	2b80      	cmp	r3, #128	; 0x80
 800eda8:	f000 8265 	beq.w	800f276 <_vfprintf_r+0x8ae>
 800edac:	9b03      	ldr	r3, [sp, #12]
 800edae:	9905      	ldr	r1, [sp, #20]
 800edb0:	1a5c      	subs	r4, r3, r1
 800edb2:	2c00      	cmp	r4, #0
 800edb4:	f300 829f 	bgt.w	800f2f6 <_vfprintf_r+0x92e>
 800edb8:	05f4      	lsls	r4, r6, #23
 800edba:	f100 8206 	bmi.w	800f1ca <_vfprintf_r+0x802>
 800edbe:	9b05      	ldr	r3, [sp, #20]
 800edc0:	f8c8 3004 	str.w	r3, [r8, #4]
 800edc4:	441a      	add	r2, r3
 800edc6:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800edc8:	f8c8 7000 	str.w	r7, [r8]
 800edcc:	3301      	adds	r3, #1
 800edce:	2b07      	cmp	r3, #7
 800edd0:	9226      	str	r2, [sp, #152]	; 0x98
 800edd2:	9325      	str	r3, [sp, #148]	; 0x94
 800edd4:	f300 830d 	bgt.w	800f3f2 <_vfprintf_r+0xa2a>
 800edd8:	f108 0808 	add.w	r8, r8, #8
 800eddc:	0774      	lsls	r4, r6, #29
 800edde:	d505      	bpl.n	800edec <_vfprintf_r+0x424>
 800ede0:	9b06      	ldr	r3, [sp, #24]
 800ede2:	9902      	ldr	r1, [sp, #8]
 800ede4:	1a5c      	subs	r4, r3, r1
 800ede6:	2c00      	cmp	r4, #0
 800ede8:	f300 8374 	bgt.w	800f4d4 <_vfprintf_r+0xb0c>
 800edec:	9b04      	ldr	r3, [sp, #16]
 800edee:	9906      	ldr	r1, [sp, #24]
 800edf0:	9802      	ldr	r0, [sp, #8]
 800edf2:	4281      	cmp	r1, r0
 800edf4:	bfac      	ite	ge
 800edf6:	185b      	addge	r3, r3, r1
 800edf8:	181b      	addlt	r3, r3, r0
 800edfa:	9304      	str	r3, [sp, #16]
 800edfc:	2a00      	cmp	r2, #0
 800edfe:	f47f af4a 	bne.w	800ec96 <_vfprintf_r+0x2ce>
 800ee02:	2300      	movs	r3, #0
 800ee04:	9325      	str	r3, [sp, #148]	; 0x94
 800ee06:	9b07      	ldr	r3, [sp, #28]
 800ee08:	b11b      	cbz	r3, 800ee12 <_vfprintf_r+0x44a>
 800ee0a:	9907      	ldr	r1, [sp, #28]
 800ee0c:	4658      	mov	r0, fp
 800ee0e:	f004 f9b5 	bl	801317c <_free_r>
 800ee12:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800ee16:	464f      	mov	r7, r9
 800ee18:	e62c      	b.n	800ea74 <_vfprintf_r+0xac>
 800ee1a:	930b      	str	r3, [sp, #44]	; 0x2c
 800ee1c:	9b08      	ldr	r3, [sp, #32]
 800ee1e:	3307      	adds	r3, #7
 800ee20:	f023 0307 	bic.w	r3, r3, #7
 800ee24:	ecb3 8b02 	vldmia	r3!, {d8}
 800ee28:	eeb0 7bc8 	vabs.f64	d7, d8
 800ee2c:	eeb4 7b49 	vcmp.f64	d7, d9
 800ee30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ee34:	9308      	str	r3, [sp, #32]
 800ee36:	f340 84cd 	ble.w	800f7d4 <_vfprintf_r+0xe0c>
 800ee3a:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
 800ee3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ee42:	f101 810d 	bmi.w	8010060 <_vfprintf_r+0x1698>
 800ee46:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 800ee4a:	4fa9      	ldr	r7, [pc, #676]	; (800f0f0 <_vfprintf_r+0x728>)
 800ee4c:	4ba9      	ldr	r3, [pc, #676]	; (800f0f4 <_vfprintf_r+0x72c>)
 800ee4e:	f026 0680 	bic.w	r6, r6, #128	; 0x80
 800ee52:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ee54:	2a47      	cmp	r2, #71	; 0x47
 800ee56:	bfc8      	it	gt
 800ee58:	461f      	movgt	r7, r3
 800ee5a:	2300      	movs	r3, #0
 800ee5c:	2203      	movs	r2, #3
 800ee5e:	9307      	str	r3, [sp, #28]
 800ee60:	9202      	str	r2, [sp, #8]
 800ee62:	9205      	str	r2, [sp, #20]
 800ee64:	9303      	str	r3, [sp, #12]
 800ee66:	930d      	str	r3, [sp, #52]	; 0x34
 800ee68:	930f      	str	r3, [sp, #60]	; 0x3c
 800ee6a:	930c      	str	r3, [sp, #48]	; 0x30
 800ee6c:	2900      	cmp	r1, #0
 800ee6e:	f43f af61 	beq.w	800ed34 <_vfprintf_r+0x36c>
 800ee72:	9b02      	ldr	r3, [sp, #8]
 800ee74:	3301      	adds	r3, #1
 800ee76:	9302      	str	r3, [sp, #8]
 800ee78:	e75c      	b.n	800ed34 <_vfprintf_r+0x36c>
 800ee7a:	0598      	lsls	r0, r3, #22
 800ee7c:	f53f af26 	bmi.w	800eccc <_vfprintf_r+0x304>
 800ee80:	ee1b 4a10 	vmov	r4, s22
 800ee84:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800ee86:	f003 f9e1 	bl	801224c <__retarget_lock_release_recursive>
 800ee8a:	89a2      	ldrh	r2, [r4, #12]
 800ee8c:	e71e      	b.n	800eccc <_vfprintf_r+0x304>
 800ee8e:	f899 3000 	ldrb.w	r3, [r9]
 800ee92:	f046 0620 	orr.w	r6, r6, #32
 800ee96:	e618      	b.n	800eaca <_vfprintf_r+0x102>
 800ee98:	2b43      	cmp	r3, #67	; 0x43
 800ee9a:	930b      	str	r3, [sp, #44]	; 0x2c
 800ee9c:	f000 855f 	beq.w	800f95e <_vfprintf_r+0xf96>
 800eea0:	06f5      	lsls	r5, r6, #27
 800eea2:	f100 855c 	bmi.w	800f95e <_vfprintf_r+0xf96>
 800eea6:	9b08      	ldr	r3, [sp, #32]
 800eea8:	2101      	movs	r1, #1
 800eeaa:	f853 2b04 	ldr.w	r2, [r3], #4
 800eeae:	9102      	str	r1, [sp, #8]
 800eeb0:	f88d 20dc 	strb.w	r2, [sp, #220]	; 0xdc
 800eeb4:	9308      	str	r3, [sp, #32]
 800eeb6:	9105      	str	r1, [sp, #20]
 800eeb8:	af37      	add	r7, sp, #220	; 0xdc
 800eeba:	2100      	movs	r1, #0
 800eebc:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
 800eec0:	9107      	str	r1, [sp, #28]
 800eec2:	9103      	str	r1, [sp, #12]
 800eec4:	910d      	str	r1, [sp, #52]	; 0x34
 800eec6:	910f      	str	r1, [sp, #60]	; 0x3c
 800eec8:	910c      	str	r1, [sp, #48]	; 0x30
 800eeca:	e733      	b.n	800ed34 <_vfprintf_r+0x36c>
 800eecc:	930b      	str	r3, [sp, #44]	; 0x2c
 800eece:	9b08      	ldr	r3, [sp, #32]
 800eed0:	461a      	mov	r2, r3
 800eed2:	2300      	movs	r3, #0
 800eed4:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
 800eed8:	4613      	mov	r3, r2
 800eeda:	f853 7b04 	ldr.w	r7, [r3], #4
 800eede:	9308      	str	r3, [sp, #32]
 800eee0:	2f00      	cmp	r7, #0
 800eee2:	f000 852c 	beq.w	800f93e <_vfprintf_r+0xf76>
 800eee6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800eee8:	2b53      	cmp	r3, #83	; 0x53
 800eeea:	f000 860c 	beq.w	800fb06 <_vfprintf_r+0x113e>
 800eeee:	f016 0310 	ands.w	r3, r6, #16
 800eef2:	930c      	str	r3, [sp, #48]	; 0x30
 800eef4:	f040 8607 	bne.w	800fb06 <_vfprintf_r+0x113e>
 800eef8:	9b03      	ldr	r3, [sp, #12]
 800eefa:	1c5a      	adds	r2, r3, #1
 800eefc:	f001 8022 	beq.w	800ff44 <_vfprintf_r+0x157c>
 800ef00:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ef02:	461a      	mov	r2, r3
 800ef04:	4638      	mov	r0, r7
 800ef06:	f7f1 fd4b 	bl	80009a0 <memchr>
 800ef0a:	9007      	str	r0, [sp, #28]
 800ef0c:	2800      	cmp	r0, #0
 800ef0e:	f001 82a6 	beq.w	801045e <_vfprintf_r+0x1a96>
 800ef12:	9b07      	ldr	r3, [sp, #28]
 800ef14:	1bda      	subs	r2, r3, r7
 800ef16:	9205      	str	r2, [sp, #20]
 800ef18:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ef1a:	9303      	str	r3, [sp, #12]
 800ef1c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 800ef20:	930d      	str	r3, [sp, #52]	; 0x34
 800ef22:	930f      	str	r3, [sp, #60]	; 0x3c
 800ef24:	9307      	str	r3, [sp, #28]
 800ef26:	2373      	movs	r3, #115	; 0x73
 800ef28:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 800ef2c:	9202      	str	r2, [sp, #8]
 800ef2e:	930b      	str	r3, [sp, #44]	; 0x2c
 800ef30:	e79c      	b.n	800ee6c <_vfprintf_r+0x4a4>
 800ef32:	06b4      	lsls	r4, r6, #26
 800ef34:	930b      	str	r3, [sp, #44]	; 0x2c
 800ef36:	9b08      	ldr	r3, [sp, #32]
 800ef38:	f140 80ce 	bpl.w	800f0d8 <_vfprintf_r+0x710>
 800ef3c:	3307      	adds	r3, #7
 800ef3e:	f023 0307 	bic.w	r3, r3, #7
 800ef42:	461a      	mov	r2, r3
 800ef44:	4611      	mov	r1, r2
 800ef46:	685b      	ldr	r3, [r3, #4]
 800ef48:	f851 2b08 	ldr.w	r2, [r1], #8
 800ef4c:	9108      	str	r1, [sp, #32]
 800ef4e:	4619      	mov	r1, r3
 800ef50:	2b00      	cmp	r3, #0
 800ef52:	f2c0 8429 	blt.w	800f7a8 <_vfprintf_r+0xde0>
 800ef56:	9b03      	ldr	r3, [sp, #12]
 800ef58:	3301      	adds	r3, #1
 800ef5a:	f000 8292 	beq.w	800f482 <_vfprintf_r+0xaba>
 800ef5e:	f026 0680 	bic.w	r6, r6, #128	; 0x80
 800ef62:	ea52 0301 	orrs.w	r3, r2, r1
 800ef66:	9602      	str	r6, [sp, #8]
 800ef68:	f040 828c 	bne.w	800f484 <_vfprintf_r+0xabc>
 800ef6c:	9b03      	ldr	r3, [sp, #12]
 800ef6e:	2b00      	cmp	r3, #0
 800ef70:	f040 828d 	bne.w	800f48e <_vfprintf_r+0xac6>
 800ef74:	2300      	movs	r3, #0
 800ef76:	9303      	str	r3, [sp, #12]
 800ef78:	9305      	str	r3, [sp, #20]
 800ef7a:	af50      	add	r7, sp, #320	; 0x140
 800ef7c:	e0fa      	b.n	800f174 <_vfprintf_r+0x7ac>
 800ef7e:	9b08      	ldr	r3, [sp, #32]
 800ef80:	f853 2b04 	ldr.w	r2, [r3], #4
 800ef84:	9206      	str	r2, [sp, #24]
 800ef86:	2a00      	cmp	r2, #0
 800ef88:	f280 83d4 	bge.w	800f734 <_vfprintf_r+0xd6c>
 800ef8c:	9a06      	ldr	r2, [sp, #24]
 800ef8e:	9308      	str	r3, [sp, #32]
 800ef90:	4252      	negs	r2, r2
 800ef92:	9206      	str	r2, [sp, #24]
 800ef94:	f899 3000 	ldrb.w	r3, [r9]
 800ef98:	f046 0604 	orr.w	r6, r6, #4
 800ef9c:	e595      	b.n	800eaca <_vfprintf_r+0x102>
 800ef9e:	f899 3000 	ldrb.w	r3, [r9]
 800efa2:	2b6c      	cmp	r3, #108	; 0x6c
 800efa4:	bf03      	ittte	eq
 800efa6:	f899 3001 	ldrbeq.w	r3, [r9, #1]
 800efaa:	f046 0620 	orreq.w	r6, r6, #32
 800efae:	f109 0901 	addeq.w	r9, r9, #1
 800efb2:	f046 0610 	orrne.w	r6, r6, #16
 800efb6:	e588      	b.n	800eaca <_vfprintf_r+0x102>
 800efb8:	f899 3000 	ldrb.w	r3, [r9]
 800efbc:	2b68      	cmp	r3, #104	; 0x68
 800efbe:	bf03      	ittte	eq
 800efc0:	f899 3001 	ldrbeq.w	r3, [r9, #1]
 800efc4:	f446 7600 	orreq.w	r6, r6, #512	; 0x200
 800efc8:	f109 0901 	addeq.w	r9, r9, #1
 800efcc:	f046 0640 	orrne.w	r6, r6, #64	; 0x40
 800efd0:	e57b      	b.n	800eaca <_vfprintf_r+0x102>
 800efd2:	f899 3000 	ldrb.w	r3, [r9]
 800efd6:	f88d 4067 	strb.w	r4, [sp, #103]	; 0x67
 800efda:	e576      	b.n	800eaca <_vfprintf_r+0x102>
 800efdc:	f899 3000 	ldrb.w	r3, [r9]
 800efe0:	f046 0680 	orr.w	r6, r6, #128	; 0x80
 800efe4:	e571      	b.n	800eaca <_vfprintf_r+0x102>
 800efe6:	4649      	mov	r1, r9
 800efe8:	f811 3b01 	ldrb.w	r3, [r1], #1
 800efec:	2b2a      	cmp	r3, #42	; 0x2a
 800efee:	f001 82b6 	beq.w	801055e <_vfprintf_r+0x1b96>
 800eff2:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800eff6:	2a09      	cmp	r2, #9
 800eff8:	4689      	mov	r9, r1
 800effa:	bf98      	it	ls
 800effc:	2100      	movls	r1, #0
 800effe:	f201 8160 	bhi.w	80102c2 <_vfprintf_r+0x18fa>
 800f002:	f819 3b01 	ldrb.w	r3, [r9], #1
 800f006:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 800f00a:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800f00e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800f012:	2a09      	cmp	r2, #9
 800f014:	d9f5      	bls.n	800f002 <_vfprintf_r+0x63a>
 800f016:	9103      	str	r1, [sp, #12]
 800f018:	e559      	b.n	800eace <_vfprintf_r+0x106>
 800f01a:	f899 3000 	ldrb.w	r3, [r9]
 800f01e:	f046 0601 	orr.w	r6, r6, #1
 800f022:	e552      	b.n	800eaca <_vfprintf_r+0x102>
 800f024:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
 800f028:	2b00      	cmp	r3, #0
 800f02a:	f47f add3 	bne.w	800ebd4 <_vfprintf_r+0x20c>
 800f02e:	f899 3000 	ldrb.w	r3, [r9]
 800f032:	f88d 5067 	strb.w	r5, [sp, #103]	; 0x67
 800f036:	e548      	b.n	800eaca <_vfprintf_r+0x102>
 800f038:	930b      	str	r3, [sp, #44]	; 0x2c
 800f03a:	f046 0610 	orr.w	r6, r6, #16
 800f03e:	f016 0120 	ands.w	r1, r6, #32
 800f042:	f000 834e 	beq.w	800f6e2 <_vfprintf_r+0xd1a>
 800f046:	9b08      	ldr	r3, [sp, #32]
 800f048:	3307      	adds	r3, #7
 800f04a:	f023 0307 	bic.w	r3, r3, #7
 800f04e:	6859      	ldr	r1, [r3, #4]
 800f050:	f853 2b08 	ldr.w	r2, [r3], #8
 800f054:	9308      	str	r3, [sp, #32]
 800f056:	f426 6380 	bic.w	r3, r6, #1024	; 0x400
 800f05a:	9302      	str	r3, [sp, #8]
 800f05c:	2300      	movs	r3, #0
 800f05e:	2000      	movs	r0, #0
 800f060:	9c03      	ldr	r4, [sp, #12]
 800f062:	f88d 0067 	strb.w	r0, [sp, #103]	; 0x67
 800f066:	1c66      	adds	r6, r4, #1
 800f068:	d06d      	beq.n	800f146 <_vfprintf_r+0x77e>
 800f06a:	9802      	ldr	r0, [sp, #8]
 800f06c:	f020 0680 	bic.w	r6, r0, #128	; 0x80
 800f070:	ea52 0001 	orrs.w	r0, r2, r1
 800f074:	d166      	bne.n	800f144 <_vfprintf_r+0x77c>
 800f076:	2c00      	cmp	r4, #0
 800f078:	f040 85a9 	bne.w	800fbce <_vfprintf_r+0x1206>
 800f07c:	2b00      	cmp	r3, #0
 800f07e:	f47f af79 	bne.w	800ef74 <_vfprintf_r+0x5ac>
 800f082:	9b02      	ldr	r3, [sp, #8]
 800f084:	f013 0301 	ands.w	r3, r3, #1
 800f088:	9305      	str	r3, [sp, #20]
 800f08a:	f000 8380 	beq.w	800f78e <_vfprintf_r+0xdc6>
 800f08e:	2330      	movs	r3, #48	; 0x30
 800f090:	f88d 313f 	strb.w	r3, [sp, #319]	; 0x13f
 800f094:	f20d 173f 	addw	r7, sp, #319	; 0x13f
 800f098:	e06c      	b.n	800f174 <_vfprintf_r+0x7ac>
 800f09a:	930b      	str	r3, [sp, #44]	; 0x2c
 800f09c:	f046 0310 	orr.w	r3, r6, #16
 800f0a0:	9302      	str	r3, [sp, #8]
 800f0a2:	9b02      	ldr	r3, [sp, #8]
 800f0a4:	f013 0120 	ands.w	r1, r3, #32
 800f0a8:	f000 832e 	beq.w	800f708 <_vfprintf_r+0xd40>
 800f0ac:	9b08      	ldr	r3, [sp, #32]
 800f0ae:	3307      	adds	r3, #7
 800f0b0:	f023 0307 	bic.w	r3, r3, #7
 800f0b4:	6859      	ldr	r1, [r3, #4]
 800f0b6:	f853 2b08 	ldr.w	r2, [r3], #8
 800f0ba:	9308      	str	r3, [sp, #32]
 800f0bc:	2301      	movs	r3, #1
 800f0be:	e7ce      	b.n	800f05e <_vfprintf_r+0x696>
 800f0c0:	f899 3000 	ldrb.w	r3, [r9]
 800f0c4:	f046 0608 	orr.w	r6, r6, #8
 800f0c8:	e4ff      	b.n	800eaca <_vfprintf_r+0x102>
 800f0ca:	f046 0610 	orr.w	r6, r6, #16
 800f0ce:	06b4      	lsls	r4, r6, #26
 800f0d0:	930b      	str	r3, [sp, #44]	; 0x2c
 800f0d2:	9b08      	ldr	r3, [sp, #32]
 800f0d4:	f53f af32 	bmi.w	800ef3c <_vfprintf_r+0x574>
 800f0d8:	06f0      	lsls	r0, r6, #27
 800f0da:	f100 835d 	bmi.w	800f798 <_vfprintf_r+0xdd0>
 800f0de:	0671      	lsls	r1, r6, #25
 800f0e0:	f140 8357 	bpl.w	800f792 <_vfprintf_r+0xdca>
 800f0e4:	f933 2b04 	ldrsh.w	r2, [r3], #4
 800f0e8:	9308      	str	r3, [sp, #32]
 800f0ea:	17d1      	asrs	r1, r2, #31
 800f0ec:	460b      	mov	r3, r1
 800f0ee:	e72f      	b.n	800ef50 <_vfprintf_r+0x588>
 800f0f0:	080159ec 	.word	0x080159ec
 800f0f4:	080159f0 	.word	0x080159f0
 800f0f8:	9b08      	ldr	r3, [sp, #32]
 800f0fa:	f046 0202 	orr.w	r2, r6, #2
 800f0fe:	9202      	str	r2, [sp, #8]
 800f100:	f853 2b04 	ldr.w	r2, [r3], #4
 800f104:	9308      	str	r3, [sp, #32]
 800f106:	f647 0330 	movw	r3, #30768	; 0x7830
 800f10a:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
 800f10e:	2078      	movs	r0, #120	; 0x78
 800f110:	4b93      	ldr	r3, [pc, #588]	; (800f360 <_vfprintf_r+0x998>)
 800f112:	9312      	str	r3, [sp, #72]	; 0x48
 800f114:	2100      	movs	r1, #0
 800f116:	2302      	movs	r3, #2
 800f118:	900b      	str	r0, [sp, #44]	; 0x2c
 800f11a:	e7a0      	b.n	800f05e <_vfprintf_r+0x696>
 800f11c:	06b3      	lsls	r3, r6, #26
 800f11e:	f100 83b6 	bmi.w	800f88e <_vfprintf_r+0xec6>
 800f122:	06f7      	lsls	r7, r6, #27
 800f124:	f100 8558 	bmi.w	800fbd8 <_vfprintf_r+0x1210>
 800f128:	0675      	lsls	r5, r6, #25
 800f12a:	f100 8693 	bmi.w	800fe54 <_vfprintf_r+0x148c>
 800f12e:	05b4      	lsls	r4, r6, #22
 800f130:	f140 8552 	bpl.w	800fbd8 <_vfprintf_r+0x1210>
 800f134:	9b08      	ldr	r3, [sp, #32]
 800f136:	9904      	ldr	r1, [sp, #16]
 800f138:	f853 2b04 	ldr.w	r2, [r3], #4
 800f13c:	9308      	str	r3, [sp, #32]
 800f13e:	7011      	strb	r1, [r2, #0]
 800f140:	464f      	mov	r7, r9
 800f142:	e497      	b.n	800ea74 <_vfprintf_r+0xac>
 800f144:	9602      	str	r6, [sp, #8]
 800f146:	2b01      	cmp	r3, #1
 800f148:	f000 819c 	beq.w	800f484 <_vfprintf_r+0xabc>
 800f14c:	2b02      	cmp	r3, #2
 800f14e:	af50      	add	r7, sp, #320	; 0x140
 800f150:	d11f      	bne.n	800f192 <_vfprintf_r+0x7ca>
 800f152:	9812      	ldr	r0, [sp, #72]	; 0x48
 800f154:	f002 030f 	and.w	r3, r2, #15
 800f158:	0912      	lsrs	r2, r2, #4
 800f15a:	5cc3      	ldrb	r3, [r0, r3]
 800f15c:	f807 3d01 	strb.w	r3, [r7, #-1]!
 800f160:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 800f164:	0909      	lsrs	r1, r1, #4
 800f166:	ea52 0301 	orrs.w	r3, r2, r1
 800f16a:	d1f3      	bne.n	800f154 <_vfprintf_r+0x78c>
 800f16c:	9e02      	ldr	r6, [sp, #8]
 800f16e:	ab50      	add	r3, sp, #320	; 0x140
 800f170:	1bdb      	subs	r3, r3, r7
 800f172:	9305      	str	r3, [sp, #20]
 800f174:	9a05      	ldr	r2, [sp, #20]
 800f176:	9803      	ldr	r0, [sp, #12]
 800f178:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 800f17c:	4282      	cmp	r2, r0
 800f17e:	f04f 0300 	mov.w	r3, #0
 800f182:	bfb8      	it	lt
 800f184:	4602      	movlt	r2, r0
 800f186:	9307      	str	r3, [sp, #28]
 800f188:	9202      	str	r2, [sp, #8]
 800f18a:	930d      	str	r3, [sp, #52]	; 0x34
 800f18c:	930f      	str	r3, [sp, #60]	; 0x3c
 800f18e:	930c      	str	r3, [sp, #48]	; 0x30
 800f190:	e66c      	b.n	800ee6c <_vfprintf_r+0x4a4>
 800f192:	f002 0307 	and.w	r3, r2, #7
 800f196:	08d2      	lsrs	r2, r2, #3
 800f198:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
 800f19c:	08c9      	lsrs	r1, r1, #3
 800f19e:	3330      	adds	r3, #48	; 0x30
 800f1a0:	ea52 0401 	orrs.w	r4, r2, r1
 800f1a4:	4638      	mov	r0, r7
 800f1a6:	f807 3d01 	strb.w	r3, [r7, #-1]!
 800f1aa:	d1f2      	bne.n	800f192 <_vfprintf_r+0x7ca>
 800f1ac:	9e02      	ldr	r6, [sp, #8]
 800f1ae:	07f5      	lsls	r5, r6, #31
 800f1b0:	d5dd      	bpl.n	800f16e <_vfprintf_r+0x7a6>
 800f1b2:	2b30      	cmp	r3, #48	; 0x30
 800f1b4:	d0da      	beq.n	800f16c <_vfprintf_r+0x7a4>
 800f1b6:	2330      	movs	r3, #48	; 0x30
 800f1b8:	3802      	subs	r0, #2
 800f1ba:	f807 3c01 	strb.w	r3, [r7, #-1]
 800f1be:	ab50      	add	r3, sp, #320	; 0x140
 800f1c0:	1a1b      	subs	r3, r3, r0
 800f1c2:	9e02      	ldr	r6, [sp, #8]
 800f1c4:	9305      	str	r3, [sp, #20]
 800f1c6:	4607      	mov	r7, r0
 800f1c8:	e7d4      	b.n	800f174 <_vfprintf_r+0x7ac>
 800f1ca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f1cc:	2b65      	cmp	r3, #101	; 0x65
 800f1ce:	f340 80cd 	ble.w	800f36c <_vfprintf_r+0x9a4>
 800f1d2:	eeb5 8b40 	vcmp.f64	d8, #0.0
 800f1d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f1da:	f040 81b3 	bne.w	800f544 <_vfprintf_r+0xb7c>
 800f1de:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f1e0:	4960      	ldr	r1, [pc, #384]	; (800f364 <_vfprintf_r+0x99c>)
 800f1e2:	f8c8 1000 	str.w	r1, [r8]
 800f1e6:	3301      	adds	r3, #1
 800f1e8:	3201      	adds	r2, #1
 800f1ea:	2101      	movs	r1, #1
 800f1ec:	2b07      	cmp	r3, #7
 800f1ee:	9226      	str	r2, [sp, #152]	; 0x98
 800f1f0:	9325      	str	r3, [sp, #148]	; 0x94
 800f1f2:	f8c8 1004 	str.w	r1, [r8, #4]
 800f1f6:	f300 8478 	bgt.w	800faea <_vfprintf_r+0x1122>
 800f1fa:	f108 0808 	add.w	r8, r8, #8
 800f1fe:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800f200:	990e      	ldr	r1, [sp, #56]	; 0x38
 800f202:	428b      	cmp	r3, r1
 800f204:	f280 8292 	bge.w	800f72c <_vfprintf_r+0xd64>
 800f208:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800f20a:	9911      	ldr	r1, [sp, #68]	; 0x44
 800f20c:	441a      	add	r2, r3
 800f20e:	e9c8 1300 	strd	r1, r3, [r8]
 800f212:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f214:	9226      	str	r2, [sp, #152]	; 0x98
 800f216:	3301      	adds	r3, #1
 800f218:	2b07      	cmp	r3, #7
 800f21a:	9325      	str	r3, [sp, #148]	; 0x94
 800f21c:	f300 8382 	bgt.w	800f924 <_vfprintf_r+0xf5c>
 800f220:	f108 0808 	add.w	r8, r8, #8
 800f224:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f226:	1e5c      	subs	r4, r3, #1
 800f228:	2c00      	cmp	r4, #0
 800f22a:	f77f add7 	ble.w	800eddc <_vfprintf_r+0x414>
 800f22e:	2c10      	cmp	r4, #16
 800f230:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f232:	f340 84bf 	ble.w	800fbb4 <_vfprintf_r+0x11ec>
 800f236:	ee1b 7a10 	vmov	r7, s22
 800f23a:	2510      	movs	r5, #16
 800f23c:	e005      	b.n	800f24a <_vfprintf_r+0x882>
 800f23e:	f108 0808 	add.w	r8, r8, #8
 800f242:	3c10      	subs	r4, #16
 800f244:	2c10      	cmp	r4, #16
 800f246:	f340 84b5 	ble.w	800fbb4 <_vfprintf_r+0x11ec>
 800f24a:	3301      	adds	r3, #1
 800f24c:	4946      	ldr	r1, [pc, #280]	; (800f368 <_vfprintf_r+0x9a0>)
 800f24e:	3210      	adds	r2, #16
 800f250:	2b07      	cmp	r3, #7
 800f252:	e9c8 1500 	strd	r1, r5, [r8]
 800f256:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f25a:	ddf0      	ble.n	800f23e <_vfprintf_r+0x876>
 800f25c:	aa24      	add	r2, sp, #144	; 0x90
 800f25e:	4639      	mov	r1, r7
 800f260:	4658      	mov	r0, fp
 800f262:	f001 fa17 	bl	8010694 <__sprint_r>
 800f266:	2800      	cmp	r0, #0
 800f268:	f47f ad1e 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f26c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f270:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f274:	e7e5      	b.n	800f242 <_vfprintf_r+0x87a>
 800f276:	9b06      	ldr	r3, [sp, #24]
 800f278:	9902      	ldr	r1, [sp, #8]
 800f27a:	1a5c      	subs	r4, r3, r1
 800f27c:	2c00      	cmp	r4, #0
 800f27e:	f77f ad95 	ble.w	800edac <_vfprintf_r+0x3e4>
 800f282:	2c10      	cmp	r4, #16
 800f284:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f286:	dd22      	ble.n	800f2ce <_vfprintf_r+0x906>
 800f288:	9609      	str	r6, [sp, #36]	; 0x24
 800f28a:	2510      	movs	r5, #16
 800f28c:	ee1b 6a10 	vmov	r6, s22
 800f290:	e004      	b.n	800f29c <_vfprintf_r+0x8d4>
 800f292:	3c10      	subs	r4, #16
 800f294:	2c10      	cmp	r4, #16
 800f296:	f108 0808 	add.w	r8, r8, #8
 800f29a:	dd17      	ble.n	800f2cc <_vfprintf_r+0x904>
 800f29c:	3301      	adds	r3, #1
 800f29e:	4932      	ldr	r1, [pc, #200]	; (800f368 <_vfprintf_r+0x9a0>)
 800f2a0:	3210      	adds	r2, #16
 800f2a2:	2b07      	cmp	r3, #7
 800f2a4:	e9c8 1500 	strd	r1, r5, [r8]
 800f2a8:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f2ac:	ddf1      	ble.n	800f292 <_vfprintf_r+0x8ca>
 800f2ae:	aa24      	add	r2, sp, #144	; 0x90
 800f2b0:	4631      	mov	r1, r6
 800f2b2:	4658      	mov	r0, fp
 800f2b4:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f2b8:	f001 f9ec 	bl	8010694 <__sprint_r>
 800f2bc:	2800      	cmp	r0, #0
 800f2be:	f47f acf3 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f2c2:	3c10      	subs	r4, #16
 800f2c4:	2c10      	cmp	r4, #16
 800f2c6:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f2ca:	dce7      	bgt.n	800f29c <_vfprintf_r+0x8d4>
 800f2cc:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800f2ce:	4926      	ldr	r1, [pc, #152]	; (800f368 <_vfprintf_r+0x9a0>)
 800f2d0:	f8c8 4004 	str.w	r4, [r8, #4]
 800f2d4:	3301      	adds	r3, #1
 800f2d6:	4422      	add	r2, r4
 800f2d8:	2b07      	cmp	r3, #7
 800f2da:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f2de:	f8c8 1000 	str.w	r1, [r8]
 800f2e2:	f300 8311 	bgt.w	800f908 <_vfprintf_r+0xf40>
 800f2e6:	9b03      	ldr	r3, [sp, #12]
 800f2e8:	9905      	ldr	r1, [sp, #20]
 800f2ea:	1a5c      	subs	r4, r3, r1
 800f2ec:	2c00      	cmp	r4, #0
 800f2ee:	f108 0808 	add.w	r8, r8, #8
 800f2f2:	f77f ad61 	ble.w	800edb8 <_vfprintf_r+0x3f0>
 800f2f6:	2c10      	cmp	r4, #16
 800f2f8:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f2fa:	dd21      	ble.n	800f340 <_vfprintf_r+0x978>
 800f2fc:	4641      	mov	r1, r8
 800f2fe:	2510      	movs	r5, #16
 800f300:	ee1b 8a10 	vmov	r8, s22
 800f304:	e004      	b.n	800f310 <_vfprintf_r+0x948>
 800f306:	3c10      	subs	r4, #16
 800f308:	2c10      	cmp	r4, #16
 800f30a:	f101 0108 	add.w	r1, r1, #8
 800f30e:	dd16      	ble.n	800f33e <_vfprintf_r+0x976>
 800f310:	3301      	adds	r3, #1
 800f312:	4815      	ldr	r0, [pc, #84]	; (800f368 <_vfprintf_r+0x9a0>)
 800f314:	3210      	adds	r2, #16
 800f316:	2b07      	cmp	r3, #7
 800f318:	e9c1 0500 	strd	r0, r5, [r1]
 800f31c:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f320:	ddf1      	ble.n	800f306 <_vfprintf_r+0x93e>
 800f322:	aa24      	add	r2, sp, #144	; 0x90
 800f324:	4641      	mov	r1, r8
 800f326:	4658      	mov	r0, fp
 800f328:	f001 f9b4 	bl	8010694 <__sprint_r>
 800f32c:	2800      	cmp	r0, #0
 800f32e:	f47f acbb 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f332:	3c10      	subs	r4, #16
 800f334:	2c10      	cmp	r4, #16
 800f336:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f33a:	a927      	add	r1, sp, #156	; 0x9c
 800f33c:	dce8      	bgt.n	800f310 <_vfprintf_r+0x948>
 800f33e:	4688      	mov	r8, r1
 800f340:	3301      	adds	r3, #1
 800f342:	4909      	ldr	r1, [pc, #36]	; (800f368 <_vfprintf_r+0x9a0>)
 800f344:	f8c8 4004 	str.w	r4, [r8, #4]
 800f348:	4422      	add	r2, r4
 800f34a:	2b07      	cmp	r3, #7
 800f34c:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f350:	f8c8 1000 	str.w	r1, [r8]
 800f354:	f300 81b7 	bgt.w	800f6c6 <_vfprintf_r+0xcfe>
 800f358:	f108 0808 	add.w	r8, r8, #8
 800f35c:	e52c      	b.n	800edb8 <_vfprintf_r+0x3f0>
 800f35e:	bf00      	nop
 800f360:	080159fc 	.word	0x080159fc
 800f364:	08015a2c 	.word	0x08015a2c
 800f368:	08015a40 	.word	0x08015a40
 800f36c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f36e:	2b01      	cmp	r3, #1
 800f370:	f340 8163 	ble.w	800f63a <_vfprintf_r+0xc72>
 800f374:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f376:	f8c8 7000 	str.w	r7, [r8]
 800f37a:	3301      	adds	r3, #1
 800f37c:	3201      	adds	r2, #1
 800f37e:	2101      	movs	r1, #1
 800f380:	2b07      	cmp	r3, #7
 800f382:	9226      	str	r2, [sp, #152]	; 0x98
 800f384:	9325      	str	r3, [sp, #148]	; 0x94
 800f386:	f8c8 1004 	str.w	r1, [r8, #4]
 800f38a:	f300 8319 	bgt.w	800f9c0 <_vfprintf_r+0xff8>
 800f38e:	f108 0808 	add.w	r8, r8, #8
 800f392:	9910      	ldr	r1, [sp, #64]	; 0x40
 800f394:	9811      	ldr	r0, [sp, #68]	; 0x44
 800f396:	3301      	adds	r3, #1
 800f398:	440a      	add	r2, r1
 800f39a:	2b07      	cmp	r3, #7
 800f39c:	e9c8 0100 	strd	r0, r1, [r8]
 800f3a0:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f3a4:	f300 82fe 	bgt.w	800f9a4 <_vfprintf_r+0xfdc>
 800f3a8:	f108 0808 	add.w	r8, r8, #8
 800f3ac:	eeb5 8b40 	vcmp.f64	d8, #0.0
 800f3b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f3b4:	f000 815f 	beq.w	800f676 <_vfprintf_r+0xcae>
 800f3b8:	990e      	ldr	r1, [sp, #56]	; 0x38
 800f3ba:	3301      	adds	r3, #1
 800f3bc:	3901      	subs	r1, #1
 800f3be:	3701      	adds	r7, #1
 800f3c0:	440a      	add	r2, r1
 800f3c2:	2b07      	cmp	r3, #7
 800f3c4:	f8c8 7000 	str.w	r7, [r8]
 800f3c8:	9325      	str	r3, [sp, #148]	; 0x94
 800f3ca:	f8c8 1004 	str.w	r1, [r8, #4]
 800f3ce:	9226      	str	r2, [sp, #152]	; 0x98
 800f3d0:	f300 8143 	bgt.w	800f65a <_vfprintf_r+0xc92>
 800f3d4:	f108 0808 	add.w	r8, r8, #8
 800f3d8:	9914      	ldr	r1, [sp, #80]	; 0x50
 800f3da:	f8c8 1004 	str.w	r1, [r8, #4]
 800f3de:	3301      	adds	r3, #1
 800f3e0:	440a      	add	r2, r1
 800f3e2:	2b07      	cmp	r3, #7
 800f3e4:	a91e      	add	r1, sp, #120	; 0x78
 800f3e6:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f3ea:	f8c8 1000 	str.w	r1, [r8]
 800f3ee:	f77f acf3 	ble.w	800edd8 <_vfprintf_r+0x410>
 800f3f2:	ee1b 1a10 	vmov	r1, s22
 800f3f6:	aa24      	add	r2, sp, #144	; 0x90
 800f3f8:	4658      	mov	r0, fp
 800f3fa:	f001 f94b 	bl	8010694 <__sprint_r>
 800f3fe:	2800      	cmp	r0, #0
 800f400:	f47f ac52 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f404:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800f406:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f40a:	e4e7      	b.n	800eddc <_vfprintf_r+0x414>
 800f40c:	2c10      	cmp	r4, #16
 800f40e:	e9dd 1225 	ldrd	r1, r2, [sp, #148]	; 0x94
 800f412:	4dbb      	ldr	r5, [pc, #748]	; (800f700 <_vfprintf_r+0xd38>)
 800f414:	dd25      	ble.n	800f462 <_vfprintf_r+0xa9a>
 800f416:	9617      	str	r6, [sp, #92]	; 0x5c
 800f418:	2310      	movs	r3, #16
 800f41a:	ee1b 6a10 	vmov	r6, s22
 800f41e:	4608      	mov	r0, r1
 800f420:	e004      	b.n	800f42c <_vfprintf_r+0xa64>
 800f422:	3c10      	subs	r4, #16
 800f424:	2c10      	cmp	r4, #16
 800f426:	f108 0808 	add.w	r8, r8, #8
 800f42a:	dd18      	ble.n	800f45e <_vfprintf_r+0xa96>
 800f42c:	3001      	adds	r0, #1
 800f42e:	3210      	adds	r2, #16
 800f430:	2807      	cmp	r0, #7
 800f432:	e9c8 5300 	strd	r5, r3, [r8]
 800f436:	e9cd 0225 	strd	r0, r2, [sp, #148]	; 0x94
 800f43a:	ddf2      	ble.n	800f422 <_vfprintf_r+0xa5a>
 800f43c:	aa24      	add	r2, sp, #144	; 0x90
 800f43e:	4631      	mov	r1, r6
 800f440:	4658      	mov	r0, fp
 800f442:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f446:	f001 f925 	bl	8010694 <__sprint_r>
 800f44a:	2800      	cmp	r0, #0
 800f44c:	f47f ac2c 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f450:	3c10      	subs	r4, #16
 800f452:	2c10      	cmp	r4, #16
 800f454:	e9dd 0225 	ldrd	r0, r2, [sp, #148]	; 0x94
 800f458:	f04f 0310 	mov.w	r3, #16
 800f45c:	dce6      	bgt.n	800f42c <_vfprintf_r+0xa64>
 800f45e:	9e17      	ldr	r6, [sp, #92]	; 0x5c
 800f460:	4601      	mov	r1, r0
 800f462:	3101      	adds	r1, #1
 800f464:	4422      	add	r2, r4
 800f466:	2907      	cmp	r1, #7
 800f468:	e9cd 1225 	strd	r1, r2, [sp, #148]	; 0x94
 800f46c:	f8c8 5000 	str.w	r5, [r8]
 800f470:	f8c8 4004 	str.w	r4, [r8, #4]
 800f474:	f300 8319 	bgt.w	800faaa <_vfprintf_r+0x10e2>
 800f478:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 800f47c:	f108 0808 	add.w	r8, r8, #8
 800f480:	e46a      	b.n	800ed58 <_vfprintf_r+0x390>
 800f482:	9602      	str	r6, [sp, #8]
 800f484:	2a0a      	cmp	r2, #10
 800f486:	f171 0300 	sbcs.w	r3, r1, #0
 800f48a:	f080 82af 	bcs.w	800f9ec <_vfprintf_r+0x1024>
 800f48e:	3230      	adds	r2, #48	; 0x30
 800f490:	2301      	movs	r3, #1
 800f492:	9e02      	ldr	r6, [sp, #8]
 800f494:	f88d 213f 	strb.w	r2, [sp, #319]	; 0x13f
 800f498:	9305      	str	r3, [sp, #20]
 800f49a:	f20d 173f 	addw	r7, sp, #319	; 0x13f
 800f49e:	e669      	b.n	800f174 <_vfprintf_r+0x7ac>
 800f4a0:	ee1b 1a10 	vmov	r1, s22
 800f4a4:	aa24      	add	r2, sp, #144	; 0x90
 800f4a6:	4658      	mov	r0, fp
 800f4a8:	f001 f8f4 	bl	8010694 <__sprint_r>
 800f4ac:	2800      	cmp	r0, #0
 800f4ae:	f47f abfb 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f4b2:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800f4b4:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f4b8:	e461      	b.n	800ed7e <_vfprintf_r+0x3b6>
 800f4ba:	ee1b 1a10 	vmov	r1, s22
 800f4be:	aa24      	add	r2, sp, #144	; 0x90
 800f4c0:	4658      	mov	r0, fp
 800f4c2:	f001 f8e7 	bl	8010694 <__sprint_r>
 800f4c6:	2800      	cmp	r0, #0
 800f4c8:	f47f abee 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f4cc:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800f4ce:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f4d2:	e467      	b.n	800eda4 <_vfprintf_r+0x3dc>
 800f4d4:	2c10      	cmp	r4, #16
 800f4d6:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f4d8:	4d89      	ldr	r5, [pc, #548]	; (800f700 <_vfprintf_r+0xd38>)
 800f4da:	dd1f      	ble.n	800f51c <_vfprintf_r+0xb54>
 800f4dc:	ee1b 7a10 	vmov	r7, s22
 800f4e0:	2610      	movs	r6, #16
 800f4e2:	e004      	b.n	800f4ee <_vfprintf_r+0xb26>
 800f4e4:	3c10      	subs	r4, #16
 800f4e6:	2c10      	cmp	r4, #16
 800f4e8:	f108 0808 	add.w	r8, r8, #8
 800f4ec:	dd16      	ble.n	800f51c <_vfprintf_r+0xb54>
 800f4ee:	3301      	adds	r3, #1
 800f4f0:	3210      	adds	r2, #16
 800f4f2:	2b07      	cmp	r3, #7
 800f4f4:	e9c8 5600 	strd	r5, r6, [r8]
 800f4f8:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f4fc:	ddf2      	ble.n	800f4e4 <_vfprintf_r+0xb1c>
 800f4fe:	aa24      	add	r2, sp, #144	; 0x90
 800f500:	4639      	mov	r1, r7
 800f502:	4658      	mov	r0, fp
 800f504:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f508:	f001 f8c4 	bl	8010694 <__sprint_r>
 800f50c:	2800      	cmp	r0, #0
 800f50e:	f47f abcb 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f512:	3c10      	subs	r4, #16
 800f514:	2c10      	cmp	r4, #16
 800f516:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f51a:	dce8      	bgt.n	800f4ee <_vfprintf_r+0xb26>
 800f51c:	3301      	adds	r3, #1
 800f51e:	4422      	add	r2, r4
 800f520:	2b07      	cmp	r3, #7
 800f522:	e9c8 5400 	strd	r5, r4, [r8]
 800f526:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f52a:	f77f ac5f 	ble.w	800edec <_vfprintf_r+0x424>
 800f52e:	ee1b 1a10 	vmov	r1, s22
 800f532:	aa24      	add	r2, sp, #144	; 0x90
 800f534:	4658      	mov	r0, fp
 800f536:	f001 f8ad 	bl	8010694 <__sprint_r>
 800f53a:	2800      	cmp	r0, #0
 800f53c:	f47f abb4 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f540:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800f542:	e453      	b.n	800edec <_vfprintf_r+0x424>
 800f544:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800f546:	2900      	cmp	r1, #0
 800f548:	f340 80f9 	ble.w	800f73e <_vfprintf_r+0xd76>
 800f54c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800f54e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f550:	429d      	cmp	r5, r3
 800f552:	bfa8      	it	ge
 800f554:	461d      	movge	r5, r3
 800f556:	2d00      	cmp	r5, #0
 800f558:	dd0b      	ble.n	800f572 <_vfprintf_r+0xbaa>
 800f55a:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f55c:	3301      	adds	r3, #1
 800f55e:	442a      	add	r2, r5
 800f560:	2b07      	cmp	r3, #7
 800f562:	e9c8 7500 	strd	r7, r5, [r8]
 800f566:	9226      	str	r2, [sp, #152]	; 0x98
 800f568:	9325      	str	r3, [sp, #148]	; 0x94
 800f56a:	f300 867c 	bgt.w	8010266 <_vfprintf_r+0x189e>
 800f56e:	f108 0808 	add.w	r8, r8, #8
 800f572:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800f574:	2d00      	cmp	r5, #0
 800f576:	bfa8      	it	ge
 800f578:	1b64      	subge	r4, r4, r5
 800f57a:	2c00      	cmp	r4, #0
 800f57c:	f300 8361 	bgt.w	800fc42 <_vfprintf_r+0x127a>
 800f580:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f582:	0571      	lsls	r1, r6, #21
 800f584:	443b      	add	r3, r7
 800f586:	9305      	str	r3, [sp, #20]
 800f588:	f100 8578 	bmi.w	801007c <_vfprintf_r+0x16b4>
 800f58c:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
 800f58e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f590:	429c      	cmp	r4, r3
 800f592:	db02      	blt.n	800f59a <_vfprintf_r+0xbd2>
 800f594:	07f3      	lsls	r3, r6, #31
 800f596:	f140 844c 	bpl.w	800fe32 <_vfprintf_r+0x146a>
 800f59a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800f59c:	9911      	ldr	r1, [sp, #68]	; 0x44
 800f59e:	441a      	add	r2, r3
 800f5a0:	e9c8 1300 	strd	r1, r3, [r8]
 800f5a4:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f5a6:	9226      	str	r2, [sp, #152]	; 0x98
 800f5a8:	3301      	adds	r3, #1
 800f5aa:	2b07      	cmp	r3, #7
 800f5ac:	9325      	str	r3, [sp, #148]	; 0x94
 800f5ae:	f300 8668 	bgt.w	8010282 <_vfprintf_r+0x18ba>
 800f5b2:	f108 0808 	add.w	r8, r8, #8
 800f5b6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f5b8:	1b1c      	subs	r4, r3, r4
 800f5ba:	18fd      	adds	r5, r7, r3
 800f5bc:	9b05      	ldr	r3, [sp, #20]
 800f5be:	1aed      	subs	r5, r5, r3
 800f5c0:	42a5      	cmp	r5, r4
 800f5c2:	bfa8      	it	ge
 800f5c4:	4625      	movge	r5, r4
 800f5c6:	2d00      	cmp	r5, #0
 800f5c8:	dd0d      	ble.n	800f5e6 <_vfprintf_r+0xc1e>
 800f5ca:	f8c8 3000 	str.w	r3, [r8]
 800f5ce:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f5d0:	f8c8 5004 	str.w	r5, [r8, #4]
 800f5d4:	3301      	adds	r3, #1
 800f5d6:	442a      	add	r2, r5
 800f5d8:	2b07      	cmp	r3, #7
 800f5da:	9226      	str	r2, [sp, #152]	; 0x98
 800f5dc:	9325      	str	r3, [sp, #148]	; 0x94
 800f5de:	f300 865f 	bgt.w	80102a0 <_vfprintf_r+0x18d8>
 800f5e2:	f108 0808 	add.w	r8, r8, #8
 800f5e6:	2d00      	cmp	r5, #0
 800f5e8:	bfa8      	it	ge
 800f5ea:	1b64      	subge	r4, r4, r5
 800f5ec:	2c00      	cmp	r4, #0
 800f5ee:	f77f abf5 	ble.w	800eddc <_vfprintf_r+0x414>
 800f5f2:	2c10      	cmp	r4, #16
 800f5f4:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f5f6:	f340 82dd 	ble.w	800fbb4 <_vfprintf_r+0x11ec>
 800f5fa:	ee1b 7a10 	vmov	r7, s22
 800f5fe:	2510      	movs	r5, #16
 800f600:	e005      	b.n	800f60e <_vfprintf_r+0xc46>
 800f602:	f108 0808 	add.w	r8, r8, #8
 800f606:	3c10      	subs	r4, #16
 800f608:	2c10      	cmp	r4, #16
 800f60a:	f340 82d3 	ble.w	800fbb4 <_vfprintf_r+0x11ec>
 800f60e:	3301      	adds	r3, #1
 800f610:	493c      	ldr	r1, [pc, #240]	; (800f704 <_vfprintf_r+0xd3c>)
 800f612:	3210      	adds	r2, #16
 800f614:	2b07      	cmp	r3, #7
 800f616:	e9c8 1500 	strd	r1, r5, [r8]
 800f61a:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f61e:	ddf0      	ble.n	800f602 <_vfprintf_r+0xc3a>
 800f620:	aa24      	add	r2, sp, #144	; 0x90
 800f622:	4639      	mov	r1, r7
 800f624:	4658      	mov	r0, fp
 800f626:	f001 f835 	bl	8010694 <__sprint_r>
 800f62a:	2800      	cmp	r0, #0
 800f62c:	f47f ab3c 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f630:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f634:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f638:	e7e5      	b.n	800f606 <_vfprintf_r+0xc3e>
 800f63a:	07f5      	lsls	r5, r6, #31
 800f63c:	f53f ae9a 	bmi.w	800f374 <_vfprintf_r+0x9ac>
 800f640:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f642:	f8c8 7000 	str.w	r7, [r8]
 800f646:	3301      	adds	r3, #1
 800f648:	3201      	adds	r2, #1
 800f64a:	2101      	movs	r1, #1
 800f64c:	2b07      	cmp	r3, #7
 800f64e:	9226      	str	r2, [sp, #152]	; 0x98
 800f650:	9325      	str	r3, [sp, #148]	; 0x94
 800f652:	f8c8 1004 	str.w	r1, [r8, #4]
 800f656:	f77f aebd 	ble.w	800f3d4 <_vfprintf_r+0xa0c>
 800f65a:	ee1b 1a10 	vmov	r1, s22
 800f65e:	aa24      	add	r2, sp, #144	; 0x90
 800f660:	4658      	mov	r0, fp
 800f662:	f001 f817 	bl	8010694 <__sprint_r>
 800f666:	2800      	cmp	r0, #0
 800f668:	f47f ab1e 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f66c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f670:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f674:	e6b0      	b.n	800f3d8 <_vfprintf_r+0xa10>
 800f676:	990e      	ldr	r1, [sp, #56]	; 0x38
 800f678:	1e4c      	subs	r4, r1, #1
 800f67a:	2c00      	cmp	r4, #0
 800f67c:	f77f aeac 	ble.w	800f3d8 <_vfprintf_r+0xa10>
 800f680:	2c10      	cmp	r4, #16
 800f682:	f340 82b2 	ble.w	800fbea <_vfprintf_r+0x1222>
 800f686:	ee1b 7a10 	vmov	r7, s22
 800f68a:	2510      	movs	r5, #16
 800f68c:	e005      	b.n	800f69a <_vfprintf_r+0xcd2>
 800f68e:	f108 0808 	add.w	r8, r8, #8
 800f692:	3c10      	subs	r4, #16
 800f694:	2c10      	cmp	r4, #16
 800f696:	f340 82a8 	ble.w	800fbea <_vfprintf_r+0x1222>
 800f69a:	3301      	adds	r3, #1
 800f69c:	4919      	ldr	r1, [pc, #100]	; (800f704 <_vfprintf_r+0xd3c>)
 800f69e:	3210      	adds	r2, #16
 800f6a0:	2b07      	cmp	r3, #7
 800f6a2:	e9c8 1500 	strd	r1, r5, [r8]
 800f6a6:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800f6aa:	ddf0      	ble.n	800f68e <_vfprintf_r+0xcc6>
 800f6ac:	aa24      	add	r2, sp, #144	; 0x90
 800f6ae:	4639      	mov	r1, r7
 800f6b0:	4658      	mov	r0, fp
 800f6b2:	f000 ffef 	bl	8010694 <__sprint_r>
 800f6b6:	2800      	cmp	r0, #0
 800f6b8:	f47f aaf6 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f6bc:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f6c0:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f6c4:	e7e5      	b.n	800f692 <_vfprintf_r+0xcca>
 800f6c6:	ee1b 1a10 	vmov	r1, s22
 800f6ca:	aa24      	add	r2, sp, #144	; 0x90
 800f6cc:	4658      	mov	r0, fp
 800f6ce:	f000 ffe1 	bl	8010694 <__sprint_r>
 800f6d2:	2800      	cmp	r0, #0
 800f6d4:	f47f aae8 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f6d8:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800f6da:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f6de:	f7ff bb6b 	b.w	800edb8 <_vfprintf_r+0x3f0>
 800f6e2:	f016 0310 	ands.w	r3, r6, #16
 800f6e6:	f040 80dd 	bne.w	800f8a4 <_vfprintf_r+0xedc>
 800f6ea:	f016 0240 	ands.w	r2, r6, #64	; 0x40
 800f6ee:	f000 82d9 	beq.w	800fca4 <_vfprintf_r+0x12dc>
 800f6f2:	9808      	ldr	r0, [sp, #32]
 800f6f4:	f850 2b04 	ldr.w	r2, [r0], #4
 800f6f8:	9008      	str	r0, [sp, #32]
 800f6fa:	4619      	mov	r1, r3
 800f6fc:	b292      	uxth	r2, r2
 800f6fe:	e4aa      	b.n	800f056 <_vfprintf_r+0x68e>
 800f700:	08015a30 	.word	0x08015a30
 800f704:	08015a40 	.word	0x08015a40
 800f708:	9b02      	ldr	r3, [sp, #8]
 800f70a:	f013 0310 	ands.w	r3, r3, #16
 800f70e:	f040 80b7 	bne.w	800f880 <_vfprintf_r+0xeb8>
 800f712:	9a02      	ldr	r2, [sp, #8]
 800f714:	f012 0240 	ands.w	r2, r2, #64	; 0x40
 800f718:	f000 82b4 	beq.w	800fc84 <_vfprintf_r+0x12bc>
 800f71c:	9808      	ldr	r0, [sp, #32]
 800f71e:	f850 2b04 	ldr.w	r2, [r0], #4
 800f722:	9008      	str	r0, [sp, #32]
 800f724:	4619      	mov	r1, r3
 800f726:	b292      	uxth	r2, r2
 800f728:	2301      	movs	r3, #1
 800f72a:	e498      	b.n	800f05e <_vfprintf_r+0x696>
 800f72c:	07f0      	lsls	r0, r6, #31
 800f72e:	f57f ab55 	bpl.w	800eddc <_vfprintf_r+0x414>
 800f732:	e569      	b.n	800f208 <_vfprintf_r+0x840>
 800f734:	9308      	str	r3, [sp, #32]
 800f736:	f899 3000 	ldrb.w	r3, [r9]
 800f73a:	f7ff b9c6 	b.w	800eaca <_vfprintf_r+0x102>
 800f73e:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f740:	48a6      	ldr	r0, [pc, #664]	; (800f9dc <_vfprintf_r+0x1014>)
 800f742:	f8c8 0000 	str.w	r0, [r8]
 800f746:	3301      	adds	r3, #1
 800f748:	3201      	adds	r2, #1
 800f74a:	2001      	movs	r0, #1
 800f74c:	2b07      	cmp	r3, #7
 800f74e:	9226      	str	r2, [sp, #152]	; 0x98
 800f750:	9325      	str	r3, [sp, #148]	; 0x94
 800f752:	f8c8 0004 	str.w	r0, [r8, #4]
 800f756:	f300 8562 	bgt.w	801021e <_vfprintf_r+0x1856>
 800f75a:	f108 0808 	add.w	r8, r8, #8
 800f75e:	2900      	cmp	r1, #0
 800f760:	f040 8250 	bne.w	800fc04 <_vfprintf_r+0x123c>
 800f764:	990e      	ldr	r1, [sp, #56]	; 0x38
 800f766:	f006 0301 	and.w	r3, r6, #1
 800f76a:	430b      	orrs	r3, r1
 800f76c:	f43f ab36 	beq.w	800eddc <_vfprintf_r+0x414>
 800f770:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800f772:	9911      	ldr	r1, [sp, #68]	; 0x44
 800f774:	441a      	add	r2, r3
 800f776:	e9c8 1300 	strd	r1, r3, [r8]
 800f77a:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f77c:	9226      	str	r2, [sp, #152]	; 0x98
 800f77e:	3301      	adds	r3, #1
 800f780:	2b07      	cmp	r3, #7
 800f782:	9325      	str	r3, [sp, #148]	; 0x94
 800f784:	f300 83f0 	bgt.w	800ff68 <_vfprintf_r+0x15a0>
 800f788:	f108 0808 	add.w	r8, r8, #8
 800f78c:	e24b      	b.n	800fc26 <_vfprintf_r+0x125e>
 800f78e:	af50      	add	r7, sp, #320	; 0x140
 800f790:	e4f0      	b.n	800f174 <_vfprintf_r+0x7ac>
 800f792:	05b2      	lsls	r2, r6, #22
 800f794:	f100 8357 	bmi.w	800fe46 <_vfprintf_r+0x147e>
 800f798:	f853 2b04 	ldr.w	r2, [r3], #4
 800f79c:	9308      	str	r3, [sp, #32]
 800f79e:	17d1      	asrs	r1, r2, #31
 800f7a0:	460b      	mov	r3, r1
 800f7a2:	2b00      	cmp	r3, #0
 800f7a4:	f6bf abd7 	bge.w	800ef56 <_vfprintf_r+0x58e>
 800f7a8:	4252      	negs	r2, r2
 800f7aa:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800f7ae:	9602      	str	r6, [sp, #8]
 800f7b0:	202d      	movs	r0, #45	; 0x2d
 800f7b2:	2301      	movs	r3, #1
 800f7b4:	e454      	b.n	800f060 <_vfprintf_r+0x698>
 800f7b6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800f7b8:	2b00      	cmp	r3, #0
 800f7ba:	f43f aa0b 	beq.w	800ebd4 <_vfprintf_r+0x20c>
 800f7be:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800f7c0:	781b      	ldrb	r3, [r3, #0]
 800f7c2:	2b00      	cmp	r3, #0
 800f7c4:	f43f aa06 	beq.w	800ebd4 <_vfprintf_r+0x20c>
 800f7c8:	f899 3000 	ldrb.w	r3, [r9]
 800f7cc:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
 800f7d0:	f7ff b97b 	b.w	800eaca <_vfprintf_r+0x102>
 800f7d4:	eeb4 8b48 	vcmp.f64	d8, d8
 800f7d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f7dc:	f180 8688 	bvs.w	80104f0 <_vfprintf_r+0x1b28>
 800f7e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f7e2:	2b61      	cmp	r3, #97	; 0x61
 800f7e4:	f000 853d 	beq.w	8010262 <_vfprintf_r+0x189a>
 800f7e8:	2b41      	cmp	r3, #65	; 0x41
 800f7ea:	f000 833c 	beq.w	800fe66 <_vfprintf_r+0x149e>
 800f7ee:	9b03      	ldr	r3, [sp, #12]
 800f7f0:	3301      	adds	r3, #1
 800f7f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f7f4:	f023 0420 	bic.w	r4, r3, #32
 800f7f8:	f000 8629 	beq.w	801044e <_vfprintf_r+0x1a86>
 800f7fc:	2c47      	cmp	r4, #71	; 0x47
 800f7fe:	d104      	bne.n	800f80a <_vfprintf_r+0xe42>
 800f800:	9b03      	ldr	r3, [sp, #12]
 800f802:	2b00      	cmp	r3, #0
 800f804:	bf08      	it	eq
 800f806:	2301      	moveq	r3, #1
 800f808:	9303      	str	r3, [sp, #12]
 800f80a:	ee18 3a90 	vmov	r3, s17
 800f80e:	2b00      	cmp	r3, #0
 800f810:	f446 7280 	orr.w	r2, r6, #256	; 0x100
 800f814:	4635      	mov	r5, r6
 800f816:	f2c0 85c7 	blt.w	80103a8 <_vfprintf_r+0x19e0>
 800f81a:	eeb0 ab48 	vmov.f64	d10, d8
 800f81e:	2300      	movs	r3, #0
 800f820:	4616      	mov	r6, r2
 800f822:	9309      	str	r3, [sp, #36]	; 0x24
 800f824:	9307      	str	r3, [sp, #28]
 800f826:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f828:	3b41      	subs	r3, #65	; 0x41
 800f82a:	2b25      	cmp	r3, #37	; 0x25
 800f82c:	f200 826a 	bhi.w	800fd04 <_vfprintf_r+0x133c>
 800f830:	e8df f013 	tbh	[pc, r3, lsl #1]
 800f834:	026803c3 	.word	0x026803c3
 800f838:	02680268 	.word	0x02680268
 800f83c:	03c003bc 	.word	0x03c003bc
 800f840:	02680268 	.word	0x02680268
 800f844:	02680268 	.word	0x02680268
 800f848:	02680268 	.word	0x02680268
 800f84c:	02680268 	.word	0x02680268
 800f850:	02680268 	.word	0x02680268
 800f854:	02680268 	.word	0x02680268
 800f858:	02680268 	.word	0x02680268
 800f85c:	02680268 	.word	0x02680268
 800f860:	02680268 	.word	0x02680268
 800f864:	02680268 	.word	0x02680268
 800f868:	02680268 	.word	0x02680268
 800f86c:	02680268 	.word	0x02680268
 800f870:	02680268 	.word	0x02680268
 800f874:	02680268 	.word	0x02680268
 800f878:	02680268 	.word	0x02680268
 800f87c:	03c003bc 	.word	0x03c003bc
 800f880:	9b08      	ldr	r3, [sp, #32]
 800f882:	f853 2b04 	ldr.w	r2, [r3], #4
 800f886:	9308      	str	r3, [sp, #32]
 800f888:	2301      	movs	r3, #1
 800f88a:	f7ff bbe8 	b.w	800f05e <_vfprintf_r+0x696>
 800f88e:	9b08      	ldr	r3, [sp, #32]
 800f890:	9804      	ldr	r0, [sp, #16]
 800f892:	f853 1b04 	ldr.w	r1, [r3], #4
 800f896:	9308      	str	r3, [sp, #32]
 800f898:	17c2      	asrs	r2, r0, #31
 800f89a:	e9c1 0200 	strd	r0, r2, [r1]
 800f89e:	464f      	mov	r7, r9
 800f8a0:	f7ff b8e8 	b.w	800ea74 <_vfprintf_r+0xac>
 800f8a4:	9b08      	ldr	r3, [sp, #32]
 800f8a6:	f853 2b04 	ldr.w	r2, [r3], #4
 800f8aa:	9308      	str	r3, [sp, #32]
 800f8ac:	f7ff bbd3 	b.w	800f056 <_vfprintf_r+0x68e>
 800f8b0:	930b      	str	r3, [sp, #44]	; 0x2c
 800f8b2:	4b4b      	ldr	r3, [pc, #300]	; (800f9e0 <_vfprintf_r+0x1018>)
 800f8b4:	9312      	str	r3, [sp, #72]	; 0x48
 800f8b6:	f016 0120 	ands.w	r1, r6, #32
 800f8ba:	d06a      	beq.n	800f992 <_vfprintf_r+0xfca>
 800f8bc:	9b08      	ldr	r3, [sp, #32]
 800f8be:	3307      	adds	r3, #7
 800f8c0:	f023 0307 	bic.w	r3, r3, #7
 800f8c4:	6859      	ldr	r1, [r3, #4]
 800f8c6:	f853 2b08 	ldr.w	r2, [r3], #8
 800f8ca:	9308      	str	r3, [sp, #32]
 800f8cc:	07f7      	lsls	r7, r6, #31
 800f8ce:	d50a      	bpl.n	800f8e6 <_vfprintf_r+0xf1e>
 800f8d0:	ea52 0301 	orrs.w	r3, r2, r1
 800f8d4:	d007      	beq.n	800f8e6 <_vfprintf_r+0xf1e>
 800f8d6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f8d8:	f88d 3069 	strb.w	r3, [sp, #105]	; 0x69
 800f8dc:	2330      	movs	r3, #48	; 0x30
 800f8de:	f046 0602 	orr.w	r6, r6, #2
 800f8e2:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
 800f8e6:	f426 6380 	bic.w	r3, r6, #1024	; 0x400
 800f8ea:	9302      	str	r3, [sp, #8]
 800f8ec:	2302      	movs	r3, #2
 800f8ee:	f7ff bbb6 	b.w	800f05e <_vfprintf_r+0x696>
 800f8f2:	930b      	str	r3, [sp, #44]	; 0x2c
 800f8f4:	f7ff bba3 	b.w	800f03e <_vfprintf_r+0x676>
 800f8f8:	930b      	str	r3, [sp, #44]	; 0x2c
 800f8fa:	9602      	str	r6, [sp, #8]
 800f8fc:	f7ff bbd1 	b.w	800f0a2 <_vfprintf_r+0x6da>
 800f900:	930b      	str	r3, [sp, #44]	; 0x2c
 800f902:	4b38      	ldr	r3, [pc, #224]	; (800f9e4 <_vfprintf_r+0x101c>)
 800f904:	9312      	str	r3, [sp, #72]	; 0x48
 800f906:	e7d6      	b.n	800f8b6 <_vfprintf_r+0xeee>
 800f908:	ee1b 1a10 	vmov	r1, s22
 800f90c:	aa24      	add	r2, sp, #144	; 0x90
 800f90e:	4658      	mov	r0, fp
 800f910:	f000 fec0 	bl	8010694 <__sprint_r>
 800f914:	2800      	cmp	r0, #0
 800f916:	f47f a9c7 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f91a:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800f91c:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f920:	f7ff ba44 	b.w	800edac <_vfprintf_r+0x3e4>
 800f924:	ee1b 1a10 	vmov	r1, s22
 800f928:	aa24      	add	r2, sp, #144	; 0x90
 800f92a:	4658      	mov	r0, fp
 800f92c:	f000 feb2 	bl	8010694 <__sprint_r>
 800f930:	2800      	cmp	r0, #0
 800f932:	f47f a9b9 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f936:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800f938:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f93c:	e472      	b.n	800f224 <_vfprintf_r+0x85c>
 800f93e:	9b03      	ldr	r3, [sp, #12]
 800f940:	9707      	str	r7, [sp, #28]
 800f942:	2b06      	cmp	r3, #6
 800f944:	463a      	mov	r2, r7
 800f946:	bf28      	it	cs
 800f948:	2306      	movcs	r3, #6
 800f94a:	9703      	str	r7, [sp, #12]
 800f94c:	4639      	mov	r1, r7
 800f94e:	9302      	str	r3, [sp, #8]
 800f950:	4f25      	ldr	r7, [pc, #148]	; (800f9e8 <_vfprintf_r+0x1020>)
 800f952:	9305      	str	r3, [sp, #20]
 800f954:	920d      	str	r2, [sp, #52]	; 0x34
 800f956:	920f      	str	r2, [sp, #60]	; 0x3c
 800f958:	920c      	str	r2, [sp, #48]	; 0x30
 800f95a:	f7ff ba87 	b.w	800ee6c <_vfprintf_r+0x4a4>
 800f95e:	9c08      	ldr	r4, [sp, #32]
 800f960:	2208      	movs	r2, #8
 800f962:	2100      	movs	r1, #0
 800f964:	a822      	add	r0, sp, #136	; 0x88
 800f966:	af37      	add	r7, sp, #220	; 0xdc
 800f968:	f7fe ff3c 	bl	800e7e4 <memset>
 800f96c:	ab22      	add	r3, sp, #136	; 0x88
 800f96e:	f854 2b04 	ldr.w	r2, [r4], #4
 800f972:	4639      	mov	r1, r7
 800f974:	4658      	mov	r0, fp
 800f976:	f004 fd8f 	bl	8014498 <_wcrtomb_r>
 800f97a:	4603      	mov	r3, r0
 800f97c:	3301      	adds	r3, #1
 800f97e:	9005      	str	r0, [sp, #20]
 800f980:	f000 8509 	beq.w	8010396 <_vfprintf_r+0x19ce>
 800f984:	9b05      	ldr	r3, [sp, #20]
 800f986:	9408      	str	r4, [sp, #32]
 800f988:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800f98c:	9302      	str	r3, [sp, #8]
 800f98e:	f7ff ba94 	b.w	800eeba <_vfprintf_r+0x4f2>
 800f992:	f016 0310 	ands.w	r3, r6, #16
 800f996:	f000 809d 	beq.w	800fad4 <_vfprintf_r+0x110c>
 800f99a:	9b08      	ldr	r3, [sp, #32]
 800f99c:	f853 2b04 	ldr.w	r2, [r3], #4
 800f9a0:	9308      	str	r3, [sp, #32]
 800f9a2:	e793      	b.n	800f8cc <_vfprintf_r+0xf04>
 800f9a4:	ee1b 1a10 	vmov	r1, s22
 800f9a8:	aa24      	add	r2, sp, #144	; 0x90
 800f9aa:	4658      	mov	r0, fp
 800f9ac:	f000 fe72 	bl	8010694 <__sprint_r>
 800f9b0:	2800      	cmp	r0, #0
 800f9b2:	f47f a979 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f9b6:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f9ba:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f9be:	e4f5      	b.n	800f3ac <_vfprintf_r+0x9e4>
 800f9c0:	ee1b 1a10 	vmov	r1, s22
 800f9c4:	aa24      	add	r2, sp, #144	; 0x90
 800f9c6:	4658      	mov	r0, fp
 800f9c8:	f000 fe64 	bl	8010694 <__sprint_r>
 800f9cc:	2800      	cmp	r0, #0
 800f9ce:	f47f a96b 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800f9d2:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800f9d6:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800f9da:	e4da      	b.n	800f392 <_vfprintf_r+0x9ca>
 800f9dc:	08015a2c 	.word	0x08015a2c
 800f9e0:	080159fc 	.word	0x080159fc
 800f9e4:	08015a10 	.word	0x08015a10
 800f9e8:	08015a24 	.word	0x08015a24
 800f9ec:	9802      	ldr	r0, [sp, #8]
 800f9ee:	f8cd 801c 	str.w	r8, [sp, #28]
 800f9f2:	af50      	add	r7, sp, #320	; 0x140
 800f9f4:	f400 6080 	and.w	r0, r0, #1024	; 0x400
 800f9f8:	2400      	movs	r4, #0
 800f9fa:	ee0a ba10 	vmov	s20, fp
 800f9fe:	4bbf      	ldr	r3, [pc, #764]	; (800fcfc <_vfprintf_r+0x1334>)
 800fa00:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
 800fa04:	f8cd 9014 	str.w	r9, [sp, #20]
 800fa08:	46bb      	mov	fp, r7
 800fa0a:	2605      	movs	r6, #5
 800fa0c:	46a4      	mov	ip, r4
 800fa0e:	4607      	mov	r7, r0
 800fa10:	e005      	b.n	800fa1e <_vfprintf_r+0x1056>
 800fa12:	2a0a      	cmp	r2, #10
 800fa14:	f171 0100 	sbcs.w	r1, r1, #0
 800fa18:	d336      	bcc.n	800fa88 <_vfprintf_r+0x10c0>
 800fa1a:	464a      	mov	r2, r9
 800fa1c:	4629      	mov	r1, r5
 800fa1e:	1850      	adds	r0, r2, r1
 800fa20:	f140 0000 	adc.w	r0, r0, #0
 800fa24:	fba3 4500 	umull	r4, r5, r3, r0
 800fa28:	f025 0403 	bic.w	r4, r5, #3
 800fa2c:	eb04 0495 	add.w	r4, r4, r5, lsr #2
 800fa30:	1b00      	subs	r0, r0, r4
 800fa32:	1a14      	subs	r4, r2, r0
 800fa34:	f04f 35cc 	mov.w	r5, #3435973836	; 0xcccccccc
 800fa38:	f161 0e00 	sbc.w	lr, r1, #0
 800fa3c:	fb05 f504 	mul.w	r5, r5, r4
 800fa40:	fba4 9403 	umull	r9, r4, r4, r3
 800fa44:	fb03 550e 	mla	r5, r3, lr, r5
 800fa48:	f009 0e01 	and.w	lr, r9, #1
 800fa4c:	4425      	add	r5, r4
 800fa4e:	fbae 4e06 	umull	r4, lr, lr, r6
 800fa52:	1824      	adds	r4, r4, r0
 800fa54:	ea4f 0959 	mov.w	r9, r9, lsr #1
 800fa58:	3430      	adds	r4, #48	; 0x30
 800fa5a:	f80b 4c01 	strb.w	r4, [fp, #-1]
 800fa5e:	ea49 79c5 	orr.w	r9, r9, r5, lsl #31
 800fa62:	f10c 0c01 	add.w	ip, ip, #1
 800fa66:	f10b 3bff 	add.w	fp, fp, #4294967295
 800fa6a:	086d      	lsrs	r5, r5, #1
 800fa6c:	2f00      	cmp	r7, #0
 800fa6e:	d0d0      	beq.n	800fa12 <_vfprintf_r+0x104a>
 800fa70:	f898 0000 	ldrb.w	r0, [r8]
 800fa74:	4584      	cmp	ip, r0
 800fa76:	d1cc      	bne.n	800fa12 <_vfprintf_r+0x104a>
 800fa78:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 800fa7c:	d0c9      	beq.n	800fa12 <_vfprintf_r+0x104a>
 800fa7e:	2a0a      	cmp	r2, #10
 800fa80:	f171 0100 	sbcs.w	r1, r1, #0
 800fa84:	f080 82bf 	bcs.w	8010006 <_vfprintf_r+0x163e>
 800fa88:	465f      	mov	r7, fp
 800fa8a:	ab50      	add	r3, sp, #320	; 0x140
 800fa8c:	1bdb      	subs	r3, r3, r7
 800fa8e:	f8dd 9014 	ldr.w	r9, [sp, #20]
 800fa92:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
 800fa96:	ee1a ba10 	vmov	fp, s20
 800fa9a:	f8dd 801c 	ldr.w	r8, [sp, #28]
 800fa9e:	9e02      	ldr	r6, [sp, #8]
 800faa0:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
 800faa4:	9305      	str	r3, [sp, #20]
 800faa6:	f7ff bb65 	b.w	800f174 <_vfprintf_r+0x7ac>
 800faaa:	ee1b 1a10 	vmov	r1, s22
 800faae:	aa24      	add	r2, sp, #144	; 0x90
 800fab0:	4658      	mov	r0, fp
 800fab2:	f000 fdef 	bl	8010694 <__sprint_r>
 800fab6:	2800      	cmp	r0, #0
 800fab8:	f47f a8f6 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800fabc:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 800fac0:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800fac2:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800fac6:	f7ff b947 	b.w	800ed58 <_vfprintf_r+0x390>
 800faca:	4658      	mov	r0, fp
 800facc:	f001 ff4c 	bl	8011968 <__sinit>
 800fad0:	f7fe bf9c 	b.w	800ea0c <_vfprintf_r+0x44>
 800fad4:	f016 0240 	ands.w	r2, r6, #64	; 0x40
 800fad8:	f000 80f2 	beq.w	800fcc0 <_vfprintf_r+0x12f8>
 800fadc:	9808      	ldr	r0, [sp, #32]
 800fade:	f850 2b04 	ldr.w	r2, [r0], #4
 800fae2:	9008      	str	r0, [sp, #32]
 800fae4:	4619      	mov	r1, r3
 800fae6:	b292      	uxth	r2, r2
 800fae8:	e6f0      	b.n	800f8cc <_vfprintf_r+0xf04>
 800faea:	ee1b 1a10 	vmov	r1, s22
 800faee:	aa24      	add	r2, sp, #144	; 0x90
 800faf0:	4658      	mov	r0, fp
 800faf2:	f000 fdcf 	bl	8010694 <__sprint_r>
 800faf6:	2800      	cmp	r0, #0
 800faf8:	f47f a8d6 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800fafc:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800fafe:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800fb02:	f7ff bb7c 	b.w	800f1fe <_vfprintf_r+0x836>
 800fb06:	ad22      	add	r5, sp, #136	; 0x88
 800fb08:	2208      	movs	r2, #8
 800fb0a:	2100      	movs	r1, #0
 800fb0c:	4628      	mov	r0, r5
 800fb0e:	971d      	str	r7, [sp, #116]	; 0x74
 800fb10:	f7fe fe68 	bl	800e7e4 <memset>
 800fb14:	9b03      	ldr	r3, [sp, #12]
 800fb16:	1c58      	adds	r0, r3, #1
 800fb18:	f000 8368 	beq.w	80101ec <_vfprintf_r+0x1824>
 800fb1c:	2400      	movs	r4, #0
 800fb1e:	f8cd 9008 	str.w	r9, [sp, #8]
 800fb22:	9607      	str	r6, [sp, #28]
 800fb24:	4699      	mov	r9, r3
 800fb26:	4626      	mov	r6, r4
 800fb28:	e00c      	b.n	800fb44 <_vfprintf_r+0x117c>
 800fb2a:	a937      	add	r1, sp, #220	; 0xdc
 800fb2c:	4658      	mov	r0, fp
 800fb2e:	f004 fcb3 	bl	8014498 <_wcrtomb_r>
 800fb32:	1c41      	adds	r1, r0, #1
 800fb34:	4430      	add	r0, r6
 800fb36:	f000 842e 	beq.w	8010396 <_vfprintf_r+0x19ce>
 800fb3a:	4548      	cmp	r0, r9
 800fb3c:	dc08      	bgt.n	800fb50 <_vfprintf_r+0x1188>
 800fb3e:	f000 84e7 	beq.w	8010510 <_vfprintf_r+0x1b48>
 800fb42:	4606      	mov	r6, r0
 800fb44:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 800fb46:	5912      	ldr	r2, [r2, r4]
 800fb48:	462b      	mov	r3, r5
 800fb4a:	3404      	adds	r4, #4
 800fb4c:	2a00      	cmp	r2, #0
 800fb4e:	d1ec      	bne.n	800fb2a <_vfprintf_r+0x1162>
 800fb50:	9605      	str	r6, [sp, #20]
 800fb52:	f8dd 9008 	ldr.w	r9, [sp, #8]
 800fb56:	9e07      	ldr	r6, [sp, #28]
 800fb58:	9b05      	ldr	r3, [sp, #20]
 800fb5a:	2b00      	cmp	r3, #0
 800fb5c:	f000 8354 	beq.w	8010208 <_vfprintf_r+0x1840>
 800fb60:	2b63      	cmp	r3, #99	; 0x63
 800fb62:	f340 83d8 	ble.w	8010316 <_vfprintf_r+0x194e>
 800fb66:	1c59      	adds	r1, r3, #1
 800fb68:	4658      	mov	r0, fp
 800fb6a:	f003 fc0d 	bl	8013388 <_malloc_r>
 800fb6e:	4607      	mov	r7, r0
 800fb70:	2800      	cmp	r0, #0
 800fb72:	f000 8410 	beq.w	8010396 <_vfprintf_r+0x19ce>
 800fb76:	9007      	str	r0, [sp, #28]
 800fb78:	2208      	movs	r2, #8
 800fb7a:	2100      	movs	r1, #0
 800fb7c:	4628      	mov	r0, r5
 800fb7e:	f7fe fe31 	bl	800e7e4 <memset>
 800fb82:	9c05      	ldr	r4, [sp, #20]
 800fb84:	9500      	str	r5, [sp, #0]
 800fb86:	4623      	mov	r3, r4
 800fb88:	aa1d      	add	r2, sp, #116	; 0x74
 800fb8a:	4639      	mov	r1, r7
 800fb8c:	4658      	mov	r0, fp
 800fb8e:	f004 fca9 	bl	80144e4 <_wcsrtombs_r>
 800fb92:	4284      	cmp	r4, r0
 800fb94:	f040 84ef 	bne.w	8010576 <_vfprintf_r+0x1bae>
 800fb98:	9a05      	ldr	r2, [sp, #20]
 800fb9a:	2300      	movs	r3, #0
 800fb9c:	54bb      	strb	r3, [r7, r2]
 800fb9e:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 800fba2:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 800fba6:	9303      	str	r3, [sp, #12]
 800fba8:	9202      	str	r2, [sp, #8]
 800fbaa:	930d      	str	r3, [sp, #52]	; 0x34
 800fbac:	930f      	str	r3, [sp, #60]	; 0x3c
 800fbae:	930c      	str	r3, [sp, #48]	; 0x30
 800fbb0:	f7ff b95c 	b.w	800ee6c <_vfprintf_r+0x4a4>
 800fbb4:	3301      	adds	r3, #1
 800fbb6:	4952      	ldr	r1, [pc, #328]	; (800fd00 <_vfprintf_r+0x1338>)
 800fbb8:	f8c8 4004 	str.w	r4, [r8, #4]
 800fbbc:	4422      	add	r2, r4
 800fbbe:	2b07      	cmp	r3, #7
 800fbc0:	f8c8 1000 	str.w	r1, [r8]
 800fbc4:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800fbc8:	f77f a906 	ble.w	800edd8 <_vfprintf_r+0x410>
 800fbcc:	e411      	b.n	800f3f2 <_vfprintf_r+0xa2a>
 800fbce:	2b01      	cmp	r3, #1
 800fbd0:	9602      	str	r6, [sp, #8]
 800fbd2:	f47f aabb 	bne.w	800f14c <_vfprintf_r+0x784>
 800fbd6:	e45a      	b.n	800f48e <_vfprintf_r+0xac6>
 800fbd8:	9b08      	ldr	r3, [sp, #32]
 800fbda:	9904      	ldr	r1, [sp, #16]
 800fbdc:	f853 2b04 	ldr.w	r2, [r3], #4
 800fbe0:	464f      	mov	r7, r9
 800fbe2:	6011      	str	r1, [r2, #0]
 800fbe4:	9308      	str	r3, [sp, #32]
 800fbe6:	f7fe bf45 	b.w	800ea74 <_vfprintf_r+0xac>
 800fbea:	3301      	adds	r3, #1
 800fbec:	4944      	ldr	r1, [pc, #272]	; (800fd00 <_vfprintf_r+0x1338>)
 800fbee:	f8c8 4004 	str.w	r4, [r8, #4]
 800fbf2:	4422      	add	r2, r4
 800fbf4:	2b07      	cmp	r3, #7
 800fbf6:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800fbfa:	f8c8 1000 	str.w	r1, [r8]
 800fbfe:	f77f abe9 	ble.w	800f3d4 <_vfprintf_r+0xa0c>
 800fc02:	e52a      	b.n	800f65a <_vfprintf_r+0xc92>
 800fc04:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800fc06:	9811      	ldr	r0, [sp, #68]	; 0x44
 800fc08:	441a      	add	r2, r3
 800fc0a:	e9c8 0300 	strd	r0, r3, [r8]
 800fc0e:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800fc10:	9226      	str	r2, [sp, #152]	; 0x98
 800fc12:	3301      	adds	r3, #1
 800fc14:	2b07      	cmp	r3, #7
 800fc16:	9325      	str	r3, [sp, #148]	; 0x94
 800fc18:	f300 81a6 	bgt.w	800ff68 <_vfprintf_r+0x15a0>
 800fc1c:	f108 0808 	add.w	r8, r8, #8
 800fc20:	2900      	cmp	r1, #0
 800fc22:	f2c0 837c 	blt.w	801031e <_vfprintf_r+0x1956>
 800fc26:	990e      	ldr	r1, [sp, #56]	; 0x38
 800fc28:	f8c8 7000 	str.w	r7, [r8]
 800fc2c:	3301      	adds	r3, #1
 800fc2e:	440a      	add	r2, r1
 800fc30:	2b07      	cmp	r3, #7
 800fc32:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800fc36:	f8c8 1004 	str.w	r1, [r8, #4]
 800fc3a:	f77f a8cd 	ble.w	800edd8 <_vfprintf_r+0x410>
 800fc3e:	f7ff bbd8 	b.w	800f3f2 <_vfprintf_r+0xa2a>
 800fc42:	2c10      	cmp	r4, #16
 800fc44:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800fc46:	dd49      	ble.n	800fcdc <_vfprintf_r+0x1314>
 800fc48:	4641      	mov	r1, r8
 800fc4a:	2510      	movs	r5, #16
 800fc4c:	ee1b 8a10 	vmov	r8, s22
 800fc50:	e003      	b.n	800fc5a <_vfprintf_r+0x1292>
 800fc52:	3108      	adds	r1, #8
 800fc54:	3c10      	subs	r4, #16
 800fc56:	2c10      	cmp	r4, #16
 800fc58:	dd3f      	ble.n	800fcda <_vfprintf_r+0x1312>
 800fc5a:	3301      	adds	r3, #1
 800fc5c:	4828      	ldr	r0, [pc, #160]	; (800fd00 <_vfprintf_r+0x1338>)
 800fc5e:	3210      	adds	r2, #16
 800fc60:	2b07      	cmp	r3, #7
 800fc62:	e9c1 0500 	strd	r0, r5, [r1]
 800fc66:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800fc6a:	ddf2      	ble.n	800fc52 <_vfprintf_r+0x128a>
 800fc6c:	aa24      	add	r2, sp, #144	; 0x90
 800fc6e:	4641      	mov	r1, r8
 800fc70:	4658      	mov	r0, fp
 800fc72:	f000 fd0f 	bl	8010694 <__sprint_r>
 800fc76:	2800      	cmp	r0, #0
 800fc78:	f47f a816 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800fc7c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800fc80:	a927      	add	r1, sp, #156	; 0x9c
 800fc82:	e7e7      	b.n	800fc54 <_vfprintf_r+0x128c>
 800fc84:	9b02      	ldr	r3, [sp, #8]
 800fc86:	f413 7100 	ands.w	r1, r3, #512	; 0x200
 800fc8a:	9b08      	ldr	r3, [sp, #32]
 800fc8c:	bf1a      	itte	ne
 800fc8e:	4611      	movne	r1, r2
 800fc90:	f853 2b04 	ldrne.w	r2, [r3], #4
 800fc94:	f853 2b04 	ldreq.w	r2, [r3], #4
 800fc98:	9308      	str	r3, [sp, #32]
 800fc9a:	bf18      	it	ne
 800fc9c:	b2d2      	uxtbne	r2, r2
 800fc9e:	2301      	movs	r3, #1
 800fca0:	f7ff b9dd 	b.w	800f05e <_vfprintf_r+0x696>
 800fca4:	9b08      	ldr	r3, [sp, #32]
 800fca6:	f416 7100 	ands.w	r1, r6, #512	; 0x200
 800fcaa:	bf1a      	itte	ne
 800fcac:	4611      	movne	r1, r2
 800fcae:	f853 2b04 	ldrne.w	r2, [r3], #4
 800fcb2:	f853 2b04 	ldreq.w	r2, [r3], #4
 800fcb6:	9308      	str	r3, [sp, #32]
 800fcb8:	bf18      	it	ne
 800fcba:	b2d2      	uxtbne	r2, r2
 800fcbc:	f7ff b9cb 	b.w	800f056 <_vfprintf_r+0x68e>
 800fcc0:	9b08      	ldr	r3, [sp, #32]
 800fcc2:	f416 7100 	ands.w	r1, r6, #512	; 0x200
 800fcc6:	bf1a      	itte	ne
 800fcc8:	4611      	movne	r1, r2
 800fcca:	f853 2b04 	ldrne.w	r2, [r3], #4
 800fcce:	f853 2b04 	ldreq.w	r2, [r3], #4
 800fcd2:	9308      	str	r3, [sp, #32]
 800fcd4:	bf18      	it	ne
 800fcd6:	b2d2      	uxtbne	r2, r2
 800fcd8:	e5f8      	b.n	800f8cc <_vfprintf_r+0xf04>
 800fcda:	4688      	mov	r8, r1
 800fcdc:	3301      	adds	r3, #1
 800fcde:	4908      	ldr	r1, [pc, #32]	; (800fd00 <_vfprintf_r+0x1338>)
 800fce0:	f8c8 4004 	str.w	r4, [r8, #4]
 800fce4:	4422      	add	r2, r4
 800fce6:	2b07      	cmp	r3, #7
 800fce8:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 800fcec:	f8c8 1000 	str.w	r1, [r8]
 800fcf0:	f300 814e 	bgt.w	800ff90 <_vfprintf_r+0x15c8>
 800fcf4:	f108 0808 	add.w	r8, r8, #8
 800fcf8:	e442      	b.n	800f580 <_vfprintf_r+0xbb8>
 800fcfa:	bf00      	nop
 800fcfc:	cccccccd 	.word	0xcccccccd
 800fd00:	08015a40 	.word	0x08015a40
 800fd04:	9a03      	ldr	r2, [sp, #12]
 800fd06:	2102      	movs	r1, #2
 800fd08:	ab22      	add	r3, sp, #136	; 0x88
 800fd0a:	9301      	str	r3, [sp, #4]
 800fd0c:	ab1d      	add	r3, sp, #116	; 0x74
 800fd0e:	9300      	str	r3, [sp, #0]
 800fd10:	4658      	mov	r0, fp
 800fd12:	ab1b      	add	r3, sp, #108	; 0x6c
 800fd14:	eeb0 0b4a 	vmov.f64	d0, d10
 800fd18:	9202      	str	r2, [sp, #8]
 800fd1a:	f002 fb69 	bl	80123f0 <_dtoa_r>
 800fd1e:	2c47      	cmp	r4, #71	; 0x47
 800fd20:	9a02      	ldr	r2, [sp, #8]
 800fd22:	4607      	mov	r7, r0
 800fd24:	f000 828a 	beq.w	801023c <_vfprintf_r+0x1874>
 800fd28:	2c46      	cmp	r4, #70	; 0x46
 800fd2a:	4410      	add	r0, r2
 800fd2c:	d105      	bne.n	800fd3a <_vfprintf_r+0x1372>
 800fd2e:	783b      	ldrb	r3, [r7, #0]
 800fd30:	2b30      	cmp	r3, #48	; 0x30
 800fd32:	f000 83a2 	beq.w	801047a <_vfprintf_r+0x1ab2>
 800fd36:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800fd38:	4410      	add	r0, r2
 800fd3a:	eeb5 ab40 	vcmp.f64	d10, #0.0
 800fd3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fd42:	f040 8247 	bne.w	80101d4 <_vfprintf_r+0x180c>
 800fd46:	4603      	mov	r3, r0
 800fd48:	1bdb      	subs	r3, r3, r7
 800fd4a:	930e      	str	r3, [sp, #56]	; 0x38
 800fd4c:	2c47      	cmp	r4, #71	; 0x47
 800fd4e:	f000 8146 	beq.w	800ffde <_vfprintf_r+0x1616>
 800fd52:	2c46      	cmp	r4, #70	; 0x46
 800fd54:	f000 82b9 	beq.w	80102ca <_vfprintf_r+0x1902>
 800fd58:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800fd5a:	930c      	str	r3, [sp, #48]	; 0x30
 800fd5c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800fd5e:	2c41      	cmp	r4, #65	; 0x41
 800fd60:	f103 33ff 	add.w	r3, r3, #4294967295
 800fd64:	931b      	str	r3, [sp, #108]	; 0x6c
 800fd66:	f000 82d1 	beq.w	801030c <_vfprintf_r+0x1944>
 800fd6a:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 800fd6e:	2100      	movs	r1, #0
 800fd70:	2b00      	cmp	r3, #0
 800fd72:	bfb8      	it	lt
 800fd74:	9b0c      	ldrlt	r3, [sp, #48]	; 0x30
 800fd76:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
 800fd7a:	bfba      	itte	lt
 800fd7c:	f1c3 0301 	rsblt	r3, r3, #1
 800fd80:	222d      	movlt	r2, #45	; 0x2d
 800fd82:	222b      	movge	r2, #43	; 0x2b
 800fd84:	2b09      	cmp	r3, #9
 800fd86:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
 800fd8a:	f340 8349 	ble.w	8010420 <_vfprintf_r+0x1a58>
 800fd8e:	f10d 048f 	add.w	r4, sp, #143	; 0x8f
 800fd92:	4eb6      	ldr	r6, [pc, #728]	; (801006c <_vfprintf_r+0x16a4>)
 800fd94:	4622      	mov	r2, r4
 800fd96:	4610      	mov	r0, r2
 800fd98:	fb86 2103 	smull	r2, r1, r6, r3
 800fd9c:	17da      	asrs	r2, r3, #31
 800fd9e:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 800fda2:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800fda6:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 800fdaa:	3130      	adds	r1, #48	; 0x30
 800fdac:	f800 1c01 	strb.w	r1, [r0, #-1]
 800fdb0:	4619      	mov	r1, r3
 800fdb2:	2963      	cmp	r1, #99	; 0x63
 800fdb4:	4613      	mov	r3, r2
 800fdb6:	f100 32ff 	add.w	r2, r0, #4294967295
 800fdba:	dcec      	bgt.n	800fd96 <_vfprintf_r+0x13ce>
 800fdbc:	3330      	adds	r3, #48	; 0x30
 800fdbe:	b2d9      	uxtb	r1, r3
 800fdc0:	1e83      	subs	r3, r0, #2
 800fdc2:	429c      	cmp	r4, r3
 800fdc4:	f802 1c01 	strb.w	r1, [r2, #-1]
 800fdc8:	f240 83b3 	bls.w	8010532 <_vfprintf_r+0x1b6a>
 800fdcc:	4613      	mov	r3, r2
 800fdce:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 800fdd2:	e001      	b.n	800fdd8 <_vfprintf_r+0x1410>
 800fdd4:	f813 1b01 	ldrb.w	r1, [r3], #1
 800fdd8:	f802 1b01 	strb.w	r1, [r2], #1
 800fddc:	429c      	cmp	r4, r3
 800fdde:	d1f9      	bne.n	800fdd4 <_vfprintf_r+0x140c>
 800fde0:	f10d 0391 	add.w	r3, sp, #145	; 0x91
 800fde4:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 800fde8:	1a1b      	subs	r3, r3, r0
 800fdea:	4413      	add	r3, r2
 800fdec:	aa1e      	add	r2, sp, #120	; 0x78
 800fdee:	1a9b      	subs	r3, r3, r2
 800fdf0:	9314      	str	r3, [sp, #80]	; 0x50
 800fdf2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800fdf4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800fdf6:	2b01      	cmp	r3, #1
 800fdf8:	441a      	add	r2, r3
 800fdfa:	9205      	str	r2, [sp, #20]
 800fdfc:	f340 832b 	ble.w	8010456 <_vfprintf_r+0x1a8e>
 800fe00:	9b05      	ldr	r3, [sp, #20]
 800fe02:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800fe04:	4413      	add	r3, r2
 800fe06:	9305      	str	r3, [sp, #20]
 800fe08:	9a05      	ldr	r2, [sp, #20]
 800fe0a:	f425 6380 	bic.w	r3, r5, #1024	; 0x400
 800fe0e:	f443 7680 	orr.w	r6, r3, #256	; 0x100
 800fe12:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 800fe16:	2300      	movs	r3, #0
 800fe18:	930d      	str	r3, [sp, #52]	; 0x34
 800fe1a:	9202      	str	r2, [sp, #8]
 800fe1c:	930f      	str	r3, [sp, #60]	; 0x3c
 800fe1e:	930c      	str	r3, [sp, #48]	; 0x30
 800fe20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fe22:	2b00      	cmp	r3, #0
 800fe24:	f040 80e8 	bne.w	800fff8 <_vfprintf_r+0x1630>
 800fe28:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 800fe2c:	9303      	str	r3, [sp, #12]
 800fe2e:	f7ff b81d 	b.w	800ee6c <_vfprintf_r+0x4a4>
 800fe32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800fe34:	9905      	ldr	r1, [sp, #20]
 800fe36:	18fd      	adds	r5, r7, r3
 800fe38:	1a6d      	subs	r5, r5, r1
 800fe3a:	1b1c      	subs	r4, r3, r4
 800fe3c:	42a5      	cmp	r5, r4
 800fe3e:	bfa8      	it	ge
 800fe40:	4625      	movge	r5, r4
 800fe42:	f7ff bbd0 	b.w	800f5e6 <_vfprintf_r+0xc1e>
 800fe46:	f913 2b04 	ldrsb.w	r2, [r3], #4
 800fe4a:	9308      	str	r3, [sp, #32]
 800fe4c:	17d1      	asrs	r1, r2, #31
 800fe4e:	460b      	mov	r3, r1
 800fe50:	f7ff b87e 	b.w	800ef50 <_vfprintf_r+0x588>
 800fe54:	9b08      	ldr	r3, [sp, #32]
 800fe56:	9904      	ldr	r1, [sp, #16]
 800fe58:	f853 2b04 	ldr.w	r2, [r3], #4
 800fe5c:	9308      	str	r3, [sp, #32]
 800fe5e:	8011      	strh	r1, [r2, #0]
 800fe60:	464f      	mov	r7, r9
 800fe62:	f7fe be07 	b.w	800ea74 <_vfprintf_r+0xac>
 800fe66:	2358      	movs	r3, #88	; 0x58
 800fe68:	f88d 3069 	strb.w	r3, [sp, #105]	; 0x69
 800fe6c:	2330      	movs	r3, #48	; 0x30
 800fe6e:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
 800fe72:	9b03      	ldr	r3, [sp, #12]
 800fe74:	2b63      	cmp	r3, #99	; 0x63
 800fe76:	f046 0502 	orr.w	r5, r6, #2
 800fe7a:	f300 82df 	bgt.w	801043c <_vfprintf_r+0x1a74>
 800fe7e:	2300      	movs	r3, #0
 800fe80:	9307      	str	r3, [sp, #28]
 800fe82:	af37      	add	r7, sp, #220	; 0xdc
 800fe84:	ee18 3a90 	vmov	r3, s17
 800fe88:	2b00      	cmp	r3, #0
 800fe8a:	f446 7681 	orr.w	r6, r6, #258	; 0x102
 800fe8e:	f2c0 8233 	blt.w	80102f8 <_vfprintf_r+0x1930>
 800fe92:	eeb0 ab48 	vmov.f64	d10, d8
 800fe96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800fe98:	f023 0420 	bic.w	r4, r3, #32
 800fe9c:	2300      	movs	r3, #0
 800fe9e:	9309      	str	r3, [sp, #36]	; 0x24
 800fea0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800fea2:	2b61      	cmp	r3, #97	; 0x61
 800fea4:	f47f acbf 	bne.w	800f826 <_vfprintf_r+0xe5e>
 800fea8:	eeb0 0b4a 	vmov.f64	d0, d10
 800feac:	a81b      	add	r0, sp, #108	; 0x6c
 800feae:	f002 f9cf 	bl	8012250 <frexp>
 800feb2:	eeb4 7b00 	vmov.f64	d7, #64	; 0x3e000000  0.125
 800feb6:	ee20 0b07 	vmul.f64	d0, d0, d7
 800feba:	eeb5 0b40 	vcmp.f64	d0, #0.0
 800febe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fec2:	d101      	bne.n	800fec8 <_vfprintf_r+0x1500>
 800fec4:	2301      	movs	r3, #1
 800fec6:	931b      	str	r3, [sp, #108]	; 0x6c
 800fec8:	4869      	ldr	r0, [pc, #420]	; (8010070 <_vfprintf_r+0x16a8>)
 800feca:	9b03      	ldr	r3, [sp, #12]
 800fecc:	eeb3 5b00 	vmov.f64	d5, #48	; 0x41800000  16.0
 800fed0:	3b01      	subs	r3, #1
 800fed2:	463a      	mov	r2, r7
 800fed4:	e004      	b.n	800fee0 <_vfprintf_r+0x1518>
 800fed6:	eeb5 0b40 	vcmp.f64	d0, #0.0
 800feda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fede:	d013      	beq.n	800ff08 <_vfprintf_r+0x1540>
 800fee0:	ee20 0b05 	vmul.f64	d0, d0, d5
 800fee4:	eefd 7bc0 	vcvt.s32.f64	s15, d0
 800fee8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800feec:	ee17 1a90 	vmov	r1, s15
 800fef0:	5c41      	ldrb	r1, [r0, r1]
 800fef2:	eeb8 6be7 	vcvt.f64.s32	d6, s15
 800fef6:	4694      	mov	ip, r2
 800fef8:	ee30 0b46 	vsub.f64	d0, d0, d6
 800fefc:	f802 1b01 	strb.w	r1, [r2], #1
 800ff00:	4619      	mov	r1, r3
 800ff02:	f103 33ff 	add.w	r3, r3, #4294967295
 800ff06:	d1e6      	bne.n	800fed6 <_vfprintf_r+0x150e>
 800ff08:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
 800ff0c:	eeb4 0bc6 	vcmpe.f64	d0, d6
 800ff10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ff14:	f300 824c 	bgt.w	80103b0 <_vfprintf_r+0x19e8>
 800ff18:	eeb4 0b46 	vcmp.f64	d0, d6
 800ff1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ff20:	d104      	bne.n	800ff2c <_vfprintf_r+0x1564>
 800ff22:	ee17 3a90 	vmov	r3, s15
 800ff26:	07db      	lsls	r3, r3, #31
 800ff28:	f100 8242 	bmi.w	80103b0 <_vfprintf_r+0x19e8>
 800ff2c:	2900      	cmp	r1, #0
 800ff2e:	db06      	blt.n	800ff3e <_vfprintf_r+0x1576>
 800ff30:	1c4b      	adds	r3, r1, #1
 800ff32:	4413      	add	r3, r2
 800ff34:	2130      	movs	r1, #48	; 0x30
 800ff36:	f802 1b01 	strb.w	r1, [r2], #1
 800ff3a:	4293      	cmp	r3, r2
 800ff3c:	d1fb      	bne.n	800ff36 <_vfprintf_r+0x156e>
 800ff3e:	1bd3      	subs	r3, r2, r7
 800ff40:	930e      	str	r3, [sp, #56]	; 0x38
 800ff42:	e703      	b.n	800fd4c <_vfprintf_r+0x1384>
 800ff44:	4638      	mov	r0, r7
 800ff46:	f7f0 fcbb 	bl	80008c0 <strlen>
 800ff4a:	4602      	mov	r2, r0
 800ff4c:	9005      	str	r0, [sp, #20]
 800ff4e:	f7fe bfe3 	b.w	800ef18 <_vfprintf_r+0x550>
 800ff52:	ee1b 1a10 	vmov	r1, s22
 800ff56:	aa24      	add	r2, sp, #144	; 0x90
 800ff58:	4658      	mov	r0, fp
 800ff5a:	f000 fb9b 	bl	8010694 <__sprint_r>
 800ff5e:	2800      	cmp	r0, #0
 800ff60:	f43e ae88 	beq.w	800ec74 <_vfprintf_r+0x2ac>
 800ff64:	f7fe bea6 	b.w	800ecb4 <_vfprintf_r+0x2ec>
 800ff68:	ee1b 1a10 	vmov	r1, s22
 800ff6c:	aa24      	add	r2, sp, #144	; 0x90
 800ff6e:	4658      	mov	r0, fp
 800ff70:	f000 fb90 	bl	8010694 <__sprint_r>
 800ff74:	2800      	cmp	r0, #0
 800ff76:	f47e ae97 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800ff7a:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 800ff7e:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800ff80:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800ff84:	e64c      	b.n	800fc20 <_vfprintf_r+0x1258>
 800ff86:	6d88      	ldr	r0, [r1, #88]	; 0x58
 800ff88:	f002 f960 	bl	801224c <__retarget_lock_release_recursive>
 800ff8c:	f7fe be42 	b.w	800ec14 <_vfprintf_r+0x24c>
 800ff90:	ee1b 1a10 	vmov	r1, s22
 800ff94:	aa24      	add	r2, sp, #144	; 0x90
 800ff96:	4658      	mov	r0, fp
 800ff98:	f000 fb7c 	bl	8010694 <__sprint_r>
 800ff9c:	2800      	cmp	r0, #0
 800ff9e:	f47e ae83 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 800ffa2:	9a26      	ldr	r2, [sp, #152]	; 0x98
 800ffa4:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 800ffa8:	f7ff baea 	b.w	800f580 <_vfprintf_r+0xbb8>
 800ffac:	9b03      	ldr	r3, [sp, #12]
 800ffae:	2102      	movs	r1, #2
 800ffb0:	1c5a      	adds	r2, r3, #1
 800ffb2:	e6a9      	b.n	800fd08 <_vfprintf_r+0x1340>
 800ffb4:	9a03      	ldr	r2, [sp, #12]
 800ffb6:	2103      	movs	r1, #3
 800ffb8:	e6a6      	b.n	800fd08 <_vfprintf_r+0x1340>
 800ffba:	a81b      	add	r0, sp, #108	; 0x6c
 800ffbc:	eeb0 0b4a 	vmov.f64	d0, d10
 800ffc0:	f002 f946 	bl	8012250 <frexp>
 800ffc4:	eeb4 7b00 	vmov.f64	d7, #64	; 0x3e000000  0.125
 800ffc8:	ee20 0b07 	vmul.f64	d0, d0, d7
 800ffcc:	eeb5 0b40 	vcmp.f64	d0, #0.0
 800ffd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ffd4:	d101      	bne.n	800ffda <_vfprintf_r+0x1612>
 800ffd6:	2301      	movs	r3, #1
 800ffd8:	931b      	str	r3, [sp, #108]	; 0x6c
 800ffda:	4826      	ldr	r0, [pc, #152]	; (8010074 <_vfprintf_r+0x16ac>)
 800ffdc:	e775      	b.n	800feca <_vfprintf_r+0x1502>
 800ffde:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800ffe0:	930c      	str	r3, [sp, #48]	; 0x30
 800ffe2:	1cdc      	adds	r4, r3, #3
 800ffe4:	db02      	blt.n	800ffec <_vfprintf_r+0x1624>
 800ffe6:	9a03      	ldr	r2, [sp, #12]
 800ffe8:	4293      	cmp	r3, r2
 800ffea:	dd1d      	ble.n	8010028 <_vfprintf_r+0x1660>
 800ffec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800ffee:	3b02      	subs	r3, #2
 800fff0:	930b      	str	r3, [sp, #44]	; 0x2c
 800fff2:	f023 0420 	bic.w	r4, r3, #32
 800fff6:	e6b1      	b.n	800fd5c <_vfprintf_r+0x1394>
 800fff8:	212d      	movs	r1, #45	; 0x2d
 800fffa:	2300      	movs	r3, #0
 800fffc:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
 8010000:	9303      	str	r3, [sp, #12]
 8010002:	f7fe bf36 	b.w	800ee72 <_vfprintf_r+0x4aa>
 8010006:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8010008:	9915      	ldr	r1, [sp, #84]	; 0x54
 801000a:	ebab 0b03 	sub.w	fp, fp, r3
 801000e:	461a      	mov	r2, r3
 8010010:	4658      	mov	r0, fp
 8010012:	f7fe fc9f 	bl	800e954 <strncpy>
 8010016:	f898 2001 	ldrb.w	r2, [r8, #1]
 801001a:	4b17      	ldr	r3, [pc, #92]	; (8010078 <_vfprintf_r+0x16b0>)
 801001c:	b10a      	cbz	r2, 8010022 <_vfprintf_r+0x165a>
 801001e:	f108 0801 	add.w	r8, r8, #1
 8010022:	f04f 0c00 	mov.w	ip, #0
 8010026:	e4f8      	b.n	800fa1a <_vfprintf_r+0x1052>
 8010028:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801002a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801002c:	4293      	cmp	r3, r2
 801002e:	f2c0 81a7 	blt.w	8010380 <_vfprintf_r+0x19b8>
 8010032:	07e9      	lsls	r1, r5, #31
 8010034:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010036:	f140 821e 	bpl.w	8010476 <_vfprintf_r+0x1aae>
 801003a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801003c:	4413      	add	r3, r2
 801003e:	9305      	str	r3, [sp, #20]
 8010040:	056a      	lsls	r2, r5, #21
 8010042:	d503      	bpl.n	801004c <_vfprintf_r+0x1684>
 8010044:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010046:	2b00      	cmp	r3, #0
 8010048:	f300 8228 	bgt.w	801049c <_vfprintf_r+0x1ad4>
 801004c:	9b05      	ldr	r3, [sp, #20]
 801004e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8010052:	9302      	str	r3, [sp, #8]
 8010054:	2367      	movs	r3, #103	; 0x67
 8010056:	930b      	str	r3, [sp, #44]	; 0x2c
 8010058:	2300      	movs	r3, #0
 801005a:	930d      	str	r3, [sp, #52]	; 0x34
 801005c:	930f      	str	r3, [sp, #60]	; 0x3c
 801005e:	e6df      	b.n	800fe20 <_vfprintf_r+0x1458>
 8010060:	212d      	movs	r1, #45	; 0x2d
 8010062:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
 8010066:	f7fe bef0 	b.w	800ee4a <_vfprintf_r+0x482>
 801006a:	bf00      	nop
 801006c:	66666667 	.word	0x66666667
 8010070:	080159fc 	.word	0x080159fc
 8010074:	08015a10 	.word	0x08015a10
 8010078:	cccccccd 	.word	0xcccccccd
 801007c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801007e:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8010082:	4640      	mov	r0, r8
 8010084:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 8010088:	960a      	str	r6, [sp, #40]	; 0x28
 801008a:	18fb      	adds	r3, r7, r3
 801008c:	9303      	str	r3, [sp, #12]
 801008e:	9d05      	ldr	r5, [sp, #20]
 8010090:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 8010092:	f8dd 9058 	ldr.w	r9, [sp, #88]	; 0x58
 8010096:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010098:	970b      	str	r7, [sp, #44]	; 0x2c
 801009a:	ee1b 1a10 	vmov	r1, s22
 801009e:	f1b8 0f00 	cmp.w	r8, #0
 80100a2:	d031      	beq.n	8010108 <_vfprintf_r+0x1740>
 80100a4:	2b00      	cmp	r3, #0
 80100a6:	d177      	bne.n	8010198 <_vfprintf_r+0x17d0>
 80100a8:	3e01      	subs	r6, #1
 80100aa:	f108 38ff 	add.w	r8, r8, #4294967295
 80100ae:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80100b0:	e9c0 3900 	strd	r3, r9, [r0]
 80100b4:	9b25      	ldr	r3, [sp, #148]	; 0x94
 80100b6:	3301      	adds	r3, #1
 80100b8:	444a      	add	r2, r9
 80100ba:	2b07      	cmp	r3, #7
 80100bc:	9226      	str	r2, [sp, #152]	; 0x98
 80100be:	9325      	str	r3, [sp, #148]	; 0x94
 80100c0:	dc6e      	bgt.n	80101a0 <_vfprintf_r+0x17d8>
 80100c2:	3008      	adds	r0, #8
 80100c4:	9b03      	ldr	r3, [sp, #12]
 80100c6:	f896 c000 	ldrb.w	ip, [r6]
 80100ca:	1b5b      	subs	r3, r3, r5
 80100cc:	4563      	cmp	r3, ip
 80100ce:	bfa8      	it	ge
 80100d0:	4663      	movge	r3, ip
 80100d2:	2b00      	cmp	r3, #0
 80100d4:	461f      	mov	r7, r3
 80100d6:	dd0b      	ble.n	80100f0 <_vfprintf_r+0x1728>
 80100d8:	9c25      	ldr	r4, [sp, #148]	; 0x94
 80100da:	3401      	adds	r4, #1
 80100dc:	441a      	add	r2, r3
 80100de:	2c07      	cmp	r4, #7
 80100e0:	e9c0 5300 	strd	r5, r3, [r0]
 80100e4:	9226      	str	r2, [sp, #152]	; 0x98
 80100e6:	9425      	str	r4, [sp, #148]	; 0x94
 80100e8:	dc66      	bgt.n	80101b8 <_vfprintf_r+0x17f0>
 80100ea:	f896 c000 	ldrb.w	ip, [r6]
 80100ee:	3008      	adds	r0, #8
 80100f0:	2f00      	cmp	r7, #0
 80100f2:	bfac      	ite	ge
 80100f4:	ebac 0407 	subge.w	r4, ip, r7
 80100f8:	4664      	movlt	r4, ip
 80100fa:	2c00      	cmp	r4, #0
 80100fc:	dc15      	bgt.n	801012a <_vfprintf_r+0x1762>
 80100fe:	4465      	add	r5, ip
 8010100:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010102:	f1b8 0f00 	cmp.w	r8, #0
 8010106:	d1cd      	bne.n	80100a4 <_vfprintf_r+0x16dc>
 8010108:	2b00      	cmp	r3, #0
 801010a:	d145      	bne.n	8010198 <_vfprintf_r+0x17d0>
 801010c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 801010e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010110:	9613      	str	r6, [sp, #76]	; 0x4c
 8010112:	18fb      	adds	r3, r7, r3
 8010114:	429d      	cmp	r5, r3
 8010116:	4629      	mov	r1, r5
 8010118:	bf28      	it	cs
 801011a:	4619      	movcs	r1, r3
 801011c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8010120:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8010122:	9105      	str	r1, [sp, #20]
 8010124:	4680      	mov	r8, r0
 8010126:	f7ff ba31 	b.w	800f58c <_vfprintf_r+0xbc4>
 801012a:	2c10      	cmp	r4, #16
 801012c:	f8dd c094 	ldr.w	ip, [sp, #148]	; 0x94
 8010130:	dd23      	ble.n	801017a <_vfprintf_r+0x17b2>
 8010132:	9505      	str	r5, [sp, #20]
 8010134:	2710      	movs	r7, #16
 8010136:	4663      	mov	r3, ip
 8010138:	460d      	mov	r5, r1
 801013a:	e004      	b.n	8010146 <_vfprintf_r+0x177e>
 801013c:	3c10      	subs	r4, #16
 801013e:	2c10      	cmp	r4, #16
 8010140:	f100 0008 	add.w	r0, r0, #8
 8010144:	dd16      	ble.n	8010174 <_vfprintf_r+0x17ac>
 8010146:	3301      	adds	r3, #1
 8010148:	49a7      	ldr	r1, [pc, #668]	; (80103e8 <_vfprintf_r+0x1a20>)
 801014a:	3210      	adds	r2, #16
 801014c:	2b07      	cmp	r3, #7
 801014e:	e9c0 1700 	strd	r1, r7, [r0]
 8010152:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 8010156:	ddf1      	ble.n	801013c <_vfprintf_r+0x1774>
 8010158:	aa24      	add	r2, sp, #144	; 0x90
 801015a:	4629      	mov	r1, r5
 801015c:	4658      	mov	r0, fp
 801015e:	f000 fa99 	bl	8010694 <__sprint_r>
 8010162:	2800      	cmp	r0, #0
 8010164:	f47e ada0 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 8010168:	3c10      	subs	r4, #16
 801016a:	2c10      	cmp	r4, #16
 801016c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 8010170:	a827      	add	r0, sp, #156	; 0x9c
 8010172:	dce8      	bgt.n	8010146 <_vfprintf_r+0x177e>
 8010174:	4629      	mov	r1, r5
 8010176:	9d05      	ldr	r5, [sp, #20]
 8010178:	469c      	mov	ip, r3
 801017a:	f10c 0301 	add.w	r3, ip, #1
 801017e:	4422      	add	r2, r4
 8010180:	6044      	str	r4, [r0, #4]
 8010182:	2b07      	cmp	r3, #7
 8010184:	4c98      	ldr	r4, [pc, #608]	; (80103e8 <_vfprintf_r+0x1a20>)
 8010186:	6004      	str	r4, [r0, #0]
 8010188:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 801018c:	dc5a      	bgt.n	8010244 <_vfprintf_r+0x187c>
 801018e:	f896 c000 	ldrb.w	ip, [r6]
 8010192:	3008      	adds	r0, #8
 8010194:	4465      	add	r5, ip
 8010196:	e7b3      	b.n	8010100 <_vfprintf_r+0x1738>
 8010198:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801019a:	3b01      	subs	r3, #1
 801019c:	930d      	str	r3, [sp, #52]	; 0x34
 801019e:	e786      	b.n	80100ae <_vfprintf_r+0x16e6>
 80101a0:	aa24      	add	r2, sp, #144	; 0x90
 80101a2:	4658      	mov	r0, fp
 80101a4:	9105      	str	r1, [sp, #20]
 80101a6:	f000 fa75 	bl	8010694 <__sprint_r>
 80101aa:	2800      	cmp	r0, #0
 80101ac:	f47e ad7c 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 80101b0:	9a26      	ldr	r2, [sp, #152]	; 0x98
 80101b2:	9905      	ldr	r1, [sp, #20]
 80101b4:	a827      	add	r0, sp, #156	; 0x9c
 80101b6:	e785      	b.n	80100c4 <_vfprintf_r+0x16fc>
 80101b8:	aa24      	add	r2, sp, #144	; 0x90
 80101ba:	4658      	mov	r0, fp
 80101bc:	9105      	str	r1, [sp, #20]
 80101be:	f000 fa69 	bl	8010694 <__sprint_r>
 80101c2:	2800      	cmp	r0, #0
 80101c4:	f47e ad70 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 80101c8:	f896 c000 	ldrb.w	ip, [r6]
 80101cc:	9a26      	ldr	r2, [sp, #152]	; 0x98
 80101ce:	9905      	ldr	r1, [sp, #20]
 80101d0:	a827      	add	r0, sp, #156	; 0x9c
 80101d2:	e78d      	b.n	80100f0 <_vfprintf_r+0x1728>
 80101d4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80101d6:	4283      	cmp	r3, r0
 80101d8:	f4bf adb6 	bcs.w	800fd48 <_vfprintf_r+0x1380>
 80101dc:	2130      	movs	r1, #48	; 0x30
 80101de:	1c5a      	adds	r2, r3, #1
 80101e0:	9222      	str	r2, [sp, #136]	; 0x88
 80101e2:	7019      	strb	r1, [r3, #0]
 80101e4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80101e6:	4298      	cmp	r0, r3
 80101e8:	d8f9      	bhi.n	80101de <_vfprintf_r+0x1816>
 80101ea:	e5ad      	b.n	800fd48 <_vfprintf_r+0x1380>
 80101ec:	2300      	movs	r3, #0
 80101ee:	4619      	mov	r1, r3
 80101f0:	9500      	str	r5, [sp, #0]
 80101f2:	aa1d      	add	r2, sp, #116	; 0x74
 80101f4:	4658      	mov	r0, fp
 80101f6:	f004 f975 	bl	80144e4 <_wcsrtombs_r>
 80101fa:	4603      	mov	r3, r0
 80101fc:	3301      	adds	r3, #1
 80101fe:	9005      	str	r0, [sp, #20]
 8010200:	f000 80c9 	beq.w	8010396 <_vfprintf_r+0x19ce>
 8010204:	971d      	str	r7, [sp, #116]	; 0x74
 8010206:	e4a7      	b.n	800fb58 <_vfprintf_r+0x1190>
 8010208:	9b05      	ldr	r3, [sp, #20]
 801020a:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 801020e:	930d      	str	r3, [sp, #52]	; 0x34
 8010210:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8010214:	930f      	str	r3, [sp, #60]	; 0x3c
 8010216:	930c      	str	r3, [sp, #48]	; 0x30
 8010218:	9307      	str	r3, [sp, #28]
 801021a:	f7fe be27 	b.w	800ee6c <_vfprintf_r+0x4a4>
 801021e:	ee1b 1a10 	vmov	r1, s22
 8010222:	aa24      	add	r2, sp, #144	; 0x90
 8010224:	4658      	mov	r0, fp
 8010226:	f000 fa35 	bl	8010694 <__sprint_r>
 801022a:	2800      	cmp	r0, #0
 801022c:	f47e ad3c 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 8010230:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8010232:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8010234:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 8010238:	f7ff ba91 	b.w	800f75e <_vfprintf_r+0xd96>
 801023c:	07eb      	lsls	r3, r5, #31
 801023e:	d463      	bmi.n	8010308 <_vfprintf_r+0x1940>
 8010240:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8010242:	e581      	b.n	800fd48 <_vfprintf_r+0x1380>
 8010244:	aa24      	add	r2, sp, #144	; 0x90
 8010246:	4658      	mov	r0, fp
 8010248:	9105      	str	r1, [sp, #20]
 801024a:	f000 fa23 	bl	8010694 <__sprint_r>
 801024e:	2800      	cmp	r0, #0
 8010250:	f47e ad2a 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 8010254:	f896 c000 	ldrb.w	ip, [r6]
 8010258:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801025a:	9905      	ldr	r1, [sp, #20]
 801025c:	a827      	add	r0, sp, #156	; 0x9c
 801025e:	4465      	add	r5, ip
 8010260:	e74e      	b.n	8010100 <_vfprintf_r+0x1738>
 8010262:	2378      	movs	r3, #120	; 0x78
 8010264:	e600      	b.n	800fe68 <_vfprintf_r+0x14a0>
 8010266:	ee1b 1a10 	vmov	r1, s22
 801026a:	aa24      	add	r2, sp, #144	; 0x90
 801026c:	4658      	mov	r0, fp
 801026e:	f000 fa11 	bl	8010694 <__sprint_r>
 8010272:	2800      	cmp	r0, #0
 8010274:	f47e ad18 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 8010278:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801027a:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 801027e:	f7ff b978 	b.w	800f572 <_vfprintf_r+0xbaa>
 8010282:	ee1b 1a10 	vmov	r1, s22
 8010286:	aa24      	add	r2, sp, #144	; 0x90
 8010288:	4658      	mov	r0, fp
 801028a:	f000 fa03 	bl	8010694 <__sprint_r>
 801028e:	2800      	cmp	r0, #0
 8010290:	f47e ad0a 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 8010294:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
 8010296:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8010298:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 801029c:	f7ff b98b 	b.w	800f5b6 <_vfprintf_r+0xbee>
 80102a0:	ee1b 1a10 	vmov	r1, s22
 80102a4:	aa24      	add	r2, sp, #144	; 0x90
 80102a6:	4658      	mov	r0, fp
 80102a8:	f000 f9f4 	bl	8010694 <__sprint_r>
 80102ac:	2800      	cmp	r0, #0
 80102ae:	f47e acfb 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 80102b2:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
 80102b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80102b6:	9a26      	ldr	r2, [sp, #152]	; 0x98
 80102b8:	1b1c      	subs	r4, r3, r4
 80102ba:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 80102be:	f7ff b992 	b.w	800f5e6 <_vfprintf_r+0xc1e>
 80102c2:	2200      	movs	r2, #0
 80102c4:	9203      	str	r2, [sp, #12]
 80102c6:	f7fe bc02 	b.w	800eace <_vfprintf_r+0x106>
 80102ca:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80102cc:	920c      	str	r2, [sp, #48]	; 0x30
 80102ce:	2a00      	cmp	r2, #0
 80102d0:	f005 0301 	and.w	r3, r5, #1
 80102d4:	f340 8130 	ble.w	8010538 <_vfprintf_r+0x1b70>
 80102d8:	9903      	ldr	r1, [sp, #12]
 80102da:	430b      	orrs	r3, r1
 80102dc:	f040 80d7 	bne.w	801048e <_vfprintf_r+0x1ac6>
 80102e0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80102e2:	9305      	str	r3, [sp, #20]
 80102e4:	2366      	movs	r3, #102	; 0x66
 80102e6:	930b      	str	r3, [sp, #44]	; 0x2c
 80102e8:	056a      	lsls	r2, r5, #21
 80102ea:	f100 80d9 	bmi.w	80104a0 <_vfprintf_r+0x1ad8>
 80102ee:	9b05      	ldr	r3, [sp, #20]
 80102f0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80102f4:	9302      	str	r3, [sp, #8]
 80102f6:	e6af      	b.n	8010058 <_vfprintf_r+0x1690>
 80102f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80102fa:	f023 0420 	bic.w	r4, r3, #32
 80102fe:	232d      	movs	r3, #45	; 0x2d
 8010300:	9309      	str	r3, [sp, #36]	; 0x24
 8010302:	eeb1 ab48 	vneg.f64	d10, d8
 8010306:	e5cb      	b.n	800fea0 <_vfprintf_r+0x14d8>
 8010308:	18b8      	adds	r0, r7, r2
 801030a:	e516      	b.n	800fd3a <_vfprintf_r+0x1372>
 801030c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801030e:	320f      	adds	r2, #15
 8010310:	b2d2      	uxtb	r2, r2
 8010312:	2101      	movs	r1, #1
 8010314:	e52c      	b.n	800fd70 <_vfprintf_r+0x13a8>
 8010316:	2300      	movs	r3, #0
 8010318:	9307      	str	r3, [sp, #28]
 801031a:	af37      	add	r7, sp, #220	; 0xdc
 801031c:	e42c      	b.n	800fb78 <_vfprintf_r+0x11b0>
 801031e:	424c      	negs	r4, r1
 8010320:	3110      	adds	r1, #16
 8010322:	da63      	bge.n	80103ec <_vfprintf_r+0x1a24>
 8010324:	ee1b 1a10 	vmov	r1, s22
 8010328:	2510      	movs	r5, #16
 801032a:	e004      	b.n	8010336 <_vfprintf_r+0x196e>
 801032c:	f108 0808 	add.w	r8, r8, #8
 8010330:	3c10      	subs	r4, #16
 8010332:	2c10      	cmp	r4, #16
 8010334:	dd5a      	ble.n	80103ec <_vfprintf_r+0x1a24>
 8010336:	3301      	adds	r3, #1
 8010338:	482b      	ldr	r0, [pc, #172]	; (80103e8 <_vfprintf_r+0x1a20>)
 801033a:	3210      	adds	r2, #16
 801033c:	2b07      	cmp	r3, #7
 801033e:	e9c8 0500 	strd	r0, r5, [r8]
 8010342:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 8010346:	ddf1      	ble.n	801032c <_vfprintf_r+0x1964>
 8010348:	aa24      	add	r2, sp, #144	; 0x90
 801034a:	4658      	mov	r0, fp
 801034c:	9103      	str	r1, [sp, #12]
 801034e:	f000 f9a1 	bl	8010694 <__sprint_r>
 8010352:	2800      	cmp	r0, #0
 8010354:	f47e aca8 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 8010358:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 801035c:	9903      	ldr	r1, [sp, #12]
 801035e:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 8010362:	e7e5      	b.n	8010330 <_vfprintf_r+0x1968>
 8010364:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8010366:	07d8      	lsls	r0, r3, #31
 8010368:	d405      	bmi.n	8010376 <_vfprintf_r+0x19ae>
 801036a:	89ab      	ldrh	r3, [r5, #12]
 801036c:	0599      	lsls	r1, r3, #22
 801036e:	d402      	bmi.n	8010376 <_vfprintf_r+0x19ae>
 8010370:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8010372:	f001 ff6b 	bl	801224c <__retarget_lock_release_recursive>
 8010376:	f04f 33ff 	mov.w	r3, #4294967295
 801037a:	9304      	str	r3, [sp, #16]
 801037c:	f7fe bca9 	b.w	800ecd2 <_vfprintf_r+0x30a>
 8010380:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010382:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8010384:	189a      	adds	r2, r3, r2
 8010386:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010388:	9205      	str	r2, [sp, #20]
 801038a:	2b00      	cmp	r3, #0
 801038c:	f340 80c7 	ble.w	801051e <_vfprintf_r+0x1b56>
 8010390:	2367      	movs	r3, #103	; 0x67
 8010392:	930b      	str	r3, [sp, #44]	; 0x2c
 8010394:	e7a8      	b.n	80102e8 <_vfprintf_r+0x1920>
 8010396:	ee1b 2a10 	vmov	r2, s22
 801039a:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
 801039e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80103a2:	8193      	strh	r3, [r2, #12]
 80103a4:	f7fe bc8a 	b.w	800ecbc <_vfprintf_r+0x2f4>
 80103a8:	2300      	movs	r3, #0
 80103aa:	4616      	mov	r6, r2
 80103ac:	9307      	str	r3, [sp, #28]
 80103ae:	e7a6      	b.n	80102fe <_vfprintf_r+0x1936>
 80103b0:	f8cd c088 	str.w	ip, [sp, #136]	; 0x88
 80103b4:	f812 1c01 	ldrb.w	r1, [r2, #-1]
 80103b8:	f890 c00f 	ldrb.w	ip, [r0, #15]
 80103bc:	458c      	cmp	ip, r1
 80103be:	4613      	mov	r3, r2
 80103c0:	d10a      	bne.n	80103d8 <_vfprintf_r+0x1a10>
 80103c2:	f04f 0e30 	mov.w	lr, #48	; 0x30
 80103c6:	f803 ec01 	strb.w	lr, [r3, #-1]
 80103ca:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80103cc:	1e59      	subs	r1, r3, #1
 80103ce:	9122      	str	r1, [sp, #136]	; 0x88
 80103d0:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 80103d4:	458c      	cmp	ip, r1
 80103d6:	d0f6      	beq.n	80103c6 <_vfprintf_r+0x19fe>
 80103d8:	2939      	cmp	r1, #57	; 0x39
 80103da:	bf16      	itet	ne
 80103dc:	3101      	addne	r1, #1
 80103de:	7a81      	ldrbeq	r1, [r0, #10]
 80103e0:	b2c9      	uxtbne	r1, r1
 80103e2:	f803 1c01 	strb.w	r1, [r3, #-1]
 80103e6:	e5aa      	b.n	800ff3e <_vfprintf_r+0x1576>
 80103e8:	08015a40 	.word	0x08015a40
 80103ec:	3301      	adds	r3, #1
 80103ee:	4968      	ldr	r1, [pc, #416]	; (8010590 <_vfprintf_r+0x1bc8>)
 80103f0:	f8c8 4004 	str.w	r4, [r8, #4]
 80103f4:	4422      	add	r2, r4
 80103f6:	2b07      	cmp	r3, #7
 80103f8:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
 80103fc:	f8c8 1000 	str.w	r1, [r8]
 8010400:	f77f a9c2 	ble.w	800f788 <_vfprintf_r+0xdc0>
 8010404:	ee1b 1a10 	vmov	r1, s22
 8010408:	aa24      	add	r2, sp, #144	; 0x90
 801040a:	4658      	mov	r0, fp
 801040c:	f000 f942 	bl	8010694 <__sprint_r>
 8010410:	2800      	cmp	r0, #0
 8010412:	f47e ac49 	bne.w	800eca8 <_vfprintf_r+0x2e0>
 8010416:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
 801041a:	f10d 089c 	add.w	r8, sp, #156	; 0x9c
 801041e:	e402      	b.n	800fc26 <_vfprintf_r+0x125e>
 8010420:	2900      	cmp	r1, #0
 8010422:	d162      	bne.n	80104ea <_vfprintf_r+0x1b22>
 8010424:	2230      	movs	r2, #48	; 0x30
 8010426:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
 801042a:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 801042e:	3330      	adds	r3, #48	; 0x30
 8010430:	f802 3b01 	strb.w	r3, [r2], #1
 8010434:	ab1e      	add	r3, sp, #120	; 0x78
 8010436:	1ad3      	subs	r3, r2, r3
 8010438:	9314      	str	r3, [sp, #80]	; 0x50
 801043a:	e4da      	b.n	800fdf2 <_vfprintf_r+0x142a>
 801043c:	1c59      	adds	r1, r3, #1
 801043e:	4658      	mov	r0, fp
 8010440:	f002 ffa2 	bl	8013388 <_malloc_r>
 8010444:	4607      	mov	r7, r0
 8010446:	2800      	cmp	r0, #0
 8010448:	d0a5      	beq.n	8010396 <_vfprintf_r+0x19ce>
 801044a:	9007      	str	r0, [sp, #28]
 801044c:	e51a      	b.n	800fe84 <_vfprintf_r+0x14bc>
 801044e:	2306      	movs	r3, #6
 8010450:	9303      	str	r3, [sp, #12]
 8010452:	f7ff b9da 	b.w	800f80a <_vfprintf_r+0xe42>
 8010456:	07e8      	lsls	r0, r5, #31
 8010458:	f57f acd6 	bpl.w	800fe08 <_vfprintf_r+0x1440>
 801045c:	e4d0      	b.n	800fe00 <_vfprintf_r+0x1438>
 801045e:	9b03      	ldr	r3, [sp, #12]
 8010460:	9302      	str	r3, [sp, #8]
 8010462:	9305      	str	r3, [sp, #20]
 8010464:	2373      	movs	r3, #115	; 0x73
 8010466:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
 801046a:	9003      	str	r0, [sp, #12]
 801046c:	900d      	str	r0, [sp, #52]	; 0x34
 801046e:	900f      	str	r0, [sp, #60]	; 0x3c
 8010470:	930b      	str	r3, [sp, #44]	; 0x2c
 8010472:	f7fe bcfb 	b.w	800ee6c <_vfprintf_r+0x4a4>
 8010476:	9305      	str	r3, [sp, #20]
 8010478:	e5e2      	b.n	8010040 <_vfprintf_r+0x1678>
 801047a:	eeb5 ab40 	vcmp.f64	d10, #0.0
 801047e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010482:	f43f ac58 	beq.w	800fd36 <_vfprintf_r+0x136e>
 8010486:	f1c2 0201 	rsb	r2, r2, #1
 801048a:	921b      	str	r2, [sp, #108]	; 0x6c
 801048c:	e454      	b.n	800fd38 <_vfprintf_r+0x1370>
 801048e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010490:	18d3      	adds	r3, r2, r3
 8010492:	4419      	add	r1, r3
 8010494:	2366      	movs	r3, #102	; 0x66
 8010496:	9105      	str	r1, [sp, #20]
 8010498:	930b      	str	r3, [sp, #44]	; 0x2c
 801049a:	e725      	b.n	80102e8 <_vfprintf_r+0x1920>
 801049c:	2367      	movs	r3, #103	; 0x67
 801049e:	930b      	str	r3, [sp, #44]	; 0x2c
 80104a0:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80104a2:	780b      	ldrb	r3, [r1, #0]
 80104a4:	2bff      	cmp	r3, #255	; 0xff
 80104a6:	d06e      	beq.n	8010586 <_vfprintf_r+0x1bbe>
 80104a8:	2400      	movs	r4, #0
 80104aa:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80104ac:	4620      	mov	r0, r4
 80104ae:	e003      	b.n	80104b8 <_vfprintf_r+0x1af0>
 80104b0:	3001      	adds	r0, #1
 80104b2:	3101      	adds	r1, #1
 80104b4:	2bff      	cmp	r3, #255	; 0xff
 80104b6:	d008      	beq.n	80104ca <_vfprintf_r+0x1b02>
 80104b8:	4293      	cmp	r3, r2
 80104ba:	da06      	bge.n	80104ca <_vfprintf_r+0x1b02>
 80104bc:	1ad2      	subs	r2, r2, r3
 80104be:	784b      	ldrb	r3, [r1, #1]
 80104c0:	2b00      	cmp	r3, #0
 80104c2:	d1f5      	bne.n	80104b0 <_vfprintf_r+0x1ae8>
 80104c4:	780b      	ldrb	r3, [r1, #0]
 80104c6:	3401      	adds	r4, #1
 80104c8:	e7f4      	b.n	80104b4 <_vfprintf_r+0x1aec>
 80104ca:	9113      	str	r1, [sp, #76]	; 0x4c
 80104cc:	920c      	str	r2, [sp, #48]	; 0x30
 80104ce:	900f      	str	r0, [sp, #60]	; 0x3c
 80104d0:	940d      	str	r4, [sp, #52]	; 0x34
 80104d2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80104d4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80104d6:	9916      	ldr	r1, [sp, #88]	; 0x58
 80104d8:	4413      	add	r3, r2
 80104da:	9a05      	ldr	r2, [sp, #20]
 80104dc:	fb01 2303 	mla	r3, r1, r3, r2
 80104e0:	9305      	str	r3, [sp, #20]
 80104e2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80104e6:	9302      	str	r3, [sp, #8]
 80104e8:	e49a      	b.n	800fe20 <_vfprintf_r+0x1458>
 80104ea:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 80104ee:	e79e      	b.n	801042e <_vfprintf_r+0x1a66>
 80104f0:	ee18 3a90 	vmov	r3, s17
 80104f4:	2b00      	cmp	r3, #0
 80104f6:	bfb4      	ite	lt
 80104f8:	212d      	movlt	r1, #45	; 0x2d
 80104fa:	f89d 1067 	ldrbge.w	r1, [sp, #103]	; 0x67
 80104fe:	4f25      	ldr	r7, [pc, #148]	; (8010594 <_vfprintf_r+0x1bcc>)
 8010500:	4b25      	ldr	r3, [pc, #148]	; (8010598 <_vfprintf_r+0x1bd0>)
 8010502:	bfb8      	it	lt
 8010504:	f88d 1067 	strblt.w	r1, [sp, #103]	; 0x67
 8010508:	f026 0680 	bic.w	r6, r6, #128	; 0x80
 801050c:	f7fe bca1 	b.w	800ee52 <_vfprintf_r+0x48a>
 8010510:	9b03      	ldr	r3, [sp, #12]
 8010512:	f8dd 9008 	ldr.w	r9, [sp, #8]
 8010516:	9e07      	ldr	r6, [sp, #28]
 8010518:	9305      	str	r3, [sp, #20]
 801051a:	f7ff bb1d 	b.w	800fb58 <_vfprintf_r+0x1190>
 801051e:	f1c3 0301 	rsb	r3, r3, #1
 8010522:	441a      	add	r2, r3
 8010524:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8010528:	9302      	str	r3, [sp, #8]
 801052a:	2367      	movs	r3, #103	; 0x67
 801052c:	9205      	str	r2, [sp, #20]
 801052e:	930b      	str	r3, [sp, #44]	; 0x2c
 8010530:	e592      	b.n	8010058 <_vfprintf_r+0x1690>
 8010532:	2302      	movs	r3, #2
 8010534:	9314      	str	r3, [sp, #80]	; 0x50
 8010536:	e45c      	b.n	800fdf2 <_vfprintf_r+0x142a>
 8010538:	9a03      	ldr	r2, [sp, #12]
 801053a:	4313      	orrs	r3, r2
 801053c:	d105      	bne.n	801054a <_vfprintf_r+0x1b82>
 801053e:	2301      	movs	r3, #1
 8010540:	2266      	movs	r2, #102	; 0x66
 8010542:	9302      	str	r3, [sp, #8]
 8010544:	920b      	str	r2, [sp, #44]	; 0x2c
 8010546:	9305      	str	r3, [sp, #20]
 8010548:	e586      	b.n	8010058 <_vfprintf_r+0x1690>
 801054a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801054c:	3301      	adds	r3, #1
 801054e:	441a      	add	r2, r3
 8010550:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8010554:	9302      	str	r3, [sp, #8]
 8010556:	2366      	movs	r3, #102	; 0x66
 8010558:	9205      	str	r2, [sp, #20]
 801055a:	930b      	str	r3, [sp, #44]	; 0x2c
 801055c:	e57c      	b.n	8010058 <_vfprintf_r+0x1690>
 801055e:	9a08      	ldr	r2, [sp, #32]
 8010560:	f899 3001 	ldrb.w	r3, [r9, #1]
 8010564:	4689      	mov	r9, r1
 8010566:	f852 1b04 	ldr.w	r1, [r2], #4
 801056a:	9208      	str	r2, [sp, #32]
 801056c:	ea41 71e1 	orr.w	r1, r1, r1, asr #31
 8010570:	9103      	str	r1, [sp, #12]
 8010572:	f7fe baaa 	b.w	800eaca <_vfprintf_r+0x102>
 8010576:	ee1b 2a10 	vmov	r2, s22
 801057a:	8993      	ldrh	r3, [r2, #12]
 801057c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8010580:	8193      	strh	r3, [r2, #12]
 8010582:	f7fe bb91 	b.w	800eca8 <_vfprintf_r+0x2e0>
 8010586:	2300      	movs	r3, #0
 8010588:	930d      	str	r3, [sp, #52]	; 0x34
 801058a:	930f      	str	r3, [sp, #60]	; 0x3c
 801058c:	e7a1      	b.n	80104d2 <_vfprintf_r+0x1b0a>
 801058e:	bf00      	nop
 8010590:	08015a40 	.word	0x08015a40
 8010594:	080159f4 	.word	0x080159f4
 8010598:	080159f8 	.word	0x080159f8

0801059c <__sbprintf>:
 801059c:	b570      	push	{r4, r5, r6, lr}
 801059e:	460c      	mov	r4, r1
 80105a0:	8989      	ldrh	r1, [r1, #12]
 80105a2:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 80105a6:	f021 0102 	bic.w	r1, r1, #2
 80105aa:	f8ad 1014 	strh.w	r1, [sp, #20]
 80105ae:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80105b0:	911b      	str	r1, [sp, #108]	; 0x6c
 80105b2:	89e1      	ldrh	r1, [r4, #14]
 80105b4:	f8ad 1016 	strh.w	r1, [sp, #22]
 80105b8:	69e1      	ldr	r1, [r4, #28]
 80105ba:	9109      	str	r1, [sp, #36]	; 0x24
 80105bc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80105be:	910b      	str	r1, [sp, #44]	; 0x2c
 80105c0:	a91c      	add	r1, sp, #112	; 0x70
 80105c2:	9102      	str	r1, [sp, #8]
 80105c4:	9106      	str	r1, [sp, #24]
 80105c6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80105ca:	4606      	mov	r6, r0
 80105cc:	9104      	str	r1, [sp, #16]
 80105ce:	9107      	str	r1, [sp, #28]
 80105d0:	a818      	add	r0, sp, #96	; 0x60
 80105d2:	2100      	movs	r1, #0
 80105d4:	e9cd 3200 	strd	r3, r2, [sp]
 80105d8:	9108      	str	r1, [sp, #32]
 80105da:	f001 fe31 	bl	8012240 <__retarget_lock_init_recursive>
 80105de:	e9dd 3200 	ldrd	r3, r2, [sp]
 80105e2:	a902      	add	r1, sp, #8
 80105e4:	4630      	mov	r0, r6
 80105e6:	f7fe f9ef 	bl	800e9c8 <_vfprintf_r>
 80105ea:	1e05      	subs	r5, r0, #0
 80105ec:	db07      	blt.n	80105fe <__sbprintf+0x62>
 80105ee:	a902      	add	r1, sp, #8
 80105f0:	4630      	mov	r0, r6
 80105f2:	f001 f8f9 	bl	80117e8 <_fflush_r>
 80105f6:	2800      	cmp	r0, #0
 80105f8:	bf18      	it	ne
 80105fa:	f04f 35ff 	movne.w	r5, #4294967295
 80105fe:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8010602:	065b      	lsls	r3, r3, #25
 8010604:	d503      	bpl.n	801060e <__sbprintf+0x72>
 8010606:	89a3      	ldrh	r3, [r4, #12]
 8010608:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801060c:	81a3      	strh	r3, [r4, #12]
 801060e:	9818      	ldr	r0, [sp, #96]	; 0x60
 8010610:	f001 fe18 	bl	8012244 <__retarget_lock_close_recursive>
 8010614:	4628      	mov	r0, r5
 8010616:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 801061a:	bd70      	pop	{r4, r5, r6, pc}

0801061c <__sprint_r.part.0>:
 801061c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010620:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8010622:	049c      	lsls	r4, r3, #18
 8010624:	4690      	mov	r8, r2
 8010626:	d52d      	bpl.n	8010684 <__sprint_r.part.0+0x68>
 8010628:	6893      	ldr	r3, [r2, #8]
 801062a:	6812      	ldr	r2, [r2, #0]
 801062c:	b343      	cbz	r3, 8010680 <__sprint_r.part.0+0x64>
 801062e:	468b      	mov	fp, r1
 8010630:	4606      	mov	r6, r0
 8010632:	f102 0908 	add.w	r9, r2, #8
 8010636:	e959 5a02 	ldrd	r5, sl, [r9, #-8]
 801063a:	ea5f 079a 	movs.w	r7, sl, lsr #2
 801063e:	d015      	beq.n	801066c <__sprint_r.part.0+0x50>
 8010640:	3d04      	subs	r5, #4
 8010642:	2400      	movs	r4, #0
 8010644:	e001      	b.n	801064a <__sprint_r.part.0+0x2e>
 8010646:	42a7      	cmp	r7, r4
 8010648:	d00e      	beq.n	8010668 <__sprint_r.part.0+0x4c>
 801064a:	f855 1f04 	ldr.w	r1, [r5, #4]!
 801064e:	465a      	mov	r2, fp
 8010650:	4630      	mov	r0, r6
 8010652:	f001 fce7 	bl	8012024 <_fputwc_r>
 8010656:	1c43      	adds	r3, r0, #1
 8010658:	f104 0401 	add.w	r4, r4, #1
 801065c:	d1f3      	bne.n	8010646 <__sprint_r.part.0+0x2a>
 801065e:	2300      	movs	r3, #0
 8010660:	e9c8 3301 	strd	r3, r3, [r8, #4]
 8010664:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010668:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801066c:	f02a 0a03 	bic.w	sl, sl, #3
 8010670:	eba3 030a 	sub.w	r3, r3, sl
 8010674:	f8c8 3008 	str.w	r3, [r8, #8]
 8010678:	f109 0908 	add.w	r9, r9, #8
 801067c:	2b00      	cmp	r3, #0
 801067e:	d1da      	bne.n	8010636 <__sprint_r.part.0+0x1a>
 8010680:	2000      	movs	r0, #0
 8010682:	e7ec      	b.n	801065e <__sprint_r.part.0+0x42>
 8010684:	f001 f99a 	bl	80119bc <__sfvwrite_r>
 8010688:	2300      	movs	r3, #0
 801068a:	e9c8 3301 	strd	r3, r3, [r8, #4]
 801068e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010692:	bf00      	nop

08010694 <__sprint_r>:
 8010694:	b410      	push	{r4}
 8010696:	6894      	ldr	r4, [r2, #8]
 8010698:	b11c      	cbz	r4, 80106a2 <__sprint_r+0xe>
 801069a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801069e:	f7ff bfbd 	b.w	801061c <__sprint_r.part.0>
 80106a2:	4620      	mov	r0, r4
 80106a4:	6054      	str	r4, [r2, #4]
 80106a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80106aa:	4770      	bx	lr

080106ac <_vfiprintf_r>:
 80106ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80106b0:	ed2d 8b02 	vpush	{d8}
 80106b4:	b0c5      	sub	sp, #276	; 0x114
 80106b6:	f10d 0a50 	add.w	sl, sp, #80	; 0x50
 80106ba:	4683      	mov	fp, r0
 80106bc:	ee08 1a10 	vmov	s16, r1
 80106c0:	4616      	mov	r6, r2
 80106c2:	2100      	movs	r1, #0
 80106c4:	2208      	movs	r2, #8
 80106c6:	4650      	mov	r0, sl
 80106c8:	461c      	mov	r4, r3
 80106ca:	9307      	str	r3, [sp, #28]
 80106cc:	f7fe f88a 	bl	800e7e4 <memset>
 80106d0:	f1bb 0f00 	cmp.w	fp, #0
 80106d4:	d004      	beq.n	80106e0 <_vfiprintf_r+0x34>
 80106d6:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 80106da:	2b00      	cmp	r3, #0
 80106dc:	f000 86a0 	beq.w	8011420 <_vfiprintf_r+0xd74>
 80106e0:	ee18 2a10 	vmov	r2, s16
 80106e4:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80106e6:	07db      	lsls	r3, r3, #31
 80106e8:	f140 8513 	bpl.w	8011112 <_vfiprintf_r+0xa66>
 80106ec:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
 80106f0:	b28a      	uxth	r2, r1
 80106f2:	0495      	lsls	r5, r2, #18
 80106f4:	d40b      	bmi.n	801070e <_vfiprintf_r+0x62>
 80106f6:	ee18 3a10 	vmov	r3, s16
 80106fa:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 80106fe:	8199      	strh	r1, [r3, #12]
 8010700:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8010702:	b28a      	uxth	r2, r1
 8010704:	ee18 1a10 	vmov	r1, s16
 8010708:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 801070c:	664b      	str	r3, [r1, #100]	; 0x64
 801070e:	0710      	lsls	r0, r2, #28
 8010710:	f140 8105 	bpl.w	801091e <_vfiprintf_r+0x272>
 8010714:	ee18 3a10 	vmov	r3, s16
 8010718:	691b      	ldr	r3, [r3, #16]
 801071a:	2b00      	cmp	r3, #0
 801071c:	f000 80ff 	beq.w	801091e <_vfiprintf_r+0x272>
 8010720:	f002 031a 	and.w	r3, r2, #26
 8010724:	2b0a      	cmp	r3, #10
 8010726:	f000 810a 	beq.w	801093e <_vfiprintf_r+0x292>
 801072a:	2300      	movs	r3, #0
 801072c:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
 8010730:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8010734:	aa1b      	add	r2, sp, #108	; 0x6c
 8010736:	930c      	str	r3, [sp, #48]	; 0x30
 8010738:	9218      	str	r2, [sp, #96]	; 0x60
 801073a:	4691      	mov	r9, r2
 801073c:	930b      	str	r3, [sp, #44]	; 0x2c
 801073e:	9305      	str	r3, [sp, #20]
 8010740:	46b0      	mov	r8, r6
 8010742:	4644      	mov	r4, r8
 8010744:	4ba8      	ldr	r3, [pc, #672]	; (80109e8 <_vfiprintf_r+0x33c>)
 8010746:	f8d3 50e4 	ldr.w	r5, [r3, #228]	; 0xe4
 801074a:	f001 fd1b 	bl	8012184 <__locale_mb_cur_max>
 801074e:	4622      	mov	r2, r4
 8010750:	4603      	mov	r3, r0
 8010752:	a912      	add	r1, sp, #72	; 0x48
 8010754:	f8cd a000 	str.w	sl, [sp]
 8010758:	4658      	mov	r0, fp
 801075a:	47a8      	blx	r5
 801075c:	2800      	cmp	r0, #0
 801075e:	f000 8145 	beq.w	80109ec <_vfiprintf_r+0x340>
 8010762:	f2c0 8139 	blt.w	80109d8 <_vfiprintf_r+0x32c>
 8010766:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8010768:	2a25      	cmp	r2, #37	; 0x25
 801076a:	4603      	mov	r3, r0
 801076c:	d001      	beq.n	8010772 <_vfiprintf_r+0xc6>
 801076e:	441c      	add	r4, r3
 8010770:	e7e8      	b.n	8010744 <_vfiprintf_r+0x98>
 8010772:	ebb4 0608 	subs.w	r6, r4, r8
 8010776:	4605      	mov	r5, r0
 8010778:	f040 813c 	bne.w	80109f4 <_vfiprintf_r+0x348>
 801077c:	2300      	movs	r3, #0
 801077e:	7861      	ldrb	r1, [r4, #1]
 8010780:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
 8010784:	f104 0801 	add.w	r8, r4, #1
 8010788:	9306      	str	r3, [sp, #24]
 801078a:	f04f 37ff 	mov.w	r7, #4294967295
 801078e:	461e      	mov	r6, r3
 8010790:	242b      	movs	r4, #43	; 0x2b
 8010792:	f108 0801 	add.w	r8, r8, #1
 8010796:	f1a1 0320 	sub.w	r3, r1, #32
 801079a:	2b5a      	cmp	r3, #90	; 0x5a
 801079c:	f200 8178 	bhi.w	8010a90 <_vfiprintf_r+0x3e4>
 80107a0:	e8df f013 	tbh	[pc, r3, lsl #1]
 80107a4:	017602b5 	.word	0x017602b5
 80107a8:	02b00176 	.word	0x02b00176
 80107ac:	01760176 	.word	0x01760176
 80107b0:	006a0176 	.word	0x006a0176
 80107b4:	01760176 	.word	0x01760176
 80107b8:	028d027d 	.word	0x028d027d
 80107bc:	02880176 	.word	0x02880176
 80107c0:	01760297 	.word	0x01760297
 80107c4:	005b0292 	.word	0x005b0292
 80107c8:	005b005b 	.word	0x005b005b
 80107cc:	005b005b 	.word	0x005b005b
 80107d0:	005b005b 	.word	0x005b005b
 80107d4:	005b005b 	.word	0x005b005b
 80107d8:	01760176 	.word	0x01760176
 80107dc:	01760176 	.word	0x01760176
 80107e0:	01760176 	.word	0x01760176
 80107e4:	01760176 	.word	0x01760176
 80107e8:	025c0176 	.word	0x025c0176
 80107ec:	01760084 	.word	0x01760084
 80107f0:	01760176 	.word	0x01760176
 80107f4:	01760176 	.word	0x01760176
 80107f8:	01760176 	.word	0x01760176
 80107fc:	01760176 	.word	0x01760176
 8010800:	00e80176 	.word	0x00e80176
 8010804:	01760176 	.word	0x01760176
 8010808:	02330176 	.word	0x02330176
 801080c:	02da0176 	.word	0x02da0176
 8010810:	01760176 	.word	0x01760176
 8010814:	0176058b 	.word	0x0176058b
 8010818:	01760176 	.word	0x01760176
 801081c:	01760176 	.word	0x01760176
 8010820:	01760176 	.word	0x01760176
 8010824:	01760176 	.word	0x01760176
 8010828:	025c0176 	.word	0x025c0176
 801082c:	01760086 	.word	0x01760086
 8010830:	01760176 	.word	0x01760176
 8010834:	008602cd 	.word	0x008602cd
 8010838:	0176007f 	.word	0x0176007f
 801083c:	017602c0 	.word	0x017602c0
 8010840:	00ea02fd 	.word	0x00ea02fd
 8010844:	007f02ed 	.word	0x007f02ed
 8010848:	02330176 	.word	0x02330176
 801084c:	0569007c 	.word	0x0569007c
 8010850:	01760176 	.word	0x01760176
 8010854:	0176056b 	.word	0x0176056b
 8010858:	007c      	.short	0x007c
 801085a:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 801085e:	2200      	movs	r2, #0
 8010860:	f818 1b01 	ldrb.w	r1, [r8], #1
 8010864:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8010868:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 801086c:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8010870:	2b09      	cmp	r3, #9
 8010872:	d9f5      	bls.n	8010860 <_vfiprintf_r+0x1b4>
 8010874:	9206      	str	r2, [sp, #24]
 8010876:	e78e      	b.n	8010796 <_vfiprintf_r+0xea>
 8010878:	4658      	mov	r0, fp
 801087a:	f001 fc89 	bl	8012190 <_localeconv_r>
 801087e:	6843      	ldr	r3, [r0, #4]
 8010880:	930d      	str	r3, [sp, #52]	; 0x34
 8010882:	4618      	mov	r0, r3
 8010884:	f7f0 f81c 	bl	80008c0 <strlen>
 8010888:	900e      	str	r0, [sp, #56]	; 0x38
 801088a:	4605      	mov	r5, r0
 801088c:	4658      	mov	r0, fp
 801088e:	f001 fc7f 	bl	8012190 <_localeconv_r>
 8010892:	6883      	ldr	r3, [r0, #8]
 8010894:	930b      	str	r3, [sp, #44]	; 0x2c
 8010896:	2d00      	cmp	r5, #0
 8010898:	f040 84d6 	bne.w	8011248 <_vfiprintf_r+0xb9c>
 801089c:	f898 1000 	ldrb.w	r1, [r8]
 80108a0:	e777      	b.n	8010792 <_vfiprintf_r+0xe6>
 80108a2:	f898 1000 	ldrb.w	r1, [r8]
 80108a6:	f046 0620 	orr.w	r6, r6, #32
 80108aa:	e772      	b.n	8010792 <_vfiprintf_r+0xe6>
 80108ac:	f046 0610 	orr.w	r6, r6, #16
 80108b0:	06b4      	lsls	r4, r6, #26
 80108b2:	f140 818e 	bpl.w	8010bd2 <_vfiprintf_r+0x526>
 80108b6:	9b07      	ldr	r3, [sp, #28]
 80108b8:	3307      	adds	r3, #7
 80108ba:	f023 0307 	bic.w	r3, r3, #7
 80108be:	461a      	mov	r2, r3
 80108c0:	6859      	ldr	r1, [r3, #4]
 80108c2:	f852 3b08 	ldr.w	r3, [r2], #8
 80108c6:	9207      	str	r2, [sp, #28]
 80108c8:	460a      	mov	r2, r1
 80108ca:	2900      	cmp	r1, #0
 80108cc:	f2c0 8470 	blt.w	80111b0 <_vfiprintf_r+0xb04>
 80108d0:	1c79      	adds	r1, r7, #1
 80108d2:	f000 85a2 	beq.w	801141a <_vfiprintf_r+0xd6e>
 80108d6:	f026 0180 	bic.w	r1, r6, #128	; 0x80
 80108da:	9103      	str	r1, [sp, #12]
 80108dc:	ea53 0102 	orrs.w	r1, r3, r2
 80108e0:	f000 843f 	beq.w	8011162 <_vfiprintf_r+0xab6>
 80108e4:	2b0a      	cmp	r3, #10
 80108e6:	f172 0100 	sbcs.w	r1, r2, #0
 80108ea:	f080 8541 	bcs.w	8011370 <_vfiprintf_r+0xcc4>
 80108ee:	3330      	adds	r3, #48	; 0x30
 80108f0:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 80108f4:	9e03      	ldr	r6, [sp, #12]
 80108f6:	2301      	movs	r3, #1
 80108f8:	9304      	str	r3, [sp, #16]
 80108fa:	f20d 140f 	addw	r4, sp, #271	; 0x10f
 80108fe:	9b04      	ldr	r3, [sp, #16]
 8010900:	42bb      	cmp	r3, r7
 8010902:	bfb8      	it	lt
 8010904:	463b      	movlt	r3, r7
 8010906:	9303      	str	r3, [sp, #12]
 8010908:	2300      	movs	r3, #0
 801090a:	9308      	str	r3, [sp, #32]
 801090c:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
 8010910:	2b00      	cmp	r3, #0
 8010912:	f000 80cb 	beq.w	8010aac <_vfiprintf_r+0x400>
 8010916:	9b03      	ldr	r3, [sp, #12]
 8010918:	3301      	adds	r3, #1
 801091a:	9303      	str	r3, [sp, #12]
 801091c:	e0c6      	b.n	8010aac <_vfiprintf_r+0x400>
 801091e:	ee18 1a10 	vmov	r1, s16
 8010922:	4658      	mov	r0, fp
 8010924:	ee18 5a10 	vmov	r5, s16
 8010928:	f001 fac0 	bl	8011eac <__swsetup_r>
 801092c:	2800      	cmp	r0, #0
 801092e:	f040 8652 	bne.w	80115d6 <_vfiprintf_r+0xf2a>
 8010932:	89aa      	ldrh	r2, [r5, #12]
 8010934:	f002 031a 	and.w	r3, r2, #26
 8010938:	2b0a      	cmp	r3, #10
 801093a:	f47f aef6 	bne.w	801072a <_vfiprintf_r+0x7e>
 801093e:	ee18 1a10 	vmov	r1, s16
 8010942:	f9b1 300e 	ldrsh.w	r3, [r1, #14]
 8010946:	2b00      	cmp	r3, #0
 8010948:	f6ff aeef 	blt.w	801072a <_vfiprintf_r+0x7e>
 801094c:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 801094e:	07db      	lsls	r3, r3, #31
 8010950:	d402      	bmi.n	8010958 <_vfiprintf_r+0x2ac>
 8010952:	0597      	lsls	r7, r2, #22
 8010954:	f140 8612 	bpl.w	801157c <_vfiprintf_r+0xed0>
 8010958:	ee18 1a10 	vmov	r1, s16
 801095c:	4623      	mov	r3, r4
 801095e:	4632      	mov	r2, r6
 8010960:	4658      	mov	r0, fp
 8010962:	f000 fe69 	bl	8011638 <__sbprintf>
 8010966:	9005      	str	r0, [sp, #20]
 8010968:	9805      	ldr	r0, [sp, #20]
 801096a:	b045      	add	sp, #276	; 0x114
 801096c:	ecbd 8b02 	vpop	{d8}
 8010970:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010974:	f046 0610 	orr.w	r6, r6, #16
 8010978:	f016 0220 	ands.w	r2, r6, #32
 801097c:	f000 8136 	beq.w	8010bec <_vfiprintf_r+0x540>
 8010980:	9b07      	ldr	r3, [sp, #28]
 8010982:	3307      	adds	r3, #7
 8010984:	f023 0307 	bic.w	r3, r3, #7
 8010988:	4619      	mov	r1, r3
 801098a:	685a      	ldr	r2, [r3, #4]
 801098c:	f851 3b08 	ldr.w	r3, [r1], #8
 8010990:	9107      	str	r1, [sp, #28]
 8010992:	f426 6180 	bic.w	r1, r6, #1024	; 0x400
 8010996:	9103      	str	r1, [sp, #12]
 8010998:	2100      	movs	r1, #0
 801099a:	2000      	movs	r0, #0
 801099c:	f88d 0043 	strb.w	r0, [sp, #67]	; 0x43
 80109a0:	1c78      	adds	r0, r7, #1
 80109a2:	f000 8210 	beq.w	8010dc6 <_vfiprintf_r+0x71a>
 80109a6:	9803      	ldr	r0, [sp, #12]
 80109a8:	f020 0680 	bic.w	r6, r0, #128	; 0x80
 80109ac:	ea53 0002 	orrs.w	r0, r3, r2
 80109b0:	f040 8208 	bne.w	8010dc4 <_vfiprintf_r+0x718>
 80109b4:	2f00      	cmp	r7, #0
 80109b6:	f040 8538 	bne.w	801142a <_vfiprintf_r+0xd7e>
 80109ba:	2900      	cmp	r1, #0
 80109bc:	f040 83d5 	bne.w	801116a <_vfiprintf_r+0xabe>
 80109c0:	9b03      	ldr	r3, [sp, #12]
 80109c2:	f013 0301 	ands.w	r3, r3, #1
 80109c6:	9304      	str	r3, [sp, #16]
 80109c8:	f000 8411 	beq.w	80111ee <_vfiprintf_r+0xb42>
 80109cc:	2330      	movs	r3, #48	; 0x30
 80109ce:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
 80109d2:	f20d 140f 	addw	r4, sp, #271	; 0x10f
 80109d6:	e792      	b.n	80108fe <_vfiprintf_r+0x252>
 80109d8:	2208      	movs	r2, #8
 80109da:	2100      	movs	r1, #0
 80109dc:	4650      	mov	r0, sl
 80109de:	f7fd ff01 	bl	800e7e4 <memset>
 80109e2:	2301      	movs	r3, #1
 80109e4:	441c      	add	r4, r3
 80109e6:	e6ad      	b.n	8010744 <_vfiprintf_r+0x98>
 80109e8:	24000170 	.word	0x24000170
 80109ec:	ebb4 0608 	subs.w	r6, r4, r8
 80109f0:	4605      	mov	r5, r0
 80109f2:	d01b      	beq.n	8010a2c <_vfiprintf_r+0x380>
 80109f4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80109f6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80109f8:	3301      	adds	r3, #1
 80109fa:	4432      	add	r2, r6
 80109fc:	2b07      	cmp	r3, #7
 80109fe:	e9c9 8600 	strd	r8, r6, [r9]
 8010a02:	921a      	str	r2, [sp, #104]	; 0x68
 8010a04:	9319      	str	r3, [sp, #100]	; 0x64
 8010a06:	dd1c      	ble.n	8010a42 <_vfiprintf_r+0x396>
 8010a08:	2a00      	cmp	r2, #0
 8010a0a:	f000 83a6 	beq.w	801115a <_vfiprintf_r+0xaae>
 8010a0e:	ee18 1a10 	vmov	r1, s16
 8010a12:	aa18      	add	r2, sp, #96	; 0x60
 8010a14:	4658      	mov	r0, fp
 8010a16:	f7ff fe01 	bl	801061c <__sprint_r.part.0>
 8010a1a:	bb20      	cbnz	r0, 8010a66 <_vfiprintf_r+0x3ba>
 8010a1c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010a20:	9b05      	ldr	r3, [sp, #20]
 8010a22:	4433      	add	r3, r6
 8010a24:	9305      	str	r3, [sp, #20]
 8010a26:	2d00      	cmp	r5, #0
 8010a28:	f47f aea8 	bne.w	801077c <_vfiprintf_r+0xd0>
 8010a2c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8010a2e:	2b00      	cmp	r3, #0
 8010a30:	f040 85c1 	bne.w	80115b6 <_vfiprintf_r+0xf0a>
 8010a34:	ee18 3a10 	vmov	r3, s16
 8010a38:	2200      	movs	r2, #0
 8010a3a:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8010a3e:	9219      	str	r2, [sp, #100]	; 0x64
 8010a40:	e015      	b.n	8010a6e <_vfiprintf_r+0x3c2>
 8010a42:	f109 0908 	add.w	r9, r9, #8
 8010a46:	e7eb      	b.n	8010a20 <_vfiprintf_r+0x374>
 8010a48:	ee18 1a10 	vmov	r1, s16
 8010a4c:	aa18      	add	r2, sp, #96	; 0x60
 8010a4e:	4658      	mov	r0, fp
 8010a50:	f7ff fde4 	bl	801061c <__sprint_r.part.0>
 8010a54:	2800      	cmp	r0, #0
 8010a56:	f000 80a6 	beq.w	8010ba6 <_vfiprintf_r+0x4fa>
 8010a5a:	9b08      	ldr	r3, [sp, #32]
 8010a5c:	b11b      	cbz	r3, 8010a66 <_vfiprintf_r+0x3ba>
 8010a5e:	9908      	ldr	r1, [sp, #32]
 8010a60:	4658      	mov	r0, fp
 8010a62:	f002 fb8b 	bl	801317c <_free_r>
 8010a66:	ee18 3a10 	vmov	r3, s16
 8010a6a:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8010a6e:	ee18 2a10 	vmov	r2, s16
 8010a72:	6e52      	ldr	r2, [r2, #100]	; 0x64
 8010a74:	f012 0f01 	tst.w	r2, #1
 8010a78:	b29a      	uxth	r2, r3
 8010a7a:	f000 80a0 	beq.w	8010bbe <_vfiprintf_r+0x512>
 8010a7e:	0650      	lsls	r0, r2, #25
 8010a80:	f100 85b2 	bmi.w	80115e8 <_vfiprintf_r+0xf3c>
 8010a84:	9805      	ldr	r0, [sp, #20]
 8010a86:	b045      	add	sp, #276	; 0x114
 8010a88:	ecbd 8b02 	vpop	{d8}
 8010a8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010a90:	2900      	cmp	r1, #0
 8010a92:	d0cb      	beq.n	8010a2c <_vfiprintf_r+0x380>
 8010a94:	2300      	movs	r3, #0
 8010a96:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
 8010a9a:	2301      	movs	r3, #1
 8010a9c:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8010aa0:	f88d 10ac 	strb.w	r1, [sp, #172]	; 0xac
 8010aa4:	ac2b      	add	r4, sp, #172	; 0xac
 8010aa6:	2300      	movs	r3, #0
 8010aa8:	9308      	str	r3, [sp, #32]
 8010aaa:	461f      	mov	r7, r3
 8010aac:	f016 0302 	ands.w	r3, r6, #2
 8010ab0:	9309      	str	r3, [sp, #36]	; 0x24
 8010ab2:	d002      	beq.n	8010aba <_vfiprintf_r+0x40e>
 8010ab4:	9b03      	ldr	r3, [sp, #12]
 8010ab6:	3302      	adds	r3, #2
 8010ab8:	9303      	str	r3, [sp, #12]
 8010aba:	f016 0384 	ands.w	r3, r6, #132	; 0x84
 8010abe:	930a      	str	r3, [sp, #40]	; 0x28
 8010ac0:	d105      	bne.n	8010ace <_vfiprintf_r+0x422>
 8010ac2:	9b06      	ldr	r3, [sp, #24]
 8010ac4:	9a03      	ldr	r2, [sp, #12]
 8010ac6:	1a9d      	subs	r5, r3, r2
 8010ac8:	2d00      	cmp	r5, #0
 8010aca:	f300 827b 	bgt.w	8010fc4 <_vfiprintf_r+0x918>
 8010ace:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 8010ad2:	1c41      	adds	r1, r0, #1
 8010ad4:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
 8010ad8:	b182      	cbz	r2, 8010afc <_vfiprintf_r+0x450>
 8010ada:	2201      	movs	r2, #1
 8010adc:	3301      	adds	r3, #1
 8010ade:	f8c9 2004 	str.w	r2, [r9, #4]
 8010ae2:	2907      	cmp	r1, #7
 8010ae4:	f10d 0243 	add.w	r2, sp, #67	; 0x43
 8010ae8:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
 8010aec:	f8c9 2000 	str.w	r2, [r9]
 8010af0:	f300 824a 	bgt.w	8010f88 <_vfiprintf_r+0x8dc>
 8010af4:	4608      	mov	r0, r1
 8010af6:	f109 0908 	add.w	r9, r9, #8
 8010afa:	3101      	adds	r1, #1
 8010afc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010afe:	b1e2      	cbz	r2, 8010b3a <_vfiprintf_r+0x48e>
 8010b00:	aa11      	add	r2, sp, #68	; 0x44
 8010b02:	3302      	adds	r3, #2
 8010b04:	f8c9 2000 	str.w	r2, [r9]
 8010b08:	2907      	cmp	r1, #7
 8010b0a:	f04f 0202 	mov.w	r2, #2
 8010b0e:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
 8010b12:	f8c9 2004 	str.w	r2, [r9, #4]
 8010b16:	f340 8250 	ble.w	8010fba <_vfiprintf_r+0x90e>
 8010b1a:	2b00      	cmp	r3, #0
 8010b1c:	f000 8343 	beq.w	80111a6 <_vfiprintf_r+0xafa>
 8010b20:	ee18 1a10 	vmov	r1, s16
 8010b24:	aa18      	add	r2, sp, #96	; 0x60
 8010b26:	4658      	mov	r0, fp
 8010b28:	f7ff fd78 	bl	801061c <__sprint_r.part.0>
 8010b2c:	2800      	cmp	r0, #0
 8010b2e:	d194      	bne.n	8010a5a <_vfiprintf_r+0x3ae>
 8010b30:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 8010b34:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010b38:	1c41      	adds	r1, r0, #1
 8010b3a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010b3c:	2a80      	cmp	r2, #128	; 0x80
 8010b3e:	f000 8184 	beq.w	8010e4a <_vfiprintf_r+0x79e>
 8010b42:	9a04      	ldr	r2, [sp, #16]
 8010b44:	1abd      	subs	r5, r7, r2
 8010b46:	2d00      	cmp	r5, #0
 8010b48:	f300 81d7 	bgt.w	8010efa <_vfiprintf_r+0x84e>
 8010b4c:	9a04      	ldr	r2, [sp, #16]
 8010b4e:	f8c9 4000 	str.w	r4, [r9]
 8010b52:	4413      	add	r3, r2
 8010b54:	2907      	cmp	r1, #7
 8010b56:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
 8010b5a:	f8c9 2004 	str.w	r2, [r9, #4]
 8010b5e:	f340 816e 	ble.w	8010e3e <_vfiprintf_r+0x792>
 8010b62:	2b00      	cmp	r3, #0
 8010b64:	f000 8275 	beq.w	8011052 <_vfiprintf_r+0x9a6>
 8010b68:	ee18 1a10 	vmov	r1, s16
 8010b6c:	aa18      	add	r2, sp, #96	; 0x60
 8010b6e:	4658      	mov	r0, fp
 8010b70:	f7ff fd54 	bl	801061c <__sprint_r.part.0>
 8010b74:	2800      	cmp	r0, #0
 8010b76:	f47f af70 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 8010b7a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8010b7c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010b80:	0775      	lsls	r5, r6, #29
 8010b82:	d505      	bpl.n	8010b90 <_vfiprintf_r+0x4e4>
 8010b84:	9a06      	ldr	r2, [sp, #24]
 8010b86:	9903      	ldr	r1, [sp, #12]
 8010b88:	1a54      	subs	r4, r2, r1
 8010b8a:	2c00      	cmp	r4, #0
 8010b8c:	f300 826b 	bgt.w	8011066 <_vfiprintf_r+0x9ba>
 8010b90:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 8010b94:	9803      	ldr	r0, [sp, #12]
 8010b96:	4281      	cmp	r1, r0
 8010b98:	bfac      	ite	ge
 8010b9a:	1852      	addge	r2, r2, r1
 8010b9c:	1812      	addlt	r2, r2, r0
 8010b9e:	9205      	str	r2, [sp, #20]
 8010ba0:	2b00      	cmp	r3, #0
 8010ba2:	f47f af51 	bne.w	8010a48 <_vfiprintf_r+0x39c>
 8010ba6:	9908      	ldr	r1, [sp, #32]
 8010ba8:	2300      	movs	r3, #0
 8010baa:	9319      	str	r3, [sp, #100]	; 0x64
 8010bac:	2900      	cmp	r1, #0
 8010bae:	f000 8149 	beq.w	8010e44 <_vfiprintf_r+0x798>
 8010bb2:	4658      	mov	r0, fp
 8010bb4:	f002 fae2 	bl	801317c <_free_r>
 8010bb8:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010bbc:	e5c1      	b.n	8010742 <_vfiprintf_r+0x96>
 8010bbe:	059c      	lsls	r4, r3, #22
 8010bc0:	f53f af5d 	bmi.w	8010a7e <_vfiprintf_r+0x3d2>
 8010bc4:	ee18 4a10 	vmov	r4, s16
 8010bc8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8010bca:	f001 fb3f 	bl	801224c <__retarget_lock_release_recursive>
 8010bce:	89a2      	ldrh	r2, [r4, #12]
 8010bd0:	e755      	b.n	8010a7e <_vfiprintf_r+0x3d2>
 8010bd2:	06f0      	lsls	r0, r6, #27
 8010bd4:	9a07      	ldr	r2, [sp, #28]
 8010bd6:	f100 831f 	bmi.w	8011218 <_vfiprintf_r+0xb6c>
 8010bda:	0671      	lsls	r1, r6, #25
 8010bdc:	f140 8319 	bpl.w	8011212 <_vfiprintf_r+0xb66>
 8010be0:	f932 3b04 	ldrsh.w	r3, [r2], #4
 8010be4:	9207      	str	r2, [sp, #28]
 8010be6:	17da      	asrs	r2, r3, #31
 8010be8:	4611      	mov	r1, r2
 8010bea:	e66e      	b.n	80108ca <_vfiprintf_r+0x21e>
 8010bec:	f016 0310 	ands.w	r3, r6, #16
 8010bf0:	9907      	ldr	r1, [sp, #28]
 8010bf2:	f040 8309 	bne.w	8011208 <_vfiprintf_r+0xb5c>
 8010bf6:	f016 0040 	ands.w	r0, r6, #64	; 0x40
 8010bfa:	f000 8301 	beq.w	8011200 <_vfiprintf_r+0xb54>
 8010bfe:	461a      	mov	r2, r3
 8010c00:	f851 3b04 	ldr.w	r3, [r1], #4
 8010c04:	9107      	str	r1, [sp, #28]
 8010c06:	b29b      	uxth	r3, r3
 8010c08:	e6c3      	b.n	8010992 <_vfiprintf_r+0x2e6>
 8010c0a:	9b07      	ldr	r3, [sp, #28]
 8010c0c:	461a      	mov	r2, r3
 8010c0e:	2300      	movs	r3, #0
 8010c10:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
 8010c14:	4613      	mov	r3, r2
 8010c16:	f853 4b04 	ldr.w	r4, [r3], #4
 8010c1a:	9303      	str	r3, [sp, #12]
 8010c1c:	2c00      	cmp	r4, #0
 8010c1e:	f000 8412 	beq.w	8011446 <_vfiprintf_r+0xd9a>
 8010c22:	2953      	cmp	r1, #83	; 0x53
 8010c24:	f000 8365 	beq.w	80112f2 <_vfiprintf_r+0xc46>
 8010c28:	f016 0510 	ands.w	r5, r6, #16
 8010c2c:	f040 8361 	bne.w	80112f2 <_vfiprintf_r+0xc46>
 8010c30:	1c7b      	adds	r3, r7, #1
 8010c32:	f000 84b3 	beq.w	801159c <_vfiprintf_r+0xef0>
 8010c36:	463a      	mov	r2, r7
 8010c38:	4629      	mov	r1, r5
 8010c3a:	4620      	mov	r0, r4
 8010c3c:	f7ef feb0 	bl	80009a0 <memchr>
 8010c40:	9008      	str	r0, [sp, #32]
 8010c42:	2800      	cmp	r0, #0
 8010c44:	f000 849f 	beq.w	8011586 <_vfiprintf_r+0xeda>
 8010c48:	1b03      	subs	r3, r0, r4
 8010c4a:	9a03      	ldr	r2, [sp, #12]
 8010c4c:	9304      	str	r3, [sp, #16]
 8010c4e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8010c52:	462f      	mov	r7, r5
 8010c54:	9207      	str	r2, [sp, #28]
 8010c56:	9303      	str	r3, [sp, #12]
 8010c58:	9508      	str	r5, [sp, #32]
 8010c5a:	e657      	b.n	801090c <_vfiprintf_r+0x260>
 8010c5c:	2943      	cmp	r1, #67	; 0x43
 8010c5e:	d002      	beq.n	8010c66 <_vfiprintf_r+0x5ba>
 8010c60:	06f5      	lsls	r5, r6, #27
 8010c62:	f140 832d 	bpl.w	80112c0 <_vfiprintf_r+0xc14>
 8010c66:	9d07      	ldr	r5, [sp, #28]
 8010c68:	2208      	movs	r2, #8
 8010c6a:	2100      	movs	r1, #0
 8010c6c:	a816      	add	r0, sp, #88	; 0x58
 8010c6e:	ac2b      	add	r4, sp, #172	; 0xac
 8010c70:	f7fd fdb8 	bl	800e7e4 <memset>
 8010c74:	ab16      	add	r3, sp, #88	; 0x58
 8010c76:	f855 2b04 	ldr.w	r2, [r5], #4
 8010c7a:	4621      	mov	r1, r4
 8010c7c:	4658      	mov	r0, fp
 8010c7e:	f003 fc0b 	bl	8014498 <_wcrtomb_r>
 8010c82:	4603      	mov	r3, r0
 8010c84:	3301      	adds	r3, #1
 8010c86:	9004      	str	r0, [sp, #16]
 8010c88:	f000 84b3 	beq.w	80115f2 <_vfiprintf_r+0xf46>
 8010c8c:	9b04      	ldr	r3, [sp, #16]
 8010c8e:	9507      	str	r5, [sp, #28]
 8010c90:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8010c94:	9303      	str	r3, [sp, #12]
 8010c96:	2300      	movs	r3, #0
 8010c98:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
 8010c9c:	e703      	b.n	8010aa6 <_vfiprintf_r+0x3fa>
 8010c9e:	9b07      	ldr	r3, [sp, #28]
 8010ca0:	f853 2b04 	ldr.w	r2, [r3], #4
 8010ca4:	9206      	str	r2, [sp, #24]
 8010ca6:	2a00      	cmp	r2, #0
 8010ca8:	f280 829c 	bge.w	80111e4 <_vfiprintf_r+0xb38>
 8010cac:	9a06      	ldr	r2, [sp, #24]
 8010cae:	4252      	negs	r2, r2
 8010cb0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8010cb4:	f898 1000 	ldrb.w	r1, [r8]
 8010cb8:	f046 0604 	orr.w	r6, r6, #4
 8010cbc:	e569      	b.n	8010792 <_vfiprintf_r+0xe6>
 8010cbe:	f898 1000 	ldrb.w	r1, [r8]
 8010cc2:	f88d 4043 	strb.w	r4, [sp, #67]	; 0x43
 8010cc6:	e564      	b.n	8010792 <_vfiprintf_r+0xe6>
 8010cc8:	f898 1000 	ldrb.w	r1, [r8]
 8010ccc:	f046 0680 	orr.w	r6, r6, #128	; 0x80
 8010cd0:	e55f      	b.n	8010792 <_vfiprintf_r+0xe6>
 8010cd2:	4642      	mov	r2, r8
 8010cd4:	f812 1b01 	ldrb.w	r1, [r2], #1
 8010cd8:	292a      	cmp	r1, #42	; 0x2a
 8010cda:	f000 8496 	beq.w	801160a <_vfiprintf_r+0xf5e>
 8010cde:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8010ce2:	2b09      	cmp	r3, #9
 8010ce4:	4690      	mov	r8, r2
 8010ce6:	f04f 0700 	mov.w	r7, #0
 8010cea:	f63f ad54 	bhi.w	8010796 <_vfiprintf_r+0xea>
 8010cee:	f818 1b01 	ldrb.w	r1, [r8], #1
 8010cf2:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8010cf6:	eb03 0747 	add.w	r7, r3, r7, lsl #1
 8010cfa:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8010cfe:	2b09      	cmp	r3, #9
 8010d00:	d9f5      	bls.n	8010cee <_vfiprintf_r+0x642>
 8010d02:	e548      	b.n	8010796 <_vfiprintf_r+0xea>
 8010d04:	f898 1000 	ldrb.w	r1, [r8]
 8010d08:	f046 0601 	orr.w	r6, r6, #1
 8010d0c:	e541      	b.n	8010792 <_vfiprintf_r+0xe6>
 8010d0e:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
 8010d12:	2b00      	cmp	r3, #0
 8010d14:	f47f adc2 	bne.w	801089c <_vfiprintf_r+0x1f0>
 8010d18:	2320      	movs	r3, #32
 8010d1a:	f898 1000 	ldrb.w	r1, [r8]
 8010d1e:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
 8010d22:	e536      	b.n	8010792 <_vfiprintf_r+0xe6>
 8010d24:	f898 1000 	ldrb.w	r1, [r8]
 8010d28:	296c      	cmp	r1, #108	; 0x6c
 8010d2a:	bf03      	ittte	eq
 8010d2c:	f898 1001 	ldrbeq.w	r1, [r8, #1]
 8010d30:	f046 0620 	orreq.w	r6, r6, #32
 8010d34:	f108 0801 	addeq.w	r8, r8, #1
 8010d38:	f046 0610 	orrne.w	r6, r6, #16
 8010d3c:	e529      	b.n	8010792 <_vfiprintf_r+0xe6>
 8010d3e:	f898 1000 	ldrb.w	r1, [r8]
 8010d42:	2968      	cmp	r1, #104	; 0x68
 8010d44:	bf03      	ittte	eq
 8010d46:	f898 1001 	ldrbeq.w	r1, [r8, #1]
 8010d4a:	f446 7600 	orreq.w	r6, r6, #512	; 0x200
 8010d4e:	f108 0801 	addeq.w	r8, r8, #1
 8010d52:	f046 0640 	orrne.w	r6, r6, #64	; 0x40
 8010d56:	e51c      	b.n	8010792 <_vfiprintf_r+0xe6>
 8010d58:	f046 0310 	orr.w	r3, r6, #16
 8010d5c:	9303      	str	r3, [sp, #12]
 8010d5e:	9b03      	ldr	r3, [sp, #12]
 8010d60:	f013 0220 	ands.w	r2, r3, #32
 8010d64:	f000 8206 	beq.w	8011174 <_vfiprintf_r+0xac8>
 8010d68:	9b07      	ldr	r3, [sp, #28]
 8010d6a:	3307      	adds	r3, #7
 8010d6c:	f023 0307 	bic.w	r3, r3, #7
 8010d70:	4619      	mov	r1, r3
 8010d72:	685a      	ldr	r2, [r3, #4]
 8010d74:	f851 3b08 	ldr.w	r3, [r1], #8
 8010d78:	9107      	str	r1, [sp, #28]
 8010d7a:	2101      	movs	r1, #1
 8010d7c:	e60d      	b.n	801099a <_vfiprintf_r+0x2ee>
 8010d7e:	9a07      	ldr	r2, [sp, #28]
 8010d80:	f046 0302 	orr.w	r3, r6, #2
 8010d84:	9303      	str	r3, [sp, #12]
 8010d86:	f852 3b04 	ldr.w	r3, [r2], #4
 8010d8a:	9207      	str	r2, [sp, #28]
 8010d8c:	f647 0230 	movw	r2, #30768	; 0x7830
 8010d90:	f8ad 2044 	strh.w	r2, [sp, #68]	; 0x44
 8010d94:	4ab8      	ldr	r2, [pc, #736]	; (8011078 <_vfiprintf_r+0x9cc>)
 8010d96:	920c      	str	r2, [sp, #48]	; 0x30
 8010d98:	2102      	movs	r1, #2
 8010d9a:	2200      	movs	r2, #0
 8010d9c:	e5fd      	b.n	801099a <_vfiprintf_r+0x2ee>
 8010d9e:	06b7      	lsls	r7, r6, #26
 8010da0:	f100 8248 	bmi.w	8011234 <_vfiprintf_r+0xb88>
 8010da4:	06f5      	lsls	r5, r6, #27
 8010da6:	f100 8346 	bmi.w	8011436 <_vfiprintf_r+0xd8a>
 8010daa:	0674      	lsls	r4, r6, #25
 8010dac:	f100 83d5 	bmi.w	801155a <_vfiprintf_r+0xeae>
 8010db0:	05b0      	lsls	r0, r6, #22
 8010db2:	f140 8340 	bpl.w	8011436 <_vfiprintf_r+0xd8a>
 8010db6:	9b07      	ldr	r3, [sp, #28]
 8010db8:	9905      	ldr	r1, [sp, #20]
 8010dba:	f853 2b04 	ldr.w	r2, [r3], #4
 8010dbe:	9307      	str	r3, [sp, #28]
 8010dc0:	7011      	strb	r1, [r2, #0]
 8010dc2:	e4be      	b.n	8010742 <_vfiprintf_r+0x96>
 8010dc4:	9603      	str	r6, [sp, #12]
 8010dc6:	2901      	cmp	r1, #1
 8010dc8:	f43f ad8c 	beq.w	80108e4 <_vfiprintf_r+0x238>
 8010dcc:	2902      	cmp	r1, #2
 8010dce:	ac44      	add	r4, sp, #272	; 0x110
 8010dd0:	d111      	bne.n	8010df6 <_vfiprintf_r+0x74a>
 8010dd2:	980c      	ldr	r0, [sp, #48]	; 0x30
 8010dd4:	f003 010f 	and.w	r1, r3, #15
 8010dd8:	091b      	lsrs	r3, r3, #4
 8010dda:	5c41      	ldrb	r1, [r0, r1]
 8010ddc:	f804 1d01 	strb.w	r1, [r4, #-1]!
 8010de0:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8010de4:	0912      	lsrs	r2, r2, #4
 8010de6:	ea53 0102 	orrs.w	r1, r3, r2
 8010dea:	d1f3      	bne.n	8010dd4 <_vfiprintf_r+0x728>
 8010dec:	9e03      	ldr	r6, [sp, #12]
 8010dee:	ab44      	add	r3, sp, #272	; 0x110
 8010df0:	1b1b      	subs	r3, r3, r4
 8010df2:	9304      	str	r3, [sp, #16]
 8010df4:	e583      	b.n	80108fe <_vfiprintf_r+0x252>
 8010df6:	f003 0107 	and.w	r1, r3, #7
 8010dfa:	08db      	lsrs	r3, r3, #3
 8010dfc:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
 8010e00:	08d2      	lsrs	r2, r2, #3
 8010e02:	3130      	adds	r1, #48	; 0x30
 8010e04:	ea53 0502 	orrs.w	r5, r3, r2
 8010e08:	4620      	mov	r0, r4
 8010e0a:	f804 1d01 	strb.w	r1, [r4, #-1]!
 8010e0e:	d1f2      	bne.n	8010df6 <_vfiprintf_r+0x74a>
 8010e10:	9e03      	ldr	r6, [sp, #12]
 8010e12:	07f3      	lsls	r3, r6, #31
 8010e14:	d5eb      	bpl.n	8010dee <_vfiprintf_r+0x742>
 8010e16:	2930      	cmp	r1, #48	; 0x30
 8010e18:	d0e8      	beq.n	8010dec <_vfiprintf_r+0x740>
 8010e1a:	2330      	movs	r3, #48	; 0x30
 8010e1c:	3802      	subs	r0, #2
 8010e1e:	f804 3c01 	strb.w	r3, [r4, #-1]
 8010e22:	ab44      	add	r3, sp, #272	; 0x110
 8010e24:	1a1b      	subs	r3, r3, r0
 8010e26:	9e03      	ldr	r6, [sp, #12]
 8010e28:	9304      	str	r3, [sp, #16]
 8010e2a:	4604      	mov	r4, r0
 8010e2c:	e567      	b.n	80108fe <_vfiprintf_r+0x252>
 8010e2e:	9b04      	ldr	r3, [sp, #16]
 8010e30:	941b      	str	r4, [sp, #108]	; 0x6c
 8010e32:	2201      	movs	r2, #1
 8010e34:	931c      	str	r3, [sp, #112]	; 0x70
 8010e36:	931a      	str	r3, [sp, #104]	; 0x68
 8010e38:	9219      	str	r2, [sp, #100]	; 0x64
 8010e3a:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010e3e:	f109 0908 	add.w	r9, r9, #8
 8010e42:	e69d      	b.n	8010b80 <_vfiprintf_r+0x4d4>
 8010e44:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010e48:	e47b      	b.n	8010742 <_vfiprintf_r+0x96>
 8010e4a:	9a06      	ldr	r2, [sp, #24]
 8010e4c:	9d03      	ldr	r5, [sp, #12]
 8010e4e:	1b55      	subs	r5, r2, r5
 8010e50:	2d00      	cmp	r5, #0
 8010e52:	f77f ae76 	ble.w	8010b42 <_vfiprintf_r+0x496>
 8010e56:	2d10      	cmp	r5, #16
 8010e58:	f340 83bb 	ble.w	80115d2 <_vfiprintf_r+0xf26>
 8010e5c:	9409      	str	r4, [sp, #36]	; 0x24
 8010e5e:	ee18 4a10 	vmov	r4, s16
 8010e62:	e007      	b.n	8010e74 <_vfiprintf_r+0x7c8>
 8010e64:	f100 0c02 	add.w	ip, r0, #2
 8010e68:	f109 0908 	add.w	r9, r9, #8
 8010e6c:	4610      	mov	r0, r2
 8010e6e:	3d10      	subs	r5, #16
 8010e70:	2d10      	cmp	r5, #16
 8010e72:	dd1e      	ble.n	8010eb2 <_vfiprintf_r+0x806>
 8010e74:	4981      	ldr	r1, [pc, #516]	; (801107c <_vfiprintf_r+0x9d0>)
 8010e76:	f8c9 1000 	str.w	r1, [r9]
 8010e7a:	1c42      	adds	r2, r0, #1
 8010e7c:	3310      	adds	r3, #16
 8010e7e:	2110      	movs	r1, #16
 8010e80:	2a07      	cmp	r2, #7
 8010e82:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
 8010e86:	f8c9 1004 	str.w	r1, [r9, #4]
 8010e8a:	ddeb      	ble.n	8010e64 <_vfiprintf_r+0x7b8>
 8010e8c:	aa18      	add	r2, sp, #96	; 0x60
 8010e8e:	2b00      	cmp	r3, #0
 8010e90:	d074      	beq.n	8010f7c <_vfiprintf_r+0x8d0>
 8010e92:	4621      	mov	r1, r4
 8010e94:	4658      	mov	r0, fp
 8010e96:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010e9a:	f7ff fbbf 	bl	801061c <__sprint_r.part.0>
 8010e9e:	2800      	cmp	r0, #0
 8010ea0:	f47f addb 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 8010ea4:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 8010ea8:	3d10      	subs	r5, #16
 8010eaa:	2d10      	cmp	r5, #16
 8010eac:	f100 0c01 	add.w	ip, r0, #1
 8010eb0:	dce0      	bgt.n	8010e74 <_vfiprintf_r+0x7c8>
 8010eb2:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8010eb4:	4a71      	ldr	r2, [pc, #452]	; (801107c <_vfiprintf_r+0x9d0>)
 8010eb6:	f8c9 5004 	str.w	r5, [r9, #4]
 8010eba:	442b      	add	r3, r5
 8010ebc:	f1bc 0f07 	cmp.w	ip, #7
 8010ec0:	e9cd c319 	strd	ip, r3, [sp, #100]	; 0x64
 8010ec4:	f8c9 2000 	str.w	r2, [r9]
 8010ec8:	f340 8194 	ble.w	80111f4 <_vfiprintf_r+0xb48>
 8010ecc:	2b00      	cmp	r3, #0
 8010ece:	f000 831f 	beq.w	8011510 <_vfiprintf_r+0xe64>
 8010ed2:	ee18 1a10 	vmov	r1, s16
 8010ed6:	aa18      	add	r2, sp, #96	; 0x60
 8010ed8:	4658      	mov	r0, fp
 8010eda:	f7ff fb9f 	bl	801061c <__sprint_r.part.0>
 8010ede:	2800      	cmp	r0, #0
 8010ee0:	f47f adbb 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 8010ee4:	9a04      	ldr	r2, [sp, #16]
 8010ee6:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 8010eea:	1abd      	subs	r5, r7, r2
 8010eec:	2d00      	cmp	r5, #0
 8010eee:	f100 0101 	add.w	r1, r0, #1
 8010ef2:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010ef6:	f77f ae29 	ble.w	8010b4c <_vfiprintf_r+0x4a0>
 8010efa:	2d10      	cmp	r5, #16
 8010efc:	dd29      	ble.n	8010f52 <_vfiprintf_r+0x8a6>
 8010efe:	9409      	str	r4, [sp, #36]	; 0x24
 8010f00:	2710      	movs	r7, #16
 8010f02:	ee18 4a10 	vmov	r4, s16
 8010f06:	e007      	b.n	8010f18 <_vfiprintf_r+0x86c>
 8010f08:	f100 0c02 	add.w	ip, r0, #2
 8010f0c:	f109 0908 	add.w	r9, r9, #8
 8010f10:	4610      	mov	r0, r2
 8010f12:	3d10      	subs	r5, #16
 8010f14:	2d10      	cmp	r5, #16
 8010f16:	dd1a      	ble.n	8010f4e <_vfiprintf_r+0x8a2>
 8010f18:	1c42      	adds	r2, r0, #1
 8010f1a:	4958      	ldr	r1, [pc, #352]	; (801107c <_vfiprintf_r+0x9d0>)
 8010f1c:	3310      	adds	r3, #16
 8010f1e:	2a07      	cmp	r2, #7
 8010f20:	e9c9 1700 	strd	r1, r7, [r9]
 8010f24:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
 8010f28:	ddee      	ble.n	8010f08 <_vfiprintf_r+0x85c>
 8010f2a:	aa18      	add	r2, sp, #96	; 0x60
 8010f2c:	b303      	cbz	r3, 8010f70 <_vfiprintf_r+0x8c4>
 8010f2e:	4621      	mov	r1, r4
 8010f30:	4658      	mov	r0, fp
 8010f32:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010f36:	f7ff fb71 	bl	801061c <__sprint_r.part.0>
 8010f3a:	2800      	cmp	r0, #0
 8010f3c:	f47f ad8d 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 8010f40:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 8010f44:	3d10      	subs	r5, #16
 8010f46:	2d10      	cmp	r5, #16
 8010f48:	f100 0c01 	add.w	ip, r0, #1
 8010f4c:	dce4      	bgt.n	8010f18 <_vfiprintf_r+0x86c>
 8010f4e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8010f50:	4661      	mov	r1, ip
 8010f52:	4a4a      	ldr	r2, [pc, #296]	; (801107c <_vfiprintf_r+0x9d0>)
 8010f54:	f8c9 5004 	str.w	r5, [r9, #4]
 8010f58:	442b      	add	r3, r5
 8010f5a:	2907      	cmp	r1, #7
 8010f5c:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
 8010f60:	f8c9 2000 	str.w	r2, [r9]
 8010f64:	f300 80e7 	bgt.w	8011136 <_vfiprintf_r+0xa8a>
 8010f68:	f109 0908 	add.w	r9, r9, #8
 8010f6c:	3101      	adds	r1, #1
 8010f6e:	e5ed      	b.n	8010b4c <_vfiprintf_r+0x4a0>
 8010f70:	f04f 0c01 	mov.w	ip, #1
 8010f74:	4618      	mov	r0, r3
 8010f76:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010f7a:	e7ca      	b.n	8010f12 <_vfiprintf_r+0x866>
 8010f7c:	f04f 0c01 	mov.w	ip, #1
 8010f80:	4618      	mov	r0, r3
 8010f82:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010f86:	e772      	b.n	8010e6e <_vfiprintf_r+0x7c2>
 8010f88:	2b00      	cmp	r3, #0
 8010f8a:	f000 8104 	beq.w	8011196 <_vfiprintf_r+0xaea>
 8010f8e:	ee18 1a10 	vmov	r1, s16
 8010f92:	aa18      	add	r2, sp, #96	; 0x60
 8010f94:	4658      	mov	r0, fp
 8010f96:	f7ff fb41 	bl	801061c <__sprint_r.part.0>
 8010f9a:	2800      	cmp	r0, #0
 8010f9c:	f47f ad5d 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 8010fa0:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 8010fa4:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010fa8:	1c41      	adds	r1, r0, #1
 8010faa:	e5a7      	b.n	8010afc <_vfiprintf_r+0x450>
 8010fac:	2302      	movs	r3, #2
 8010fae:	aa11      	add	r2, sp, #68	; 0x44
 8010fb0:	931c      	str	r3, [sp, #112]	; 0x70
 8010fb2:	921b      	str	r2, [sp, #108]	; 0x6c
 8010fb4:	2101      	movs	r1, #1
 8010fb6:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8010fba:	4608      	mov	r0, r1
 8010fbc:	f109 0908 	add.w	r9, r9, #8
 8010fc0:	1c41      	adds	r1, r0, #1
 8010fc2:	e5ba      	b.n	8010b3a <_vfiprintf_r+0x48e>
 8010fc4:	2d10      	cmp	r5, #16
 8010fc6:	f340 82e5 	ble.w	8011594 <_vfiprintf_r+0xee8>
 8010fca:	e9dd 1319 	ldrd	r1, r3, [sp, #100]	; 0x64
 8010fce:	940f      	str	r4, [sp, #60]	; 0x3c
 8010fd0:	4608      	mov	r0, r1
 8010fd2:	ee18 4a10 	vmov	r4, s16
 8010fd6:	e007      	b.n	8010fe8 <_vfiprintf_r+0x93c>
 8010fd8:	f100 0c02 	add.w	ip, r0, #2
 8010fdc:	f109 0908 	add.w	r9, r9, #8
 8010fe0:	4610      	mov	r0, r2
 8010fe2:	3d10      	subs	r5, #16
 8010fe4:	2d10      	cmp	r5, #16
 8010fe6:	dd1d      	ble.n	8011024 <_vfiprintf_r+0x978>
 8010fe8:	4925      	ldr	r1, [pc, #148]	; (8011080 <_vfiprintf_r+0x9d4>)
 8010fea:	f8c9 1000 	str.w	r1, [r9]
 8010fee:	1c42      	adds	r2, r0, #1
 8010ff0:	3310      	adds	r3, #16
 8010ff2:	2110      	movs	r1, #16
 8010ff4:	2a07      	cmp	r2, #7
 8010ff6:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
 8010ffa:	f8c9 1004 	str.w	r1, [r9, #4]
 8010ffe:	ddeb      	ble.n	8010fd8 <_vfiprintf_r+0x92c>
 8011000:	aa18      	add	r2, sp, #96	; 0x60
 8011002:	b303      	cbz	r3, 8011046 <_vfiprintf_r+0x99a>
 8011004:	4621      	mov	r1, r4
 8011006:	4658      	mov	r0, fp
 8011008:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 801100c:	f7ff fb06 	bl	801061c <__sprint_r.part.0>
 8011010:	2800      	cmp	r0, #0
 8011012:	f47f ad22 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 8011016:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 801101a:	3d10      	subs	r5, #16
 801101c:	2d10      	cmp	r5, #16
 801101e:	f100 0c01 	add.w	ip, r0, #1
 8011022:	dce1      	bgt.n	8010fe8 <_vfiprintf_r+0x93c>
 8011024:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8011026:	4660      	mov	r0, ip
 8011028:	4a15      	ldr	r2, [pc, #84]	; (8011080 <_vfiprintf_r+0x9d4>)
 801102a:	f8c9 5004 	str.w	r5, [r9, #4]
 801102e:	442b      	add	r3, r5
 8011030:	2807      	cmp	r0, #7
 8011032:	e9cd 0319 	strd	r0, r3, [sp, #100]	; 0x64
 8011036:	f8c9 2000 	str.w	r2, [r9]
 801103a:	f300 80c1 	bgt.w	80111c0 <_vfiprintf_r+0xb14>
 801103e:	f109 0908 	add.w	r9, r9, #8
 8011042:	1c41      	adds	r1, r0, #1
 8011044:	e546      	b.n	8010ad4 <_vfiprintf_r+0x428>
 8011046:	4618      	mov	r0, r3
 8011048:	f04f 0c01 	mov.w	ip, #1
 801104c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8011050:	e7c7      	b.n	8010fe2 <_vfiprintf_r+0x936>
 8011052:	0776      	lsls	r6, r6, #29
 8011054:	9319      	str	r3, [sp, #100]	; 0x64
 8011056:	d553      	bpl.n	8011100 <_vfiprintf_r+0xa54>
 8011058:	9a06      	ldr	r2, [sp, #24]
 801105a:	9903      	ldr	r1, [sp, #12]
 801105c:	1a54      	subs	r4, r2, r1
 801105e:	2c00      	cmp	r4, #0
 8011060:	dd4e      	ble.n	8011100 <_vfiprintf_r+0xa54>
 8011062:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8011066:	2c10      	cmp	r4, #16
 8011068:	f340 82b0 	ble.w	80115cc <_vfiprintf_r+0xf20>
 801106c:	9919      	ldr	r1, [sp, #100]	; 0x64
 801106e:	ee18 6a10 	vmov	r6, s16
 8011072:	2510      	movs	r5, #16
 8011074:	e00d      	b.n	8011092 <_vfiprintf_r+0x9e6>
 8011076:	bf00      	nop
 8011078:	080159fc 	.word	0x080159fc
 801107c:	08015a60 	.word	0x08015a60
 8011080:	08015a50 	.word	0x08015a50
 8011084:	1c88      	adds	r0, r1, #2
 8011086:	f109 0908 	add.w	r9, r9, #8
 801108a:	4611      	mov	r1, r2
 801108c:	3c10      	subs	r4, #16
 801108e:	2c10      	cmp	r4, #16
 8011090:	dd1a      	ble.n	80110c8 <_vfiprintf_r+0xa1c>
 8011092:	1c4a      	adds	r2, r1, #1
 8011094:	48b3      	ldr	r0, [pc, #716]	; (8011364 <_vfiprintf_r+0xcb8>)
 8011096:	3310      	adds	r3, #16
 8011098:	2a07      	cmp	r2, #7
 801109a:	e9c9 0500 	strd	r0, r5, [r9]
 801109e:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
 80110a2:	ddef      	ble.n	8011084 <_vfiprintf_r+0x9d8>
 80110a4:	aa18      	add	r2, sp, #96	; 0x60
 80110a6:	b333      	cbz	r3, 80110f6 <_vfiprintf_r+0xa4a>
 80110a8:	4631      	mov	r1, r6
 80110aa:	4658      	mov	r0, fp
 80110ac:	f7ff fab6 	bl	801061c <__sprint_r.part.0>
 80110b0:	2800      	cmp	r0, #0
 80110b2:	f47f acd2 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 80110b6:	e9dd 1319 	ldrd	r1, r3, [sp, #100]	; 0x64
 80110ba:	3c10      	subs	r4, #16
 80110bc:	2c10      	cmp	r4, #16
 80110be:	f101 0001 	add.w	r0, r1, #1
 80110c2:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 80110c6:	dce4      	bgt.n	8011092 <_vfiprintf_r+0x9e6>
 80110c8:	4aa6      	ldr	r2, [pc, #664]	; (8011364 <_vfiprintf_r+0xcb8>)
 80110ca:	f8c9 4004 	str.w	r4, [r9, #4]
 80110ce:	4423      	add	r3, r4
 80110d0:	2807      	cmp	r0, #7
 80110d2:	e9cd 0319 	strd	r0, r3, [sp, #100]	; 0x64
 80110d6:	f8c9 2000 	str.w	r2, [r9]
 80110da:	f77f ad59 	ble.w	8010b90 <_vfiprintf_r+0x4e4>
 80110de:	b17b      	cbz	r3, 8011100 <_vfiprintf_r+0xa54>
 80110e0:	ee18 1a10 	vmov	r1, s16
 80110e4:	aa18      	add	r2, sp, #96	; 0x60
 80110e6:	4658      	mov	r0, fp
 80110e8:	f7ff fa98 	bl	801061c <__sprint_r.part.0>
 80110ec:	2800      	cmp	r0, #0
 80110ee:	f47f acb4 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 80110f2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80110f4:	e54c      	b.n	8010b90 <_vfiprintf_r+0x4e4>
 80110f6:	2001      	movs	r0, #1
 80110f8:	4619      	mov	r1, r3
 80110fa:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 80110fe:	e7c5      	b.n	801108c <_vfiprintf_r+0x9e0>
 8011100:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
 8011104:	9903      	ldr	r1, [sp, #12]
 8011106:	428a      	cmp	r2, r1
 8011108:	bfac      	ite	ge
 801110a:	189b      	addge	r3, r3, r2
 801110c:	185b      	addlt	r3, r3, r1
 801110e:	9305      	str	r3, [sp, #20]
 8011110:	e549      	b.n	8010ba6 <_vfiprintf_r+0x4fa>
 8011112:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
 8011116:	058f      	lsls	r7, r1, #22
 8011118:	ee18 3a10 	vmov	r3, s16
 801111c:	b28a      	uxth	r2, r1
 801111e:	f53f aae8 	bmi.w	80106f2 <_vfiprintf_r+0x46>
 8011122:	ee18 5a10 	vmov	r5, s16
 8011126:	6d98      	ldr	r0, [r3, #88]	; 0x58
 8011128:	f001 f88e 	bl	8012248 <__retarget_lock_acquire_recursive>
 801112c:	f9b5 100c 	ldrsh.w	r1, [r5, #12]
 8011130:	b28a      	uxth	r2, r1
 8011132:	f7ff bade 	b.w	80106f2 <_vfiprintf_r+0x46>
 8011136:	2b00      	cmp	r3, #0
 8011138:	f43f ae79 	beq.w	8010e2e <_vfiprintf_r+0x782>
 801113c:	ee18 1a10 	vmov	r1, s16
 8011140:	aa18      	add	r2, sp, #96	; 0x60
 8011142:	4658      	mov	r0, fp
 8011144:	f7ff fa6a 	bl	801061c <__sprint_r.part.0>
 8011148:	2800      	cmp	r0, #0
 801114a:	f47f ac86 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 801114e:	9919      	ldr	r1, [sp, #100]	; 0x64
 8011150:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8011152:	3101      	adds	r1, #1
 8011154:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8011158:	e4f8      	b.n	8010b4c <_vfiprintf_r+0x4a0>
 801115a:	9219      	str	r2, [sp, #100]	; 0x64
 801115c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8011160:	e45e      	b.n	8010a20 <_vfiprintf_r+0x374>
 8011162:	2f00      	cmp	r7, #0
 8011164:	f47f abc3 	bne.w	80108ee <_vfiprintf_r+0x242>
 8011168:	9e03      	ldr	r6, [sp, #12]
 801116a:	2700      	movs	r7, #0
 801116c:	9704      	str	r7, [sp, #16]
 801116e:	ac44      	add	r4, sp, #272	; 0x110
 8011170:	f7ff bbc5 	b.w	80108fe <_vfiprintf_r+0x252>
 8011174:	9b03      	ldr	r3, [sp, #12]
 8011176:	f013 0310 	ands.w	r3, r3, #16
 801117a:	d154      	bne.n	8011226 <_vfiprintf_r+0xb7a>
 801117c:	9a03      	ldr	r2, [sp, #12]
 801117e:	f012 0040 	ands.w	r0, r2, #64	; 0x40
 8011182:	f000 816b 	beq.w	801145c <_vfiprintf_r+0xdb0>
 8011186:	9907      	ldr	r1, [sp, #28]
 8011188:	461a      	mov	r2, r3
 801118a:	f851 3b04 	ldr.w	r3, [r1], #4
 801118e:	9107      	str	r1, [sp, #28]
 8011190:	b29b      	uxth	r3, r3
 8011192:	2101      	movs	r1, #1
 8011194:	e401      	b.n	801099a <_vfiprintf_r+0x2ee>
 8011196:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011198:	2a00      	cmp	r2, #0
 801119a:	d164      	bne.n	8011266 <_vfiprintf_r+0xbba>
 801119c:	4618      	mov	r0, r3
 801119e:	2101      	movs	r1, #1
 80111a0:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 80111a4:	e4c9      	b.n	8010b3a <_vfiprintf_r+0x48e>
 80111a6:	2101      	movs	r1, #1
 80111a8:	4618      	mov	r0, r3
 80111aa:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 80111ae:	e4c4      	b.n	8010b3a <_vfiprintf_r+0x48e>
 80111b0:	425b      	negs	r3, r3
 80111b2:	eb62 0242 	sbc.w	r2, r2, r2, lsl #1
 80111b6:	9603      	str	r6, [sp, #12]
 80111b8:	202d      	movs	r0, #45	; 0x2d
 80111ba:	2101      	movs	r1, #1
 80111bc:	f7ff bbee 	b.w	801099c <_vfiprintf_r+0x2f0>
 80111c0:	2b00      	cmp	r3, #0
 80111c2:	f000 8088 	beq.w	80112d6 <_vfiprintf_r+0xc2a>
 80111c6:	ee18 1a10 	vmov	r1, s16
 80111ca:	aa18      	add	r2, sp, #96	; 0x60
 80111cc:	4658      	mov	r0, fp
 80111ce:	f7ff fa25 	bl	801061c <__sprint_r.part.0>
 80111d2:	2800      	cmp	r0, #0
 80111d4:	f47f ac41 	bne.w	8010a5a <_vfiprintf_r+0x3ae>
 80111d8:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
 80111dc:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 80111e0:	1c41      	adds	r1, r0, #1
 80111e2:	e477      	b.n	8010ad4 <_vfiprintf_r+0x428>
 80111e4:	f898 1000 	ldrb.w	r1, [r8]
 80111e8:	9307      	str	r3, [sp, #28]
 80111ea:	f7ff bad2 	b.w	8010792 <_vfiprintf_r+0xe6>
 80111ee:	ac44      	add	r4, sp, #272	; 0x110
 80111f0:	f7ff bb85 	b.w	80108fe <_vfiprintf_r+0x252>
 80111f4:	f109 0908 	add.w	r9, r9, #8
 80111f8:	f10c 0101 	add.w	r1, ip, #1
 80111fc:	4660      	mov	r0, ip
 80111fe:	e4a0      	b.n	8010b42 <_vfiprintf_r+0x496>
 8011200:	f416 7200 	ands.w	r2, r6, #512	; 0x200
 8011204:	f040 8197 	bne.w	8011536 <_vfiprintf_r+0xe8a>
 8011208:	f851 3b04 	ldr.w	r3, [r1], #4
 801120c:	9107      	str	r1, [sp, #28]
 801120e:	f7ff bbc0 	b.w	8010992 <_vfiprintf_r+0x2e6>
 8011212:	05b3      	lsls	r3, r6, #22
 8011214:	f100 8188 	bmi.w	8011528 <_vfiprintf_r+0xe7c>
 8011218:	f852 3b04 	ldr.w	r3, [r2], #4
 801121c:	9207      	str	r2, [sp, #28]
 801121e:	17da      	asrs	r2, r3, #31
 8011220:	4611      	mov	r1, r2
 8011222:	f7ff bb52 	b.w	80108ca <_vfiprintf_r+0x21e>
 8011226:	9907      	ldr	r1, [sp, #28]
 8011228:	f851 3b04 	ldr.w	r3, [r1], #4
 801122c:	9107      	str	r1, [sp, #28]
 801122e:	2101      	movs	r1, #1
 8011230:	f7ff bbb3 	b.w	801099a <_vfiprintf_r+0x2ee>
 8011234:	9b07      	ldr	r3, [sp, #28]
 8011236:	9805      	ldr	r0, [sp, #20]
 8011238:	f853 1b04 	ldr.w	r1, [r3], #4
 801123c:	9307      	str	r3, [sp, #28]
 801123e:	17c2      	asrs	r2, r0, #31
 8011240:	e9c1 0200 	strd	r0, r2, [r1]
 8011244:	f7ff ba7d 	b.w	8010742 <_vfiprintf_r+0x96>
 8011248:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801124a:	2b00      	cmp	r3, #0
 801124c:	f43f ab26 	beq.w	801089c <_vfiprintf_r+0x1f0>
 8011250:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011252:	781b      	ldrb	r3, [r3, #0]
 8011254:	2b00      	cmp	r3, #0
 8011256:	f43f ab21 	beq.w	801089c <_vfiprintf_r+0x1f0>
 801125a:	f898 1000 	ldrb.w	r1, [r8]
 801125e:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
 8011262:	f7ff ba96 	b.w	8010792 <_vfiprintf_r+0xe6>
 8011266:	2302      	movs	r3, #2
 8011268:	aa11      	add	r2, sp, #68	; 0x44
 801126a:	931c      	str	r3, [sp, #112]	; 0x70
 801126c:	921b      	str	r2, [sp, #108]	; 0x6c
 801126e:	2001      	movs	r0, #1
 8011270:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8011274:	e6a2      	b.n	8010fbc <_vfiprintf_r+0x910>
 8011276:	9603      	str	r6, [sp, #12]
 8011278:	e571      	b.n	8010d5e <_vfiprintf_r+0x6b2>
 801127a:	4b3b      	ldr	r3, [pc, #236]	; (8011368 <_vfiprintf_r+0xcbc>)
 801127c:	930c      	str	r3, [sp, #48]	; 0x30
 801127e:	f016 0220 	ands.w	r2, r6, #32
 8011282:	d059      	beq.n	8011338 <_vfiprintf_r+0xc8c>
 8011284:	9b07      	ldr	r3, [sp, #28]
 8011286:	3307      	adds	r3, #7
 8011288:	f023 0307 	bic.w	r3, r3, #7
 801128c:	4618      	mov	r0, r3
 801128e:	685a      	ldr	r2, [r3, #4]
 8011290:	f850 3b08 	ldr.w	r3, [r0], #8
 8011294:	9007      	str	r0, [sp, #28]
 8011296:	07f4      	lsls	r4, r6, #31
 8011298:	d509      	bpl.n	80112ae <_vfiprintf_r+0xc02>
 801129a:	ea53 0002 	orrs.w	r0, r3, r2
 801129e:	d006      	beq.n	80112ae <_vfiprintf_r+0xc02>
 80112a0:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
 80112a4:	2130      	movs	r1, #48	; 0x30
 80112a6:	f046 0602 	orr.w	r6, r6, #2
 80112aa:	f88d 1044 	strb.w	r1, [sp, #68]	; 0x44
 80112ae:	f426 6180 	bic.w	r1, r6, #1024	; 0x400
 80112b2:	9103      	str	r1, [sp, #12]
 80112b4:	2102      	movs	r1, #2
 80112b6:	f7ff bb70 	b.w	801099a <_vfiprintf_r+0x2ee>
 80112ba:	4b2c      	ldr	r3, [pc, #176]	; (801136c <_vfiprintf_r+0xcc0>)
 80112bc:	930c      	str	r3, [sp, #48]	; 0x30
 80112be:	e7de      	b.n	801127e <_vfiprintf_r+0xbd2>
 80112c0:	9b07      	ldr	r3, [sp, #28]
 80112c2:	2101      	movs	r1, #1
 80112c4:	f853 2b04 	ldr.w	r2, [r3], #4
 80112c8:	9103      	str	r1, [sp, #12]
 80112ca:	f88d 20ac 	strb.w	r2, [sp, #172]	; 0xac
 80112ce:	9307      	str	r3, [sp, #28]
 80112d0:	9104      	str	r1, [sp, #16]
 80112d2:	ac2b      	add	r4, sp, #172	; 0xac
 80112d4:	e4df      	b.n	8010c96 <_vfiprintf_r+0x5ea>
 80112d6:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
 80112da:	2a00      	cmp	r2, #0
 80112dc:	f040 8132 	bne.w	8011544 <_vfiprintf_r+0xe98>
 80112e0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80112e2:	2a00      	cmp	r2, #0
 80112e4:	f47f ae62 	bne.w	8010fac <_vfiprintf_r+0x900>
 80112e8:	4618      	mov	r0, r3
 80112ea:	2101      	movs	r1, #1
 80112ec:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 80112f0:	e427      	b.n	8010b42 <_vfiprintf_r+0x496>
 80112f2:	2100      	movs	r1, #0
 80112f4:	2208      	movs	r2, #8
 80112f6:	a816      	add	r0, sp, #88	; 0x58
 80112f8:	9413      	str	r4, [sp, #76]	; 0x4c
 80112fa:	f7fd fa73 	bl	800e7e4 <memset>
 80112fe:	1c79      	adds	r1, r7, #1
 8011300:	f000 80bc 	beq.w	801147c <_vfiprintf_r+0xdd0>
 8011304:	2500      	movs	r5, #0
 8011306:	9407      	str	r4, [sp, #28]
 8011308:	462c      	mov	r4, r5
 801130a:	e00c      	b.n	8011326 <_vfiprintf_r+0xc7a>
 801130c:	a92b      	add	r1, sp, #172	; 0xac
 801130e:	4658      	mov	r0, fp
 8011310:	f003 f8c2 	bl	8014498 <_wcrtomb_r>
 8011314:	1c42      	adds	r2, r0, #1
 8011316:	4420      	add	r0, r4
 8011318:	f000 816b 	beq.w	80115f2 <_vfiprintf_r+0xf46>
 801131c:	42b8      	cmp	r0, r7
 801131e:	dc08      	bgt.n	8011332 <_vfiprintf_r+0xc86>
 8011320:	f000 8170 	beq.w	8011604 <_vfiprintf_r+0xf58>
 8011324:	4604      	mov	r4, r0
 8011326:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011328:	5952      	ldr	r2, [r2, r5]
 801132a:	ab16      	add	r3, sp, #88	; 0x58
 801132c:	3504      	adds	r5, #4
 801132e:	2a00      	cmp	r2, #0
 8011330:	d1ec      	bne.n	801130c <_vfiprintf_r+0xc60>
 8011332:	9404      	str	r4, [sp, #16]
 8011334:	9c07      	ldr	r4, [sp, #28]
 8011336:	e0af      	b.n	8011498 <_vfiprintf_r+0xdec>
 8011338:	f016 0310 	ands.w	r3, r6, #16
 801133c:	9807      	ldr	r0, [sp, #28]
 801133e:	d10c      	bne.n	801135a <_vfiprintf_r+0xcae>
 8011340:	f016 0440 	ands.w	r4, r6, #64	; 0x40
 8011344:	d005      	beq.n	8011352 <_vfiprintf_r+0xca6>
 8011346:	461a      	mov	r2, r3
 8011348:	f850 3b04 	ldr.w	r3, [r0], #4
 801134c:	9007      	str	r0, [sp, #28]
 801134e:	b29b      	uxth	r3, r3
 8011350:	e7a1      	b.n	8011296 <_vfiprintf_r+0xbea>
 8011352:	f416 7200 	ands.w	r2, r6, #512	; 0x200
 8011356:	f040 80e1 	bne.w	801151c <_vfiprintf_r+0xe70>
 801135a:	f850 3b04 	ldr.w	r3, [r0], #4
 801135e:	9007      	str	r0, [sp, #28]
 8011360:	e799      	b.n	8011296 <_vfiprintf_r+0xbea>
 8011362:	bf00      	nop
 8011364:	08015a50 	.word	0x08015a50
 8011368:	080159fc 	.word	0x080159fc
 801136c:	08015a10 	.word	0x08015a10
 8011370:	9903      	ldr	r1, [sp, #12]
 8011372:	9704      	str	r7, [sp, #16]
 8011374:	ac44      	add	r4, sp, #272	; 0x110
 8011376:	469e      	mov	lr, r3
 8011378:	ee08 ba90 	vmov	s17, fp
 801137c:	f401 6680 	and.w	r6, r1, #1024	; 0x400
 8011380:	f04f 0c00 	mov.w	ip, #0
 8011384:	4623      	mov	r3, r4
 8011386:	e006      	b.n	8011396 <_vfiprintf_r+0xcea>
 8011388:	f1be 0f0a 	cmp.w	lr, #10
 801138c:	f172 0200 	sbcs.w	r2, r2, #0
 8011390:	d339      	bcc.n	8011406 <_vfiprintf_r+0xd5a>
 8011392:	46a6      	mov	lr, r4
 8011394:	462a      	mov	r2, r5
 8011396:	49a6      	ldr	r1, [pc, #664]	; (8011630 <_vfiprintf_r+0xf84>)
 8011398:	eb1e 0002 	adds.w	r0, lr, r2
 801139c:	f140 0000 	adc.w	r0, r0, #0
 80113a0:	460f      	mov	r7, r1
 80113a2:	fba1 1400 	umull	r1, r4, r1, r0
 80113a6:	f024 0103 	bic.w	r1, r4, #3
 80113aa:	eb01 0194 	add.w	r1, r1, r4, lsr #2
 80113ae:	1a40      	subs	r0, r0, r1
 80113b0:	ebbe 0100 	subs.w	r1, lr, r0
 80113b4:	f04f 35cc 	mov.w	r5, #3435973836	; 0xcccccccc
 80113b8:	f162 0400 	sbc.w	r4, r2, #0
 80113bc:	fb05 f501 	mul.w	r5, r5, r1
 80113c0:	fb07 5504 	mla	r5, r7, r4, r5
 80113c4:	fba1 4107 	umull	r4, r1, r1, r7
 80113c8:	440d      	add	r5, r1
 80113ca:	2705      	movs	r7, #5
 80113cc:	f004 0101 	and.w	r1, r4, #1
 80113d0:	fba1 1b07 	umull	r1, fp, r1, r7
 80113d4:	1809      	adds	r1, r1, r0
 80113d6:	0864      	lsrs	r4, r4, #1
 80113d8:	3130      	adds	r1, #48	; 0x30
 80113da:	f803 1c01 	strb.w	r1, [r3, #-1]
 80113de:	ea44 74c5 	orr.w	r4, r4, r5, lsl #31
 80113e2:	f10c 0c01 	add.w	ip, ip, #1
 80113e6:	3b01      	subs	r3, #1
 80113e8:	086d      	lsrs	r5, r5, #1
 80113ea:	2e00      	cmp	r6, #0
 80113ec:	d0cc      	beq.n	8011388 <_vfiprintf_r+0xcdc>
 80113ee:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80113f0:	7809      	ldrb	r1, [r1, #0]
 80113f2:	4561      	cmp	r1, ip
 80113f4:	d1c8      	bne.n	8011388 <_vfiprintf_r+0xcdc>
 80113f6:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 80113fa:	d0c5      	beq.n	8011388 <_vfiprintf_r+0xcdc>
 80113fc:	f1be 0f0a 	cmp.w	lr, #10
 8011400:	f172 0200 	sbcs.w	r2, r2, #0
 8011404:	d26c      	bcs.n	80114e0 <_vfiprintf_r+0xe34>
 8011406:	461c      	mov	r4, r3
 8011408:	ab44      	add	r3, sp, #272	; 0x110
 801140a:	1b1b      	subs	r3, r3, r4
 801140c:	9f04      	ldr	r7, [sp, #16]
 801140e:	9e03      	ldr	r6, [sp, #12]
 8011410:	9304      	str	r3, [sp, #16]
 8011412:	ee18 ba90 	vmov	fp, s17
 8011416:	f7ff ba72 	b.w	80108fe <_vfiprintf_r+0x252>
 801141a:	9603      	str	r6, [sp, #12]
 801141c:	f7ff ba62 	b.w	80108e4 <_vfiprintf_r+0x238>
 8011420:	4658      	mov	r0, fp
 8011422:	f000 faa1 	bl	8011968 <__sinit>
 8011426:	f7ff b95b 	b.w	80106e0 <_vfiprintf_r+0x34>
 801142a:	2901      	cmp	r1, #1
 801142c:	9603      	str	r6, [sp, #12]
 801142e:	f47f accd 	bne.w	8010dcc <_vfiprintf_r+0x720>
 8011432:	f7ff ba5c 	b.w	80108ee <_vfiprintf_r+0x242>
 8011436:	9b07      	ldr	r3, [sp, #28]
 8011438:	9905      	ldr	r1, [sp, #20]
 801143a:	f853 2b04 	ldr.w	r2, [r3], #4
 801143e:	6011      	str	r1, [r2, #0]
 8011440:	9307      	str	r3, [sp, #28]
 8011442:	f7ff b97e 	b.w	8010742 <_vfiprintf_r+0x96>
 8011446:	2f06      	cmp	r7, #6
 8011448:	463b      	mov	r3, r7
 801144a:	9a03      	ldr	r2, [sp, #12]
 801144c:	4c79      	ldr	r4, [pc, #484]	; (8011634 <_vfiprintf_r+0xf88>)
 801144e:	9207      	str	r2, [sp, #28]
 8011450:	bf28      	it	cs
 8011452:	2306      	movcs	r3, #6
 8011454:	9304      	str	r3, [sp, #16]
 8011456:	9303      	str	r3, [sp, #12]
 8011458:	f7ff bb25 	b.w	8010aa6 <_vfiprintf_r+0x3fa>
 801145c:	9b03      	ldr	r3, [sp, #12]
 801145e:	9907      	ldr	r1, [sp, #28]
 8011460:	f413 7200 	ands.w	r2, r3, #512	; 0x200
 8011464:	bf14      	ite	ne
 8011466:	f851 3b04 	ldrne.w	r3, [r1], #4
 801146a:	f851 3b04 	ldreq.w	r3, [r1], #4
 801146e:	9107      	str	r1, [sp, #28]
 8011470:	bf1c      	itt	ne
 8011472:	4602      	movne	r2, r0
 8011474:	b2db      	uxtbne	r3, r3
 8011476:	2101      	movs	r1, #1
 8011478:	f7ff ba8f 	b.w	801099a <_vfiprintf_r+0x2ee>
 801147c:	ab16      	add	r3, sp, #88	; 0x58
 801147e:	9300      	str	r3, [sp, #0]
 8011480:	2300      	movs	r3, #0
 8011482:	4619      	mov	r1, r3
 8011484:	aa13      	add	r2, sp, #76	; 0x4c
 8011486:	4658      	mov	r0, fp
 8011488:	f003 f82c 	bl	80144e4 <_wcsrtombs_r>
 801148c:	4603      	mov	r3, r0
 801148e:	3301      	adds	r3, #1
 8011490:	9004      	str	r0, [sp, #16]
 8011492:	f000 80ae 	beq.w	80115f2 <_vfiprintf_r+0xf46>
 8011496:	9413      	str	r4, [sp, #76]	; 0x4c
 8011498:	9b04      	ldr	r3, [sp, #16]
 801149a:	2b00      	cmp	r3, #0
 801149c:	d030      	beq.n	8011500 <_vfiprintf_r+0xe54>
 801149e:	2b63      	cmp	r3, #99	; 0x63
 80114a0:	dc63      	bgt.n	801156a <_vfiprintf_r+0xebe>
 80114a2:	2300      	movs	r3, #0
 80114a4:	9308      	str	r3, [sp, #32]
 80114a6:	ac2b      	add	r4, sp, #172	; 0xac
 80114a8:	2208      	movs	r2, #8
 80114aa:	2100      	movs	r1, #0
 80114ac:	a816      	add	r0, sp, #88	; 0x58
 80114ae:	f7fd f999 	bl	800e7e4 <memset>
 80114b2:	9d04      	ldr	r5, [sp, #16]
 80114b4:	ab16      	add	r3, sp, #88	; 0x58
 80114b6:	9300      	str	r3, [sp, #0]
 80114b8:	aa13      	add	r2, sp, #76	; 0x4c
 80114ba:	462b      	mov	r3, r5
 80114bc:	4621      	mov	r1, r4
 80114be:	4658      	mov	r0, fp
 80114c0:	f003 f810 	bl	80144e4 <_wcsrtombs_r>
 80114c4:	4285      	cmp	r5, r0
 80114c6:	f040 80ab 	bne.w	8011620 <_vfiprintf_r+0xf74>
 80114ca:	9b03      	ldr	r3, [sp, #12]
 80114cc:	9a04      	ldr	r2, [sp, #16]
 80114ce:	9307      	str	r3, [sp, #28]
 80114d0:	2300      	movs	r3, #0
 80114d2:	54a3      	strb	r3, [r4, r2]
 80114d4:	461f      	mov	r7, r3
 80114d6:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 80114da:	9303      	str	r3, [sp, #12]
 80114dc:	f7ff ba16 	b.w	801090c <_vfiprintf_r+0x260>
 80114e0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80114e2:	990d      	ldr	r1, [sp, #52]	; 0x34
 80114e4:	1a9b      	subs	r3, r3, r2
 80114e6:	4618      	mov	r0, r3
 80114e8:	9308      	str	r3, [sp, #32]
 80114ea:	f7fd fa33 	bl	800e954 <strncpy>
 80114ee:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80114f0:	9b08      	ldr	r3, [sp, #32]
 80114f2:	784a      	ldrb	r2, [r1, #1]
 80114f4:	b10a      	cbz	r2, 80114fa <_vfiprintf_r+0xe4e>
 80114f6:	3101      	adds	r1, #1
 80114f8:	910b      	str	r1, [sp, #44]	; 0x2c
 80114fa:	f04f 0c00 	mov.w	ip, #0
 80114fe:	e748      	b.n	8011392 <_vfiprintf_r+0xce6>
 8011500:	9b03      	ldr	r3, [sp, #12]
 8011502:	9307      	str	r3, [sp, #28]
 8011504:	9b04      	ldr	r3, [sp, #16]
 8011506:	9303      	str	r3, [sp, #12]
 8011508:	461f      	mov	r7, r3
 801150a:	9308      	str	r3, [sp, #32]
 801150c:	f7ff b9fe 	b.w	801090c <_vfiprintf_r+0x260>
 8011510:	2101      	movs	r1, #1
 8011512:	4618      	mov	r0, r3
 8011514:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8011518:	f7ff bb13 	b.w	8010b42 <_vfiprintf_r+0x496>
 801151c:	f850 3b04 	ldr.w	r3, [r0], #4
 8011520:	9007      	str	r0, [sp, #28]
 8011522:	4622      	mov	r2, r4
 8011524:	b2db      	uxtb	r3, r3
 8011526:	e6b6      	b.n	8011296 <_vfiprintf_r+0xbea>
 8011528:	f912 3b04 	ldrsb.w	r3, [r2], #4
 801152c:	9207      	str	r2, [sp, #28]
 801152e:	17da      	asrs	r2, r3, #31
 8011530:	4611      	mov	r1, r2
 8011532:	f7ff b9ca 	b.w	80108ca <_vfiprintf_r+0x21e>
 8011536:	f851 3b04 	ldr.w	r3, [r1], #4
 801153a:	9107      	str	r1, [sp, #28]
 801153c:	4602      	mov	r2, r0
 801153e:	b2db      	uxtb	r3, r3
 8011540:	f7ff ba27 	b.w	8010992 <_vfiprintf_r+0x2e6>
 8011544:	2301      	movs	r3, #1
 8011546:	931c      	str	r3, [sp, #112]	; 0x70
 8011548:	2101      	movs	r1, #1
 801154a:	f10d 0343 	add.w	r3, sp, #67	; 0x43
 801154e:	931b      	str	r3, [sp, #108]	; 0x6c
 8011550:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
 8011554:	460b      	mov	r3, r1
 8011556:	f7ff bacd 	b.w	8010af4 <_vfiprintf_r+0x448>
 801155a:	9b07      	ldr	r3, [sp, #28]
 801155c:	9905      	ldr	r1, [sp, #20]
 801155e:	f853 2b04 	ldr.w	r2, [r3], #4
 8011562:	9307      	str	r3, [sp, #28]
 8011564:	8011      	strh	r1, [r2, #0]
 8011566:	f7ff b8ec 	b.w	8010742 <_vfiprintf_r+0x96>
 801156a:	1c59      	adds	r1, r3, #1
 801156c:	4658      	mov	r0, fp
 801156e:	f001 ff0b 	bl	8013388 <_malloc_r>
 8011572:	4604      	mov	r4, r0
 8011574:	2800      	cmp	r0, #0
 8011576:	d03c      	beq.n	80115f2 <_vfiprintf_r+0xf46>
 8011578:	9008      	str	r0, [sp, #32]
 801157a:	e795      	b.n	80114a8 <_vfiprintf_r+0xdfc>
 801157c:	6d88      	ldr	r0, [r1, #88]	; 0x58
 801157e:	f000 fe65 	bl	801224c <__retarget_lock_release_recursive>
 8011582:	f7ff b9e9 	b.w	8010958 <_vfiprintf_r+0x2ac>
 8011586:	9b03      	ldr	r3, [sp, #12]
 8011588:	9307      	str	r3, [sp, #28]
 801158a:	e9cd 7703 	strd	r7, r7, [sp, #12]
 801158e:	9f08      	ldr	r7, [sp, #32]
 8011590:	f7ff b9bc 	b.w	801090c <_vfiprintf_r+0x260>
 8011594:	9819      	ldr	r0, [sp, #100]	; 0x64
 8011596:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8011598:	3001      	adds	r0, #1
 801159a:	e545      	b.n	8011028 <_vfiprintf_r+0x97c>
 801159c:	9b03      	ldr	r3, [sp, #12]
 801159e:	9307      	str	r3, [sp, #28]
 80115a0:	4620      	mov	r0, r4
 80115a2:	f7ef f98d 	bl	80008c0 <strlen>
 80115a6:	ea20 73e0 	bic.w	r3, r0, r0, asr #31
 80115aa:	462f      	mov	r7, r5
 80115ac:	9004      	str	r0, [sp, #16]
 80115ae:	9303      	str	r3, [sp, #12]
 80115b0:	9508      	str	r5, [sp, #32]
 80115b2:	f7ff b9ab 	b.w	801090c <_vfiprintf_r+0x260>
 80115b6:	ee18 1a10 	vmov	r1, s16
 80115ba:	aa18      	add	r2, sp, #96	; 0x60
 80115bc:	4658      	mov	r0, fp
 80115be:	f7ff f82d 	bl	801061c <__sprint_r.part.0>
 80115c2:	2800      	cmp	r0, #0
 80115c4:	f43f aa36 	beq.w	8010a34 <_vfiprintf_r+0x388>
 80115c8:	f7ff ba4d 	b.w	8010a66 <_vfiprintf_r+0x3ba>
 80115cc:	9819      	ldr	r0, [sp, #100]	; 0x64
 80115ce:	3001      	adds	r0, #1
 80115d0:	e57a      	b.n	80110c8 <_vfiprintf_r+0xa1c>
 80115d2:	468c      	mov	ip, r1
 80115d4:	e46e      	b.n	8010eb4 <_vfiprintf_r+0x808>
 80115d6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80115d8:	07d9      	lsls	r1, r3, #31
 80115da:	d405      	bmi.n	80115e8 <_vfiprintf_r+0xf3c>
 80115dc:	89ab      	ldrh	r3, [r5, #12]
 80115de:	059a      	lsls	r2, r3, #22
 80115e0:	d402      	bmi.n	80115e8 <_vfiprintf_r+0xf3c>
 80115e2:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80115e4:	f000 fe32 	bl	801224c <__retarget_lock_release_recursive>
 80115e8:	f04f 33ff 	mov.w	r3, #4294967295
 80115ec:	9305      	str	r3, [sp, #20]
 80115ee:	f7ff ba49 	b.w	8010a84 <_vfiprintf_r+0x3d8>
 80115f2:	ee18 2a10 	vmov	r2, s16
 80115f6:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
 80115fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80115fe:	8193      	strh	r3, [r2, #12]
 8011600:	f7ff ba35 	b.w	8010a6e <_vfiprintf_r+0x3c2>
 8011604:	9c07      	ldr	r4, [sp, #28]
 8011606:	9704      	str	r7, [sp, #16]
 8011608:	e746      	b.n	8011498 <_vfiprintf_r+0xdec>
 801160a:	9b07      	ldr	r3, [sp, #28]
 801160c:	f898 1001 	ldrb.w	r1, [r8, #1]
 8011610:	f853 7b04 	ldr.w	r7, [r3], #4
 8011614:	9307      	str	r3, [sp, #28]
 8011616:	4690      	mov	r8, r2
 8011618:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 801161c:	f7ff b8b9 	b.w	8010792 <_vfiprintf_r+0xe6>
 8011620:	ee18 2a10 	vmov	r2, s16
 8011624:	8993      	ldrh	r3, [r2, #12]
 8011626:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801162a:	8193      	strh	r3, [r2, #12]
 801162c:	f7ff ba15 	b.w	8010a5a <_vfiprintf_r+0x3ae>
 8011630:	cccccccd 	.word	0xcccccccd
 8011634:	08015a24 	.word	0x08015a24

08011638 <__sbprintf>:
 8011638:	b570      	push	{r4, r5, r6, lr}
 801163a:	460c      	mov	r4, r1
 801163c:	8989      	ldrh	r1, [r1, #12]
 801163e:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 8011642:	f021 0102 	bic.w	r1, r1, #2
 8011646:	f8ad 1014 	strh.w	r1, [sp, #20]
 801164a:	6e61      	ldr	r1, [r4, #100]	; 0x64
 801164c:	911b      	str	r1, [sp, #108]	; 0x6c
 801164e:	89e1      	ldrh	r1, [r4, #14]
 8011650:	f8ad 1016 	strh.w	r1, [sp, #22]
 8011654:	69e1      	ldr	r1, [r4, #28]
 8011656:	9109      	str	r1, [sp, #36]	; 0x24
 8011658:	6a61      	ldr	r1, [r4, #36]	; 0x24
 801165a:	910b      	str	r1, [sp, #44]	; 0x2c
 801165c:	a91c      	add	r1, sp, #112	; 0x70
 801165e:	9102      	str	r1, [sp, #8]
 8011660:	9106      	str	r1, [sp, #24]
 8011662:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8011666:	4606      	mov	r6, r0
 8011668:	9104      	str	r1, [sp, #16]
 801166a:	9107      	str	r1, [sp, #28]
 801166c:	a818      	add	r0, sp, #96	; 0x60
 801166e:	2100      	movs	r1, #0
 8011670:	e9cd 3200 	strd	r3, r2, [sp]
 8011674:	9108      	str	r1, [sp, #32]
 8011676:	f000 fde3 	bl	8012240 <__retarget_lock_init_recursive>
 801167a:	e9dd 3200 	ldrd	r3, r2, [sp]
 801167e:	a902      	add	r1, sp, #8
 8011680:	4630      	mov	r0, r6
 8011682:	f7ff f813 	bl	80106ac <_vfiprintf_r>
 8011686:	1e05      	subs	r5, r0, #0
 8011688:	db07      	blt.n	801169a <__sbprintf+0x62>
 801168a:	a902      	add	r1, sp, #8
 801168c:	4630      	mov	r0, r6
 801168e:	f000 f8ab 	bl	80117e8 <_fflush_r>
 8011692:	2800      	cmp	r0, #0
 8011694:	bf18      	it	ne
 8011696:	f04f 35ff 	movne.w	r5, #4294967295
 801169a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 801169e:	065b      	lsls	r3, r3, #25
 80116a0:	d503      	bpl.n	80116aa <__sbprintf+0x72>
 80116a2:	89a3      	ldrh	r3, [r4, #12]
 80116a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80116a8:	81a3      	strh	r3, [r4, #12]
 80116aa:	9818      	ldr	r0, [sp, #96]	; 0x60
 80116ac:	f000 fdca 	bl	8012244 <__retarget_lock_close_recursive>
 80116b0:	4628      	mov	r0, r5
 80116b2:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 80116b6:	bd70      	pop	{r4, r5, r6, pc}

080116b8 <__sflush_r>:
 80116b8:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 80116bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80116c0:	460c      	mov	r4, r1
 80116c2:	0711      	lsls	r1, r2, #28
 80116c4:	4680      	mov	r8, r0
 80116c6:	d447      	bmi.n	8011758 <__sflush_r+0xa0>
 80116c8:	6863      	ldr	r3, [r4, #4]
 80116ca:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80116ce:	2b00      	cmp	r3, #0
 80116d0:	81a2      	strh	r2, [r4, #12]
 80116d2:	dd5e      	ble.n	8011792 <__sflush_r+0xda>
 80116d4:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 80116d6:	2d00      	cmp	r5, #0
 80116d8:	d058      	beq.n	801178c <__sflush_r+0xd4>
 80116da:	2300      	movs	r3, #0
 80116dc:	f8d8 6000 	ldr.w	r6, [r8]
 80116e0:	f8c8 3000 	str.w	r3, [r8]
 80116e4:	b293      	uxth	r3, r2
 80116e6:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 80116ea:	d156      	bne.n	801179a <__sflush_r+0xe2>
 80116ec:	2301      	movs	r3, #1
 80116ee:	69e1      	ldr	r1, [r4, #28]
 80116f0:	4640      	mov	r0, r8
 80116f2:	47a8      	blx	r5
 80116f4:	1c43      	adds	r3, r0, #1
 80116f6:	d067      	beq.n	80117c8 <__sflush_r+0x110>
 80116f8:	89a3      	ldrh	r3, [r4, #12]
 80116fa:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 80116fc:	075f      	lsls	r7, r3, #29
 80116fe:	d505      	bpl.n	801170c <__sflush_r+0x54>
 8011700:	6863      	ldr	r3, [r4, #4]
 8011702:	1ac0      	subs	r0, r0, r3
 8011704:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8011706:	b10b      	cbz	r3, 801170c <__sflush_r+0x54>
 8011708:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 801170a:	1ac0      	subs	r0, r0, r3
 801170c:	69e1      	ldr	r1, [r4, #28]
 801170e:	4602      	mov	r2, r0
 8011710:	2300      	movs	r3, #0
 8011712:	4640      	mov	r0, r8
 8011714:	47a8      	blx	r5
 8011716:	1c41      	adds	r1, r0, #1
 8011718:	d141      	bne.n	801179e <__sflush_r+0xe6>
 801171a:	f8d8 3000 	ldr.w	r3, [r8]
 801171e:	2b00      	cmp	r3, #0
 8011720:	d03d      	beq.n	801179e <__sflush_r+0xe6>
 8011722:	2b1d      	cmp	r3, #29
 8011724:	d001      	beq.n	801172a <__sflush_r+0x72>
 8011726:	2b16      	cmp	r3, #22
 8011728:	d156      	bne.n	80117d8 <__sflush_r+0x120>
 801172a:	89a3      	ldrh	r3, [r4, #12]
 801172c:	6922      	ldr	r2, [r4, #16]
 801172e:	6022      	str	r2, [r4, #0]
 8011730:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8011734:	2100      	movs	r1, #0
 8011736:	6061      	str	r1, [r4, #4]
 8011738:	81a3      	strh	r3, [r4, #12]
 801173a:	6b21      	ldr	r1, [r4, #48]	; 0x30
 801173c:	f8c8 6000 	str.w	r6, [r8]
 8011740:	b321      	cbz	r1, 801178c <__sflush_r+0xd4>
 8011742:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8011746:	4299      	cmp	r1, r3
 8011748:	d002      	beq.n	8011750 <__sflush_r+0x98>
 801174a:	4640      	mov	r0, r8
 801174c:	f001 fd16 	bl	801317c <_free_r>
 8011750:	2000      	movs	r0, #0
 8011752:	6320      	str	r0, [r4, #48]	; 0x30
 8011754:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011758:	6926      	ldr	r6, [r4, #16]
 801175a:	b1be      	cbz	r6, 801178c <__sflush_r+0xd4>
 801175c:	b293      	uxth	r3, r2
 801175e:	6825      	ldr	r5, [r4, #0]
 8011760:	6026      	str	r6, [r4, #0]
 8011762:	079a      	lsls	r2, r3, #30
 8011764:	bf0c      	ite	eq
 8011766:	6963      	ldreq	r3, [r4, #20]
 8011768:	2300      	movne	r3, #0
 801176a:	1bad      	subs	r5, r5, r6
 801176c:	60a3      	str	r3, [r4, #8]
 801176e:	e00b      	b.n	8011788 <__sflush_r+0xd0>
 8011770:	462b      	mov	r3, r5
 8011772:	4632      	mov	r2, r6
 8011774:	69e1      	ldr	r1, [r4, #28]
 8011776:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8011778:	4640      	mov	r0, r8
 801177a:	47b8      	blx	r7
 801177c:	f1b0 0c00 	subs.w	ip, r0, #0
 8011780:	eba5 050c 	sub.w	r5, r5, ip
 8011784:	4466      	add	r6, ip
 8011786:	dd17      	ble.n	80117b8 <__sflush_r+0x100>
 8011788:	2d00      	cmp	r5, #0
 801178a:	dcf1      	bgt.n	8011770 <__sflush_r+0xb8>
 801178c:	2000      	movs	r0, #0
 801178e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011792:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8011794:	2b00      	cmp	r3, #0
 8011796:	dc9d      	bgt.n	80116d4 <__sflush_r+0x1c>
 8011798:	e7f8      	b.n	801178c <__sflush_r+0xd4>
 801179a:	6d20      	ldr	r0, [r4, #80]	; 0x50
 801179c:	e7ae      	b.n	80116fc <__sflush_r+0x44>
 801179e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80117a2:	6922      	ldr	r2, [r4, #16]
 80117a4:	6022      	str	r2, [r4, #0]
 80117a6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80117aa:	81a3      	strh	r3, [r4, #12]
 80117ac:	2200      	movs	r2, #0
 80117ae:	04db      	lsls	r3, r3, #19
 80117b0:	6062      	str	r2, [r4, #4]
 80117b2:	d5c2      	bpl.n	801173a <__sflush_r+0x82>
 80117b4:	6520      	str	r0, [r4, #80]	; 0x50
 80117b6:	e7c0      	b.n	801173a <__sflush_r+0x82>
 80117b8:	89a3      	ldrh	r3, [r4, #12]
 80117ba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80117be:	f04f 30ff 	mov.w	r0, #4294967295
 80117c2:	81a3      	strh	r3, [r4, #12]
 80117c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80117c8:	f8d8 3000 	ldr.w	r3, [r8]
 80117cc:	2b00      	cmp	r3, #0
 80117ce:	d093      	beq.n	80116f8 <__sflush_r+0x40>
 80117d0:	2b1d      	cmp	r3, #29
 80117d2:	d006      	beq.n	80117e2 <__sflush_r+0x12a>
 80117d4:	2b16      	cmp	r3, #22
 80117d6:	d004      	beq.n	80117e2 <__sflush_r+0x12a>
 80117d8:	89a3      	ldrh	r3, [r4, #12]
 80117da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80117de:	81a3      	strh	r3, [r4, #12]
 80117e0:	e7d5      	b.n	801178e <__sflush_r+0xd6>
 80117e2:	f8c8 6000 	str.w	r6, [r8]
 80117e6:	e7d1      	b.n	801178c <__sflush_r+0xd4>

080117e8 <_fflush_r>:
 80117e8:	b538      	push	{r3, r4, r5, lr}
 80117ea:	460c      	mov	r4, r1
 80117ec:	4605      	mov	r5, r0
 80117ee:	b108      	cbz	r0, 80117f4 <_fflush_r+0xc>
 80117f0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80117f2:	b303      	cbz	r3, 8011836 <_fflush_r+0x4e>
 80117f4:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
 80117f8:	b188      	cbz	r0, 801181e <_fflush_r+0x36>
 80117fa:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80117fc:	07db      	lsls	r3, r3, #31
 80117fe:	d401      	bmi.n	8011804 <_fflush_r+0x1c>
 8011800:	0581      	lsls	r1, r0, #22
 8011802:	d50f      	bpl.n	8011824 <_fflush_r+0x3c>
 8011804:	4628      	mov	r0, r5
 8011806:	4621      	mov	r1, r4
 8011808:	f7ff ff56 	bl	80116b8 <__sflush_r>
 801180c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801180e:	07da      	lsls	r2, r3, #31
 8011810:	4605      	mov	r5, r0
 8011812:	d402      	bmi.n	801181a <_fflush_r+0x32>
 8011814:	89a3      	ldrh	r3, [r4, #12]
 8011816:	059b      	lsls	r3, r3, #22
 8011818:	d508      	bpl.n	801182c <_fflush_r+0x44>
 801181a:	4628      	mov	r0, r5
 801181c:	bd38      	pop	{r3, r4, r5, pc}
 801181e:	4605      	mov	r5, r0
 8011820:	4628      	mov	r0, r5
 8011822:	bd38      	pop	{r3, r4, r5, pc}
 8011824:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8011826:	f000 fd0f 	bl	8012248 <__retarget_lock_acquire_recursive>
 801182a:	e7eb      	b.n	8011804 <_fflush_r+0x1c>
 801182c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801182e:	f000 fd0d 	bl	801224c <__retarget_lock_release_recursive>
 8011832:	4628      	mov	r0, r5
 8011834:	bd38      	pop	{r3, r4, r5, pc}
 8011836:	f000 f897 	bl	8011968 <__sinit>
 801183a:	e7db      	b.n	80117f4 <_fflush_r+0xc>

0801183c <stdio_exit_handler>:
 801183c:	4a02      	ldr	r2, [pc, #8]	; (8011848 <stdio_exit_handler+0xc>)
 801183e:	4903      	ldr	r1, [pc, #12]	; (801184c <stdio_exit_handler+0x10>)
 8011840:	4803      	ldr	r0, [pc, #12]	; (8011850 <stdio_exit_handler+0x14>)
 8011842:	f000 ba35 	b.w	8011cb0 <_fwalk_sglue>
 8011846:	bf00      	nop
 8011848:	24000164 	.word	0x24000164
 801184c:	080144fd 	.word	0x080144fd
 8011850:	24000040 	.word	0x24000040

08011854 <cleanup_stdio>:
 8011854:	4b0c      	ldr	r3, [pc, #48]	; (8011888 <cleanup_stdio+0x34>)
 8011856:	6841      	ldr	r1, [r0, #4]
 8011858:	4299      	cmp	r1, r3
 801185a:	b510      	push	{r4, lr}
 801185c:	4604      	mov	r4, r0
 801185e:	d001      	beq.n	8011864 <cleanup_stdio+0x10>
 8011860:	f002 fe4c 	bl	80144fc <_fclose_r>
 8011864:	68a1      	ldr	r1, [r4, #8]
 8011866:	4b09      	ldr	r3, [pc, #36]	; (801188c <cleanup_stdio+0x38>)
 8011868:	4299      	cmp	r1, r3
 801186a:	d002      	beq.n	8011872 <cleanup_stdio+0x1e>
 801186c:	4620      	mov	r0, r4
 801186e:	f002 fe45 	bl	80144fc <_fclose_r>
 8011872:	68e1      	ldr	r1, [r4, #12]
 8011874:	4b06      	ldr	r3, [pc, #24]	; (8011890 <cleanup_stdio+0x3c>)
 8011876:	4299      	cmp	r1, r3
 8011878:	d004      	beq.n	8011884 <cleanup_stdio+0x30>
 801187a:	4620      	mov	r0, r4
 801187c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8011880:	f002 be3c 	b.w	80144fc <_fclose_r>
 8011884:	bd10      	pop	{r4, pc}
 8011886:	bf00      	nop
 8011888:	24006044 	.word	0x24006044
 801188c:	240060ac 	.word	0x240060ac
 8011890:	24006114 	.word	0x24006114

08011894 <global_stdio_init.part.0>:
 8011894:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8011898:	4c2a      	ldr	r4, [pc, #168]	; (8011944 <global_stdio_init.part.0+0xb0>)
 801189a:	4b2b      	ldr	r3, [pc, #172]	; (8011948 <global_stdio_init.part.0+0xb4>)
 801189c:	482b      	ldr	r0, [pc, #172]	; (801194c <global_stdio_init.part.0+0xb8>)
 801189e:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 8011960 <global_stdio_init.part.0+0xcc>
 80118a2:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8011964 <global_stdio_init.part.0+0xd0>
 80118a6:	4f2a      	ldr	r7, [pc, #168]	; (8011950 <global_stdio_init.part.0+0xbc>)
 80118a8:	6018      	str	r0, [r3, #0]
 80118aa:	2500      	movs	r5, #0
 80118ac:	2304      	movs	r3, #4
 80118ae:	2208      	movs	r2, #8
 80118b0:	4629      	mov	r1, r5
 80118b2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80118b6:	4e27      	ldr	r6, [pc, #156]	; (8011954 <global_stdio_init.part.0+0xc0>)
 80118b8:	6665      	str	r5, [r4, #100]	; 0x64
 80118ba:	e9c4 5302 	strd	r5, r3, [r4, #8]
 80118be:	e9c4 5500 	strd	r5, r5, [r4]
 80118c2:	e9c4 5504 	strd	r5, r5, [r4, #16]
 80118c6:	61a5      	str	r5, [r4, #24]
 80118c8:	f7fc ff8c 	bl	800e7e4 <memset>
 80118cc:	4b22      	ldr	r3, [pc, #136]	; (8011958 <global_stdio_init.part.0+0xc4>)
 80118ce:	6763      	str	r3, [r4, #116]	; 0x74
 80118d0:	2208      	movs	r2, #8
 80118d2:	4629      	mov	r1, r5
 80118d4:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
 80118d8:	e9c4 4907 	strd	r4, r9, [r4, #28]
 80118dc:	e9c4 8709 	strd	r8, r7, [r4, #36]	; 0x24
 80118e0:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
 80118e4:	e9c4 551e 	strd	r5, r5, [r4, #120]	; 0x78
 80118e8:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
 80118ec:	6725      	str	r5, [r4, #112]	; 0x70
 80118ee:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
 80118f2:	62e6      	str	r6, [r4, #44]	; 0x2c
 80118f4:	f7fc ff76 	bl	800e7e4 <memset>
 80118f8:	4b18      	ldr	r3, [pc, #96]	; (801195c <global_stdio_init.part.0+0xc8>)
 80118fa:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
 80118fe:	4629      	mov	r1, r5
 8011900:	f104 0368 	add.w	r3, r4, #104	; 0x68
 8011904:	2208      	movs	r2, #8
 8011906:	f504 7096 	add.w	r0, r4, #300	; 0x12c
 801190a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 801190e:	e9c4 9822 	strd	r9, r8, [r4, #136]	; 0x88
 8011912:	e9c4 7624 	strd	r7, r6, [r4, #144]	; 0x90
 8011916:	e9c4 5534 	strd	r5, r5, [r4, #208]	; 0xd0
 801191a:	e9c4 5538 	strd	r5, r5, [r4, #224]	; 0xe0
 801191e:	f8c4 5134 	str.w	r5, [r4, #308]	; 0x134
 8011922:	f8c4 50d8 	str.w	r5, [r4, #216]	; 0xd8
 8011926:	f8c4 50e8 	str.w	r5, [r4, #232]	; 0xe8
 801192a:	f7fc ff5b 	bl	800e7e4 <memset>
 801192e:	f104 03d0 	add.w	r3, r4, #208	; 0xd0
 8011932:	e9c4 983c 	strd	r9, r8, [r4, #240]	; 0xf0
 8011936:	e9c4 763e 	strd	r7, r6, [r4, #248]	; 0xf8
 801193a:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 801193e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8011942:	bf00      	nop
 8011944:	24006044 	.word	0x24006044
 8011948:	2400617c 	.word	0x2400617c
 801194c:	0801183d 	.word	0x0801183d
 8011950:	08011dd5 	.word	0x08011dd5
 8011954:	08011df5 	.word	0x08011df5
 8011958:	00010009 	.word	0x00010009
 801195c:	00020012 	.word	0x00020012
 8011960:	08011d71 	.word	0x08011d71
 8011964:	08011d95 	.word	0x08011d95

08011968 <__sinit>:
 8011968:	b510      	push	{r4, lr}
 801196a:	4604      	mov	r4, r0
 801196c:	480a      	ldr	r0, [pc, #40]	; (8011998 <__sinit+0x30>)
 801196e:	f000 fc6b 	bl	8012248 <__retarget_lock_acquire_recursive>
 8011972:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8011974:	b923      	cbnz	r3, 8011980 <__sinit+0x18>
 8011976:	4b09      	ldr	r3, [pc, #36]	; (801199c <__sinit+0x34>)
 8011978:	4a09      	ldr	r2, [pc, #36]	; (80119a0 <__sinit+0x38>)
 801197a:	681b      	ldr	r3, [r3, #0]
 801197c:	6362      	str	r2, [r4, #52]	; 0x34
 801197e:	b123      	cbz	r3, 801198a <__sinit+0x22>
 8011980:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8011984:	4804      	ldr	r0, [pc, #16]	; (8011998 <__sinit+0x30>)
 8011986:	f000 bc61 	b.w	801224c <__retarget_lock_release_recursive>
 801198a:	f7ff ff83 	bl	8011894 <global_stdio_init.part.0>
 801198e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8011992:	4801      	ldr	r0, [pc, #4]	; (8011998 <__sinit+0x30>)
 8011994:	f000 bc5a 	b.w	801224c <__retarget_lock_release_recursive>
 8011998:	24006188 	.word	0x24006188
 801199c:	2400617c 	.word	0x2400617c
 80119a0:	08011855 	.word	0x08011855

080119a4 <__sfp_lock_acquire>:
 80119a4:	4801      	ldr	r0, [pc, #4]	; (80119ac <__sfp_lock_acquire+0x8>)
 80119a6:	f000 bc4f 	b.w	8012248 <__retarget_lock_acquire_recursive>
 80119aa:	bf00      	nop
 80119ac:	24006188 	.word	0x24006188

080119b0 <__sfp_lock_release>:
 80119b0:	4801      	ldr	r0, [pc, #4]	; (80119b8 <__sfp_lock_release+0x8>)
 80119b2:	f000 bc4b 	b.w	801224c <__retarget_lock_release_recursive>
 80119b6:	bf00      	nop
 80119b8:	24006188 	.word	0x24006188

080119bc <__sfvwrite_r>:
 80119bc:	6893      	ldr	r3, [r2, #8]
 80119be:	2b00      	cmp	r3, #0
 80119c0:	f000 8085 	beq.w	8011ace <__sfvwrite_r+0x112>
 80119c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80119c8:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
 80119cc:	460c      	mov	r4, r1
 80119ce:	0719      	lsls	r1, r3, #28
 80119d0:	4680      	mov	r8, r0
 80119d2:	b083      	sub	sp, #12
 80119d4:	4617      	mov	r7, r2
 80119d6:	b298      	uxth	r0, r3
 80119d8:	d525      	bpl.n	8011a26 <__sfvwrite_r+0x6a>
 80119da:	6923      	ldr	r3, [r4, #16]
 80119dc:	b31b      	cbz	r3, 8011a26 <__sfvwrite_r+0x6a>
 80119de:	f010 0302 	ands.w	r3, r0, #2
 80119e2:	683d      	ldr	r5, [r7, #0]
 80119e4:	d02d      	beq.n	8011a42 <__sfvwrite_r+0x86>
 80119e6:	f04f 0a00 	mov.w	sl, #0
 80119ea:	f8df b2c0 	ldr.w	fp, [pc, #704]	; 8011cac <__sfvwrite_r+0x2f0>
 80119ee:	4656      	mov	r6, sl
 80119f0:	46b9      	mov	r9, r7
 80119f2:	455e      	cmp	r6, fp
 80119f4:	4633      	mov	r3, r6
 80119f6:	4652      	mov	r2, sl
 80119f8:	bf28      	it	cs
 80119fa:	465b      	movcs	r3, fp
 80119fc:	4640      	mov	r0, r8
 80119fe:	2e00      	cmp	r6, #0
 8011a00:	d052      	beq.n	8011aa8 <__sfvwrite_r+0xec>
 8011a02:	69e1      	ldr	r1, [r4, #28]
 8011a04:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8011a06:	47b8      	blx	r7
 8011a08:	2800      	cmp	r0, #0
 8011a0a:	dd56      	ble.n	8011aba <__sfvwrite_r+0xfe>
 8011a0c:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8011a10:	1a1b      	subs	r3, r3, r0
 8011a12:	4482      	add	sl, r0
 8011a14:	1a36      	subs	r6, r6, r0
 8011a16:	f8c9 3008 	str.w	r3, [r9, #8]
 8011a1a:	2b00      	cmp	r3, #0
 8011a1c:	d1e9      	bne.n	80119f2 <__sfvwrite_r+0x36>
 8011a1e:	2000      	movs	r0, #0
 8011a20:	b003      	add	sp, #12
 8011a22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011a26:	4621      	mov	r1, r4
 8011a28:	4640      	mov	r0, r8
 8011a2a:	f000 fa3f 	bl	8011eac <__swsetup_r>
 8011a2e:	2800      	cmp	r0, #0
 8011a30:	f040 8138 	bne.w	8011ca4 <__sfvwrite_r+0x2e8>
 8011a34:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011a38:	683d      	ldr	r5, [r7, #0]
 8011a3a:	b298      	uxth	r0, r3
 8011a3c:	f010 0302 	ands.w	r3, r0, #2
 8011a40:	d1d1      	bne.n	80119e6 <__sfvwrite_r+0x2a>
 8011a42:	f010 0901 	ands.w	r9, r0, #1
 8011a46:	d144      	bne.n	8011ad2 <__sfvwrite_r+0x116>
 8011a48:	464e      	mov	r6, r9
 8011a4a:	9700      	str	r7, [sp, #0]
 8011a4c:	b346      	cbz	r6, 8011aa0 <__sfvwrite_r+0xe4>
 8011a4e:	0582      	lsls	r2, r0, #22
 8011a50:	f8d4 b008 	ldr.w	fp, [r4, #8]
 8011a54:	f140 8085 	bpl.w	8011b62 <__sfvwrite_r+0x1a6>
 8011a58:	45b3      	cmp	fp, r6
 8011a5a:	465a      	mov	r2, fp
 8011a5c:	f200 80b4 	bhi.w	8011bc8 <__sfvwrite_r+0x20c>
 8011a60:	f410 6f90 	tst.w	r0, #1152	; 0x480
 8011a64:	f040 80c1 	bne.w	8011bea <__sfvwrite_r+0x22e>
 8011a68:	6820      	ldr	r0, [r4, #0]
 8011a6a:	9201      	str	r2, [sp, #4]
 8011a6c:	4649      	mov	r1, r9
 8011a6e:	f000 fb0d 	bl	801208c <memmove>
 8011a72:	68a3      	ldr	r3, [r4, #8]
 8011a74:	9a01      	ldr	r2, [sp, #4]
 8011a76:	eba3 010b 	sub.w	r1, r3, fp
 8011a7a:	6823      	ldr	r3, [r4, #0]
 8011a7c:	60a1      	str	r1, [r4, #8]
 8011a7e:	4413      	add	r3, r2
 8011a80:	46b2      	mov	sl, r6
 8011a82:	6023      	str	r3, [r4, #0]
 8011a84:	2600      	movs	r6, #0
 8011a86:	9a00      	ldr	r2, [sp, #0]
 8011a88:	6893      	ldr	r3, [r2, #8]
 8011a8a:	eba3 030a 	sub.w	r3, r3, sl
 8011a8e:	44d1      	add	r9, sl
 8011a90:	6093      	str	r3, [r2, #8]
 8011a92:	2b00      	cmp	r3, #0
 8011a94:	d0c3      	beq.n	8011a1e <__sfvwrite_r+0x62>
 8011a96:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
 8011a9a:	b280      	uxth	r0, r0
 8011a9c:	2e00      	cmp	r6, #0
 8011a9e:	d1d6      	bne.n	8011a4e <__sfvwrite_r+0x92>
 8011aa0:	e9d5 9600 	ldrd	r9, r6, [r5]
 8011aa4:	3508      	adds	r5, #8
 8011aa6:	e7d1      	b.n	8011a4c <__sfvwrite_r+0x90>
 8011aa8:	e9d5 a600 	ldrd	sl, r6, [r5]
 8011aac:	3508      	adds	r5, #8
 8011aae:	e7a0      	b.n	80119f2 <__sfvwrite_r+0x36>
 8011ab0:	4621      	mov	r1, r4
 8011ab2:	4640      	mov	r0, r8
 8011ab4:	f7ff fe98 	bl	80117e8 <_fflush_r>
 8011ab8:	b388      	cbz	r0, 8011b1e <__sfvwrite_r+0x162>
 8011aba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011abe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011ac2:	f04f 30ff 	mov.w	r0, #4294967295
 8011ac6:	81a3      	strh	r3, [r4, #12]
 8011ac8:	b003      	add	sp, #12
 8011aca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011ace:	2000      	movs	r0, #0
 8011ad0:	4770      	bx	lr
 8011ad2:	461e      	mov	r6, r3
 8011ad4:	46ba      	mov	sl, r7
 8011ad6:	4699      	mov	r9, r3
 8011ad8:	4618      	mov	r0, r3
 8011ada:	9500      	str	r5, [sp, #0]
 8011adc:	461f      	mov	r7, r3
 8011ade:	b366      	cbz	r6, 8011b3a <__sfvwrite_r+0x17e>
 8011ae0:	2800      	cmp	r0, #0
 8011ae2:	d032      	beq.n	8011b4a <__sfvwrite_r+0x18e>
 8011ae4:	464a      	mov	r2, r9
 8011ae6:	e9d4 1304 	ldrd	r1, r3, [r4, #16]
 8011aea:	6820      	ldr	r0, [r4, #0]
 8011aec:	68a5      	ldr	r5, [r4, #8]
 8011aee:	42b2      	cmp	r2, r6
 8011af0:	bf28      	it	cs
 8011af2:	4632      	movcs	r2, r6
 8011af4:	4288      	cmp	r0, r1
 8011af6:	d904      	bls.n	8011b02 <__sfvwrite_r+0x146>
 8011af8:	eb05 0b03 	add.w	fp, r5, r3
 8011afc:	455a      	cmp	r2, fp
 8011afe:	f300 80a7 	bgt.w	8011c50 <__sfvwrite_r+0x294>
 8011b02:	4293      	cmp	r3, r2
 8011b04:	dc64      	bgt.n	8011bd0 <__sfvwrite_r+0x214>
 8011b06:	69e1      	ldr	r1, [r4, #28]
 8011b08:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8011b0a:	463a      	mov	r2, r7
 8011b0c:	4640      	mov	r0, r8
 8011b0e:	47a8      	blx	r5
 8011b10:	f1b0 0b00 	subs.w	fp, r0, #0
 8011b14:	ddd1      	ble.n	8011aba <__sfvwrite_r+0xfe>
 8011b16:	ebb9 090b 	subs.w	r9, r9, fp
 8011b1a:	d0c9      	beq.n	8011ab0 <__sfvwrite_r+0xf4>
 8011b1c:	2001      	movs	r0, #1
 8011b1e:	f8da 3008 	ldr.w	r3, [sl, #8]
 8011b22:	eba3 030b 	sub.w	r3, r3, fp
 8011b26:	445f      	add	r7, fp
 8011b28:	eba6 060b 	sub.w	r6, r6, fp
 8011b2c:	f8ca 3008 	str.w	r3, [sl, #8]
 8011b30:	2b00      	cmp	r3, #0
 8011b32:	f43f af74 	beq.w	8011a1e <__sfvwrite_r+0x62>
 8011b36:	2e00      	cmp	r6, #0
 8011b38:	d1d2      	bne.n	8011ae0 <__sfvwrite_r+0x124>
 8011b3a:	9a00      	ldr	r2, [sp, #0]
 8011b3c:	6856      	ldr	r6, [r2, #4]
 8011b3e:	4613      	mov	r3, r2
 8011b40:	3208      	adds	r2, #8
 8011b42:	9200      	str	r2, [sp, #0]
 8011b44:	2e00      	cmp	r6, #0
 8011b46:	d0f8      	beq.n	8011b3a <__sfvwrite_r+0x17e>
 8011b48:	681f      	ldr	r7, [r3, #0]
 8011b4a:	4632      	mov	r2, r6
 8011b4c:	210a      	movs	r1, #10
 8011b4e:	4638      	mov	r0, r7
 8011b50:	f7ee ff26 	bl	80009a0 <memchr>
 8011b54:	2800      	cmp	r0, #0
 8011b56:	f000 809c 	beq.w	8011c92 <__sfvwrite_r+0x2d6>
 8011b5a:	3001      	adds	r0, #1
 8011b5c:	eba0 0907 	sub.w	r9, r0, r7
 8011b60:	e7c0      	b.n	8011ae4 <__sfvwrite_r+0x128>
 8011b62:	6820      	ldr	r0, [r4, #0]
 8011b64:	6923      	ldr	r3, [r4, #16]
 8011b66:	4298      	cmp	r0, r3
 8011b68:	d816      	bhi.n	8011b98 <__sfvwrite_r+0x1dc>
 8011b6a:	6962      	ldr	r2, [r4, #20]
 8011b6c:	42b2      	cmp	r2, r6
 8011b6e:	d813      	bhi.n	8011b98 <__sfvwrite_r+0x1dc>
 8011b70:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8011b74:	42b3      	cmp	r3, r6
 8011b76:	bf28      	it	cs
 8011b78:	4633      	movcs	r3, r6
 8011b7a:	69e1      	ldr	r1, [r4, #28]
 8011b7c:	fb93 f3f2 	sdiv	r3, r3, r2
 8011b80:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8011b82:	fb02 f303 	mul.w	r3, r2, r3
 8011b86:	4640      	mov	r0, r8
 8011b88:	464a      	mov	r2, r9
 8011b8a:	47b8      	blx	r7
 8011b8c:	f1b0 0a00 	subs.w	sl, r0, #0
 8011b90:	dd93      	ble.n	8011aba <__sfvwrite_r+0xfe>
 8011b92:	eba6 060a 	sub.w	r6, r6, sl
 8011b96:	e776      	b.n	8011a86 <__sfvwrite_r+0xca>
 8011b98:	45b3      	cmp	fp, r6
 8011b9a:	46da      	mov	sl, fp
 8011b9c:	bf28      	it	cs
 8011b9e:	46b2      	movcs	sl, r6
 8011ba0:	4652      	mov	r2, sl
 8011ba2:	4649      	mov	r1, r9
 8011ba4:	f000 fa72 	bl	801208c <memmove>
 8011ba8:	68a3      	ldr	r3, [r4, #8]
 8011baa:	6822      	ldr	r2, [r4, #0]
 8011bac:	eba3 030a 	sub.w	r3, r3, sl
 8011bb0:	4452      	add	r2, sl
 8011bb2:	60a3      	str	r3, [r4, #8]
 8011bb4:	6022      	str	r2, [r4, #0]
 8011bb6:	2b00      	cmp	r3, #0
 8011bb8:	d1eb      	bne.n	8011b92 <__sfvwrite_r+0x1d6>
 8011bba:	4621      	mov	r1, r4
 8011bbc:	4640      	mov	r0, r8
 8011bbe:	f7ff fe13 	bl	80117e8 <_fflush_r>
 8011bc2:	2800      	cmp	r0, #0
 8011bc4:	d0e5      	beq.n	8011b92 <__sfvwrite_r+0x1d6>
 8011bc6:	e778      	b.n	8011aba <__sfvwrite_r+0xfe>
 8011bc8:	6820      	ldr	r0, [r4, #0]
 8011bca:	46b3      	mov	fp, r6
 8011bcc:	4632      	mov	r2, r6
 8011bce:	e74c      	b.n	8011a6a <__sfvwrite_r+0xae>
 8011bd0:	4639      	mov	r1, r7
 8011bd2:	9201      	str	r2, [sp, #4]
 8011bd4:	f000 fa5a 	bl	801208c <memmove>
 8011bd8:	9a01      	ldr	r2, [sp, #4]
 8011bda:	68a3      	ldr	r3, [r4, #8]
 8011bdc:	1a9b      	subs	r3, r3, r2
 8011bde:	60a3      	str	r3, [r4, #8]
 8011be0:	6823      	ldr	r3, [r4, #0]
 8011be2:	4413      	add	r3, r2
 8011be4:	6023      	str	r3, [r4, #0]
 8011be6:	4693      	mov	fp, r2
 8011be8:	e795      	b.n	8011b16 <__sfvwrite_r+0x15a>
 8011bea:	6823      	ldr	r3, [r4, #0]
 8011bec:	6921      	ldr	r1, [r4, #16]
 8011bee:	eba3 0b01 	sub.w	fp, r3, r1
 8011bf2:	6963      	ldr	r3, [r4, #20]
 8011bf4:	eb03 0a43 	add.w	sl, r3, r3, lsl #1
 8011bf8:	eb0a 7ada 	add.w	sl, sl, sl, lsr #31
 8011bfc:	f10b 0301 	add.w	r3, fp, #1
 8011c00:	ea4f 0a6a 	mov.w	sl, sl, asr #1
 8011c04:	4433      	add	r3, r6
 8011c06:	4553      	cmp	r3, sl
 8011c08:	4652      	mov	r2, sl
 8011c0a:	bf84      	itt	hi
 8011c0c:	469a      	movhi	sl, r3
 8011c0e:	4652      	movhi	r2, sl
 8011c10:	0543      	lsls	r3, r0, #21
 8011c12:	d52c      	bpl.n	8011c6e <__sfvwrite_r+0x2b2>
 8011c14:	4611      	mov	r1, r2
 8011c16:	4640      	mov	r0, r8
 8011c18:	f001 fbb6 	bl	8013388 <_malloc_r>
 8011c1c:	2800      	cmp	r0, #0
 8011c1e:	d03b      	beq.n	8011c98 <__sfvwrite_r+0x2dc>
 8011c20:	465a      	mov	r2, fp
 8011c22:	6921      	ldr	r1, [r4, #16]
 8011c24:	9001      	str	r0, [sp, #4]
 8011c26:	f7ee fda9 	bl	800077c <memcpy>
 8011c2a:	89a2      	ldrh	r2, [r4, #12]
 8011c2c:	9b01      	ldr	r3, [sp, #4]
 8011c2e:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8011c32:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8011c36:	81a2      	strh	r2, [r4, #12]
 8011c38:	eb03 000b 	add.w	r0, r3, fp
 8011c3c:	6123      	str	r3, [r4, #16]
 8011c3e:	ebaa 030b 	sub.w	r3, sl, fp
 8011c42:	f8c4 a014 	str.w	sl, [r4, #20]
 8011c46:	60a3      	str	r3, [r4, #8]
 8011c48:	6020      	str	r0, [r4, #0]
 8011c4a:	46b3      	mov	fp, r6
 8011c4c:	4632      	mov	r2, r6
 8011c4e:	e70c      	b.n	8011a6a <__sfvwrite_r+0xae>
 8011c50:	4639      	mov	r1, r7
 8011c52:	465a      	mov	r2, fp
 8011c54:	f000 fa1a 	bl	801208c <memmove>
 8011c58:	6823      	ldr	r3, [r4, #0]
 8011c5a:	445b      	add	r3, fp
 8011c5c:	6023      	str	r3, [r4, #0]
 8011c5e:	4621      	mov	r1, r4
 8011c60:	4640      	mov	r0, r8
 8011c62:	f7ff fdc1 	bl	80117e8 <_fflush_r>
 8011c66:	2800      	cmp	r0, #0
 8011c68:	f43f af55 	beq.w	8011b16 <__sfvwrite_r+0x15a>
 8011c6c:	e725      	b.n	8011aba <__sfvwrite_r+0xfe>
 8011c6e:	4640      	mov	r0, r8
 8011c70:	f002 fa18 	bl	80140a4 <_realloc_r>
 8011c74:	4603      	mov	r3, r0
 8011c76:	2800      	cmp	r0, #0
 8011c78:	d1de      	bne.n	8011c38 <__sfvwrite_r+0x27c>
 8011c7a:	6921      	ldr	r1, [r4, #16]
 8011c7c:	4640      	mov	r0, r8
 8011c7e:	f001 fa7d 	bl	801317c <_free_r>
 8011c82:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011c86:	220c      	movs	r2, #12
 8011c88:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8011c8c:	f8c8 2000 	str.w	r2, [r8]
 8011c90:	e715      	b.n	8011abe <__sfvwrite_r+0x102>
 8011c92:	1c72      	adds	r2, r6, #1
 8011c94:	4691      	mov	r9, r2
 8011c96:	e726      	b.n	8011ae6 <__sfvwrite_r+0x12a>
 8011c98:	220c      	movs	r2, #12
 8011c9a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011c9e:	f8c8 2000 	str.w	r2, [r8]
 8011ca2:	e70c      	b.n	8011abe <__sfvwrite_r+0x102>
 8011ca4:	f04f 30ff 	mov.w	r0, #4294967295
 8011ca8:	e6ba      	b.n	8011a20 <__sfvwrite_r+0x64>
 8011caa:	bf00      	nop
 8011cac:	7ffffc00 	.word	0x7ffffc00

08011cb0 <_fwalk_sglue>:
 8011cb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8011cb4:	4680      	mov	r8, r0
 8011cb6:	460f      	mov	r7, r1
 8011cb8:	4616      	mov	r6, r2
 8011cba:	f04f 0900 	mov.w	r9, #0
 8011cbe:	e9d6 5401 	ldrd	r5, r4, [r6, #4]
 8011cc2:	3d01      	subs	r5, #1
 8011cc4:	d411      	bmi.n	8011cea <_fwalk_sglue+0x3a>
 8011cc6:	89a3      	ldrh	r3, [r4, #12]
 8011cc8:	2b01      	cmp	r3, #1
 8011cca:	f105 35ff 	add.w	r5, r5, #4294967295
 8011cce:	d908      	bls.n	8011ce2 <_fwalk_sglue+0x32>
 8011cd0:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8011cd4:	3301      	adds	r3, #1
 8011cd6:	4621      	mov	r1, r4
 8011cd8:	d003      	beq.n	8011ce2 <_fwalk_sglue+0x32>
 8011cda:	4640      	mov	r0, r8
 8011cdc:	47b8      	blx	r7
 8011cde:	ea49 0900 	orr.w	r9, r9, r0
 8011ce2:	1c6b      	adds	r3, r5, #1
 8011ce4:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8011ce8:	d1ed      	bne.n	8011cc6 <_fwalk_sglue+0x16>
 8011cea:	6836      	ldr	r6, [r6, #0]
 8011cec:	2e00      	cmp	r6, #0
 8011cee:	d1e6      	bne.n	8011cbe <_fwalk_sglue+0xe>
 8011cf0:	4648      	mov	r0, r9
 8011cf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8011cf6:	bf00      	nop

08011cf8 <_putc_r>:
 8011cf8:	b570      	push	{r4, r5, r6, lr}
 8011cfa:	460e      	mov	r6, r1
 8011cfc:	4614      	mov	r4, r2
 8011cfe:	4605      	mov	r5, r0
 8011d00:	b110      	cbz	r0, 8011d08 <_putc_r+0x10>
 8011d02:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8011d04:	2b00      	cmp	r3, #0
 8011d06:	d02f      	beq.n	8011d68 <_putc_r+0x70>
 8011d08:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8011d0a:	07d8      	lsls	r0, r3, #31
 8011d0c:	d402      	bmi.n	8011d14 <_putc_r+0x1c>
 8011d0e:	89a3      	ldrh	r3, [r4, #12]
 8011d10:	0599      	lsls	r1, r3, #22
 8011d12:	d520      	bpl.n	8011d56 <_putc_r+0x5e>
 8011d14:	68a3      	ldr	r3, [r4, #8]
 8011d16:	3b01      	subs	r3, #1
 8011d18:	2b00      	cmp	r3, #0
 8011d1a:	60a3      	str	r3, [r4, #8]
 8011d1c:	da19      	bge.n	8011d52 <_putc_r+0x5a>
 8011d1e:	69a2      	ldr	r2, [r4, #24]
 8011d20:	4293      	cmp	r3, r2
 8011d22:	db0f      	blt.n	8011d44 <_putc_r+0x4c>
 8011d24:	b2f0      	uxtb	r0, r6
 8011d26:	280a      	cmp	r0, #10
 8011d28:	d00c      	beq.n	8011d44 <_putc_r+0x4c>
 8011d2a:	6823      	ldr	r3, [r4, #0]
 8011d2c:	1c5a      	adds	r2, r3, #1
 8011d2e:	6022      	str	r2, [r4, #0]
 8011d30:	4605      	mov	r5, r0
 8011d32:	701e      	strb	r6, [r3, #0]
 8011d34:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8011d36:	07da      	lsls	r2, r3, #31
 8011d38:	d402      	bmi.n	8011d40 <_putc_r+0x48>
 8011d3a:	89a3      	ldrh	r3, [r4, #12]
 8011d3c:	059b      	lsls	r3, r3, #22
 8011d3e:	d50e      	bpl.n	8011d5e <_putc_r+0x66>
 8011d40:	4628      	mov	r0, r5
 8011d42:	bd70      	pop	{r4, r5, r6, pc}
 8011d44:	4628      	mov	r0, r5
 8011d46:	4622      	mov	r2, r4
 8011d48:	4631      	mov	r1, r6
 8011d4a:	f000 f857 	bl	8011dfc <__swbuf_r>
 8011d4e:	4605      	mov	r5, r0
 8011d50:	e7f0      	b.n	8011d34 <_putc_r+0x3c>
 8011d52:	b2f0      	uxtb	r0, r6
 8011d54:	e7e9      	b.n	8011d2a <_putc_r+0x32>
 8011d56:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8011d58:	f000 fa76 	bl	8012248 <__retarget_lock_acquire_recursive>
 8011d5c:	e7da      	b.n	8011d14 <_putc_r+0x1c>
 8011d5e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8011d60:	f000 fa74 	bl	801224c <__retarget_lock_release_recursive>
 8011d64:	4628      	mov	r0, r5
 8011d66:	bd70      	pop	{r4, r5, r6, pc}
 8011d68:	f7ff fdfe 	bl	8011968 <__sinit>
 8011d6c:	e7cc      	b.n	8011d08 <_putc_r+0x10>
 8011d6e:	bf00      	nop

08011d70 <__sread>:
 8011d70:	b510      	push	{r4, lr}
 8011d72:	460c      	mov	r4, r1
 8011d74:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8011d78:	f000 fa36 	bl	80121e8 <_read_r>
 8011d7c:	2800      	cmp	r0, #0
 8011d7e:	db03      	blt.n	8011d88 <__sread+0x18>
 8011d80:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8011d82:	4403      	add	r3, r0
 8011d84:	6523      	str	r3, [r4, #80]	; 0x50
 8011d86:	bd10      	pop	{r4, pc}
 8011d88:	89a3      	ldrh	r3, [r4, #12]
 8011d8a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8011d8e:	81a3      	strh	r3, [r4, #12]
 8011d90:	bd10      	pop	{r4, pc}
 8011d92:	bf00      	nop

08011d94 <__swrite>:
 8011d94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8011d98:	460c      	mov	r4, r1
 8011d9a:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
 8011d9e:	461f      	mov	r7, r3
 8011da0:	05cb      	lsls	r3, r1, #23
 8011da2:	4605      	mov	r5, r0
 8011da4:	4616      	mov	r6, r2
 8011da6:	d40b      	bmi.n	8011dc0 <__swrite+0x2c>
 8011da8:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 8011dac:	81a1      	strh	r1, [r4, #12]
 8011dae:	463b      	mov	r3, r7
 8011db0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8011db4:	4632      	mov	r2, r6
 8011db6:	4628      	mov	r0, r5
 8011db8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8011dbc:	f000 ba2a 	b.w	8012214 <_write_r>
 8011dc0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8011dc4:	2302      	movs	r3, #2
 8011dc6:	2200      	movs	r2, #0
 8011dc8:	f000 f9f8 	bl	80121bc <_lseek_r>
 8011dcc:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 8011dd0:	e7ea      	b.n	8011da8 <__swrite+0x14>
 8011dd2:	bf00      	nop

08011dd4 <__sseek>:
 8011dd4:	b510      	push	{r4, lr}
 8011dd6:	460c      	mov	r4, r1
 8011dd8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8011ddc:	f000 f9ee 	bl	80121bc <_lseek_r>
 8011de0:	89a3      	ldrh	r3, [r4, #12]
 8011de2:	1c42      	adds	r2, r0, #1
 8011de4:	bf0e      	itee	eq
 8011de6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8011dea:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8011dee:	6520      	strne	r0, [r4, #80]	; 0x50
 8011df0:	81a3      	strh	r3, [r4, #12]
 8011df2:	bd10      	pop	{r4, pc}

08011df4 <__sclose>:
 8011df4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8011df8:	f000 b9ce 	b.w	8012198 <_close_r>

08011dfc <__swbuf_r>:
 8011dfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011dfe:	460d      	mov	r5, r1
 8011e00:	4614      	mov	r4, r2
 8011e02:	4606      	mov	r6, r0
 8011e04:	b110      	cbz	r0, 8011e0c <__swbuf_r+0x10>
 8011e06:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8011e08:	2b00      	cmp	r3, #0
 8011e0a:	d04c      	beq.n	8011ea6 <__swbuf_r+0xaa>
 8011e0c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8011e10:	69a3      	ldr	r3, [r4, #24]
 8011e12:	60a3      	str	r3, [r4, #8]
 8011e14:	0717      	lsls	r7, r2, #28
 8011e16:	b290      	uxth	r0, r2
 8011e18:	d51b      	bpl.n	8011e52 <__swbuf_r+0x56>
 8011e1a:	6923      	ldr	r3, [r4, #16]
 8011e1c:	b1cb      	cbz	r3, 8011e52 <__swbuf_r+0x56>
 8011e1e:	b2ed      	uxtb	r5, r5
 8011e20:	0481      	lsls	r1, r0, #18
 8011e22:	462f      	mov	r7, r5
 8011e24:	d522      	bpl.n	8011e6c <__swbuf_r+0x70>
 8011e26:	6822      	ldr	r2, [r4, #0]
 8011e28:	6961      	ldr	r1, [r4, #20]
 8011e2a:	1ad3      	subs	r3, r2, r3
 8011e2c:	4299      	cmp	r1, r3
 8011e2e:	dd29      	ble.n	8011e84 <__swbuf_r+0x88>
 8011e30:	3301      	adds	r3, #1
 8011e32:	68a1      	ldr	r1, [r4, #8]
 8011e34:	3901      	subs	r1, #1
 8011e36:	60a1      	str	r1, [r4, #8]
 8011e38:	1c51      	adds	r1, r2, #1
 8011e3a:	6021      	str	r1, [r4, #0]
 8011e3c:	7015      	strb	r5, [r2, #0]
 8011e3e:	6962      	ldr	r2, [r4, #20]
 8011e40:	429a      	cmp	r2, r3
 8011e42:	d027      	beq.n	8011e94 <__swbuf_r+0x98>
 8011e44:	89a3      	ldrh	r3, [r4, #12]
 8011e46:	07db      	lsls	r3, r3, #31
 8011e48:	d501      	bpl.n	8011e4e <__swbuf_r+0x52>
 8011e4a:	2d0a      	cmp	r5, #10
 8011e4c:	d022      	beq.n	8011e94 <__swbuf_r+0x98>
 8011e4e:	4638      	mov	r0, r7
 8011e50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8011e52:	4621      	mov	r1, r4
 8011e54:	4630      	mov	r0, r6
 8011e56:	f000 f829 	bl	8011eac <__swsetup_r>
 8011e5a:	bb08      	cbnz	r0, 8011ea0 <__swbuf_r+0xa4>
 8011e5c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8011e60:	6923      	ldr	r3, [r4, #16]
 8011e62:	b290      	uxth	r0, r2
 8011e64:	b2ed      	uxtb	r5, r5
 8011e66:	0481      	lsls	r1, r0, #18
 8011e68:	462f      	mov	r7, r5
 8011e6a:	d4dc      	bmi.n	8011e26 <__swbuf_r+0x2a>
 8011e6c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8011e70:	81a2      	strh	r2, [r4, #12]
 8011e72:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8011e74:	6961      	ldr	r1, [r4, #20]
 8011e76:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8011e7a:	6662      	str	r2, [r4, #100]	; 0x64
 8011e7c:	6822      	ldr	r2, [r4, #0]
 8011e7e:	1ad3      	subs	r3, r2, r3
 8011e80:	4299      	cmp	r1, r3
 8011e82:	dcd5      	bgt.n	8011e30 <__swbuf_r+0x34>
 8011e84:	4621      	mov	r1, r4
 8011e86:	4630      	mov	r0, r6
 8011e88:	f7ff fcae 	bl	80117e8 <_fflush_r>
 8011e8c:	b940      	cbnz	r0, 8011ea0 <__swbuf_r+0xa4>
 8011e8e:	6822      	ldr	r2, [r4, #0]
 8011e90:	2301      	movs	r3, #1
 8011e92:	e7ce      	b.n	8011e32 <__swbuf_r+0x36>
 8011e94:	4621      	mov	r1, r4
 8011e96:	4630      	mov	r0, r6
 8011e98:	f7ff fca6 	bl	80117e8 <_fflush_r>
 8011e9c:	2800      	cmp	r0, #0
 8011e9e:	d0d6      	beq.n	8011e4e <__swbuf_r+0x52>
 8011ea0:	f04f 37ff 	mov.w	r7, #4294967295
 8011ea4:	e7d3      	b.n	8011e4e <__swbuf_r+0x52>
 8011ea6:	f7ff fd5f 	bl	8011968 <__sinit>
 8011eaa:	e7af      	b.n	8011e0c <__swbuf_r+0x10>

08011eac <__swsetup_r>:
 8011eac:	b538      	push	{r3, r4, r5, lr}
 8011eae:	4b31      	ldr	r3, [pc, #196]	; (8011f74 <__swsetup_r+0xc8>)
 8011eb0:	681b      	ldr	r3, [r3, #0]
 8011eb2:	4605      	mov	r5, r0
 8011eb4:	460c      	mov	r4, r1
 8011eb6:	b113      	cbz	r3, 8011ebe <__swsetup_r+0x12>
 8011eb8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011eba:	2a00      	cmp	r2, #0
 8011ebc:	d04e      	beq.n	8011f5c <__swsetup_r+0xb0>
 8011ebe:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011ec2:	0718      	lsls	r0, r3, #28
 8011ec4:	b29a      	uxth	r2, r3
 8011ec6:	d51c      	bpl.n	8011f02 <__swsetup_r+0x56>
 8011ec8:	6921      	ldr	r1, [r4, #16]
 8011eca:	b329      	cbz	r1, 8011f18 <__swsetup_r+0x6c>
 8011ecc:	f012 0001 	ands.w	r0, r2, #1
 8011ed0:	d007      	beq.n	8011ee2 <__swsetup_r+0x36>
 8011ed2:	2000      	movs	r0, #0
 8011ed4:	60a0      	str	r0, [r4, #8]
 8011ed6:	6960      	ldr	r0, [r4, #20]
 8011ed8:	4240      	negs	r0, r0
 8011eda:	61a0      	str	r0, [r4, #24]
 8011edc:	b139      	cbz	r1, 8011eee <__swsetup_r+0x42>
 8011ede:	2000      	movs	r0, #0
 8011ee0:	bd38      	pop	{r3, r4, r5, pc}
 8011ee2:	0795      	lsls	r5, r2, #30
 8011ee4:	bf58      	it	pl
 8011ee6:	6960      	ldrpl	r0, [r4, #20]
 8011ee8:	60a0      	str	r0, [r4, #8]
 8011eea:	2900      	cmp	r1, #0
 8011eec:	d1f7      	bne.n	8011ede <__swsetup_r+0x32>
 8011eee:	0612      	lsls	r2, r2, #24
 8011ef0:	bf58      	it	pl
 8011ef2:	4608      	movpl	r0, r1
 8011ef4:	d5f4      	bpl.n	8011ee0 <__swsetup_r+0x34>
 8011ef6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011efa:	81a3      	strh	r3, [r4, #12]
 8011efc:	f04f 30ff 	mov.w	r0, #4294967295
 8011f00:	bd38      	pop	{r3, r4, r5, pc}
 8011f02:	06d1      	lsls	r1, r2, #27
 8011f04:	d52e      	bpl.n	8011f64 <__swsetup_r+0xb8>
 8011f06:	0752      	lsls	r2, r2, #29
 8011f08:	d414      	bmi.n	8011f34 <__swsetup_r+0x88>
 8011f0a:	6921      	ldr	r1, [r4, #16]
 8011f0c:	f043 0308 	orr.w	r3, r3, #8
 8011f10:	81a3      	strh	r3, [r4, #12]
 8011f12:	b29a      	uxth	r2, r3
 8011f14:	2900      	cmp	r1, #0
 8011f16:	d1d9      	bne.n	8011ecc <__swsetup_r+0x20>
 8011f18:	f402 7020 	and.w	r0, r2, #640	; 0x280
 8011f1c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8011f20:	d0d4      	beq.n	8011ecc <__swsetup_r+0x20>
 8011f22:	4621      	mov	r1, r4
 8011f24:	4628      	mov	r0, r5
 8011f26:	f002 fb4d 	bl	80145c4 <__smakebuf_r>
 8011f2a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011f2e:	6921      	ldr	r1, [r4, #16]
 8011f30:	b29a      	uxth	r2, r3
 8011f32:	e7cb      	b.n	8011ecc <__swsetup_r+0x20>
 8011f34:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8011f36:	b151      	cbz	r1, 8011f4e <__swsetup_r+0xa2>
 8011f38:	f104 0240 	add.w	r2, r4, #64	; 0x40
 8011f3c:	4291      	cmp	r1, r2
 8011f3e:	d004      	beq.n	8011f4a <__swsetup_r+0x9e>
 8011f40:	4628      	mov	r0, r5
 8011f42:	f001 f91b 	bl	801317c <_free_r>
 8011f46:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011f4a:	2200      	movs	r2, #0
 8011f4c:	6322      	str	r2, [r4, #48]	; 0x30
 8011f4e:	6921      	ldr	r1, [r4, #16]
 8011f50:	2200      	movs	r2, #0
 8011f52:	e9c4 1200 	strd	r1, r2, [r4]
 8011f56:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8011f5a:	e7d7      	b.n	8011f0c <__swsetup_r+0x60>
 8011f5c:	4618      	mov	r0, r3
 8011f5e:	f7ff fd03 	bl	8011968 <__sinit>
 8011f62:	e7ac      	b.n	8011ebe <__swsetup_r+0x12>
 8011f64:	2209      	movs	r2, #9
 8011f66:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011f6a:	602a      	str	r2, [r5, #0]
 8011f6c:	f04f 30ff 	mov.w	r0, #4294967295
 8011f70:	81a3      	strh	r3, [r4, #12]
 8011f72:	bd38      	pop	{r3, r4, r5, pc}
 8011f74:	24000160 	.word	0x24000160

08011f78 <__fputwc>:
 8011f78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011f7c:	b082      	sub	sp, #8
 8011f7e:	4682      	mov	sl, r0
 8011f80:	4688      	mov	r8, r1
 8011f82:	4614      	mov	r4, r2
 8011f84:	f000 f8fe 	bl	8012184 <__locale_mb_cur_max>
 8011f88:	2801      	cmp	r0, #1
 8011f8a:	d103      	bne.n	8011f94 <__fputwc+0x1c>
 8011f8c:	f108 33ff 	add.w	r3, r8, #4294967295
 8011f90:	2bfe      	cmp	r3, #254	; 0xfe
 8011f92:	d936      	bls.n	8012002 <__fputwc+0x8a>
 8011f94:	f10d 0904 	add.w	r9, sp, #4
 8011f98:	4642      	mov	r2, r8
 8011f9a:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 8011f9e:	4649      	mov	r1, r9
 8011fa0:	4650      	mov	r0, sl
 8011fa2:	f002 fa79 	bl	8014498 <_wcrtomb_r>
 8011fa6:	1c42      	adds	r2, r0, #1
 8011fa8:	4606      	mov	r6, r0
 8011faa:	d032      	beq.n	8012012 <__fputwc+0x9a>
 8011fac:	b320      	cbz	r0, 8011ff8 <__fputwc+0x80>
 8011fae:	f89d c004 	ldrb.w	ip, [sp, #4]
 8011fb2:	2500      	movs	r5, #0
 8011fb4:	e009      	b.n	8011fca <__fputwc+0x52>
 8011fb6:	6823      	ldr	r3, [r4, #0]
 8011fb8:	1c5a      	adds	r2, r3, #1
 8011fba:	6022      	str	r2, [r4, #0]
 8011fbc:	f883 c000 	strb.w	ip, [r3]
 8011fc0:	3501      	adds	r5, #1
 8011fc2:	42b5      	cmp	r5, r6
 8011fc4:	d218      	bcs.n	8011ff8 <__fputwc+0x80>
 8011fc6:	f819 cf01 	ldrb.w	ip, [r9, #1]!
 8011fca:	68a3      	ldr	r3, [r4, #8]
 8011fcc:	3b01      	subs	r3, #1
 8011fce:	2b00      	cmp	r3, #0
 8011fd0:	60a3      	str	r3, [r4, #8]
 8011fd2:	daf0      	bge.n	8011fb6 <__fputwc+0x3e>
 8011fd4:	69a7      	ldr	r7, [r4, #24]
 8011fd6:	42bb      	cmp	r3, r7
 8011fd8:	4661      	mov	r1, ip
 8011fda:	4622      	mov	r2, r4
 8011fdc:	4650      	mov	r0, sl
 8011fde:	db02      	blt.n	8011fe6 <__fputwc+0x6e>
 8011fe0:	f1bc 0f0a 	cmp.w	ip, #10
 8011fe4:	d1e7      	bne.n	8011fb6 <__fputwc+0x3e>
 8011fe6:	f7ff ff09 	bl	8011dfc <__swbuf_r>
 8011fea:	1c43      	adds	r3, r0, #1
 8011fec:	d1e8      	bne.n	8011fc0 <__fputwc+0x48>
 8011fee:	4606      	mov	r6, r0
 8011ff0:	4630      	mov	r0, r6
 8011ff2:	b002      	add	sp, #8
 8011ff4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8011ff8:	4646      	mov	r6, r8
 8011ffa:	4630      	mov	r0, r6
 8011ffc:	b002      	add	sp, #8
 8011ffe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8012002:	fa5f fc88 	uxtb.w	ip, r8
 8012006:	f88d c004 	strb.w	ip, [sp, #4]
 801200a:	4606      	mov	r6, r0
 801200c:	f10d 0904 	add.w	r9, sp, #4
 8012010:	e7cf      	b.n	8011fb2 <__fputwc+0x3a>
 8012012:	89a3      	ldrh	r3, [r4, #12]
 8012014:	4630      	mov	r0, r6
 8012016:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801201a:	81a3      	strh	r3, [r4, #12]
 801201c:	b002      	add	sp, #8
 801201e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8012022:	bf00      	nop

08012024 <_fputwc_r>:
 8012024:	b530      	push	{r4, r5, lr}
 8012026:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8012028:	f013 0f01 	tst.w	r3, #1
 801202c:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
 8012030:	4614      	mov	r4, r2
 8012032:	b083      	sub	sp, #12
 8012034:	4605      	mov	r5, r0
 8012036:	b29a      	uxth	r2, r3
 8012038:	d101      	bne.n	801203e <_fputwc_r+0x1a>
 801203a:	0598      	lsls	r0, r3, #22
 801203c:	d51c      	bpl.n	8012078 <_fputwc_r+0x54>
 801203e:	0490      	lsls	r0, r2, #18
 8012040:	d406      	bmi.n	8012050 <_fputwc_r+0x2c>
 8012042:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8012044:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8012048:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 801204c:	81a3      	strh	r3, [r4, #12]
 801204e:	6662      	str	r2, [r4, #100]	; 0x64
 8012050:	4622      	mov	r2, r4
 8012052:	4628      	mov	r0, r5
 8012054:	f7ff ff90 	bl	8011f78 <__fputwc>
 8012058:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801205a:	07da      	lsls	r2, r3, #31
 801205c:	4605      	mov	r5, r0
 801205e:	d402      	bmi.n	8012066 <_fputwc_r+0x42>
 8012060:	89a3      	ldrh	r3, [r4, #12]
 8012062:	059b      	lsls	r3, r3, #22
 8012064:	d502      	bpl.n	801206c <_fputwc_r+0x48>
 8012066:	4628      	mov	r0, r5
 8012068:	b003      	add	sp, #12
 801206a:	bd30      	pop	{r4, r5, pc}
 801206c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801206e:	f000 f8ed 	bl	801224c <__retarget_lock_release_recursive>
 8012072:	4628      	mov	r0, r5
 8012074:	b003      	add	sp, #12
 8012076:	bd30      	pop	{r4, r5, pc}
 8012078:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801207a:	9101      	str	r1, [sp, #4]
 801207c:	f000 f8e4 	bl	8012248 <__retarget_lock_acquire_recursive>
 8012080:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8012084:	9901      	ldr	r1, [sp, #4]
 8012086:	b29a      	uxth	r2, r3
 8012088:	e7d9      	b.n	801203e <_fputwc_r+0x1a>
 801208a:	bf00      	nop

0801208c <memmove>:
 801208c:	4288      	cmp	r0, r1
 801208e:	d90d      	bls.n	80120ac <memmove+0x20>
 8012090:	188b      	adds	r3, r1, r2
 8012092:	4283      	cmp	r3, r0
 8012094:	d90a      	bls.n	80120ac <memmove+0x20>
 8012096:	eb00 0c02 	add.w	ip, r0, r2
 801209a:	b1ba      	cbz	r2, 80120cc <memmove+0x40>
 801209c:	4662      	mov	r2, ip
 801209e:	f813 cd01 	ldrb.w	ip, [r3, #-1]!
 80120a2:	f802 cd01 	strb.w	ip, [r2, #-1]!
 80120a6:	4299      	cmp	r1, r3
 80120a8:	d1f9      	bne.n	801209e <memmove+0x12>
 80120aa:	4770      	bx	lr
 80120ac:	2a0f      	cmp	r2, #15
 80120ae:	d80e      	bhi.n	80120ce <memmove+0x42>
 80120b0:	4603      	mov	r3, r0
 80120b2:	f102 3cff 	add.w	ip, r2, #4294967295
 80120b6:	b14a      	cbz	r2, 80120cc <memmove+0x40>
 80120b8:	f10c 0c01 	add.w	ip, ip, #1
 80120bc:	3b01      	subs	r3, #1
 80120be:	448c      	add	ip, r1
 80120c0:	f811 2b01 	ldrb.w	r2, [r1], #1
 80120c4:	f803 2f01 	strb.w	r2, [r3, #1]!
 80120c8:	4561      	cmp	r1, ip
 80120ca:	d1f9      	bne.n	80120c0 <memmove+0x34>
 80120cc:	4770      	bx	lr
 80120ce:	ea40 0301 	orr.w	r3, r0, r1
 80120d2:	079b      	lsls	r3, r3, #30
 80120d4:	d150      	bne.n	8012178 <memmove+0xec>
 80120d6:	f1a2 0310 	sub.w	r3, r2, #16
 80120da:	b570      	push	{r4, r5, r6, lr}
 80120dc:	f101 0c20 	add.w	ip, r1, #32
 80120e0:	f023 050f 	bic.w	r5, r3, #15
 80120e4:	f101 0e10 	add.w	lr, r1, #16
 80120e8:	f100 0410 	add.w	r4, r0, #16
 80120ec:	44ac      	add	ip, r5
 80120ee:	091b      	lsrs	r3, r3, #4
 80120f0:	f85e 5c10 	ldr.w	r5, [lr, #-16]
 80120f4:	f844 5c10 	str.w	r5, [r4, #-16]
 80120f8:	f85e 5c0c 	ldr.w	r5, [lr, #-12]
 80120fc:	f844 5c0c 	str.w	r5, [r4, #-12]
 8012100:	f85e 5c08 	ldr.w	r5, [lr, #-8]
 8012104:	f844 5c08 	str.w	r5, [r4, #-8]
 8012108:	f85e 5c04 	ldr.w	r5, [lr, #-4]
 801210c:	f844 5c04 	str.w	r5, [r4, #-4]
 8012110:	f10e 0e10 	add.w	lr, lr, #16
 8012114:	45e6      	cmp	lr, ip
 8012116:	f104 0410 	add.w	r4, r4, #16
 801211a:	d1e9      	bne.n	80120f0 <memmove+0x64>
 801211c:	3301      	adds	r3, #1
 801211e:	f012 0f0c 	tst.w	r2, #12
 8012122:	eb01 1103 	add.w	r1, r1, r3, lsl #4
 8012126:	f002 040f 	and.w	r4, r2, #15
 801212a:	eb00 1303 	add.w	r3, r0, r3, lsl #4
 801212e:	d027      	beq.n	8012180 <memmove+0xf4>
 8012130:	3c04      	subs	r4, #4
 8012132:	f024 0603 	bic.w	r6, r4, #3
 8012136:	ea4f 0c94 	mov.w	ip, r4, lsr #2
 801213a:	441e      	add	r6, r3
 801213c:	1f1c      	subs	r4, r3, #4
 801213e:	468e      	mov	lr, r1
 8012140:	f85e 5b04 	ldr.w	r5, [lr], #4
 8012144:	f844 5f04 	str.w	r5, [r4, #4]!
 8012148:	42b4      	cmp	r4, r6
 801214a:	d1f9      	bne.n	8012140 <memmove+0xb4>
 801214c:	f10c 0401 	add.w	r4, ip, #1
 8012150:	f002 0203 	and.w	r2, r2, #3
 8012154:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8012158:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 801215c:	f102 3cff 	add.w	ip, r2, #4294967295
 8012160:	b14a      	cbz	r2, 8012176 <memmove+0xea>
 8012162:	f10c 0c01 	add.w	ip, ip, #1
 8012166:	3b01      	subs	r3, #1
 8012168:	448c      	add	ip, r1
 801216a:	f811 2b01 	ldrb.w	r2, [r1], #1
 801216e:	f803 2f01 	strb.w	r2, [r3, #1]!
 8012172:	4561      	cmp	r1, ip
 8012174:	d1f9      	bne.n	801216a <memmove+0xde>
 8012176:	bd70      	pop	{r4, r5, r6, pc}
 8012178:	f102 3cff 	add.w	ip, r2, #4294967295
 801217c:	4603      	mov	r3, r0
 801217e:	e79b      	b.n	80120b8 <memmove+0x2c>
 8012180:	4622      	mov	r2, r4
 8012182:	e7eb      	b.n	801215c <memmove+0xd0>

08012184 <__locale_mb_cur_max>:
 8012184:	4b01      	ldr	r3, [pc, #4]	; (801218c <__locale_mb_cur_max+0x8>)
 8012186:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 801218a:	4770      	bx	lr
 801218c:	24000170 	.word	0x24000170

08012190 <_localeconv_r>:
 8012190:	4800      	ldr	r0, [pc, #0]	; (8012194 <_localeconv_r+0x4>)
 8012192:	4770      	bx	lr
 8012194:	24000260 	.word	0x24000260

08012198 <_close_r>:
 8012198:	b538      	push	{r3, r4, r5, lr}
 801219a:	4d07      	ldr	r5, [pc, #28]	; (80121b8 <_close_r+0x20>)
 801219c:	2200      	movs	r2, #0
 801219e:	4604      	mov	r4, r0
 80121a0:	4608      	mov	r0, r1
 80121a2:	602a      	str	r2, [r5, #0]
 80121a4:	f7f4 fdd8 	bl	8006d58 <_close>
 80121a8:	1c43      	adds	r3, r0, #1
 80121aa:	d000      	beq.n	80121ae <_close_r+0x16>
 80121ac:	bd38      	pop	{r3, r4, r5, pc}
 80121ae:	682b      	ldr	r3, [r5, #0]
 80121b0:	2b00      	cmp	r3, #0
 80121b2:	d0fb      	beq.n	80121ac <_close_r+0x14>
 80121b4:	6023      	str	r3, [r4, #0]
 80121b6:	bd38      	pop	{r3, r4, r5, pc}
 80121b8:	24006180 	.word	0x24006180

080121bc <_lseek_r>:
 80121bc:	b538      	push	{r3, r4, r5, lr}
 80121be:	460c      	mov	r4, r1
 80121c0:	4d08      	ldr	r5, [pc, #32]	; (80121e4 <_lseek_r+0x28>)
 80121c2:	4684      	mov	ip, r0
 80121c4:	4611      	mov	r1, r2
 80121c6:	4620      	mov	r0, r4
 80121c8:	461a      	mov	r2, r3
 80121ca:	2300      	movs	r3, #0
 80121cc:	602b      	str	r3, [r5, #0]
 80121ce:	4664      	mov	r4, ip
 80121d0:	f7f4 fdcc 	bl	8006d6c <_lseek>
 80121d4:	1c43      	adds	r3, r0, #1
 80121d6:	d000      	beq.n	80121da <_lseek_r+0x1e>
 80121d8:	bd38      	pop	{r3, r4, r5, pc}
 80121da:	682b      	ldr	r3, [r5, #0]
 80121dc:	2b00      	cmp	r3, #0
 80121de:	d0fb      	beq.n	80121d8 <_lseek_r+0x1c>
 80121e0:	6023      	str	r3, [r4, #0]
 80121e2:	bd38      	pop	{r3, r4, r5, pc}
 80121e4:	24006180 	.word	0x24006180

080121e8 <_read_r>:
 80121e8:	b538      	push	{r3, r4, r5, lr}
 80121ea:	460c      	mov	r4, r1
 80121ec:	4d08      	ldr	r5, [pc, #32]	; (8012210 <_read_r+0x28>)
 80121ee:	4684      	mov	ip, r0
 80121f0:	4611      	mov	r1, r2
 80121f2:	4620      	mov	r0, r4
 80121f4:	461a      	mov	r2, r3
 80121f6:	2300      	movs	r3, #0
 80121f8:	602b      	str	r3, [r5, #0]
 80121fa:	4664      	mov	r4, ip
 80121fc:	f7f4 fda2 	bl	8006d44 <_read>
 8012200:	1c43      	adds	r3, r0, #1
 8012202:	d000      	beq.n	8012206 <_read_r+0x1e>
 8012204:	bd38      	pop	{r3, r4, r5, pc}
 8012206:	682b      	ldr	r3, [r5, #0]
 8012208:	2b00      	cmp	r3, #0
 801220a:	d0fb      	beq.n	8012204 <_read_r+0x1c>
 801220c:	6023      	str	r3, [r4, #0]
 801220e:	bd38      	pop	{r3, r4, r5, pc}
 8012210:	24006180 	.word	0x24006180

08012214 <_write_r>:
 8012214:	b538      	push	{r3, r4, r5, lr}
 8012216:	460c      	mov	r4, r1
 8012218:	4d08      	ldr	r5, [pc, #32]	; (801223c <_write_r+0x28>)
 801221a:	4684      	mov	ip, r0
 801221c:	4611      	mov	r1, r2
 801221e:	4620      	mov	r0, r4
 8012220:	461a      	mov	r2, r3
 8012222:	2300      	movs	r3, #0
 8012224:	602b      	str	r3, [r5, #0]
 8012226:	4664      	mov	r4, ip
 8012228:	f7f4 fd82 	bl	8006d30 <_write>
 801222c:	1c43      	adds	r3, r0, #1
 801222e:	d000      	beq.n	8012232 <_write_r+0x1e>
 8012230:	bd38      	pop	{r3, r4, r5, pc}
 8012232:	682b      	ldr	r3, [r5, #0]
 8012234:	2b00      	cmp	r3, #0
 8012236:	d0fb      	beq.n	8012230 <_write_r+0x1c>
 8012238:	6023      	str	r3, [r4, #0]
 801223a:	bd38      	pop	{r3, r4, r5, pc}
 801223c:	24006180 	.word	0x24006180

08012240 <__retarget_lock_init_recursive>:
 8012240:	4770      	bx	lr
 8012242:	bf00      	nop

08012244 <__retarget_lock_close_recursive>:
 8012244:	4770      	bx	lr
 8012246:	bf00      	nop

08012248 <__retarget_lock_acquire_recursive>:
 8012248:	4770      	bx	lr
 801224a:	bf00      	nop

0801224c <__retarget_lock_release_recursive>:
 801224c:	4770      	bx	lr
 801224e:	bf00      	nop

08012250 <frexp>:
 8012250:	b430      	push	{r4, r5}
 8012252:	b082      	sub	sp, #8
 8012254:	ed8d 0b00 	vstr	d0, [sp]
 8012258:	9a01      	ldr	r2, [sp, #4]
 801225a:	4c19      	ldr	r4, [pc, #100]	; (80122c0 <frexp+0x70>)
 801225c:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 8012260:	2100      	movs	r1, #0
 8012262:	42a3      	cmp	r3, r4
 8012264:	6001      	str	r1, [r0, #0]
 8012266:	dc21      	bgt.n	80122ac <frexp+0x5c>
 8012268:	9c00      	ldr	r4, [sp, #0]
 801226a:	431c      	orrs	r4, r3
 801226c:	d01e      	beq.n	80122ac <frexp+0x5c>
 801226e:	4c15      	ldr	r4, [pc, #84]	; (80122c4 <frexp+0x74>)
 8012270:	4014      	ands	r4, r2
 8012272:	b954      	cbnz	r4, 801228a <frexp+0x3a>
 8012274:	ed9f 7b10 	vldr	d7, [pc, #64]	; 80122b8 <frexp+0x68>
 8012278:	ee20 7b07 	vmul.f64	d7, d0, d7
 801227c:	ed8d 7b00 	vstr	d7, [sp]
 8012280:	9a01      	ldr	r2, [sp, #4]
 8012282:	f06f 0135 	mvn.w	r1, #53	; 0x35
 8012286:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 801228a:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 801228e:	e9dd 4500 	ldrd	r4, r5, [sp]
 8012292:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 8012296:	f042 557f 	orr.w	r5, r2, #1069547520	; 0x3fc00000
 801229a:	151b      	asrs	r3, r3, #20
 801229c:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
 80122a0:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
 80122a4:	e9cd 4500 	strd	r4, r5, [sp]
 80122a8:	440b      	add	r3, r1
 80122aa:	6003      	str	r3, [r0, #0]
 80122ac:	ed9d 0b00 	vldr	d0, [sp]
 80122b0:	b002      	add	sp, #8
 80122b2:	bc30      	pop	{r4, r5}
 80122b4:	4770      	bx	lr
 80122b6:	bf00      	nop
 80122b8:	00000000 	.word	0x00000000
 80122bc:	43500000 	.word	0x43500000
 80122c0:	7fefffff 	.word	0x7fefffff
 80122c4:	7ff00000 	.word	0x7ff00000

080122c8 <quorem>:
 80122c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80122cc:	6903      	ldr	r3, [r0, #16]
 80122ce:	690c      	ldr	r4, [r1, #16]
 80122d0:	42a3      	cmp	r3, r4
 80122d2:	b083      	sub	sp, #12
 80122d4:	f2c0 8087 	blt.w	80123e6 <quorem+0x11e>
 80122d8:	3c01      	subs	r4, #1
 80122da:	f101 0514 	add.w	r5, r1, #20
 80122de:	00a3      	lsls	r3, r4, #2
 80122e0:	f100 0814 	add.w	r8, r0, #20
 80122e4:	9300      	str	r3, [sp, #0]
 80122e6:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 80122ea:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
 80122ee:	3301      	adds	r3, #1
 80122f0:	4681      	mov	r9, r0
 80122f2:	429a      	cmp	r2, r3
 80122f4:	eb08 0084 	add.w	r0, r8, r4, lsl #2
 80122f8:	eb05 0784 	add.w	r7, r5, r4, lsl #2
 80122fc:	9001      	str	r0, [sp, #4]
 80122fe:	fbb2 f6f3 	udiv	r6, r2, r3
 8012302:	d33b      	bcc.n	801237c <quorem+0xb4>
 8012304:	f04f 0c00 	mov.w	ip, #0
 8012308:	46ae      	mov	lr, r5
 801230a:	4640      	mov	r0, r8
 801230c:	46e2      	mov	sl, ip
 801230e:	4663      	mov	r3, ip
 8012310:	f85e bb04 	ldr.w	fp, [lr], #4
 8012314:	6802      	ldr	r2, [r0, #0]
 8012316:	fa1f fc8b 	uxth.w	ip, fp
 801231a:	fb06 330c 	mla	r3, r6, ip, r3
 801231e:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8012322:	ea4f 4b1b 	mov.w	fp, fp, lsr #16
 8012326:	fb06 cc0b 	mla	ip, r6, fp, ip
 801232a:	b29b      	uxth	r3, r3
 801232c:	ebaa 0303 	sub.w	r3, sl, r3
 8012330:	fa1f fa8c 	uxth.w	sl, ip
 8012334:	fa13 f382 	uxtah	r3, r3, r2
 8012338:	ebca 4212 	rsb	r2, sl, r2, lsr #16
 801233c:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8012340:	b29b      	uxth	r3, r3
 8012342:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8012346:	4577      	cmp	r7, lr
 8012348:	f840 3b04 	str.w	r3, [r0], #4
 801234c:	ea4f 4a22 	mov.w	sl, r2, asr #16
 8012350:	ea4f 431c 	mov.w	r3, ip, lsr #16
 8012354:	d2dc      	bcs.n	8012310 <quorem+0x48>
 8012356:	9b00      	ldr	r3, [sp, #0]
 8012358:	f858 3003 	ldr.w	r3, [r8, r3]
 801235c:	b973      	cbnz	r3, 801237c <quorem+0xb4>
 801235e:	9b01      	ldr	r3, [sp, #4]
 8012360:	3b04      	subs	r3, #4
 8012362:	4598      	cmp	r8, r3
 8012364:	d304      	bcc.n	8012370 <quorem+0xa8>
 8012366:	e007      	b.n	8012378 <quorem+0xb0>
 8012368:	4598      	cmp	r8, r3
 801236a:	f104 34ff 	add.w	r4, r4, #4294967295
 801236e:	d203      	bcs.n	8012378 <quorem+0xb0>
 8012370:	f853 2904 	ldr.w	r2, [r3], #-4
 8012374:	2a00      	cmp	r2, #0
 8012376:	d0f7      	beq.n	8012368 <quorem+0xa0>
 8012378:	f8c9 4010 	str.w	r4, [r9, #16]
 801237c:	4648      	mov	r0, r9
 801237e:	f001 fd5b 	bl	8013e38 <__mcmp>
 8012382:	2800      	cmp	r0, #0
 8012384:	db2b      	blt.n	80123de <quorem+0x116>
 8012386:	3601      	adds	r6, #1
 8012388:	4641      	mov	r1, r8
 801238a:	2300      	movs	r3, #0
 801238c:	f855 0b04 	ldr.w	r0, [r5], #4
 8012390:	f8d1 c000 	ldr.w	ip, [r1]
 8012394:	b282      	uxth	r2, r0
 8012396:	1a9a      	subs	r2, r3, r2
 8012398:	0c03      	lsrs	r3, r0, #16
 801239a:	fa12 f28c 	uxtah	r2, r2, ip
 801239e:	ebc3 431c 	rsb	r3, r3, ip, lsr #16
 80123a2:	eb03 4322 	add.w	r3, r3, r2, asr #16
 80123a6:	b292      	uxth	r2, r2
 80123a8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 80123ac:	42af      	cmp	r7, r5
 80123ae:	f841 2b04 	str.w	r2, [r1], #4
 80123b2:	ea4f 4323 	mov.w	r3, r3, asr #16
 80123b6:	d2e9      	bcs.n	801238c <quorem+0xc4>
 80123b8:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
 80123bc:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 80123c0:	b96a      	cbnz	r2, 80123de <quorem+0x116>
 80123c2:	3b04      	subs	r3, #4
 80123c4:	4598      	cmp	r8, r3
 80123c6:	d304      	bcc.n	80123d2 <quorem+0x10a>
 80123c8:	e007      	b.n	80123da <quorem+0x112>
 80123ca:	4598      	cmp	r8, r3
 80123cc:	f104 34ff 	add.w	r4, r4, #4294967295
 80123d0:	d203      	bcs.n	80123da <quorem+0x112>
 80123d2:	f853 2904 	ldr.w	r2, [r3], #-4
 80123d6:	2a00      	cmp	r2, #0
 80123d8:	d0f7      	beq.n	80123ca <quorem+0x102>
 80123da:	f8c9 4010 	str.w	r4, [r9, #16]
 80123de:	4630      	mov	r0, r6
 80123e0:	b003      	add	sp, #12
 80123e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80123e6:	2000      	movs	r0, #0
 80123e8:	b003      	add	sp, #12
 80123ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80123ee:	bf00      	nop

080123f0 <_dtoa_r>:
 80123f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80123f4:	ed2d 8b02 	vpush	{d8}
 80123f8:	b08f      	sub	sp, #60	; 0x3c
 80123fa:	ed8d 0b02 	vstr	d0, [sp, #8]
 80123fe:	9101      	str	r1, [sp, #4]
 8012400:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8012402:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 8012404:	9305      	str	r3, [sp, #20]
 8012406:	ec57 6b10 	vmov	r6, r7, d0
 801240a:	4604      	mov	r4, r0
 801240c:	4693      	mov	fp, r2
 801240e:	b141      	cbz	r1, 8012422 <_dtoa_r+0x32>
 8012410:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8012412:	604a      	str	r2, [r1, #4]
 8012414:	2301      	movs	r3, #1
 8012416:	4093      	lsls	r3, r2
 8012418:	608b      	str	r3, [r1, #8]
 801241a:	f001 faad 	bl	8013978 <_Bfree>
 801241e:	2300      	movs	r3, #0
 8012420:	63a3      	str	r3, [r4, #56]	; 0x38
 8012422:	f1b7 0800 	subs.w	r8, r7, #0
 8012426:	bfb4      	ite	lt
 8012428:	2301      	movlt	r3, #1
 801242a:	2300      	movge	r3, #0
 801242c:	602b      	str	r3, [r5, #0]
 801242e:	4bbe      	ldr	r3, [pc, #760]	; (8012728 <_dtoa_r+0x338>)
 8012430:	bfbc      	itt	lt
 8012432:	f028 4800 	biclt.w	r8, r8, #2147483648	; 0x80000000
 8012436:	f8cd 800c 	strlt.w	r8, [sp, #12]
 801243a:	ea33 0308 	bics.w	r3, r3, r8
 801243e:	f000 809f 	beq.w	8012580 <_dtoa_r+0x190>
 8012442:	ed9d 8b02 	vldr	d8, [sp, #8]
 8012446:	eeb5 8b40 	vcmp.f64	d8, #0.0
 801244a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801244e:	d111      	bne.n	8012474 <_dtoa_r+0x84>
 8012450:	9a05      	ldr	r2, [sp, #20]
 8012452:	2301      	movs	r3, #1
 8012454:	6013      	str	r3, [r2, #0]
 8012456:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8012458:	2b00      	cmp	r3, #0
 801245a:	f000 823f 	beq.w	80128dc <_dtoa_r+0x4ec>
 801245e:	4bb3      	ldr	r3, [pc, #716]	; (801272c <_dtoa_r+0x33c>)
 8012460:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8012462:	6013      	str	r3, [r2, #0]
 8012464:	3b01      	subs	r3, #1
 8012466:	9300      	str	r3, [sp, #0]
 8012468:	9800      	ldr	r0, [sp, #0]
 801246a:	b00f      	add	sp, #60	; 0x3c
 801246c:	ecbd 8b02 	vpop	{d8}
 8012470:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012474:	aa0c      	add	r2, sp, #48	; 0x30
 8012476:	a90d      	add	r1, sp, #52	; 0x34
 8012478:	4620      	mov	r0, r4
 801247a:	eeb0 0b48 	vmov.f64	d0, d8
 801247e:	f001 fda7 	bl	8013fd0 <__d2b>
 8012482:	ea5f 5318 	movs.w	r3, r8, lsr #20
 8012486:	4605      	mov	r5, r0
 8012488:	f040 8092 	bne.w	80125b0 <_dtoa_r+0x1c0>
 801248c:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
 8012490:	440b      	add	r3, r1
 8012492:	f203 4232 	addw	r2, r3, #1074	; 0x432
 8012496:	2a20      	cmp	r2, #32
 8012498:	f340 82fa 	ble.w	8012a90 <_dtoa_r+0x6a0>
 801249c:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
 80124a0:	fa08 f802 	lsl.w	r8, r8, r2
 80124a4:	f203 4212 	addw	r2, r3, #1042	; 0x412
 80124a8:	40d6      	lsrs	r6, r2
 80124aa:	ea48 0206 	orr.w	r2, r8, r6
 80124ae:	ee07 2a10 	vmov	s14, r2
 80124b2:	eeb8 7b47 	vcvt.f64.u32	d7, s14
 80124b6:	1e58      	subs	r0, r3, #1
 80124b8:	ee17 6a90 	vmov	r6, s15
 80124bc:	ec53 2b17 	vmov	r2, r3, d7
 80124c0:	f04f 0a01 	mov.w	sl, #1
 80124c4:	f1a6 73f8 	sub.w	r3, r6, #32505856	; 0x1f00000
 80124c8:	ed9f 3b91 	vldr	d3, [pc, #580]	; 8012710 <_dtoa_r+0x320>
 80124cc:	ed9f 7b92 	vldr	d7, [pc, #584]	; 8012718 <_dtoa_r+0x328>
 80124d0:	ed9f 5b93 	vldr	d5, [pc, #588]	; 8012720 <_dtoa_r+0x330>
 80124d4:	ee06 0a90 	vmov	s13, r0
 80124d8:	ec43 2b12 	vmov	d2, r2, r3
 80124dc:	eeb8 4be6 	vcvt.f64.s32	d4, s13
 80124e0:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
 80124e4:	ee32 6b46 	vsub.f64	d6, d2, d6
 80124e8:	eea6 7b03 	vfma.f64	d7, d6, d3
 80124ec:	eea4 7b05 	vfma.f64	d7, d4, d5
 80124f0:	eefd 6bc7 	vcvt.s32.f64	s13, d7
 80124f4:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
 80124f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80124fc:	ee16 7a90 	vmov	r7, s13
 8012500:	d508      	bpl.n	8012514 <_dtoa_r+0x124>
 8012502:	eeb8 6be6 	vcvt.f64.s32	d6, s13
 8012506:	eeb4 6b47 	vcmp.f64	d6, d7
 801250a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801250e:	bf18      	it	ne
 8012510:	f107 37ff 	addne.w	r7, r7, #4294967295
 8012514:	2f16      	cmp	r7, #22
 8012516:	f200 8145 	bhi.w	80127a4 <_dtoa_r+0x3b4>
 801251a:	4b85      	ldr	r3, [pc, #532]	; (8012730 <_dtoa_r+0x340>)
 801251c:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 8012520:	ed93 7b00 	vldr	d7, [r3]
 8012524:	eeb4 8bc7 	vcmpe.f64	d8, d7
 8012528:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801252c:	d557      	bpl.n	80125de <_dtoa_r+0x1ee>
 801252e:	1a09      	subs	r1, r1, r0
 8012530:	2300      	movs	r3, #0
 8012532:	f1b1 0801 	subs.w	r8, r1, #1
 8012536:	f107 37ff 	add.w	r7, r7, #4294967295
 801253a:	930a      	str	r3, [sp, #40]	; 0x28
 801253c:	f100 8139 	bmi.w	80127b2 <_dtoa_r+0x3c2>
 8012540:	2300      	movs	r3, #0
 8012542:	9306      	str	r3, [sp, #24]
 8012544:	2f00      	cmp	r7, #0
 8012546:	da52      	bge.n	80125ee <_dtoa_r+0x1fe>
 8012548:	9b06      	ldr	r3, [sp, #24]
 801254a:	9704      	str	r7, [sp, #16]
 801254c:	1bdb      	subs	r3, r3, r7
 801254e:	9306      	str	r3, [sp, #24]
 8012550:	427b      	negs	r3, r7
 8012552:	9308      	str	r3, [sp, #32]
 8012554:	9b01      	ldr	r3, [sp, #4]
 8012556:	2b09      	cmp	r3, #9
 8012558:	f04f 0700 	mov.w	r7, #0
 801255c:	d84e      	bhi.n	80125fc <_dtoa_r+0x20c>
 801255e:	2b05      	cmp	r3, #5
 8012560:	f340 829d 	ble.w	8012a9e <_dtoa_r+0x6ae>
 8012564:	3b04      	subs	r3, #4
 8012566:	9301      	str	r3, [sp, #4]
 8012568:	2600      	movs	r6, #0
 801256a:	9b01      	ldr	r3, [sp, #4]
 801256c:	1e9a      	subs	r2, r3, #2
 801256e:	2a03      	cmp	r2, #3
 8012570:	f200 8125 	bhi.w	80127be <_dtoa_r+0x3ce>
 8012574:	e8df f012 	tbh	[pc, r2, lsl #1]
 8012578:	03a703aa 	.word	0x03a703aa
 801257c:	037e039d 	.word	0x037e039d
 8012580:	9a05      	ldr	r2, [sp, #20]
 8012582:	f3c8 0813 	ubfx	r8, r8, #0, #20
 8012586:	f242 730f 	movw	r3, #9999	; 0x270f
 801258a:	ea58 0806 	orrs.w	r8, r8, r6
 801258e:	6013      	str	r3, [r2, #0]
 8012590:	d11e      	bne.n	80125d0 <_dtoa_r+0x1e0>
 8012592:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8012594:	2b00      	cmp	r3, #0
 8012596:	f000 8591 	beq.w	80130bc <_dtoa_r+0xccc>
 801259a:	4b66      	ldr	r3, [pc, #408]	; (8012734 <_dtoa_r+0x344>)
 801259c:	9300      	str	r3, [sp, #0]
 801259e:	3308      	adds	r3, #8
 80125a0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80125a2:	9800      	ldr	r0, [sp, #0]
 80125a4:	6013      	str	r3, [r2, #0]
 80125a6:	b00f      	add	sp, #60	; 0x3c
 80125a8:	ecbd 8b02 	vpop	{d8}
 80125ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80125b0:	ee18 6a90 	vmov	r6, s17
 80125b4:	f3c6 0613 	ubfx	r6, r6, #0, #20
 80125b8:	f2a3 30ff 	subw	r0, r3, #1023	; 0x3ff
 80125bc:	ec53 2b18 	vmov	r2, r3, d8
 80125c0:	f046 537f 	orr.w	r3, r6, #1069547520	; 0x3fc00000
 80125c4:	990c      	ldr	r1, [sp, #48]	; 0x30
 80125c6:	f04f 0a00 	mov.w	sl, #0
 80125ca:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 80125ce:	e77b      	b.n	80124c8 <_dtoa_r+0xd8>
 80125d0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80125d2:	2b00      	cmp	r3, #0
 80125d4:	f040 833b 	bne.w	8012c4e <_dtoa_r+0x85e>
 80125d8:	4b57      	ldr	r3, [pc, #348]	; (8012738 <_dtoa_r+0x348>)
 80125da:	9300      	str	r3, [sp, #0]
 80125dc:	e744      	b.n	8012468 <_dtoa_r+0x78>
 80125de:	1a09      	subs	r1, r1, r0
 80125e0:	2300      	movs	r3, #0
 80125e2:	f1b1 0801 	subs.w	r8, r1, #1
 80125e6:	930a      	str	r3, [sp, #40]	; 0x28
 80125e8:	f100 80e3 	bmi.w	80127b2 <_dtoa_r+0x3c2>
 80125ec:	9306      	str	r3, [sp, #24]
 80125ee:	2300      	movs	r3, #0
 80125f0:	9308      	str	r3, [sp, #32]
 80125f2:	9b01      	ldr	r3, [sp, #4]
 80125f4:	9704      	str	r7, [sp, #16]
 80125f6:	2b09      	cmp	r3, #9
 80125f8:	44b8      	add	r8, r7
 80125fa:	d9b0      	bls.n	801255e <_dtoa_r+0x16e>
 80125fc:	2300      	movs	r3, #0
 80125fe:	2601      	movs	r6, #1
 8012600:	9301      	str	r3, [sp, #4]
 8012602:	9607      	str	r6, [sp, #28]
 8012604:	f04f 39ff 	mov.w	r9, #4294967295
 8012608:	469b      	mov	fp, r3
 801260a:	2100      	movs	r1, #0
 801260c:	63e1      	str	r1, [r4, #60]	; 0x3c
 801260e:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8012612:	4620      	mov	r0, r4
 8012614:	f001 f98a 	bl	801392c <_Balloc>
 8012618:	9000      	str	r0, [sp, #0]
 801261a:	2800      	cmp	r0, #0
 801261c:	f000 8540 	beq.w	80130a0 <_dtoa_r+0xcb0>
 8012620:	9b00      	ldr	r3, [sp, #0]
 8012622:	63a3      	str	r3, [r4, #56]	; 0x38
 8012624:	f1b9 0f0e 	cmp.w	r9, #14
 8012628:	f200 80dc 	bhi.w	80127e4 <_dtoa_r+0x3f4>
 801262c:	2e00      	cmp	r6, #0
 801262e:	f000 80d9 	beq.w	80127e4 <_dtoa_r+0x3f4>
 8012632:	9b04      	ldr	r3, [sp, #16]
 8012634:	2b00      	cmp	r3, #0
 8012636:	f340 83de 	ble.w	8012df6 <_dtoa_r+0xa06>
 801263a:	4a3d      	ldr	r2, [pc, #244]	; (8012730 <_dtoa_r+0x340>)
 801263c:	f003 010f 	and.w	r1, r3, #15
 8012640:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 8012644:	ed92 7b00 	vldr	d7, [r2]
 8012648:	111a      	asrs	r2, r3, #4
 801264a:	05db      	lsls	r3, r3, #23
 801264c:	f140 8382 	bpl.w	8012d54 <_dtoa_r+0x964>
 8012650:	493a      	ldr	r1, [pc, #232]	; (801273c <_dtoa_r+0x34c>)
 8012652:	ed91 6b08 	vldr	d6, [r1, #32]
 8012656:	f002 020f 	and.w	r2, r2, #15
 801265a:	2003      	movs	r0, #3
 801265c:	ee88 5b06 	vdiv.f64	d5, d8, d6
 8012660:	b15a      	cbz	r2, 801267a <_dtoa_r+0x28a>
 8012662:	4936      	ldr	r1, [pc, #216]	; (801273c <_dtoa_r+0x34c>)
 8012664:	07d6      	lsls	r6, r2, #31
 8012666:	d504      	bpl.n	8012672 <_dtoa_r+0x282>
 8012668:	ed91 6b00 	vldr	d6, [r1]
 801266c:	3001      	adds	r0, #1
 801266e:	ee27 7b06 	vmul.f64	d7, d7, d6
 8012672:	1052      	asrs	r2, r2, #1
 8012674:	f101 0108 	add.w	r1, r1, #8
 8012678:	d1f4      	bne.n	8012664 <_dtoa_r+0x274>
 801267a:	ee85 6b07 	vdiv.f64	d6, d5, d7
 801267e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012680:	b13b      	cbz	r3, 8012692 <_dtoa_r+0x2a2>
 8012682:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
 8012686:	eeb4 6bc7 	vcmpe.f64	d6, d7
 801268a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801268e:	f100 84ae 	bmi.w	8012fee <_dtoa_r+0xbfe>
 8012692:	ee07 0a90 	vmov	s15, r0
 8012696:	eeb8 5be7 	vcvt.f64.s32	d5, s15
 801269a:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
 801269e:	eea5 7b06 	vfma.f64	d7, d5, d6
 80126a2:	ee17 2a90 	vmov	r2, s15
 80126a6:	ec51 0b17 	vmov	r0, r1, d7
 80126aa:	f1a2 7150 	sub.w	r1, r2, #54525952	; 0x3400000
 80126ae:	f1b9 0f00 	cmp.w	r9, #0
 80126b2:	f000 8388 	beq.w	8012dc6 <_dtoa_r+0x9d6>
 80126b6:	9e04      	ldr	r6, [sp, #16]
 80126b8:	464a      	mov	r2, r9
 80126ba:	9b07      	ldr	r3, [sp, #28]
 80126bc:	2b00      	cmp	r3, #0
 80126be:	f000 8447 	beq.w	8012f50 <_dtoa_r+0xb60>
 80126c2:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
 80126c6:	4b1a      	ldr	r3, [pc, #104]	; (8012730 <_dtoa_r+0x340>)
 80126c8:	eefd 4bc6 	vcvt.s32.f64	s9, d6
 80126cc:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
 80126d0:	eeb8 7be4 	vcvt.f64.s32	d7, s9
 80126d4:	ee36 7b47 	vsub.f64	d7, d6, d7
 80126d8:	ed1c 6b02 	vldr	d6, [ip, #-8]
 80126dc:	ee83 5b06 	vdiv.f64	d5, d3, d6
 80126e0:	ec41 0b16 	vmov	d6, r0, r1
 80126e4:	ee14 0a90 	vmov	r0, s9
 80126e8:	ee35 5b46 	vsub.f64	d5, d5, d6
 80126ec:	9900      	ldr	r1, [sp, #0]
 80126ee:	eeb4 5bc7 	vcmpe.f64	d5, d7
 80126f2:	3030      	adds	r0, #48	; 0x30
 80126f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80126f8:	f801 0b01 	strb.w	r0, [r1], #1
 80126fc:	f300 84ac 	bgt.w	8013058 <_dtoa_r+0xc68>
 8012700:	eeb7 2b00 	vmov.f64	d2, #112	; 0x3f800000  1.0
 8012704:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
 8012708:	f04f 0c00 	mov.w	ip, #0
 801270c:	e031      	b.n	8012772 <_dtoa_r+0x382>
 801270e:	bf00      	nop
 8012710:	636f4361 	.word	0x636f4361
 8012714:	3fd287a7 	.word	0x3fd287a7
 8012718:	8b60c8b3 	.word	0x8b60c8b3
 801271c:	3fc68a28 	.word	0x3fc68a28
 8012720:	509f79fb 	.word	0x509f79fb
 8012724:	3fd34413 	.word	0x3fd34413
 8012728:	7ff00000 	.word	0x7ff00000
 801272c:	08015a2d 	.word	0x08015a2d
 8012730:	08015bb8 	.word	0x08015bb8
 8012734:	08015ab4 	.word	0x08015ab4
 8012738:	08015ac0 	.word	0x08015ac0
 801273c:	08015b90 	.word	0x08015b90
 8012740:	f10c 0c01 	add.w	ip, ip, #1
 8012744:	4594      	cmp	ip, r2
 8012746:	da4d      	bge.n	80127e4 <_dtoa_r+0x3f4>
 8012748:	ee27 7b04 	vmul.f64	d7, d7, d4
 801274c:	ee25 5b04 	vmul.f64	d5, d5, d4
 8012750:	eefd 6bc7 	vcvt.s32.f64	s13, d7
 8012754:	ee16 3a90 	vmov	r3, s13
 8012758:	eeb8 3be6 	vcvt.f64.s32	d3, s13
 801275c:	3330      	adds	r3, #48	; 0x30
 801275e:	ee37 7b43 	vsub.f64	d7, d7, d3
 8012762:	eeb4 7bc5 	vcmpe.f64	d7, d5
 8012766:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801276a:	f801 3b01 	strb.w	r3, [r1], #1
 801276e:	f100 8473 	bmi.w	8013058 <_dtoa_r+0xc68>
 8012772:	ee32 6b47 	vsub.f64	d6, d2, d7
 8012776:	eeb4 6bc5 	vcmpe.f64	d6, d5
 801277a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801277e:	d5df      	bpl.n	8012740 <_dtoa_r+0x350>
 8012780:	9a00      	ldr	r2, [sp, #0]
 8012782:	9604      	str	r6, [sp, #16]
 8012784:	e002      	b.n	801278c <_dtoa_r+0x39c>
 8012786:	428a      	cmp	r2, r1
 8012788:	f000 8450 	beq.w	801302c <_dtoa_r+0xc3c>
 801278c:	4689      	mov	r9, r1
 801278e:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
 8012792:	2b39      	cmp	r3, #57	; 0x39
 8012794:	d0f7      	beq.n	8012786 <_dtoa_r+0x396>
 8012796:	3301      	adds	r3, #1
 8012798:	b2db      	uxtb	r3, r3
 801279a:	700b      	strb	r3, [r1, #0]
 801279c:	9b04      	ldr	r3, [sp, #16]
 801279e:	3301      	adds	r3, #1
 80127a0:	9304      	str	r3, [sp, #16]
 80127a2:	e155      	b.n	8012a50 <_dtoa_r+0x660>
 80127a4:	1a09      	subs	r1, r1, r0
 80127a6:	2301      	movs	r3, #1
 80127a8:	f1b1 0801 	subs.w	r8, r1, #1
 80127ac:	930a      	str	r3, [sp, #40]	; 0x28
 80127ae:	f57f aec7 	bpl.w	8012540 <_dtoa_r+0x150>
 80127b2:	f1c1 0301 	rsb	r3, r1, #1
 80127b6:	9306      	str	r3, [sp, #24]
 80127b8:	f04f 0800 	mov.w	r8, #0
 80127bc:	e6c2      	b.n	8012544 <_dtoa_r+0x154>
 80127be:	2600      	movs	r6, #0
 80127c0:	63e6      	str	r6, [r4, #60]	; 0x3c
 80127c2:	4631      	mov	r1, r6
 80127c4:	4620      	mov	r0, r4
 80127c6:	f001 f8b1 	bl	801392c <_Balloc>
 80127ca:	9000      	str	r0, [sp, #0]
 80127cc:	2800      	cmp	r0, #0
 80127ce:	f000 8467 	beq.w	80130a0 <_dtoa_r+0xcb0>
 80127d2:	9b00      	ldr	r3, [sp, #0]
 80127d4:	63a3      	str	r3, [r4, #56]	; 0x38
 80127d6:	f04f 33ff 	mov.w	r3, #4294967295
 80127da:	930b      	str	r3, [sp, #44]	; 0x2c
 80127dc:	4699      	mov	r9, r3
 80127de:	2301      	movs	r3, #1
 80127e0:	46b3      	mov	fp, r6
 80127e2:	9307      	str	r3, [sp, #28]
 80127e4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80127e6:	2a00      	cmp	r2, #0
 80127e8:	db55      	blt.n	8012896 <_dtoa_r+0x4a6>
 80127ea:	9904      	ldr	r1, [sp, #16]
 80127ec:	290e      	cmp	r1, #14
 80127ee:	dc52      	bgt.n	8012896 <_dtoa_r+0x4a6>
 80127f0:	4bb7      	ldr	r3, [pc, #732]	; (8012ad0 <_dtoa_r+0x6e0>)
 80127f2:	f1bb 0f00 	cmp.w	fp, #0
 80127f6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 80127fa:	ed93 6b00 	vldr	d6, [r3]
 80127fe:	da15      	bge.n	801282c <_dtoa_r+0x43c>
 8012800:	f1b9 0f00 	cmp.w	r9, #0
 8012804:	dc12      	bgt.n	801282c <_dtoa_r+0x43c>
 8012806:	f040 82f2 	bne.w	8012dee <_dtoa_r+0x9fe>
 801280a:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
 801280e:	ee26 7b07 	vmul.f64	d7, d6, d7
 8012812:	eeb4 8bc7 	vcmpe.f64	d8, d7
 8012816:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801281a:	46ca      	mov	sl, r9
 801281c:	464e      	mov	r6, r9
 801281e:	f200 826d 	bhi.w	8012cfc <_dtoa_r+0x90c>
 8012822:	f8dd 8000 	ldr.w	r8, [sp]
 8012826:	ea6f 0b0b 	mvn.w	fp, fp
 801282a:	e270      	b.n	8012d0e <_dtoa_r+0x91e>
 801282c:	ee88 7b06 	vdiv.f64	d7, d8, d6
 8012830:	eebd 7bc7 	vcvt.s32.f64	s14, d7
 8012834:	9900      	ldr	r1, [sp, #0]
 8012836:	ee17 3a10 	vmov	r3, s14
 801283a:	f1b9 0f01 	cmp.w	r9, #1
 801283e:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8012842:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
 8012846:	f801 3b01 	strb.w	r3, [r1], #1
 801284a:	eea5 8b46 	vfms.f64	d8, d5, d6
 801284e:	f000 8334 	beq.w	8012eba <_dtoa_r+0xaca>
 8012852:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
 8012856:	2301      	movs	r3, #1
 8012858:	e011      	b.n	801287e <_dtoa_r+0x48e>
 801285a:	ee88 7b06 	vdiv.f64	d7, d8, d6
 801285e:	eebd 7bc7 	vcvt.s32.f64	s14, d7
 8012862:	3301      	adds	r3, #1
 8012864:	ee17 2a10 	vmov	r2, s14
 8012868:	454b      	cmp	r3, r9
 801286a:	f102 0230 	add.w	r2, r2, #48	; 0x30
 801286e:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
 8012872:	f801 2b01 	strb.w	r2, [r1], #1
 8012876:	eea5 8b46 	vfms.f64	d8, d5, d6
 801287a:	f000 831e 	beq.w	8012eba <_dtoa_r+0xaca>
 801287e:	ee28 8b04 	vmul.f64	d8, d8, d4
 8012882:	eeb5 8b40 	vcmp.f64	d8, #0.0
 8012886:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801288a:	d1e6      	bne.n	801285a <_dtoa_r+0x46a>
 801288c:	9b04      	ldr	r3, [sp, #16]
 801288e:	3301      	adds	r3, #1
 8012890:	9304      	str	r3, [sp, #16]
 8012892:	4689      	mov	r9, r1
 8012894:	e0dc      	b.n	8012a50 <_dtoa_r+0x660>
 8012896:	9b07      	ldr	r3, [sp, #28]
 8012898:	b343      	cbz	r3, 80128ec <_dtoa_r+0x4fc>
 801289a:	9b01      	ldr	r3, [sp, #4]
 801289c:	2b01      	cmp	r3, #1
 801289e:	f340 8276 	ble.w	8012d8e <_dtoa_r+0x99e>
 80128a2:	9b08      	ldr	r3, [sp, #32]
 80128a4:	f109 3aff 	add.w	sl, r9, #4294967295
 80128a8:	4553      	cmp	r3, sl
 80128aa:	f280 823f 	bge.w	8012d2c <_dtoa_r+0x93c>
 80128ae:	9b08      	ldr	r3, [sp, #32]
 80128b0:	f8cd a020 	str.w	sl, [sp, #32]
 80128b4:	ebaa 0203 	sub.w	r2, sl, r3
 80128b8:	4417      	add	r7, r2
 80128ba:	f04f 0a00 	mov.w	sl, #0
 80128be:	f1b9 0f00 	cmp.w	r9, #0
 80128c2:	f2c0 8325 	blt.w	8012f10 <_dtoa_r+0xb20>
 80128c6:	9b06      	ldr	r3, [sp, #24]
 80128c8:	9309      	str	r3, [sp, #36]	; 0x24
 80128ca:	444b      	add	r3, r9
 80128cc:	44c8      	add	r8, r9
 80128ce:	9306      	str	r3, [sp, #24]
 80128d0:	2101      	movs	r1, #1
 80128d2:	4620      	mov	r0, r4
 80128d4:	f001 f8fc 	bl	8013ad0 <__i2b>
 80128d8:	4606      	mov	r6, r0
 80128da:	e00c      	b.n	80128f6 <_dtoa_r+0x506>
 80128dc:	4b7d      	ldr	r3, [pc, #500]	; (8012ad4 <_dtoa_r+0x6e4>)
 80128de:	9300      	str	r3, [sp, #0]
 80128e0:	9800      	ldr	r0, [sp, #0]
 80128e2:	b00f      	add	sp, #60	; 0x3c
 80128e4:	ecbd 8b02 	vpop	{d8}
 80128e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80128ec:	9b06      	ldr	r3, [sp, #24]
 80128ee:	f8dd a020 	ldr.w	sl, [sp, #32]
 80128f2:	9e07      	ldr	r6, [sp, #28]
 80128f4:	9309      	str	r3, [sp, #36]	; 0x24
 80128f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80128f8:	b16b      	cbz	r3, 8012916 <_dtoa_r+0x526>
 80128fa:	f1b8 0f00 	cmp.w	r8, #0
 80128fe:	dd0a      	ble.n	8012916 <_dtoa_r+0x526>
 8012900:	4543      	cmp	r3, r8
 8012902:	9906      	ldr	r1, [sp, #24]
 8012904:	461a      	mov	r2, r3
 8012906:	bfa8      	it	ge
 8012908:	4642      	movge	r2, r8
 801290a:	1a89      	subs	r1, r1, r2
 801290c:	1a9b      	subs	r3, r3, r2
 801290e:	9106      	str	r1, [sp, #24]
 8012910:	9309      	str	r3, [sp, #36]	; 0x24
 8012912:	eba8 0802 	sub.w	r8, r8, r2
 8012916:	9b08      	ldr	r3, [sp, #32]
 8012918:	b163      	cbz	r3, 8012934 <_dtoa_r+0x544>
 801291a:	9b07      	ldr	r3, [sp, #28]
 801291c:	2b00      	cmp	r3, #0
 801291e:	f000 82a7 	beq.w	8012e70 <_dtoa_r+0xa80>
 8012922:	f1ba 0f00 	cmp.w	sl, #0
 8012926:	f300 8204 	bgt.w	8012d32 <_dtoa_r+0x942>
 801292a:	9b08      	ldr	r3, [sp, #32]
 801292c:	ebb3 020a 	subs.w	r2, r3, sl
 8012930:	f040 82ff 	bne.w	8012f32 <_dtoa_r+0xb42>
 8012934:	2101      	movs	r1, #1
 8012936:	4620      	mov	r0, r4
 8012938:	f001 f8ca 	bl	8013ad0 <__i2b>
 801293c:	2f00      	cmp	r7, #0
 801293e:	4682      	mov	sl, r0
 8012940:	f300 80af 	bgt.w	8012aa2 <_dtoa_r+0x6b2>
 8012944:	9b01      	ldr	r3, [sp, #4]
 8012946:	2b01      	cmp	r3, #1
 8012948:	f340 8187 	ble.w	8012c5a <_dtoa_r+0x86a>
 801294c:	2300      	movs	r3, #0
 801294e:	9308      	str	r3, [sp, #32]
 8012950:	2001      	movs	r0, #1
 8012952:	2f00      	cmp	r7, #0
 8012954:	f040 80b1 	bne.w	8012aba <_dtoa_r+0x6ca>
 8012958:	4440      	add	r0, r8
 801295a:	f010 001f 	ands.w	r0, r0, #31
 801295e:	f000 817a 	beq.w	8012c56 <_dtoa_r+0x866>
 8012962:	f1c0 0220 	rsb	r2, r0, #32
 8012966:	2a04      	cmp	r2, #4
 8012968:	f300 8088 	bgt.w	8012a7c <_dtoa_r+0x68c>
 801296c:	f040 81f6 	bne.w	8012d5c <_dtoa_r+0x96c>
 8012970:	9b06      	ldr	r3, [sp, #24]
 8012972:	2b00      	cmp	r3, #0
 8012974:	dd05      	ble.n	8012982 <_dtoa_r+0x592>
 8012976:	4629      	mov	r1, r5
 8012978:	461a      	mov	r2, r3
 801297a:	4620      	mov	r0, r4
 801297c:	f001 f9e4 	bl	8013d48 <__lshift>
 8012980:	4605      	mov	r5, r0
 8012982:	f1b8 0f00 	cmp.w	r8, #0
 8012986:	dd05      	ble.n	8012994 <_dtoa_r+0x5a4>
 8012988:	4651      	mov	r1, sl
 801298a:	4642      	mov	r2, r8
 801298c:	4620      	mov	r0, r4
 801298e:	f001 f9db 	bl	8013d48 <__lshift>
 8012992:	4682      	mov	sl, r0
 8012994:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012996:	2b00      	cmp	r3, #0
 8012998:	f040 813f 	bne.w	8012c1a <_dtoa_r+0x82a>
 801299c:	f1b9 0f00 	cmp.w	r9, #0
 80129a0:	f340 8125 	ble.w	8012bee <_dtoa_r+0x7fe>
 80129a4:	9b07      	ldr	r3, [sp, #28]
 80129a6:	2b00      	cmp	r3, #0
 80129a8:	f040 80a3 	bne.w	8012af2 <_dtoa_r+0x702>
 80129ac:	9b04      	ldr	r3, [sp, #16]
 80129ae:	3301      	adds	r3, #1
 80129b0:	9304      	str	r3, [sp, #16]
 80129b2:	f8dd 8000 	ldr.w	r8, [sp]
 80129b6:	2701      	movs	r7, #1
 80129b8:	e007      	b.n	80129ca <_dtoa_r+0x5da>
 80129ba:	4629      	mov	r1, r5
 80129bc:	2300      	movs	r3, #0
 80129be:	220a      	movs	r2, #10
 80129c0:	4620      	mov	r0, r4
 80129c2:	f000 ffe3 	bl	801398c <__multadd>
 80129c6:	3701      	adds	r7, #1
 80129c8:	4605      	mov	r5, r0
 80129ca:	4651      	mov	r1, sl
 80129cc:	4628      	mov	r0, r5
 80129ce:	f7ff fc7b 	bl	80122c8 <quorem>
 80129d2:	45b9      	cmp	r9, r7
 80129d4:	f100 0030 	add.w	r0, r0, #48	; 0x30
 80129d8:	f808 0b01 	strb.w	r0, [r8], #1
 80129dc:	dced      	bgt.n	80129ba <_dtoa_r+0x5ca>
 80129de:	f1b9 0f00 	cmp.w	r9, #0
 80129e2:	9a00      	ldr	r2, [sp, #0]
 80129e4:	bfcc      	ite	gt
 80129e6:	46cb      	movgt	fp, r9
 80129e8:	f04f 0b01 	movle.w	fp, #1
 80129ec:	4603      	mov	r3, r0
 80129ee:	4493      	add	fp, r2
 80129f0:	2700      	movs	r7, #0
 80129f2:	4629      	mov	r1, r5
 80129f4:	2201      	movs	r2, #1
 80129f6:	4620      	mov	r0, r4
 80129f8:	9301      	str	r3, [sp, #4]
 80129fa:	f001 f9a5 	bl	8013d48 <__lshift>
 80129fe:	4651      	mov	r1, sl
 8012a00:	4605      	mov	r5, r0
 8012a02:	f001 fa19 	bl	8013e38 <__mcmp>
 8012a06:	2800      	cmp	r0, #0
 8012a08:	f340 81af 	ble.w	8012d6a <_dtoa_r+0x97a>
 8012a0c:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
 8012a10:	9a00      	ldr	r2, [sp, #0]
 8012a12:	f10b 3bff 	add.w	fp, fp, #4294967295
 8012a16:	e004      	b.n	8012a22 <_dtoa_r+0x632>
 8012a18:	455a      	cmp	r2, fp
 8012a1a:	f000 81b1 	beq.w	8012d80 <_dtoa_r+0x990>
 8012a1e:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
 8012a22:	2b39      	cmp	r3, #57	; 0x39
 8012a24:	f10b 0901 	add.w	r9, fp, #1
 8012a28:	d0f6      	beq.n	8012a18 <_dtoa_r+0x628>
 8012a2a:	3301      	adds	r3, #1
 8012a2c:	f88b 3000 	strb.w	r3, [fp]
 8012a30:	4651      	mov	r1, sl
 8012a32:	4620      	mov	r0, r4
 8012a34:	f000 ffa0 	bl	8013978 <_Bfree>
 8012a38:	b156      	cbz	r6, 8012a50 <_dtoa_r+0x660>
 8012a3a:	b12f      	cbz	r7, 8012a48 <_dtoa_r+0x658>
 8012a3c:	42b7      	cmp	r7, r6
 8012a3e:	d003      	beq.n	8012a48 <_dtoa_r+0x658>
 8012a40:	4639      	mov	r1, r7
 8012a42:	4620      	mov	r0, r4
 8012a44:	f000 ff98 	bl	8013978 <_Bfree>
 8012a48:	4631      	mov	r1, r6
 8012a4a:	4620      	mov	r0, r4
 8012a4c:	f000 ff94 	bl	8013978 <_Bfree>
 8012a50:	4629      	mov	r1, r5
 8012a52:	4620      	mov	r0, r4
 8012a54:	f000 ff90 	bl	8013978 <_Bfree>
 8012a58:	2300      	movs	r3, #0
 8012a5a:	f889 3000 	strb.w	r3, [r9]
 8012a5e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8012a62:	601a      	str	r2, [r3, #0]
 8012a64:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8012a66:	2b00      	cmp	r3, #0
 8012a68:	f43f acfe 	beq.w	8012468 <_dtoa_r+0x78>
 8012a6c:	9800      	ldr	r0, [sp, #0]
 8012a6e:	f8c3 9000 	str.w	r9, [r3]
 8012a72:	b00f      	add	sp, #60	; 0x3c
 8012a74:	ecbd 8b02 	vpop	{d8}
 8012a78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012a7c:	f1c0 001c 	rsb	r0, r0, #28
 8012a80:	9b06      	ldr	r3, [sp, #24]
 8012a82:	4403      	add	r3, r0
 8012a84:	9306      	str	r3, [sp, #24]
 8012a86:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012a88:	4403      	add	r3, r0
 8012a8a:	9309      	str	r3, [sp, #36]	; 0x24
 8012a8c:	4480      	add	r8, r0
 8012a8e:	e76f      	b.n	8012970 <_dtoa_r+0x580>
 8012a90:	f1c2 0220 	rsb	r2, r2, #32
 8012a94:	fa06 f202 	lsl.w	r2, r6, r2
 8012a98:	ee07 2a10 	vmov	s14, r2
 8012a9c:	e509      	b.n	80124b2 <_dtoa_r+0xc2>
 8012a9e:	2601      	movs	r6, #1
 8012aa0:	e563      	b.n	801256a <_dtoa_r+0x17a>
 8012aa2:	4601      	mov	r1, r0
 8012aa4:	463a      	mov	r2, r7
 8012aa6:	4620      	mov	r0, r4
 8012aa8:	f001 f8ee 	bl	8013c88 <__pow5mult>
 8012aac:	9b01      	ldr	r3, [sp, #4]
 8012aae:	2b01      	cmp	r3, #1
 8012ab0:	4682      	mov	sl, r0
 8012ab2:	f340 81c5 	ble.w	8012e40 <_dtoa_r+0xa50>
 8012ab6:	2300      	movs	r3, #0
 8012ab8:	9308      	str	r3, [sp, #32]
 8012aba:	f8da 2010 	ldr.w	r2, [sl, #16]
 8012abe:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 8012ac2:	6910      	ldr	r0, [r2, #16]
 8012ac4:	f000 ffb4 	bl	8013a30 <__hi0bits>
 8012ac8:	f1c0 0020 	rsb	r0, r0, #32
 8012acc:	e744      	b.n	8012958 <_dtoa_r+0x568>
 8012ace:	bf00      	nop
 8012ad0:	08015bb8 	.word	0x08015bb8
 8012ad4:	08015a2c 	.word	0x08015a2c
 8012ad8:	4631      	mov	r1, r6
 8012ada:	2300      	movs	r3, #0
 8012adc:	220a      	movs	r2, #10
 8012ade:	4620      	mov	r0, r4
 8012ae0:	f000 ff54 	bl	801398c <__multadd>
 8012ae4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012ae6:	2b00      	cmp	r3, #0
 8012ae8:	4606      	mov	r6, r0
 8012aea:	f340 82ce 	ble.w	801308a <_dtoa_r+0xc9a>
 8012aee:	9704      	str	r7, [sp, #16]
 8012af0:	4699      	mov	r9, r3
 8012af2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012af4:	2b00      	cmp	r3, #0
 8012af6:	dd05      	ble.n	8012b04 <_dtoa_r+0x714>
 8012af8:	4631      	mov	r1, r6
 8012afa:	461a      	mov	r2, r3
 8012afc:	4620      	mov	r0, r4
 8012afe:	f001 f923 	bl	8013d48 <__lshift>
 8012b02:	4606      	mov	r6, r0
 8012b04:	9b08      	ldr	r3, [sp, #32]
 8012b06:	2b00      	cmp	r3, #0
 8012b08:	f040 81eb 	bne.w	8012ee2 <_dtoa_r+0xaf2>
 8012b0c:	46b0      	mov	r8, r6
 8012b0e:	9b02      	ldr	r3, [sp, #8]
 8012b10:	9f00      	ldr	r7, [sp, #0]
 8012b12:	f003 0201 	and.w	r2, r3, #1
 8012b16:	1e7b      	subs	r3, r7, #1
 8012b18:	444b      	add	r3, r9
 8012b1a:	9308      	str	r3, [sp, #32]
 8012b1c:	9b01      	ldr	r3, [sp, #4]
 8012b1e:	920a      	str	r2, [sp, #40]	; 0x28
 8012b20:	4313      	orrs	r3, r2
 8012b22:	9309      	str	r3, [sp, #36]	; 0x24
 8012b24:	4651      	mov	r1, sl
 8012b26:	4628      	mov	r0, r5
 8012b28:	f7ff fbce 	bl	80122c8 <quorem>
 8012b2c:	4631      	mov	r1, r6
 8012b2e:	4683      	mov	fp, r0
 8012b30:	4628      	mov	r0, r5
 8012b32:	f001 f981 	bl	8013e38 <__mcmp>
 8012b36:	4642      	mov	r2, r8
 8012b38:	4651      	mov	r1, sl
 8012b3a:	4681      	mov	r9, r0
 8012b3c:	4620      	mov	r0, r4
 8012b3e:	f001 f99d 	bl	8013e7c <__mdiff>
 8012b42:	68c2      	ldr	r2, [r0, #12]
 8012b44:	4601      	mov	r1, r0
 8012b46:	f10b 0330 	add.w	r3, fp, #48	; 0x30
 8012b4a:	2a00      	cmp	r2, #0
 8012b4c:	d142      	bne.n	8012bd4 <_dtoa_r+0x7e4>
 8012b4e:	e9cd 0306 	strd	r0, r3, [sp, #24]
 8012b52:	4628      	mov	r0, r5
 8012b54:	f001 f970 	bl	8013e38 <__mcmp>
 8012b58:	9906      	ldr	r1, [sp, #24]
 8012b5a:	9002      	str	r0, [sp, #8]
 8012b5c:	4620      	mov	r0, r4
 8012b5e:	f000 ff0b 	bl	8013978 <_Bfree>
 8012b62:	9a02      	ldr	r2, [sp, #8]
 8012b64:	9b07      	ldr	r3, [sp, #28]
 8012b66:	b91a      	cbnz	r2, 8012b70 <_dtoa_r+0x780>
 8012b68:	9909      	ldr	r1, [sp, #36]	; 0x24
 8012b6a:	2900      	cmp	r1, #0
 8012b6c:	f000 827e 	beq.w	801306c <_dtoa_r+0xc7c>
 8012b70:	f1b9 0f00 	cmp.w	r9, #0
 8012b74:	f2c0 8183 	blt.w	8012e7e <_dtoa_r+0xa8e>
 8012b78:	9901      	ldr	r1, [sp, #4]
 8012b7a:	ea49 0901 	orr.w	r9, r9, r1
 8012b7e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8012b80:	ea51 0909 	orrs.w	r9, r1, r9
 8012b84:	f000 817b 	beq.w	8012e7e <_dtoa_r+0xa8e>
 8012b88:	2a00      	cmp	r2, #0
 8012b8a:	f300 81c6 	bgt.w	8012f1a <_dtoa_r+0xb2a>
 8012b8e:	9a08      	ldr	r2, [sp, #32]
 8012b90:	703b      	strb	r3, [r7, #0]
 8012b92:	f107 0901 	add.w	r9, r7, #1
 8012b96:	4297      	cmp	r7, r2
 8012b98:	46cb      	mov	fp, r9
 8012b9a:	f000 81c4 	beq.w	8012f26 <_dtoa_r+0xb36>
 8012b9e:	4629      	mov	r1, r5
 8012ba0:	2300      	movs	r3, #0
 8012ba2:	220a      	movs	r2, #10
 8012ba4:	4620      	mov	r0, r4
 8012ba6:	f000 fef1 	bl	801398c <__multadd>
 8012baa:	4546      	cmp	r6, r8
 8012bac:	4605      	mov	r5, r0
 8012bae:	4631      	mov	r1, r6
 8012bb0:	f04f 0300 	mov.w	r3, #0
 8012bb4:	f04f 020a 	mov.w	r2, #10
 8012bb8:	4620      	mov	r0, r4
 8012bba:	d012      	beq.n	8012be2 <_dtoa_r+0x7f2>
 8012bbc:	f000 fee6 	bl	801398c <__multadd>
 8012bc0:	4641      	mov	r1, r8
 8012bc2:	4606      	mov	r6, r0
 8012bc4:	2300      	movs	r3, #0
 8012bc6:	220a      	movs	r2, #10
 8012bc8:	4620      	mov	r0, r4
 8012bca:	f000 fedf 	bl	801398c <__multadd>
 8012bce:	464f      	mov	r7, r9
 8012bd0:	4680      	mov	r8, r0
 8012bd2:	e7a7      	b.n	8012b24 <_dtoa_r+0x734>
 8012bd4:	4620      	mov	r0, r4
 8012bd6:	9302      	str	r3, [sp, #8]
 8012bd8:	f000 fece 	bl	8013978 <_Bfree>
 8012bdc:	9b02      	ldr	r3, [sp, #8]
 8012bde:	2201      	movs	r2, #1
 8012be0:	e7c6      	b.n	8012b70 <_dtoa_r+0x780>
 8012be2:	f000 fed3 	bl	801398c <__multadd>
 8012be6:	464f      	mov	r7, r9
 8012be8:	4606      	mov	r6, r0
 8012bea:	4680      	mov	r8, r0
 8012bec:	e79a      	b.n	8012b24 <_dtoa_r+0x734>
 8012bee:	9b01      	ldr	r3, [sp, #4]
 8012bf0:	2b02      	cmp	r3, #2
 8012bf2:	dc71      	bgt.n	8012cd8 <_dtoa_r+0x8e8>
 8012bf4:	9b07      	ldr	r3, [sp, #28]
 8012bf6:	2b00      	cmp	r3, #0
 8012bf8:	f47f af7b 	bne.w	8012af2 <_dtoa_r+0x702>
 8012bfc:	9b04      	ldr	r3, [sp, #16]
 8012bfe:	4651      	mov	r1, sl
 8012c00:	3301      	adds	r3, #1
 8012c02:	4628      	mov	r0, r5
 8012c04:	9304      	str	r3, [sp, #16]
 8012c06:	f7ff fb5f 	bl	80122c8 <quorem>
 8012c0a:	f8dd b000 	ldr.w	fp, [sp]
 8012c0e:	f100 0330 	add.w	r3, r0, #48	; 0x30
 8012c12:	f80b 3b01 	strb.w	r3, [fp], #1
 8012c16:	2700      	movs	r7, #0
 8012c18:	e6eb      	b.n	80129f2 <_dtoa_r+0x602>
 8012c1a:	4651      	mov	r1, sl
 8012c1c:	4628      	mov	r0, r5
 8012c1e:	f001 f90b 	bl	8013e38 <__mcmp>
 8012c22:	2800      	cmp	r0, #0
 8012c24:	f6bf aeba 	bge.w	801299c <_dtoa_r+0x5ac>
 8012c28:	4629      	mov	r1, r5
 8012c2a:	2300      	movs	r3, #0
 8012c2c:	220a      	movs	r2, #10
 8012c2e:	4620      	mov	r0, r4
 8012c30:	f000 feac 	bl	801398c <__multadd>
 8012c34:	9b04      	ldr	r3, [sp, #16]
 8012c36:	1e5f      	subs	r7, r3, #1
 8012c38:	9b07      	ldr	r3, [sp, #28]
 8012c3a:	4605      	mov	r5, r0
 8012c3c:	2b00      	cmp	r3, #0
 8012c3e:	f47f af4b 	bne.w	8012ad8 <_dtoa_r+0x6e8>
 8012c42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012c44:	2b00      	cmp	r3, #0
 8012c46:	f340 8218 	ble.w	801307a <_dtoa_r+0xc8a>
 8012c4a:	4699      	mov	r9, r3
 8012c4c:	e6b1      	b.n	80129b2 <_dtoa_r+0x5c2>
 8012c4e:	4bbc      	ldr	r3, [pc, #752]	; (8012f40 <_dtoa_r+0xb50>)
 8012c50:	9300      	str	r3, [sp, #0]
 8012c52:	3303      	adds	r3, #3
 8012c54:	e4a4      	b.n	80125a0 <_dtoa_r+0x1b0>
 8012c56:	201c      	movs	r0, #28
 8012c58:	e712      	b.n	8012a80 <_dtoa_r+0x690>
 8012c5a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8012c5e:	2800      	cmp	r0, #0
 8012c60:	f47f ae74 	bne.w	801294c <_dtoa_r+0x55c>
 8012c64:	f3c1 0213 	ubfx	r2, r1, #0, #20
 8012c68:	2a00      	cmp	r2, #0
 8012c6a:	f000 80f4 	beq.w	8012e56 <_dtoa_r+0xa66>
 8012c6e:	9b02      	ldr	r3, [sp, #8]
 8012c70:	9308      	str	r3, [sp, #32]
 8012c72:	e66d      	b.n	8012950 <_dtoa_r+0x560>
 8012c74:	2301      	movs	r3, #1
 8012c76:	9307      	str	r3, [sp, #28]
 8012c78:	9b04      	ldr	r3, [sp, #16]
 8012c7a:	445b      	add	r3, fp
 8012c7c:	f103 0901 	add.w	r9, r3, #1
 8012c80:	f1b9 0f01 	cmp.w	r9, #1
 8012c84:	46cc      	mov	ip, r9
 8012c86:	930b      	str	r3, [sp, #44]	; 0x2c
 8012c88:	bfb8      	it	lt
 8012c8a:	f04f 0c01 	movlt.w	ip, #1
 8012c8e:	2100      	movs	r1, #0
 8012c90:	f1bc 0f17 	cmp.w	ip, #23
 8012c94:	63e1      	str	r1, [r4, #60]	; 0x3c
 8012c96:	f77f acbc 	ble.w	8012612 <_dtoa_r+0x222>
 8012c9a:	2001      	movs	r0, #1
 8012c9c:	2204      	movs	r2, #4
 8012c9e:	0052      	lsls	r2, r2, #1
 8012ca0:	f102 0314 	add.w	r3, r2, #20
 8012ca4:	4563      	cmp	r3, ip
 8012ca6:	4601      	mov	r1, r0
 8012ca8:	f100 0001 	add.w	r0, r0, #1
 8012cac:	d9f7      	bls.n	8012c9e <_dtoa_r+0x8ae>
 8012cae:	63e1      	str	r1, [r4, #60]	; 0x3c
 8012cb0:	e4af      	b.n	8012612 <_dtoa_r+0x222>
 8012cb2:	2301      	movs	r3, #1
 8012cb4:	9307      	str	r3, [sp, #28]
 8012cb6:	f1bb 0f00 	cmp.w	fp, #0
 8012cba:	dd52      	ble.n	8012d62 <_dtoa_r+0x972>
 8012cbc:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 8012cc0:	46d9      	mov	r9, fp
 8012cc2:	46dc      	mov	ip, fp
 8012cc4:	e7e3      	b.n	8012c8e <_dtoa_r+0x89e>
 8012cc6:	2300      	movs	r3, #0
 8012cc8:	9307      	str	r3, [sp, #28]
 8012cca:	e7d5      	b.n	8012c78 <_dtoa_r+0x888>
 8012ccc:	2300      	movs	r3, #0
 8012cce:	9307      	str	r3, [sp, #28]
 8012cd0:	e7f1      	b.n	8012cb6 <_dtoa_r+0x8c6>
 8012cd2:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8012cd6:	9704      	str	r7, [sp, #16]
 8012cd8:	f1b9 0f00 	cmp.w	r9, #0
 8012cdc:	f47f ada1 	bne.w	8012822 <_dtoa_r+0x432>
 8012ce0:	4651      	mov	r1, sl
 8012ce2:	464b      	mov	r3, r9
 8012ce4:	2205      	movs	r2, #5
 8012ce6:	4620      	mov	r0, r4
 8012ce8:	f000 fe50 	bl	801398c <__multadd>
 8012cec:	4601      	mov	r1, r0
 8012cee:	4682      	mov	sl, r0
 8012cf0:	4628      	mov	r0, r5
 8012cf2:	f001 f8a1 	bl	8013e38 <__mcmp>
 8012cf6:	2800      	cmp	r0, #0
 8012cf8:	f77f ad93 	ble.w	8012822 <_dtoa_r+0x432>
 8012cfc:	9b04      	ldr	r3, [sp, #16]
 8012cfe:	f103 0b01 	add.w	fp, r3, #1
 8012d02:	9b00      	ldr	r3, [sp, #0]
 8012d04:	2231      	movs	r2, #49	; 0x31
 8012d06:	4698      	mov	r8, r3
 8012d08:	f803 2b01 	strb.w	r2, [r3], #1
 8012d0c:	9300      	str	r3, [sp, #0]
 8012d0e:	4651      	mov	r1, sl
 8012d10:	4620      	mov	r0, r4
 8012d12:	f000 fe31 	bl	8013978 <_Bfree>
 8012d16:	f10b 0301 	add.w	r3, fp, #1
 8012d1a:	f8dd 9000 	ldr.w	r9, [sp]
 8012d1e:	9304      	str	r3, [sp, #16]
 8012d20:	f8cd 8000 	str.w	r8, [sp]
 8012d24:	2e00      	cmp	r6, #0
 8012d26:	f47f ae8f 	bne.w	8012a48 <_dtoa_r+0x658>
 8012d2a:	e691      	b.n	8012a50 <_dtoa_r+0x660>
 8012d2c:	eba3 0a0a 	sub.w	sl, r3, sl
 8012d30:	e5c5      	b.n	80128be <_dtoa_r+0x4ce>
 8012d32:	4631      	mov	r1, r6
 8012d34:	4652      	mov	r2, sl
 8012d36:	4620      	mov	r0, r4
 8012d38:	f000 ffa6 	bl	8013c88 <__pow5mult>
 8012d3c:	462a      	mov	r2, r5
 8012d3e:	4601      	mov	r1, r0
 8012d40:	4606      	mov	r6, r0
 8012d42:	4620      	mov	r0, r4
 8012d44:	f000 fef2 	bl	8013b2c <__multiply>
 8012d48:	4629      	mov	r1, r5
 8012d4a:	4605      	mov	r5, r0
 8012d4c:	4620      	mov	r0, r4
 8012d4e:	f000 fe13 	bl	8013978 <_Bfree>
 8012d52:	e5ea      	b.n	801292a <_dtoa_r+0x53a>
 8012d54:	2002      	movs	r0, #2
 8012d56:	eeb0 5b48 	vmov.f64	d5, d8
 8012d5a:	e481      	b.n	8012660 <_dtoa_r+0x270>
 8012d5c:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
 8012d60:	e68e      	b.n	8012a80 <_dtoa_r+0x690>
 8012d62:	f04f 0b01 	mov.w	fp, #1
 8012d66:	46d9      	mov	r9, fp
 8012d68:	e44f      	b.n	801260a <_dtoa_r+0x21a>
 8012d6a:	d103      	bne.n	8012d74 <_dtoa_r+0x984>
 8012d6c:	9b01      	ldr	r3, [sp, #4]
 8012d6e:	07db      	lsls	r3, r3, #31
 8012d70:	f53f ae4c 	bmi.w	8012a0c <_dtoa_r+0x61c>
 8012d74:	46d9      	mov	r9, fp
 8012d76:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
 8012d7a:	2b30      	cmp	r3, #48	; 0x30
 8012d7c:	d0fa      	beq.n	8012d74 <_dtoa_r+0x984>
 8012d7e:	e657      	b.n	8012a30 <_dtoa_r+0x640>
 8012d80:	9b04      	ldr	r3, [sp, #16]
 8012d82:	9a00      	ldr	r2, [sp, #0]
 8012d84:	3301      	adds	r3, #1
 8012d86:	9304      	str	r3, [sp, #16]
 8012d88:	2331      	movs	r3, #49	; 0x31
 8012d8a:	7013      	strb	r3, [r2, #0]
 8012d8c:	e650      	b.n	8012a30 <_dtoa_r+0x640>
 8012d8e:	f1ba 0f00 	cmp.w	sl, #0
 8012d92:	f000 8123 	beq.w	8012fdc <_dtoa_r+0xbec>
 8012d96:	f202 4233 	addw	r2, r2, #1075	; 0x433
 8012d9a:	9b06      	ldr	r3, [sp, #24]
 8012d9c:	9309      	str	r3, [sp, #36]	; 0x24
 8012d9e:	4413      	add	r3, r2
 8012da0:	f8dd a020 	ldr.w	sl, [sp, #32]
 8012da4:	9306      	str	r3, [sp, #24]
 8012da6:	4490      	add	r8, r2
 8012da8:	e592      	b.n	80128d0 <_dtoa_r+0x4e0>
 8012daa:	ee07 0a90 	vmov	s15, r0
 8012dae:	eeb1 5b0c 	vmov.f64	d5, #28	; 0x40e00000  7.0
 8012db2:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 8012db6:	eea6 5b07 	vfma.f64	d5, d6, d7
 8012dba:	ee15 2a90 	vmov	r2, s11
 8012dbe:	ec51 0b15 	vmov	r0, r1, d5
 8012dc2:	f1a2 7150 	sub.w	r1, r2, #54525952	; 0x3400000
 8012dc6:	ec41 0b15 	vmov	d5, r0, r1
 8012dca:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
 8012dce:	ee36 7b47 	vsub.f64	d7, d6, d7
 8012dd2:	eeb4 7bc5 	vcmpe.f64	d7, d5
 8012dd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012dda:	f300 8137 	bgt.w	801304c <_dtoa_r+0xc5c>
 8012dde:	eeb1 5b45 	vneg.f64	d5, d5
 8012de2:	eeb4 7bc5 	vcmpe.f64	d7, d5
 8012de6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012dea:	f57f acfb 	bpl.w	80127e4 <_dtoa_r+0x3f4>
 8012dee:	f04f 0a00 	mov.w	sl, #0
 8012df2:	4656      	mov	r6, sl
 8012df4:	e515      	b.n	8012822 <_dtoa_r+0x432>
 8012df6:	f000 80f5 	beq.w	8012fe4 <_dtoa_r+0xbf4>
 8012dfa:	9b04      	ldr	r3, [sp, #16]
 8012dfc:	4951      	ldr	r1, [pc, #324]	; (8012f44 <_dtoa_r+0xb54>)
 8012dfe:	425a      	negs	r2, r3
 8012e00:	f002 000f 	and.w	r0, r2, #15
 8012e04:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 8012e08:	ed91 6b00 	vldr	d6, [r1]
 8012e0c:	1112      	asrs	r2, r2, #4
 8012e0e:	ee28 6b06 	vmul.f64	d6, d8, d6
 8012e12:	f000 8142 	beq.w	801309a <_dtoa_r+0xcaa>
 8012e16:	eeb0 7b46 	vmov.f64	d7, d6
 8012e1a:	494b      	ldr	r1, [pc, #300]	; (8012f48 <_dtoa_r+0xb58>)
 8012e1c:	2600      	movs	r6, #0
 8012e1e:	2002      	movs	r0, #2
 8012e20:	07d3      	lsls	r3, r2, #31
 8012e22:	d505      	bpl.n	8012e30 <_dtoa_r+0xa40>
 8012e24:	ed91 5b00 	vldr	d5, [r1]
 8012e28:	3001      	adds	r0, #1
 8012e2a:	2601      	movs	r6, #1
 8012e2c:	ee27 7b05 	vmul.f64	d7, d7, d5
 8012e30:	1052      	asrs	r2, r2, #1
 8012e32:	f101 0108 	add.w	r1, r1, #8
 8012e36:	d1f3      	bne.n	8012e20 <_dtoa_r+0xa30>
 8012e38:	2e00      	cmp	r6, #0
 8012e3a:	fe06 6b07 	vseleq.f64	d6, d6, d7
 8012e3e:	e41e      	b.n	801267e <_dtoa_r+0x28e>
 8012e40:	9b02      	ldr	r3, [sp, #8]
 8012e42:	2b00      	cmp	r3, #0
 8012e44:	f47f ae37 	bne.w	8012ab6 <_dtoa_r+0x6c6>
 8012e48:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8012e4c:	f3c1 0213 	ubfx	r2, r1, #0, #20
 8012e50:	2a00      	cmp	r2, #0
 8012e52:	f040 8137 	bne.w	80130c4 <_dtoa_r+0xcd4>
 8012e56:	4a3d      	ldr	r2, [pc, #244]	; (8012f4c <_dtoa_r+0xb5c>)
 8012e58:	400a      	ands	r2, r1
 8012e5a:	2a00      	cmp	r2, #0
 8012e5c:	f000 80fa 	beq.w	8013054 <_dtoa_r+0xc64>
 8012e60:	9b06      	ldr	r3, [sp, #24]
 8012e62:	3301      	adds	r3, #1
 8012e64:	9306      	str	r3, [sp, #24]
 8012e66:	2301      	movs	r3, #1
 8012e68:	f108 0801 	add.w	r8, r8, #1
 8012e6c:	9308      	str	r3, [sp, #32]
 8012e6e:	e56f      	b.n	8012950 <_dtoa_r+0x560>
 8012e70:	4629      	mov	r1, r5
 8012e72:	9a08      	ldr	r2, [sp, #32]
 8012e74:	4620      	mov	r0, r4
 8012e76:	f000 ff07 	bl	8013c88 <__pow5mult>
 8012e7a:	4605      	mov	r5, r0
 8012e7c:	e55a      	b.n	8012934 <_dtoa_r+0x544>
 8012e7e:	2a00      	cmp	r2, #0
 8012e80:	dd12      	ble.n	8012ea8 <_dtoa_r+0xab8>
 8012e82:	4629      	mov	r1, r5
 8012e84:	2201      	movs	r2, #1
 8012e86:	4620      	mov	r0, r4
 8012e88:	9301      	str	r3, [sp, #4]
 8012e8a:	f000 ff5d 	bl	8013d48 <__lshift>
 8012e8e:	4651      	mov	r1, sl
 8012e90:	4605      	mov	r5, r0
 8012e92:	f000 ffd1 	bl	8013e38 <__mcmp>
 8012e96:	2800      	cmp	r0, #0
 8012e98:	9b01      	ldr	r3, [sp, #4]
 8012e9a:	f340 80e1 	ble.w	8013060 <_dtoa_r+0xc70>
 8012e9e:	2b39      	cmp	r3, #57	; 0x39
 8012ea0:	f000 80ca 	beq.w	8013038 <_dtoa_r+0xc48>
 8012ea4:	f10b 0331 	add.w	r3, fp, #49	; 0x31
 8012ea8:	46b9      	mov	r9, r7
 8012eaa:	f809 3b01 	strb.w	r3, [r9], #1
 8012eae:	9b04      	ldr	r3, [sp, #16]
 8012eb0:	3301      	adds	r3, #1
 8012eb2:	4637      	mov	r7, r6
 8012eb4:	9304      	str	r3, [sp, #16]
 8012eb6:	4646      	mov	r6, r8
 8012eb8:	e5ba      	b.n	8012a30 <_dtoa_r+0x640>
 8012eba:	ee38 8b08 	vadd.f64	d8, d8, d8
 8012ebe:	eeb4 8bc6 	vcmpe.f64	d8, d6
 8012ec2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012ec6:	dc0a      	bgt.n	8012ede <_dtoa_r+0xaee>
 8012ec8:	eeb4 8b46 	vcmp.f64	d8, d6
 8012ecc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012ed0:	f47f acdc 	bne.w	801288c <_dtoa_r+0x49c>
 8012ed4:	ee17 3a10 	vmov	r3, s14
 8012ed8:	07d8      	lsls	r0, r3, #31
 8012eda:	f57f acd7 	bpl.w	801288c <_dtoa_r+0x49c>
 8012ede:	9a00      	ldr	r2, [sp, #0]
 8012ee0:	e454      	b.n	801278c <_dtoa_r+0x39c>
 8012ee2:	6871      	ldr	r1, [r6, #4]
 8012ee4:	4620      	mov	r0, r4
 8012ee6:	f000 fd21 	bl	801392c <_Balloc>
 8012eea:	4607      	mov	r7, r0
 8012eec:	2800      	cmp	r0, #0
 8012eee:	f000 80de 	beq.w	80130ae <_dtoa_r+0xcbe>
 8012ef2:	6933      	ldr	r3, [r6, #16]
 8012ef4:	3302      	adds	r3, #2
 8012ef6:	009a      	lsls	r2, r3, #2
 8012ef8:	f106 010c 	add.w	r1, r6, #12
 8012efc:	300c      	adds	r0, #12
 8012efe:	f7ed fc3d 	bl	800077c <memcpy>
 8012f02:	4639      	mov	r1, r7
 8012f04:	2201      	movs	r2, #1
 8012f06:	4620      	mov	r0, r4
 8012f08:	f000 ff1e 	bl	8013d48 <__lshift>
 8012f0c:	4680      	mov	r8, r0
 8012f0e:	e5fe      	b.n	8012b0e <_dtoa_r+0x71e>
 8012f10:	9b06      	ldr	r3, [sp, #24]
 8012f12:	eba3 0309 	sub.w	r3, r3, r9
 8012f16:	9309      	str	r3, [sp, #36]	; 0x24
 8012f18:	e4da      	b.n	80128d0 <_dtoa_r+0x4e0>
 8012f1a:	2b39      	cmp	r3, #57	; 0x39
 8012f1c:	f000 808c 	beq.w	8013038 <_dtoa_r+0xc48>
 8012f20:	46b9      	mov	r9, r7
 8012f22:	3301      	adds	r3, #1
 8012f24:	e7c1      	b.n	8012eaa <_dtoa_r+0xaba>
 8012f26:	9a04      	ldr	r2, [sp, #16]
 8012f28:	3201      	adds	r2, #1
 8012f2a:	4637      	mov	r7, r6
 8012f2c:	9204      	str	r2, [sp, #16]
 8012f2e:	4646      	mov	r6, r8
 8012f30:	e55f      	b.n	80129f2 <_dtoa_r+0x602>
 8012f32:	4629      	mov	r1, r5
 8012f34:	4620      	mov	r0, r4
 8012f36:	f000 fea7 	bl	8013c88 <__pow5mult>
 8012f3a:	4605      	mov	r5, r0
 8012f3c:	e4fa      	b.n	8012934 <_dtoa_r+0x544>
 8012f3e:	bf00      	nop
 8012f40:	08015ac0 	.word	0x08015ac0
 8012f44:	08015bb8 	.word	0x08015bb8
 8012f48:	08015b90 	.word	0x08015b90
 8012f4c:	7ff00000 	.word	0x7ff00000
 8012f50:	4b5e      	ldr	r3, [pc, #376]	; (80130cc <_dtoa_r+0xcdc>)
 8012f52:	eefd 5bc6 	vcvt.s32.f64	s11, d6
 8012f56:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
 8012f5a:	ed1c 3b02 	vldr	d3, [ip, #-8]
 8012f5e:	eeb8 7be5 	vcvt.f64.s32	d7, s11
 8012f62:	ee36 7b47 	vsub.f64	d7, d6, d7
 8012f66:	ec41 0b16 	vmov	d6, r0, r1
 8012f6a:	ee15 1a90 	vmov	r1, s11
 8012f6e:	ee23 3b06 	vmul.f64	d3, d3, d6
 8012f72:	9800      	ldr	r0, [sp, #0]
 8012f74:	3130      	adds	r1, #48	; 0x30
 8012f76:	2a01      	cmp	r2, #1
 8012f78:	f800 1b01 	strb.w	r1, [r0], #1
 8012f7c:	f000 8083 	beq.w	8013086 <_dtoa_r+0xc96>
 8012f80:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
 8012f84:	9b00      	ldr	r3, [sp, #0]
 8012f86:	1899      	adds	r1, r3, r2
 8012f88:	ee27 7b04 	vmul.f64	d7, d7, d4
 8012f8c:	eefd 6bc7 	vcvt.s32.f64	s13, d7
 8012f90:	ee16 3a90 	vmov	r3, s13
 8012f94:	3330      	adds	r3, #48	; 0x30
 8012f96:	f800 3b01 	strb.w	r3, [r0], #1
 8012f9a:	4281      	cmp	r1, r0
 8012f9c:	eeb8 5be6 	vcvt.f64.s32	d5, s13
 8012fa0:	ee37 7b45 	vsub.f64	d7, d7, d5
 8012fa4:	d1f0      	bne.n	8012f88 <_dtoa_r+0xb98>
 8012fa6:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
 8012faa:	ee33 5b06 	vadd.f64	d5, d3, d6
 8012fae:	eeb4 5bc7 	vcmpe.f64	d5, d7
 8012fb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012fb6:	f53f abe3 	bmi.w	8012780 <_dtoa_r+0x390>
 8012fba:	ee36 6b43 	vsub.f64	d6, d6, d3
 8012fbe:	eeb4 6bc7 	vcmpe.f64	d6, d7
 8012fc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012fc6:	f77f ac0d 	ble.w	80127e4 <_dtoa_r+0x3f4>
 8012fca:	4689      	mov	r9, r1
 8012fcc:	3901      	subs	r1, #1
 8012fce:	f819 3c01 	ldrb.w	r3, [r9, #-1]
 8012fd2:	2b30      	cmp	r3, #48	; 0x30
 8012fd4:	d0f9      	beq.n	8012fca <_dtoa_r+0xbda>
 8012fd6:	1c73      	adds	r3, r6, #1
 8012fd8:	9304      	str	r3, [sp, #16]
 8012fda:	e539      	b.n	8012a50 <_dtoa_r+0x660>
 8012fdc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8012fde:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
 8012fe2:	e6da      	b.n	8012d9a <_dtoa_r+0x9aa>
 8012fe4:	2002      	movs	r0, #2
 8012fe6:	eeb0 6b48 	vmov.f64	d6, d8
 8012fea:	f7ff bb48 	b.w	801267e <_dtoa_r+0x28e>
 8012fee:	f1b9 0f00 	cmp.w	r9, #0
 8012ff2:	f43f aeda 	beq.w	8012daa <_dtoa_r+0x9ba>
 8012ff6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8012ff8:	2a00      	cmp	r2, #0
 8012ffa:	f77f abf3 	ble.w	80127e4 <_dtoa_r+0x3f4>
 8012ffe:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
 8013002:	ee26 6b04 	vmul.f64	d6, d6, d4
 8013006:	3001      	adds	r0, #1
 8013008:	ee07 0a90 	vmov	s15, r0
 801300c:	9b04      	ldr	r3, [sp, #16]
 801300e:	eeb8 5be7 	vcvt.f64.s32	d5, s15
 8013012:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
 8013016:	eea6 7b05 	vfma.f64	d7, d6, d5
 801301a:	ee17 ca90 	vmov	ip, s15
 801301e:	ec51 0b17 	vmov	r0, r1, d7
 8013022:	1e5e      	subs	r6, r3, #1
 8013024:	f1ac 7150 	sub.w	r1, ip, #54525952	; 0x3400000
 8013028:	f7ff bb47 	b.w	80126ba <_dtoa_r+0x2ca>
 801302c:	9b04      	ldr	r3, [sp, #16]
 801302e:	3301      	adds	r3, #1
 8013030:	9304      	str	r3, [sp, #16]
 8013032:	2331      	movs	r3, #49	; 0x31
 8013034:	f7ff bbb1 	b.w	801279a <_dtoa_r+0x3aa>
 8013038:	9b04      	ldr	r3, [sp, #16]
 801303a:	46bb      	mov	fp, r7
 801303c:	3301      	adds	r3, #1
 801303e:	9304      	str	r3, [sp, #16]
 8013040:	2339      	movs	r3, #57	; 0x39
 8013042:	4637      	mov	r7, r6
 8013044:	f80b 3b01 	strb.w	r3, [fp], #1
 8013048:	4646      	mov	r6, r8
 801304a:	e4e1      	b.n	8012a10 <_dtoa_r+0x620>
 801304c:	f04f 0a00 	mov.w	sl, #0
 8013050:	4656      	mov	r6, sl
 8013052:	e653      	b.n	8012cfc <_dtoa_r+0x90c>
 8013054:	9208      	str	r2, [sp, #32]
 8013056:	e47b      	b.n	8012950 <_dtoa_r+0x560>
 8013058:	1c73      	adds	r3, r6, #1
 801305a:	9304      	str	r3, [sp, #16]
 801305c:	4689      	mov	r9, r1
 801305e:	e4f7      	b.n	8012a50 <_dtoa_r+0x660>
 8013060:	f47f af22 	bne.w	8012ea8 <_dtoa_r+0xab8>
 8013064:	07da      	lsls	r2, r3, #31
 8013066:	f57f af1f 	bpl.w	8012ea8 <_dtoa_r+0xab8>
 801306a:	e718      	b.n	8012e9e <_dtoa_r+0xaae>
 801306c:	2b39      	cmp	r3, #57	; 0x39
 801306e:	d0e3      	beq.n	8013038 <_dtoa_r+0xc48>
 8013070:	f1b9 0f00 	cmp.w	r9, #0
 8013074:	f73f af16 	bgt.w	8012ea4 <_dtoa_r+0xab4>
 8013078:	e716      	b.n	8012ea8 <_dtoa_r+0xab8>
 801307a:	9b01      	ldr	r3, [sp, #4]
 801307c:	2b02      	cmp	r3, #2
 801307e:	f73f ae28 	bgt.w	8012cd2 <_dtoa_r+0x8e2>
 8013082:	9704      	str	r7, [sp, #16]
 8013084:	e5ba      	b.n	8012bfc <_dtoa_r+0x80c>
 8013086:	4601      	mov	r1, r0
 8013088:	e78d      	b.n	8012fa6 <_dtoa_r+0xbb6>
 801308a:	9b01      	ldr	r3, [sp, #4]
 801308c:	2b02      	cmp	r3, #2
 801308e:	f73f ae20 	bgt.w	8012cd2 <_dtoa_r+0x8e2>
 8013092:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8013096:	9704      	str	r7, [sp, #16]
 8013098:	e52b      	b.n	8012af2 <_dtoa_r+0x702>
 801309a:	2002      	movs	r0, #2
 801309c:	f7ff baef 	b.w	801267e <_dtoa_r+0x28e>
 80130a0:	4b0b      	ldr	r3, [pc, #44]	; (80130d0 <_dtoa_r+0xce0>)
 80130a2:	480c      	ldr	r0, [pc, #48]	; (80130d4 <_dtoa_r+0xce4>)
 80130a4:	2200      	movs	r2, #0
 80130a6:	f240 11af 	movw	r1, #431	; 0x1af
 80130aa:	f001 fb31 	bl	8014710 <__assert_func>
 80130ae:	4b08      	ldr	r3, [pc, #32]	; (80130d0 <_dtoa_r+0xce0>)
 80130b0:	4808      	ldr	r0, [pc, #32]	; (80130d4 <_dtoa_r+0xce4>)
 80130b2:	463a      	mov	r2, r7
 80130b4:	f240 21ef 	movw	r1, #751	; 0x2ef
 80130b8:	f001 fb2a 	bl	8014710 <__assert_func>
 80130bc:	4b06      	ldr	r3, [pc, #24]	; (80130d8 <_dtoa_r+0xce8>)
 80130be:	9300      	str	r3, [sp, #0]
 80130c0:	f7ff b9d2 	b.w	8012468 <_dtoa_r+0x78>
 80130c4:	9b02      	ldr	r3, [sp, #8]
 80130c6:	9308      	str	r3, [sp, #32]
 80130c8:	e4f7      	b.n	8012aba <_dtoa_r+0x6ca>
 80130ca:	bf00      	nop
 80130cc:	08015bb8 	.word	0x08015bb8
 80130d0:	08015ac4 	.word	0x08015ac4
 80130d4:	08015ad8 	.word	0x08015ad8
 80130d8:	08015ab4 	.word	0x08015ab4

080130dc <_malloc_trim_r>:
 80130dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80130de:	4f24      	ldr	r7, [pc, #144]	; (8013170 <_malloc_trim_r+0x94>)
 80130e0:	460c      	mov	r4, r1
 80130e2:	4606      	mov	r6, r0
 80130e4:	f000 fc16 	bl	8013914 <__malloc_lock>
 80130e8:	68bb      	ldr	r3, [r7, #8]
 80130ea:	685d      	ldr	r5, [r3, #4]
 80130ec:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
 80130f0:	310f      	adds	r1, #15
 80130f2:	f025 0503 	bic.w	r5, r5, #3
 80130f6:	194b      	adds	r3, r1, r5
 80130f8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80130fc:	f023 030f 	bic.w	r3, r3, #15
 8013100:	f5a3 5480 	sub.w	r4, r3, #4096	; 0x1000
 8013104:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8013108:	db07      	blt.n	801311a <_malloc_trim_r+0x3e>
 801310a:	2100      	movs	r1, #0
 801310c:	4630      	mov	r0, r6
 801310e:	f001 faed 	bl	80146ec <_sbrk_r>
 8013112:	68bb      	ldr	r3, [r7, #8]
 8013114:	442b      	add	r3, r5
 8013116:	4298      	cmp	r0, r3
 8013118:	d004      	beq.n	8013124 <_malloc_trim_r+0x48>
 801311a:	4630      	mov	r0, r6
 801311c:	f000 fc00 	bl	8013920 <__malloc_unlock>
 8013120:	2000      	movs	r0, #0
 8013122:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013124:	4261      	negs	r1, r4
 8013126:	4630      	mov	r0, r6
 8013128:	f001 fae0 	bl	80146ec <_sbrk_r>
 801312c:	3001      	adds	r0, #1
 801312e:	d00d      	beq.n	801314c <_malloc_trim_r+0x70>
 8013130:	4a10      	ldr	r2, [pc, #64]	; (8013174 <_malloc_trim_r+0x98>)
 8013132:	68bb      	ldr	r3, [r7, #8]
 8013134:	1b2d      	subs	r5, r5, r4
 8013136:	f045 0501 	orr.w	r5, r5, #1
 801313a:	605d      	str	r5, [r3, #4]
 801313c:	6813      	ldr	r3, [r2, #0]
 801313e:	4630      	mov	r0, r6
 8013140:	1b1b      	subs	r3, r3, r4
 8013142:	6013      	str	r3, [r2, #0]
 8013144:	f000 fbec 	bl	8013920 <__malloc_unlock>
 8013148:	2001      	movs	r0, #1
 801314a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801314c:	2100      	movs	r1, #0
 801314e:	4630      	mov	r0, r6
 8013150:	f001 facc 	bl	80146ec <_sbrk_r>
 8013154:	68ba      	ldr	r2, [r7, #8]
 8013156:	1a83      	subs	r3, r0, r2
 8013158:	2b0f      	cmp	r3, #15
 801315a:	ddde      	ble.n	801311a <_malloc_trim_r+0x3e>
 801315c:	f043 0301 	orr.w	r3, r3, #1
 8013160:	6053      	str	r3, [r2, #4]
 8013162:	4b05      	ldr	r3, [pc, #20]	; (8013178 <_malloc_trim_r+0x9c>)
 8013164:	4903      	ldr	r1, [pc, #12]	; (8013174 <_malloc_trim_r+0x98>)
 8013166:	681b      	ldr	r3, [r3, #0]
 8013168:	1ac0      	subs	r0, r0, r3
 801316a:	6008      	str	r0, [r1, #0]
 801316c:	e7d5      	b.n	801311a <_malloc_trim_r+0x3e>
 801316e:	bf00      	nop
 8013170:	240002dc 	.word	0x240002dc
 8013174:	2400618c 	.word	0x2400618c
 8013178:	240006e4 	.word	0x240006e4

0801317c <_free_r>:
 801317c:	2900      	cmp	r1, #0
 801317e:	d061      	beq.n	8013244 <_free_r+0xc8>
 8013180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013182:	460c      	mov	r4, r1
 8013184:	4606      	mov	r6, r0
 8013186:	f000 fbc5 	bl	8013914 <__malloc_lock>
 801318a:	f854 2c04 	ldr.w	r2, [r4, #-4]
 801318e:	4f7b      	ldr	r7, [pc, #492]	; (801337c <_free_r+0x200>)
 8013190:	f1a4 0508 	sub.w	r5, r4, #8
 8013194:	f022 0101 	bic.w	r1, r2, #1
 8013198:	eb05 0c01 	add.w	ip, r5, r1
 801319c:	68b8      	ldr	r0, [r7, #8]
 801319e:	f8dc 3004 	ldr.w	r3, [ip, #4]
 80131a2:	4560      	cmp	r0, ip
 80131a4:	f023 0303 	bic.w	r3, r3, #3
 80131a8:	f000 808b 	beq.w	80132c2 <_free_r+0x146>
 80131ac:	07d2      	lsls	r2, r2, #31
 80131ae:	f8cc 3004 	str.w	r3, [ip, #4]
 80131b2:	d432      	bmi.n	801321a <_free_r+0x9e>
 80131b4:	f854 2c08 	ldr.w	r2, [r4, #-8]
 80131b8:	1aad      	subs	r5, r5, r2
 80131ba:	4411      	add	r1, r2
 80131bc:	68aa      	ldr	r2, [r5, #8]
 80131be:	f107 0008 	add.w	r0, r7, #8
 80131c2:	4282      	cmp	r2, r0
 80131c4:	d06a      	beq.n	801329c <_free_r+0x120>
 80131c6:	eb0c 0403 	add.w	r4, ip, r3
 80131ca:	f8d4 e004 	ldr.w	lr, [r4, #4]
 80131ce:	68ec      	ldr	r4, [r5, #12]
 80131d0:	60d4      	str	r4, [r2, #12]
 80131d2:	f01e 0f01 	tst.w	lr, #1
 80131d6:	60a2      	str	r2, [r4, #8]
 80131d8:	f000 8097 	beq.w	801330a <_free_r+0x18e>
 80131dc:	f041 0301 	orr.w	r3, r1, #1
 80131e0:	606b      	str	r3, [r5, #4]
 80131e2:	f8cc 1000 	str.w	r1, [ip]
 80131e6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80131ea:	d235      	bcs.n	8013258 <_free_r+0xdc>
 80131ec:	6878      	ldr	r0, [r7, #4]
 80131ee:	08cb      	lsrs	r3, r1, #3
 80131f0:	2201      	movs	r2, #1
 80131f2:	0949      	lsrs	r1, r1, #5
 80131f4:	3301      	adds	r3, #1
 80131f6:	408a      	lsls	r2, r1
 80131f8:	4302      	orrs	r2, r0
 80131fa:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
 80131fe:	607a      	str	r2, [r7, #4]
 8013200:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
 8013204:	3a08      	subs	r2, #8
 8013206:	e9c5 1202 	strd	r1, r2, [r5, #8]
 801320a:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
 801320e:	60cd      	str	r5, [r1, #12]
 8013210:	4630      	mov	r0, r6
 8013212:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8013216:	f000 bb83 	b.w	8013920 <__malloc_unlock>
 801321a:	eb0c 0203 	add.w	r2, ip, r3
 801321e:	6852      	ldr	r2, [r2, #4]
 8013220:	07d0      	lsls	r0, r2, #31
 8013222:	d410      	bmi.n	8013246 <_free_r+0xca>
 8013224:	4419      	add	r1, r3
 8013226:	f107 0008 	add.w	r0, r7, #8
 801322a:	f8dc 3008 	ldr.w	r3, [ip, #8]
 801322e:	4283      	cmp	r3, r0
 8013230:	d073      	beq.n	801331a <_free_r+0x19e>
 8013232:	f8dc 200c 	ldr.w	r2, [ip, #12]
 8013236:	60da      	str	r2, [r3, #12]
 8013238:	6093      	str	r3, [r2, #8]
 801323a:	f041 0301 	orr.w	r3, r1, #1
 801323e:	606b      	str	r3, [r5, #4]
 8013240:	5069      	str	r1, [r5, r1]
 8013242:	e7d0      	b.n	80131e6 <_free_r+0x6a>
 8013244:	4770      	bx	lr
 8013246:	f041 0301 	orr.w	r3, r1, #1
 801324a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 801324e:	f844 3c04 	str.w	r3, [r4, #-4]
 8013252:	f8cc 1000 	str.w	r1, [ip]
 8013256:	d3c9      	bcc.n	80131ec <_free_r+0x70>
 8013258:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
 801325c:	ea4f 2351 	mov.w	r3, r1, lsr #9
 8013260:	d248      	bcs.n	80132f4 <_free_r+0x178>
 8013262:	098b      	lsrs	r3, r1, #6
 8013264:	f103 0039 	add.w	r0, r3, #57	; 0x39
 8013268:	f103 0238 	add.w	r2, r3, #56	; 0x38
 801326c:	00c3      	lsls	r3, r0, #3
 801326e:	18f8      	adds	r0, r7, r3
 8013270:	58fb      	ldr	r3, [r7, r3]
 8013272:	3808      	subs	r0, #8
 8013274:	4298      	cmp	r0, r3
 8013276:	d059      	beq.n	801332c <_free_r+0x1b0>
 8013278:	685a      	ldr	r2, [r3, #4]
 801327a:	f022 0203 	bic.w	r2, r2, #3
 801327e:	428a      	cmp	r2, r1
 8013280:	d902      	bls.n	8013288 <_free_r+0x10c>
 8013282:	689b      	ldr	r3, [r3, #8]
 8013284:	4298      	cmp	r0, r3
 8013286:	d1f7      	bne.n	8013278 <_free_r+0xfc>
 8013288:	68d8      	ldr	r0, [r3, #12]
 801328a:	e9c5 3002 	strd	r3, r0, [r5, #8]
 801328e:	6085      	str	r5, [r0, #8]
 8013290:	60dd      	str	r5, [r3, #12]
 8013292:	4630      	mov	r0, r6
 8013294:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8013298:	f000 bb42 	b.w	8013920 <__malloc_unlock>
 801329c:	eb0c 0203 	add.w	r2, ip, r3
 80132a0:	6852      	ldr	r2, [r2, #4]
 80132a2:	07d2      	lsls	r2, r2, #31
 80132a4:	d463      	bmi.n	801336e <_free_r+0x1f2>
 80132a6:	440b      	add	r3, r1
 80132a8:	e9dc 1202 	ldrd	r1, r2, [ip, #8]
 80132ac:	60ca      	str	r2, [r1, #12]
 80132ae:	6091      	str	r1, [r2, #8]
 80132b0:	f043 0201 	orr.w	r2, r3, #1
 80132b4:	606a      	str	r2, [r5, #4]
 80132b6:	4630      	mov	r0, r6
 80132b8:	50eb      	str	r3, [r5, r3]
 80132ba:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80132be:	f000 bb2f 	b.w	8013920 <__malloc_unlock>
 80132c2:	440b      	add	r3, r1
 80132c4:	07d1      	lsls	r1, r2, #31
 80132c6:	d407      	bmi.n	80132d8 <_free_r+0x15c>
 80132c8:	f854 2c08 	ldr.w	r2, [r4, #-8]
 80132cc:	1aad      	subs	r5, r5, r2
 80132ce:	4413      	add	r3, r2
 80132d0:	e9d5 1202 	ldrd	r1, r2, [r5, #8]
 80132d4:	60ca      	str	r2, [r1, #12]
 80132d6:	6091      	str	r1, [r2, #8]
 80132d8:	f043 0201 	orr.w	r2, r3, #1
 80132dc:	606a      	str	r2, [r5, #4]
 80132de:	4a28      	ldr	r2, [pc, #160]	; (8013380 <_free_r+0x204>)
 80132e0:	60bd      	str	r5, [r7, #8]
 80132e2:	6812      	ldr	r2, [r2, #0]
 80132e4:	429a      	cmp	r2, r3
 80132e6:	d893      	bhi.n	8013210 <_free_r+0x94>
 80132e8:	4b26      	ldr	r3, [pc, #152]	; (8013384 <_free_r+0x208>)
 80132ea:	4630      	mov	r0, r6
 80132ec:	6819      	ldr	r1, [r3, #0]
 80132ee:	f7ff fef5 	bl	80130dc <_malloc_trim_r>
 80132f2:	e78d      	b.n	8013210 <_free_r+0x94>
 80132f4:	2b14      	cmp	r3, #20
 80132f6:	d90a      	bls.n	801330e <_free_r+0x192>
 80132f8:	2b54      	cmp	r3, #84	; 0x54
 80132fa:	d81f      	bhi.n	801333c <_free_r+0x1c0>
 80132fc:	0b0b      	lsrs	r3, r1, #12
 80132fe:	f103 006f 	add.w	r0, r3, #111	; 0x6f
 8013302:	f103 026e 	add.w	r2, r3, #110	; 0x6e
 8013306:	00c3      	lsls	r3, r0, #3
 8013308:	e7b1      	b.n	801326e <_free_r+0xf2>
 801330a:	4419      	add	r1, r3
 801330c:	e78d      	b.n	801322a <_free_r+0xae>
 801330e:	f103 005c 	add.w	r0, r3, #92	; 0x5c
 8013312:	f103 025b 	add.w	r2, r3, #91	; 0x5b
 8013316:	00c3      	lsls	r3, r0, #3
 8013318:	e7a9      	b.n	801326e <_free_r+0xf2>
 801331a:	f041 0301 	orr.w	r3, r1, #1
 801331e:	e9c7 5504 	strd	r5, r5, [r7, #16]
 8013322:	e9c5 0002 	strd	r0, r0, [r5, #8]
 8013326:	606b      	str	r3, [r5, #4]
 8013328:	5069      	str	r1, [r5, r1]
 801332a:	e771      	b.n	8013210 <_free_r+0x94>
 801332c:	6879      	ldr	r1, [r7, #4]
 801332e:	1092      	asrs	r2, r2, #2
 8013330:	2401      	movs	r4, #1
 8013332:	fa04 f202 	lsl.w	r2, r4, r2
 8013336:	430a      	orrs	r2, r1
 8013338:	607a      	str	r2, [r7, #4]
 801333a:	e7a6      	b.n	801328a <_free_r+0x10e>
 801333c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8013340:	d806      	bhi.n	8013350 <_free_r+0x1d4>
 8013342:	0bcb      	lsrs	r3, r1, #15
 8013344:	f103 0078 	add.w	r0, r3, #120	; 0x78
 8013348:	f103 0277 	add.w	r2, r3, #119	; 0x77
 801334c:	00c3      	lsls	r3, r0, #3
 801334e:	e78e      	b.n	801326e <_free_r+0xf2>
 8013350:	f240 5254 	movw	r2, #1364	; 0x554
 8013354:	4293      	cmp	r3, r2
 8013356:	d806      	bhi.n	8013366 <_free_r+0x1ea>
 8013358:	0c8b      	lsrs	r3, r1, #18
 801335a:	f103 007d 	add.w	r0, r3, #125	; 0x7d
 801335e:	f103 027c 	add.w	r2, r3, #124	; 0x7c
 8013362:	00c3      	lsls	r3, r0, #3
 8013364:	e783      	b.n	801326e <_free_r+0xf2>
 8013366:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 801336a:	227e      	movs	r2, #126	; 0x7e
 801336c:	e77f      	b.n	801326e <_free_r+0xf2>
 801336e:	f041 0301 	orr.w	r3, r1, #1
 8013372:	606b      	str	r3, [r5, #4]
 8013374:	f8cc 1000 	str.w	r1, [ip]
 8013378:	e74a      	b.n	8013210 <_free_r+0x94>
 801337a:	bf00      	nop
 801337c:	240002dc 	.word	0x240002dc
 8013380:	240006e8 	.word	0x240006e8
 8013384:	240061bc 	.word	0x240061bc

08013388 <_malloc_r>:
 8013388:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801338c:	f101 060b 	add.w	r6, r1, #11
 8013390:	2e16      	cmp	r6, #22
 8013392:	b083      	sub	sp, #12
 8013394:	4604      	mov	r4, r0
 8013396:	d824      	bhi.n	80133e2 <_malloc_r+0x5a>
 8013398:	2910      	cmp	r1, #16
 801339a:	f200 80ba 	bhi.w	8013512 <_malloc_r+0x18a>
 801339e:	f000 fab9 	bl	8013914 <__malloc_lock>
 80133a2:	2610      	movs	r6, #16
 80133a4:	2218      	movs	r2, #24
 80133a6:	2002      	movs	r0, #2
 80133a8:	4fb5      	ldr	r7, [pc, #724]	; (8013680 <_malloc_r+0x2f8>)
 80133aa:	443a      	add	r2, r7
 80133ac:	f1a2 0108 	sub.w	r1, r2, #8
 80133b0:	6853      	ldr	r3, [r2, #4]
 80133b2:	428b      	cmp	r3, r1
 80133b4:	f000 80ba 	beq.w	801352c <_malloc_r+0x1a4>
 80133b8:	685a      	ldr	r2, [r3, #4]
 80133ba:	68d9      	ldr	r1, [r3, #12]
 80133bc:	f022 0203 	bic.w	r2, r2, #3
 80133c0:	441a      	add	r2, r3
 80133c2:	689d      	ldr	r5, [r3, #8]
 80133c4:	60e9      	str	r1, [r5, #12]
 80133c6:	608d      	str	r5, [r1, #8]
 80133c8:	6851      	ldr	r1, [r2, #4]
 80133ca:	f041 0101 	orr.w	r1, r1, #1
 80133ce:	4620      	mov	r0, r4
 80133d0:	6051      	str	r1, [r2, #4]
 80133d2:	f103 0508 	add.w	r5, r3, #8
 80133d6:	f000 faa3 	bl	8013920 <__malloc_unlock>
 80133da:	4628      	mov	r0, r5
 80133dc:	b003      	add	sp, #12
 80133de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80133e2:	f036 0607 	bics.w	r6, r6, #7
 80133e6:	f100 8094 	bmi.w	8013512 <_malloc_r+0x18a>
 80133ea:	42b1      	cmp	r1, r6
 80133ec:	f200 8091 	bhi.w	8013512 <_malloc_r+0x18a>
 80133f0:	f000 fa90 	bl	8013914 <__malloc_lock>
 80133f4:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
 80133f8:	f0c0 819a 	bcc.w	8013730 <_malloc_r+0x3a8>
 80133fc:	0a73      	lsrs	r3, r6, #9
 80133fe:	f000 808f 	beq.w	8013520 <_malloc_r+0x198>
 8013402:	2b04      	cmp	r3, #4
 8013404:	f200 816f 	bhi.w	80136e6 <_malloc_r+0x35e>
 8013408:	09b3      	lsrs	r3, r6, #6
 801340a:	f103 0039 	add.w	r0, r3, #57	; 0x39
 801340e:	f103 0c38 	add.w	ip, r3, #56	; 0x38
 8013412:	00c3      	lsls	r3, r0, #3
 8013414:	4f9a      	ldr	r7, [pc, #616]	; (8013680 <_malloc_r+0x2f8>)
 8013416:	443b      	add	r3, r7
 8013418:	f1a3 0508 	sub.w	r5, r3, #8
 801341c:	685b      	ldr	r3, [r3, #4]
 801341e:	429d      	cmp	r5, r3
 8013420:	d106      	bne.n	8013430 <_malloc_r+0xa8>
 8013422:	e00c      	b.n	801343e <_malloc_r+0xb6>
 8013424:	2900      	cmp	r1, #0
 8013426:	f280 8127 	bge.w	8013678 <_malloc_r+0x2f0>
 801342a:	68db      	ldr	r3, [r3, #12]
 801342c:	429d      	cmp	r5, r3
 801342e:	d006      	beq.n	801343e <_malloc_r+0xb6>
 8013430:	685a      	ldr	r2, [r3, #4]
 8013432:	f022 0203 	bic.w	r2, r2, #3
 8013436:	1b91      	subs	r1, r2, r6
 8013438:	290f      	cmp	r1, #15
 801343a:	ddf3      	ble.n	8013424 <_malloc_r+0x9c>
 801343c:	4660      	mov	r0, ip
 801343e:	693d      	ldr	r5, [r7, #16]
 8013440:	f8df c250 	ldr.w	ip, [pc, #592]	; 8013694 <_malloc_r+0x30c>
 8013444:	4565      	cmp	r5, ip
 8013446:	d07c      	beq.n	8013542 <_malloc_r+0x1ba>
 8013448:	686a      	ldr	r2, [r5, #4]
 801344a:	f022 0203 	bic.w	r2, r2, #3
 801344e:	1b93      	subs	r3, r2, r6
 8013450:	2b0f      	cmp	r3, #15
 8013452:	f300 817b 	bgt.w	801374c <_malloc_r+0x3c4>
 8013456:	2b00      	cmp	r3, #0
 8013458:	e9c7 cc04 	strd	ip, ip, [r7, #16]
 801345c:	f280 816c 	bge.w	8013738 <_malloc_r+0x3b0>
 8013460:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8013464:	f080 811a 	bcs.w	801369c <_malloc_r+0x314>
 8013468:	08d3      	lsrs	r3, r2, #3
 801346a:	6879      	ldr	r1, [r7, #4]
 801346c:	3301      	adds	r3, #1
 801346e:	ea4f 1e52 	mov.w	lr, r2, lsr #5
 8013472:	2201      	movs	r2, #1
 8013474:	fa02 f20e 	lsl.w	r2, r2, lr
 8013478:	430a      	orrs	r2, r1
 801347a:	f857 e033 	ldr.w	lr, [r7, r3, lsl #3]
 801347e:	f8c5 e008 	str.w	lr, [r5, #8]
 8013482:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
 8013486:	3908      	subs	r1, #8
 8013488:	60e9      	str	r1, [r5, #12]
 801348a:	607a      	str	r2, [r7, #4]
 801348c:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
 8013490:	f8ce 500c 	str.w	r5, [lr, #12]
 8013494:	1083      	asrs	r3, r0, #2
 8013496:	2101      	movs	r1, #1
 8013498:	4099      	lsls	r1, r3
 801349a:	4291      	cmp	r1, r2
 801349c:	d857      	bhi.n	801354e <_malloc_r+0x1c6>
 801349e:	4211      	tst	r1, r2
 80134a0:	d106      	bne.n	80134b0 <_malloc_r+0x128>
 80134a2:	f020 0003 	bic.w	r0, r0, #3
 80134a6:	0049      	lsls	r1, r1, #1
 80134a8:	4211      	tst	r1, r2
 80134aa:	f100 0004 	add.w	r0, r0, #4
 80134ae:	d0fa      	beq.n	80134a6 <_malloc_r+0x11e>
 80134b0:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
 80134b4:	464d      	mov	r5, r9
 80134b6:	4686      	mov	lr, r0
 80134b8:	f8d5 800c 	ldr.w	r8, [r5, #12]
 80134bc:	4545      	cmp	r5, r8
 80134be:	d108      	bne.n	80134d2 <_malloc_r+0x14a>
 80134c0:	e11d      	b.n	80136fe <_malloc_r+0x376>
 80134c2:	2b00      	cmp	r3, #0
 80134c4:	f280 8124 	bge.w	8013710 <_malloc_r+0x388>
 80134c8:	f8d8 800c 	ldr.w	r8, [r8, #12]
 80134cc:	4545      	cmp	r5, r8
 80134ce:	f000 8116 	beq.w	80136fe <_malloc_r+0x376>
 80134d2:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80134d6:	f022 0203 	bic.w	r2, r2, #3
 80134da:	1b93      	subs	r3, r2, r6
 80134dc:	2b0f      	cmp	r3, #15
 80134de:	ddf0      	ble.n	80134c2 <_malloc_r+0x13a>
 80134e0:	4620      	mov	r0, r4
 80134e2:	e9d8 5402 	ldrd	r5, r4, [r8, #8]
 80134e6:	eb08 0106 	add.w	r1, r8, r6
 80134ea:	f046 0601 	orr.w	r6, r6, #1
 80134ee:	f8c8 6004 	str.w	r6, [r8, #4]
 80134f2:	60ec      	str	r4, [r5, #12]
 80134f4:	60a5      	str	r5, [r4, #8]
 80134f6:	f043 0401 	orr.w	r4, r3, #1
 80134fa:	e9c7 1104 	strd	r1, r1, [r7, #16]
 80134fe:	e9c1 cc02 	strd	ip, ip, [r1, #8]
 8013502:	604c      	str	r4, [r1, #4]
 8013504:	f848 3002 	str.w	r3, [r8, r2]
 8013508:	f000 fa0a 	bl	8013920 <__malloc_unlock>
 801350c:	f108 0508 	add.w	r5, r8, #8
 8013510:	e002      	b.n	8013518 <_malloc_r+0x190>
 8013512:	230c      	movs	r3, #12
 8013514:	6023      	str	r3, [r4, #0]
 8013516:	2500      	movs	r5, #0
 8013518:	4628      	mov	r0, r5
 801351a:	b003      	add	sp, #12
 801351c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013520:	f44f 7300 	mov.w	r3, #512	; 0x200
 8013524:	2040      	movs	r0, #64	; 0x40
 8013526:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
 801352a:	e773      	b.n	8013414 <_malloc_r+0x8c>
 801352c:	68d3      	ldr	r3, [r2, #12]
 801352e:	429a      	cmp	r2, r3
 8013530:	bf08      	it	eq
 8013532:	3002      	addeq	r0, #2
 8013534:	f47f af40 	bne.w	80133b8 <_malloc_r+0x30>
 8013538:	693d      	ldr	r5, [r7, #16]
 801353a:	f8df c158 	ldr.w	ip, [pc, #344]	; 8013694 <_malloc_r+0x30c>
 801353e:	4565      	cmp	r5, ip
 8013540:	d182      	bne.n	8013448 <_malloc_r+0xc0>
 8013542:	687a      	ldr	r2, [r7, #4]
 8013544:	1083      	asrs	r3, r0, #2
 8013546:	2101      	movs	r1, #1
 8013548:	4099      	lsls	r1, r3
 801354a:	4291      	cmp	r1, r2
 801354c:	d9a7      	bls.n	801349e <_malloc_r+0x116>
 801354e:	68bd      	ldr	r5, [r7, #8]
 8013550:	686b      	ldr	r3, [r5, #4]
 8013552:	f023 0903 	bic.w	r9, r3, #3
 8013556:	454e      	cmp	r6, r9
 8013558:	d803      	bhi.n	8013562 <_malloc_r+0x1da>
 801355a:	eba9 0306 	sub.w	r3, r9, r6
 801355e:	2b0f      	cmp	r3, #15
 8013560:	dc7a      	bgt.n	8013658 <_malloc_r+0x2d0>
 8013562:	f8df b134 	ldr.w	fp, [pc, #308]	; 8013698 <_malloc_r+0x310>
 8013566:	4b47      	ldr	r3, [pc, #284]	; (8013684 <_malloc_r+0x2fc>)
 8013568:	f8db 2000 	ldr.w	r2, [fp]
 801356c:	681b      	ldr	r3, [r3, #0]
 801356e:	3201      	adds	r2, #1
 8013570:	4433      	add	r3, r6
 8013572:	eb05 0a09 	add.w	sl, r5, r9
 8013576:	f000 8133 	beq.w	80137e0 <_malloc_r+0x458>
 801357a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801357e:	330f      	adds	r3, #15
 8013580:	f423 687f 	bic.w	r8, r3, #4080	; 0xff0
 8013584:	f028 080f 	bic.w	r8, r8, #15
 8013588:	4641      	mov	r1, r8
 801358a:	4620      	mov	r0, r4
 801358c:	f001 f8ae 	bl	80146ec <_sbrk_r>
 8013590:	1c41      	adds	r1, r0, #1
 8013592:	4602      	mov	r2, r0
 8013594:	f000 80f3 	beq.w	801377e <_malloc_r+0x3f6>
 8013598:	4582      	cmp	sl, r0
 801359a:	f200 80ee 	bhi.w	801377a <_malloc_r+0x3f2>
 801359e:	4b3a      	ldr	r3, [pc, #232]	; (8013688 <_malloc_r+0x300>)
 80135a0:	6819      	ldr	r1, [r3, #0]
 80135a2:	4441      	add	r1, r8
 80135a4:	6019      	str	r1, [r3, #0]
 80135a6:	4608      	mov	r0, r1
 80135a8:	f000 814e 	beq.w	8013848 <_malloc_r+0x4c0>
 80135ac:	f8db 1000 	ldr.w	r1, [fp]
 80135b0:	9301      	str	r3, [sp, #4]
 80135b2:	3101      	adds	r1, #1
 80135b4:	bf1b      	ittet	ne
 80135b6:	eba2 010a 	subne.w	r1, r2, sl
 80135ba:	1809      	addne	r1, r1, r0
 80135bc:	f8cb 2000 	streq.w	r2, [fp]
 80135c0:	6019      	strne	r1, [r3, #0]
 80135c2:	f012 0b07 	ands.w	fp, r2, #7
 80135c6:	f000 8117 	beq.w	80137f8 <_malloc_r+0x470>
 80135ca:	f1cb 0108 	rsb	r1, fp, #8
 80135ce:	440a      	add	r2, r1
 80135d0:	f5cb 5180 	rsb	r1, fp, #4096	; 0x1000
 80135d4:	4490      	add	r8, r2
 80135d6:	3108      	adds	r1, #8
 80135d8:	eba1 0108 	sub.w	r1, r1, r8
 80135dc:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
 80135e0:	4651      	mov	r1, sl
 80135e2:	4620      	mov	r0, r4
 80135e4:	9200      	str	r2, [sp, #0]
 80135e6:	f001 f881 	bl	80146ec <_sbrk_r>
 80135ea:	1c42      	adds	r2, r0, #1
 80135ec:	e9dd 2300 	ldrd	r2, r3, [sp]
 80135f0:	f000 814f 	beq.w	8013892 <_malloc_r+0x50a>
 80135f4:	1a80      	subs	r0, r0, r2
 80135f6:	eb00 080a 	add.w	r8, r0, sl
 80135fa:	6819      	ldr	r1, [r3, #0]
 80135fc:	60ba      	str	r2, [r7, #8]
 80135fe:	f048 0001 	orr.w	r0, r8, #1
 8013602:	4451      	add	r1, sl
 8013604:	42bd      	cmp	r5, r7
 8013606:	6050      	str	r0, [r2, #4]
 8013608:	6019      	str	r1, [r3, #0]
 801360a:	f000 8129 	beq.w	8013860 <_malloc_r+0x4d8>
 801360e:	f1b9 0f0f 	cmp.w	r9, #15
 8013612:	f240 8127 	bls.w	8013864 <_malloc_r+0x4dc>
 8013616:	6868      	ldr	r0, [r5, #4]
 8013618:	f1a9 0c0c 	sub.w	ip, r9, #12
 801361c:	f02c 0c07 	bic.w	ip, ip, #7
 8013620:	f000 0001 	and.w	r0, r0, #1
 8013624:	ea40 000c 	orr.w	r0, r0, ip
 8013628:	6068      	str	r0, [r5, #4]
 801362a:	f04f 0e05 	mov.w	lr, #5
 801362e:	eb05 000c 	add.w	r0, r5, ip
 8013632:	f1bc 0f0f 	cmp.w	ip, #15
 8013636:	e9c0 ee01 	strd	lr, lr, [r0, #4]
 801363a:	f200 8132 	bhi.w	80138a2 <_malloc_r+0x51a>
 801363e:	6850      	ldr	r0, [r2, #4]
 8013640:	4615      	mov	r5, r2
 8013642:	4b12      	ldr	r3, [pc, #72]	; (801368c <_malloc_r+0x304>)
 8013644:	681a      	ldr	r2, [r3, #0]
 8013646:	428a      	cmp	r2, r1
 8013648:	bf38      	it	cc
 801364a:	6019      	strcc	r1, [r3, #0]
 801364c:	4b10      	ldr	r3, [pc, #64]	; (8013690 <_malloc_r+0x308>)
 801364e:	681a      	ldr	r2, [r3, #0]
 8013650:	428a      	cmp	r2, r1
 8013652:	bf38      	it	cc
 8013654:	6019      	strcc	r1, [r3, #0]
 8013656:	e094      	b.n	8013782 <_malloc_r+0x3fa>
 8013658:	19aa      	adds	r2, r5, r6
 801365a:	f043 0301 	orr.w	r3, r3, #1
 801365e:	f046 0601 	orr.w	r6, r6, #1
 8013662:	606e      	str	r6, [r5, #4]
 8013664:	4620      	mov	r0, r4
 8013666:	60ba      	str	r2, [r7, #8]
 8013668:	6053      	str	r3, [r2, #4]
 801366a:	f000 f959 	bl	8013920 <__malloc_unlock>
 801366e:	3508      	adds	r5, #8
 8013670:	4628      	mov	r0, r5
 8013672:	b003      	add	sp, #12
 8013674:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013678:	68d9      	ldr	r1, [r3, #12]
 801367a:	441a      	add	r2, r3
 801367c:	e6a1      	b.n	80133c2 <_malloc_r+0x3a>
 801367e:	bf00      	nop
 8013680:	240002dc 	.word	0x240002dc
 8013684:	240061bc 	.word	0x240061bc
 8013688:	2400618c 	.word	0x2400618c
 801368c:	240061b4 	.word	0x240061b4
 8013690:	240061b8 	.word	0x240061b8
 8013694:	240002e4 	.word	0x240002e4
 8013698:	240006e4 	.word	0x240006e4
 801369c:	f5b2 6f20 	cmp.w	r2, #2560	; 0xa00
 80136a0:	ea4f 2352 	mov.w	r3, r2, lsr #9
 80136a4:	d363      	bcc.n	801376e <_malloc_r+0x3e6>
 80136a6:	2b14      	cmp	r3, #20
 80136a8:	f200 80b7 	bhi.w	801381a <_malloc_r+0x492>
 80136ac:	f103 015c 	add.w	r1, r3, #92	; 0x5c
 80136b0:	00c9      	lsls	r1, r1, #3
 80136b2:	335b      	adds	r3, #91	; 0x5b
 80136b4:	eb07 0e01 	add.w	lr, r7, r1
 80136b8:	5879      	ldr	r1, [r7, r1]
 80136ba:	f1ae 0e08 	sub.w	lr, lr, #8
 80136be:	458e      	cmp	lr, r1
 80136c0:	f000 8091 	beq.w	80137e6 <_malloc_r+0x45e>
 80136c4:	684b      	ldr	r3, [r1, #4]
 80136c6:	f023 0303 	bic.w	r3, r3, #3
 80136ca:	4293      	cmp	r3, r2
 80136cc:	d902      	bls.n	80136d4 <_malloc_r+0x34c>
 80136ce:	6889      	ldr	r1, [r1, #8]
 80136d0:	458e      	cmp	lr, r1
 80136d2:	d1f7      	bne.n	80136c4 <_malloc_r+0x33c>
 80136d4:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 80136d8:	687a      	ldr	r2, [r7, #4]
 80136da:	e9c5 1e02 	strd	r1, lr, [r5, #8]
 80136de:	f8ce 5008 	str.w	r5, [lr, #8]
 80136e2:	60cd      	str	r5, [r1, #12]
 80136e4:	e6d6      	b.n	8013494 <_malloc_r+0x10c>
 80136e6:	2b14      	cmp	r3, #20
 80136e8:	d959      	bls.n	801379e <_malloc_r+0x416>
 80136ea:	2b54      	cmp	r3, #84	; 0x54
 80136ec:	f200 809d 	bhi.w	801382a <_malloc_r+0x4a2>
 80136f0:	0b33      	lsrs	r3, r6, #12
 80136f2:	f103 006f 	add.w	r0, r3, #111	; 0x6f
 80136f6:	f103 0c6e 	add.w	ip, r3, #110	; 0x6e
 80136fa:	00c3      	lsls	r3, r0, #3
 80136fc:	e68a      	b.n	8013414 <_malloc_r+0x8c>
 80136fe:	f10e 0e01 	add.w	lr, lr, #1
 8013702:	f01e 0f03 	tst.w	lr, #3
 8013706:	f105 0508 	add.w	r5, r5, #8
 801370a:	f47f aed5 	bne.w	80134b8 <_malloc_r+0x130>
 801370e:	e051      	b.n	80137b4 <_malloc_r+0x42c>
 8013710:	4442      	add	r2, r8
 8013712:	4645      	mov	r5, r8
 8013714:	6853      	ldr	r3, [r2, #4]
 8013716:	f8d8 100c 	ldr.w	r1, [r8, #12]
 801371a:	f043 0301 	orr.w	r3, r3, #1
 801371e:	6053      	str	r3, [r2, #4]
 8013720:	f855 3f08 	ldr.w	r3, [r5, #8]!
 8013724:	4620      	mov	r0, r4
 8013726:	60d9      	str	r1, [r3, #12]
 8013728:	608b      	str	r3, [r1, #8]
 801372a:	f000 f8f9 	bl	8013920 <__malloc_unlock>
 801372e:	e6f3      	b.n	8013518 <_malloc_r+0x190>
 8013730:	08f0      	lsrs	r0, r6, #3
 8013732:	f106 0208 	add.w	r2, r6, #8
 8013736:	e637      	b.n	80133a8 <_malloc_r+0x20>
 8013738:	442a      	add	r2, r5
 801373a:	4620      	mov	r0, r4
 801373c:	6853      	ldr	r3, [r2, #4]
 801373e:	f043 0301 	orr.w	r3, r3, #1
 8013742:	6053      	str	r3, [r2, #4]
 8013744:	3508      	adds	r5, #8
 8013746:	f000 f8eb 	bl	8013920 <__malloc_unlock>
 801374a:	e6e5      	b.n	8013518 <_malloc_r+0x190>
 801374c:	19a9      	adds	r1, r5, r6
 801374e:	4620      	mov	r0, r4
 8013750:	f046 0601 	orr.w	r6, r6, #1
 8013754:	f043 0401 	orr.w	r4, r3, #1
 8013758:	606e      	str	r6, [r5, #4]
 801375a:	e9c7 1104 	strd	r1, r1, [r7, #16]
 801375e:	e9c1 cc02 	strd	ip, ip, [r1, #8]
 8013762:	604c      	str	r4, [r1, #4]
 8013764:	50ab      	str	r3, [r5, r2]
 8013766:	f000 f8db 	bl	8013920 <__malloc_unlock>
 801376a:	3508      	adds	r5, #8
 801376c:	e6d4      	b.n	8013518 <_malloc_r+0x190>
 801376e:	0993      	lsrs	r3, r2, #6
 8013770:	f103 0139 	add.w	r1, r3, #57	; 0x39
 8013774:	00c9      	lsls	r1, r1, #3
 8013776:	3338      	adds	r3, #56	; 0x38
 8013778:	e79c      	b.n	80136b4 <_malloc_r+0x32c>
 801377a:	42bd      	cmp	r5, r7
 801377c:	d05f      	beq.n	801383e <_malloc_r+0x4b6>
 801377e:	68bd      	ldr	r5, [r7, #8]
 8013780:	6868      	ldr	r0, [r5, #4]
 8013782:	f020 0803 	bic.w	r8, r0, #3
 8013786:	4546      	cmp	r6, r8
 8013788:	eba8 0306 	sub.w	r3, r8, r6
 801378c:	d802      	bhi.n	8013794 <_malloc_r+0x40c>
 801378e:	2b0f      	cmp	r3, #15
 8013790:	f73f af62 	bgt.w	8013658 <_malloc_r+0x2d0>
 8013794:	4620      	mov	r0, r4
 8013796:	f000 f8c3 	bl	8013920 <__malloc_unlock>
 801379a:	2500      	movs	r5, #0
 801379c:	e6bc      	b.n	8013518 <_malloc_r+0x190>
 801379e:	f103 005c 	add.w	r0, r3, #92	; 0x5c
 80137a2:	f103 0c5b 	add.w	ip, r3, #91	; 0x5b
 80137a6:	00c3      	lsls	r3, r0, #3
 80137a8:	e634      	b.n	8013414 <_malloc_r+0x8c>
 80137aa:	f859 3908 	ldr.w	r3, [r9], #-8
 80137ae:	454b      	cmp	r3, r9
 80137b0:	f040 8096 	bne.w	80138e0 <_malloc_r+0x558>
 80137b4:	f010 0f03 	tst.w	r0, #3
 80137b8:	f100 30ff 	add.w	r0, r0, #4294967295
 80137bc:	d1f5      	bne.n	80137aa <_malloc_r+0x422>
 80137be:	687b      	ldr	r3, [r7, #4]
 80137c0:	ea23 0301 	bic.w	r3, r3, r1
 80137c4:	607b      	str	r3, [r7, #4]
 80137c6:	0049      	lsls	r1, r1, #1
 80137c8:	4299      	cmp	r1, r3
 80137ca:	f63f aec0 	bhi.w	801354e <_malloc_r+0x1c6>
 80137ce:	b919      	cbnz	r1, 80137d8 <_malloc_r+0x450>
 80137d0:	e6bd      	b.n	801354e <_malloc_r+0x1c6>
 80137d2:	0049      	lsls	r1, r1, #1
 80137d4:	f10e 0e04 	add.w	lr, lr, #4
 80137d8:	4219      	tst	r1, r3
 80137da:	d0fa      	beq.n	80137d2 <_malloc_r+0x44a>
 80137dc:	4670      	mov	r0, lr
 80137de:	e667      	b.n	80134b0 <_malloc_r+0x128>
 80137e0:	f103 0810 	add.w	r8, r3, #16
 80137e4:	e6d0      	b.n	8013588 <_malloc_r+0x200>
 80137e6:	109a      	asrs	r2, r3, #2
 80137e8:	f04f 0801 	mov.w	r8, #1
 80137ec:	687b      	ldr	r3, [r7, #4]
 80137ee:	fa08 f202 	lsl.w	r2, r8, r2
 80137f2:	431a      	orrs	r2, r3
 80137f4:	607a      	str	r2, [r7, #4]
 80137f6:	e770      	b.n	80136da <_malloc_r+0x352>
 80137f8:	eb02 0108 	add.w	r1, r2, r8
 80137fc:	4249      	negs	r1, r1
 80137fe:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
 8013802:	4651      	mov	r1, sl
 8013804:	4620      	mov	r0, r4
 8013806:	9200      	str	r2, [sp, #0]
 8013808:	f000 ff70 	bl	80146ec <_sbrk_r>
 801380c:	1c43      	adds	r3, r0, #1
 801380e:	e9dd 2300 	ldrd	r2, r3, [sp]
 8013812:	f47f aeef 	bne.w	80135f4 <_malloc_r+0x26c>
 8013816:	46da      	mov	sl, fp
 8013818:	e6ef      	b.n	80135fa <_malloc_r+0x272>
 801381a:	2b54      	cmp	r3, #84	; 0x54
 801381c:	d825      	bhi.n	801386a <_malloc_r+0x4e2>
 801381e:	0b13      	lsrs	r3, r2, #12
 8013820:	f103 016f 	add.w	r1, r3, #111	; 0x6f
 8013824:	00c9      	lsls	r1, r1, #3
 8013826:	336e      	adds	r3, #110	; 0x6e
 8013828:	e744      	b.n	80136b4 <_malloc_r+0x32c>
 801382a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 801382e:	d825      	bhi.n	801387c <_malloc_r+0x4f4>
 8013830:	0bf3      	lsrs	r3, r6, #15
 8013832:	f103 0078 	add.w	r0, r3, #120	; 0x78
 8013836:	f103 0c77 	add.w	ip, r3, #119	; 0x77
 801383a:	00c3      	lsls	r3, r0, #3
 801383c:	e5ea      	b.n	8013414 <_malloc_r+0x8c>
 801383e:	4b29      	ldr	r3, [pc, #164]	; (80138e4 <_malloc_r+0x55c>)
 8013840:	6818      	ldr	r0, [r3, #0]
 8013842:	4440      	add	r0, r8
 8013844:	6018      	str	r0, [r3, #0]
 8013846:	e6b1      	b.n	80135ac <_malloc_r+0x224>
 8013848:	f3ca 0c0b 	ubfx	ip, sl, #0, #12
 801384c:	f1bc 0f00 	cmp.w	ip, #0
 8013850:	f47f aeac 	bne.w	80135ac <_malloc_r+0x224>
 8013854:	68bd      	ldr	r5, [r7, #8]
 8013856:	44c8      	add	r8, r9
 8013858:	f048 0001 	orr.w	r0, r8, #1
 801385c:	6068      	str	r0, [r5, #4]
 801385e:	e6f0      	b.n	8013642 <_malloc_r+0x2ba>
 8013860:	4615      	mov	r5, r2
 8013862:	e6ee      	b.n	8013642 <_malloc_r+0x2ba>
 8013864:	2301      	movs	r3, #1
 8013866:	6053      	str	r3, [r2, #4]
 8013868:	e794      	b.n	8013794 <_malloc_r+0x40c>
 801386a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 801386e:	d823      	bhi.n	80138b8 <_malloc_r+0x530>
 8013870:	0bd3      	lsrs	r3, r2, #15
 8013872:	f103 0178 	add.w	r1, r3, #120	; 0x78
 8013876:	00c9      	lsls	r1, r1, #3
 8013878:	3377      	adds	r3, #119	; 0x77
 801387a:	e71b      	b.n	80136b4 <_malloc_r+0x32c>
 801387c:	f240 5254 	movw	r2, #1364	; 0x554
 8013880:	4293      	cmp	r3, r2
 8013882:	d823      	bhi.n	80138cc <_malloc_r+0x544>
 8013884:	0cb3      	lsrs	r3, r6, #18
 8013886:	f103 007d 	add.w	r0, r3, #125	; 0x7d
 801388a:	f103 0c7c 	add.w	ip, r3, #124	; 0x7c
 801388e:	00c3      	lsls	r3, r0, #3
 8013890:	e5c0      	b.n	8013414 <_malloc_r+0x8c>
 8013892:	f1ab 0b08 	sub.w	fp, fp, #8
 8013896:	44d8      	add	r8, fp
 8013898:	eba8 0802 	sub.w	r8, r8, r2
 801389c:	f04f 0a00 	mov.w	sl, #0
 80138a0:	e6ab      	b.n	80135fa <_malloc_r+0x272>
 80138a2:	f105 0108 	add.w	r1, r5, #8
 80138a6:	4620      	mov	r0, r4
 80138a8:	9300      	str	r3, [sp, #0]
 80138aa:	f7ff fc67 	bl	801317c <_free_r>
 80138ae:	68bd      	ldr	r5, [r7, #8]
 80138b0:	9b00      	ldr	r3, [sp, #0]
 80138b2:	6868      	ldr	r0, [r5, #4]
 80138b4:	6819      	ldr	r1, [r3, #0]
 80138b6:	e6c4      	b.n	8013642 <_malloc_r+0x2ba>
 80138b8:	f240 5154 	movw	r1, #1364	; 0x554
 80138bc:	428b      	cmp	r3, r1
 80138be:	d80b      	bhi.n	80138d8 <_malloc_r+0x550>
 80138c0:	0c93      	lsrs	r3, r2, #18
 80138c2:	f103 017d 	add.w	r1, r3, #125	; 0x7d
 80138c6:	00c9      	lsls	r1, r1, #3
 80138c8:	337c      	adds	r3, #124	; 0x7c
 80138ca:	e6f3      	b.n	80136b4 <_malloc_r+0x32c>
 80138cc:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 80138d0:	207f      	movs	r0, #127	; 0x7f
 80138d2:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 80138d6:	e59d      	b.n	8013414 <_malloc_r+0x8c>
 80138d8:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
 80138dc:	237e      	movs	r3, #126	; 0x7e
 80138de:	e6e9      	b.n	80136b4 <_malloc_r+0x32c>
 80138e0:	687b      	ldr	r3, [r7, #4]
 80138e2:	e770      	b.n	80137c6 <_malloc_r+0x43e>
 80138e4:	2400618c 	.word	0x2400618c

080138e8 <__ascii_mbtowc>:
 80138e8:	b082      	sub	sp, #8
 80138ea:	b149      	cbz	r1, 8013900 <__ascii_mbtowc+0x18>
 80138ec:	b15a      	cbz	r2, 8013906 <__ascii_mbtowc+0x1e>
 80138ee:	b16b      	cbz	r3, 801390c <__ascii_mbtowc+0x24>
 80138f0:	7813      	ldrb	r3, [r2, #0]
 80138f2:	600b      	str	r3, [r1, #0]
 80138f4:	7812      	ldrb	r2, [r2, #0]
 80138f6:	1e10      	subs	r0, r2, #0
 80138f8:	bf18      	it	ne
 80138fa:	2001      	movne	r0, #1
 80138fc:	b002      	add	sp, #8
 80138fe:	4770      	bx	lr
 8013900:	a901      	add	r1, sp, #4
 8013902:	2a00      	cmp	r2, #0
 8013904:	d1f3      	bne.n	80138ee <__ascii_mbtowc+0x6>
 8013906:	4610      	mov	r0, r2
 8013908:	b002      	add	sp, #8
 801390a:	4770      	bx	lr
 801390c:	f06f 0001 	mvn.w	r0, #1
 8013910:	e7f4      	b.n	80138fc <__ascii_mbtowc+0x14>
 8013912:	bf00      	nop

08013914 <__malloc_lock>:
 8013914:	4801      	ldr	r0, [pc, #4]	; (801391c <__malloc_lock+0x8>)
 8013916:	f7fe bc97 	b.w	8012248 <__retarget_lock_acquire_recursive>
 801391a:	bf00      	nop
 801391c:	24006184 	.word	0x24006184

08013920 <__malloc_unlock>:
 8013920:	4801      	ldr	r0, [pc, #4]	; (8013928 <__malloc_unlock+0x8>)
 8013922:	f7fe bc93 	b.w	801224c <__retarget_lock_release_recursive>
 8013926:	bf00      	nop
 8013928:	24006184 	.word	0x24006184

0801392c <_Balloc>:
 801392c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 801392e:	b570      	push	{r4, r5, r6, lr}
 8013930:	4605      	mov	r5, r0
 8013932:	460c      	mov	r4, r1
 8013934:	b14b      	cbz	r3, 801394a <_Balloc+0x1e>
 8013936:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 801393a:	b180      	cbz	r0, 801395e <_Balloc+0x32>
 801393c:	6802      	ldr	r2, [r0, #0]
 801393e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 8013942:	2300      	movs	r3, #0
 8013944:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8013948:	bd70      	pop	{r4, r5, r6, pc}
 801394a:	2221      	movs	r2, #33	; 0x21
 801394c:	2104      	movs	r1, #4
 801394e:	f000 feff 	bl	8014750 <_calloc_r>
 8013952:	4603      	mov	r3, r0
 8013954:	6468      	str	r0, [r5, #68]	; 0x44
 8013956:	2800      	cmp	r0, #0
 8013958:	d1ed      	bne.n	8013936 <_Balloc+0xa>
 801395a:	2000      	movs	r0, #0
 801395c:	bd70      	pop	{r4, r5, r6, pc}
 801395e:	2101      	movs	r1, #1
 8013960:	fa01 f604 	lsl.w	r6, r1, r4
 8013964:	1d72      	adds	r2, r6, #5
 8013966:	0092      	lsls	r2, r2, #2
 8013968:	4628      	mov	r0, r5
 801396a:	f000 fef1 	bl	8014750 <_calloc_r>
 801396e:	2800      	cmp	r0, #0
 8013970:	d0f3      	beq.n	801395a <_Balloc+0x2e>
 8013972:	e9c0 4601 	strd	r4, r6, [r0, #4]
 8013976:	e7e4      	b.n	8013942 <_Balloc+0x16>

08013978 <_Bfree>:
 8013978:	b131      	cbz	r1, 8013988 <_Bfree+0x10>
 801397a:	6c43      	ldr	r3, [r0, #68]	; 0x44
 801397c:	684a      	ldr	r2, [r1, #4]
 801397e:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8013982:	6008      	str	r0, [r1, #0]
 8013984:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8013988:	4770      	bx	lr
 801398a:	bf00      	nop

0801398c <__multadd>:
 801398c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013990:	690e      	ldr	r6, [r1, #16]
 8013992:	4680      	mov	r8, r0
 8013994:	460f      	mov	r7, r1
 8013996:	461d      	mov	r5, r3
 8013998:	f101 0e14 	add.w	lr, r1, #20
 801399c:	2000      	movs	r0, #0
 801399e:	f8de 1000 	ldr.w	r1, [lr]
 80139a2:	b28c      	uxth	r4, r1
 80139a4:	fb02 5304 	mla	r3, r2, r4, r5
 80139a8:	0c09      	lsrs	r1, r1, #16
 80139aa:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 80139ae:	fb02 cc01 	mla	ip, r2, r1, ip
 80139b2:	3001      	adds	r0, #1
 80139b4:	b29c      	uxth	r4, r3
 80139b6:	eb04 440c 	add.w	r4, r4, ip, lsl #16
 80139ba:	4286      	cmp	r6, r0
 80139bc:	f84e 4b04 	str.w	r4, [lr], #4
 80139c0:	ea4f 451c 	mov.w	r5, ip, lsr #16
 80139c4:	dceb      	bgt.n	801399e <__multadd+0x12>
 80139c6:	b13d      	cbz	r5, 80139d8 <__multadd+0x4c>
 80139c8:	68bb      	ldr	r3, [r7, #8]
 80139ca:	42b3      	cmp	r3, r6
 80139cc:	dd07      	ble.n	80139de <__multadd+0x52>
 80139ce:	eb07 0386 	add.w	r3, r7, r6, lsl #2
 80139d2:	3601      	adds	r6, #1
 80139d4:	615d      	str	r5, [r3, #20]
 80139d6:	613e      	str	r6, [r7, #16]
 80139d8:	4638      	mov	r0, r7
 80139da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80139de:	6879      	ldr	r1, [r7, #4]
 80139e0:	4640      	mov	r0, r8
 80139e2:	3101      	adds	r1, #1
 80139e4:	f7ff ffa2 	bl	801392c <_Balloc>
 80139e8:	4604      	mov	r4, r0
 80139ea:	b1b0      	cbz	r0, 8013a1a <__multadd+0x8e>
 80139ec:	693a      	ldr	r2, [r7, #16]
 80139ee:	3202      	adds	r2, #2
 80139f0:	f107 010c 	add.w	r1, r7, #12
 80139f4:	0092      	lsls	r2, r2, #2
 80139f6:	300c      	adds	r0, #12
 80139f8:	f7ec fec0 	bl	800077c <memcpy>
 80139fc:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8013a00:	687a      	ldr	r2, [r7, #4]
 8013a02:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013a06:	6039      	str	r1, [r7, #0]
 8013a08:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
 8013a0c:	4627      	mov	r7, r4
 8013a0e:	eb07 0386 	add.w	r3, r7, r6, lsl #2
 8013a12:	3601      	adds	r6, #1
 8013a14:	615d      	str	r5, [r3, #20]
 8013a16:	613e      	str	r6, [r7, #16]
 8013a18:	e7de      	b.n	80139d8 <__multadd+0x4c>
 8013a1a:	4b03      	ldr	r3, [pc, #12]	; (8013a28 <__multadd+0x9c>)
 8013a1c:	4803      	ldr	r0, [pc, #12]	; (8013a2c <__multadd+0xa0>)
 8013a1e:	4622      	mov	r2, r4
 8013a20:	21ba      	movs	r1, #186	; 0xba
 8013a22:	f000 fe75 	bl	8014710 <__assert_func>
 8013a26:	bf00      	nop
 8013a28:	08015ac4 	.word	0x08015ac4
 8013a2c:	08015b34 	.word	0x08015b34

08013a30 <__hi0bits>:
 8013a30:	0c03      	lsrs	r3, r0, #16
 8013a32:	041b      	lsls	r3, r3, #16
 8013a34:	b9d3      	cbnz	r3, 8013a6c <__hi0bits+0x3c>
 8013a36:	0400      	lsls	r0, r0, #16
 8013a38:	2310      	movs	r3, #16
 8013a3a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 8013a3e:	bf04      	itt	eq
 8013a40:	0200      	lsleq	r0, r0, #8
 8013a42:	3308      	addeq	r3, #8
 8013a44:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8013a48:	bf04      	itt	eq
 8013a4a:	0100      	lsleq	r0, r0, #4
 8013a4c:	3304      	addeq	r3, #4
 8013a4e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 8013a52:	bf04      	itt	eq
 8013a54:	0080      	lsleq	r0, r0, #2
 8013a56:	3302      	addeq	r3, #2
 8013a58:	2800      	cmp	r0, #0
 8013a5a:	db05      	blt.n	8013a68 <__hi0bits+0x38>
 8013a5c:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8013a60:	f103 0301 	add.w	r3, r3, #1
 8013a64:	bf08      	it	eq
 8013a66:	2320      	moveq	r3, #32
 8013a68:	4618      	mov	r0, r3
 8013a6a:	4770      	bx	lr
 8013a6c:	2300      	movs	r3, #0
 8013a6e:	e7e4      	b.n	8013a3a <__hi0bits+0xa>

08013a70 <__lo0bits>:
 8013a70:	6803      	ldr	r3, [r0, #0]
 8013a72:	f013 0207 	ands.w	r2, r3, #7
 8013a76:	d008      	beq.n	8013a8a <__lo0bits+0x1a>
 8013a78:	07d9      	lsls	r1, r3, #31
 8013a7a:	d41f      	bmi.n	8013abc <__lo0bits+0x4c>
 8013a7c:	079a      	lsls	r2, r3, #30
 8013a7e:	d522      	bpl.n	8013ac6 <__lo0bits+0x56>
 8013a80:	085b      	lsrs	r3, r3, #1
 8013a82:	6003      	str	r3, [r0, #0]
 8013a84:	2201      	movs	r2, #1
 8013a86:	4610      	mov	r0, r2
 8013a88:	4770      	bx	lr
 8013a8a:	b299      	uxth	r1, r3
 8013a8c:	b909      	cbnz	r1, 8013a92 <__lo0bits+0x22>
 8013a8e:	0c1b      	lsrs	r3, r3, #16
 8013a90:	2210      	movs	r2, #16
 8013a92:	b2d9      	uxtb	r1, r3
 8013a94:	b909      	cbnz	r1, 8013a9a <__lo0bits+0x2a>
 8013a96:	3208      	adds	r2, #8
 8013a98:	0a1b      	lsrs	r3, r3, #8
 8013a9a:	0719      	lsls	r1, r3, #28
 8013a9c:	bf04      	itt	eq
 8013a9e:	091b      	lsreq	r3, r3, #4
 8013aa0:	3204      	addeq	r2, #4
 8013aa2:	0799      	lsls	r1, r3, #30
 8013aa4:	bf04      	itt	eq
 8013aa6:	089b      	lsreq	r3, r3, #2
 8013aa8:	3202      	addeq	r2, #2
 8013aaa:	07d9      	lsls	r1, r3, #31
 8013aac:	d403      	bmi.n	8013ab6 <__lo0bits+0x46>
 8013aae:	085b      	lsrs	r3, r3, #1
 8013ab0:	f102 0201 	add.w	r2, r2, #1
 8013ab4:	d005      	beq.n	8013ac2 <__lo0bits+0x52>
 8013ab6:	6003      	str	r3, [r0, #0]
 8013ab8:	4610      	mov	r0, r2
 8013aba:	4770      	bx	lr
 8013abc:	2200      	movs	r2, #0
 8013abe:	4610      	mov	r0, r2
 8013ac0:	4770      	bx	lr
 8013ac2:	2220      	movs	r2, #32
 8013ac4:	e7df      	b.n	8013a86 <__lo0bits+0x16>
 8013ac6:	089b      	lsrs	r3, r3, #2
 8013ac8:	2202      	movs	r2, #2
 8013aca:	6003      	str	r3, [r0, #0]
 8013acc:	4610      	mov	r0, r2
 8013ace:	4770      	bx	lr

08013ad0 <__i2b>:
 8013ad0:	b538      	push	{r3, r4, r5, lr}
 8013ad2:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8013ad4:	4604      	mov	r4, r0
 8013ad6:	460d      	mov	r5, r1
 8013ad8:	b14b      	cbz	r3, 8013aee <__i2b+0x1e>
 8013ada:	6858      	ldr	r0, [r3, #4]
 8013adc:	b1b0      	cbz	r0, 8013b0c <__i2b+0x3c>
 8013ade:	6802      	ldr	r2, [r0, #0]
 8013ae0:	605a      	str	r2, [r3, #4]
 8013ae2:	2200      	movs	r2, #0
 8013ae4:	2301      	movs	r3, #1
 8013ae6:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8013aea:	60c2      	str	r2, [r0, #12]
 8013aec:	bd38      	pop	{r3, r4, r5, pc}
 8013aee:	2221      	movs	r2, #33	; 0x21
 8013af0:	2104      	movs	r1, #4
 8013af2:	f000 fe2d 	bl	8014750 <_calloc_r>
 8013af6:	4603      	mov	r3, r0
 8013af8:	6460      	str	r0, [r4, #68]	; 0x44
 8013afa:	2800      	cmp	r0, #0
 8013afc:	d1ed      	bne.n	8013ada <__i2b+0xa>
 8013afe:	4b09      	ldr	r3, [pc, #36]	; (8013b24 <__i2b+0x54>)
 8013b00:	4809      	ldr	r0, [pc, #36]	; (8013b28 <__i2b+0x58>)
 8013b02:	2200      	movs	r2, #0
 8013b04:	f240 1145 	movw	r1, #325	; 0x145
 8013b08:	f000 fe02 	bl	8014710 <__assert_func>
 8013b0c:	221c      	movs	r2, #28
 8013b0e:	2101      	movs	r1, #1
 8013b10:	4620      	mov	r0, r4
 8013b12:	f000 fe1d 	bl	8014750 <_calloc_r>
 8013b16:	2800      	cmp	r0, #0
 8013b18:	d0f1      	beq.n	8013afe <__i2b+0x2e>
 8013b1a:	2201      	movs	r2, #1
 8013b1c:	2302      	movs	r3, #2
 8013b1e:	e9c0 2301 	strd	r2, r3, [r0, #4]
 8013b22:	e7de      	b.n	8013ae2 <__i2b+0x12>
 8013b24:	08015ac4 	.word	0x08015ac4
 8013b28:	08015b34 	.word	0x08015b34

08013b2c <__multiply>:
 8013b2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013b30:	690e      	ldr	r6, [r1, #16]
 8013b32:	6915      	ldr	r5, [r2, #16]
 8013b34:	42ae      	cmp	r6, r5
 8013b36:	b085      	sub	sp, #20
 8013b38:	4688      	mov	r8, r1
 8013b3a:	4614      	mov	r4, r2
 8013b3c:	db05      	blt.n	8013b4a <__multiply+0x1e>
 8013b3e:	462a      	mov	r2, r5
 8013b40:	4623      	mov	r3, r4
 8013b42:	4635      	mov	r5, r6
 8013b44:	460c      	mov	r4, r1
 8013b46:	4616      	mov	r6, r2
 8013b48:	4698      	mov	r8, r3
 8013b4a:	68a3      	ldr	r3, [r4, #8]
 8013b4c:	6861      	ldr	r1, [r4, #4]
 8013b4e:	19af      	adds	r7, r5, r6
 8013b50:	42bb      	cmp	r3, r7
 8013b52:	bfb8      	it	lt
 8013b54:	3101      	addlt	r1, #1
 8013b56:	f7ff fee9 	bl	801392c <_Balloc>
 8013b5a:	9001      	str	r0, [sp, #4]
 8013b5c:	2800      	cmp	r0, #0
 8013b5e:	f000 8087 	beq.w	8013c70 <__multiply+0x144>
 8013b62:	9b01      	ldr	r3, [sp, #4]
 8013b64:	f103 0914 	add.w	r9, r3, #20
 8013b68:	eb09 0a87 	add.w	sl, r9, r7, lsl #2
 8013b6c:	45d1      	cmp	r9, sl
 8013b6e:	d205      	bcs.n	8013b7c <__multiply+0x50>
 8013b70:	464b      	mov	r3, r9
 8013b72:	2200      	movs	r2, #0
 8013b74:	f843 2b04 	str.w	r2, [r3], #4
 8013b78:	459a      	cmp	sl, r3
 8013b7a:	d8fb      	bhi.n	8013b74 <__multiply+0x48>
 8013b7c:	f108 0814 	add.w	r8, r8, #20
 8013b80:	eb08 0b86 	add.w	fp, r8, r6, lsl #2
 8013b84:	f104 0314 	add.w	r3, r4, #20
 8013b88:	45d8      	cmp	r8, fp
 8013b8a:	461a      	mov	r2, r3
 8013b8c:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8013b90:	d25f      	bcs.n	8013c52 <__multiply+0x126>
 8013b92:	1b2b      	subs	r3, r5, r4
 8013b94:	3b15      	subs	r3, #21
 8013b96:	f023 0303 	bic.w	r3, r3, #3
 8013b9a:	3304      	adds	r3, #4
 8013b9c:	3415      	adds	r4, #21
 8013b9e:	42a5      	cmp	r5, r4
 8013ba0:	bf38      	it	cc
 8013ba2:	2304      	movcc	r3, #4
 8013ba4:	e9cd a702 	strd	sl, r7, [sp, #8]
 8013ba8:	46ac      	mov	ip, r5
 8013baa:	461f      	mov	r7, r3
 8013bac:	4692      	mov	sl, r2
 8013bae:	e005      	b.n	8013bbc <__multiply+0x90>
 8013bb0:	0c09      	lsrs	r1, r1, #16
 8013bb2:	d129      	bne.n	8013c08 <__multiply+0xdc>
 8013bb4:	45c3      	cmp	fp, r8
 8013bb6:	f109 0904 	add.w	r9, r9, #4
 8013bba:	d948      	bls.n	8013c4e <__multiply+0x122>
 8013bbc:	f858 1b04 	ldr.w	r1, [r8], #4
 8013bc0:	b28d      	uxth	r5, r1
 8013bc2:	2d00      	cmp	r5, #0
 8013bc4:	d0f4      	beq.n	8013bb0 <__multiply+0x84>
 8013bc6:	4656      	mov	r6, sl
 8013bc8:	464c      	mov	r4, r9
 8013bca:	2300      	movs	r3, #0
 8013bcc:	f856 1b04 	ldr.w	r1, [r6], #4
 8013bd0:	6822      	ldr	r2, [r4, #0]
 8013bd2:	fa1f fe81 	uxth.w	lr, r1
 8013bd6:	b290      	uxth	r0, r2
 8013bd8:	0c09      	lsrs	r1, r1, #16
 8013bda:	fb05 000e 	mla	r0, r5, lr, r0
 8013bde:	0c12      	lsrs	r2, r2, #16
 8013be0:	4403      	add	r3, r0
 8013be2:	fb05 2201 	mla	r2, r5, r1, r2
 8013be6:	eb02 4213 	add.w	r2, r2, r3, lsr #16
 8013bea:	b29b      	uxth	r3, r3
 8013bec:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8013bf0:	45b4      	cmp	ip, r6
 8013bf2:	f844 3b04 	str.w	r3, [r4], #4
 8013bf6:	ea4f 4312 	mov.w	r3, r2, lsr #16
 8013bfa:	d8e7      	bhi.n	8013bcc <__multiply+0xa0>
 8013bfc:	f849 3007 	str.w	r3, [r9, r7]
 8013c00:	f858 1c04 	ldr.w	r1, [r8, #-4]
 8013c04:	0c09      	lsrs	r1, r1, #16
 8013c06:	d0d5      	beq.n	8013bb4 <__multiply+0x88>
 8013c08:	f8d9 3000 	ldr.w	r3, [r9]
 8013c0c:	4650      	mov	r0, sl
 8013c0e:	461a      	mov	r2, r3
 8013c10:	464c      	mov	r4, r9
 8013c12:	2600      	movs	r6, #0
 8013c14:	8805      	ldrh	r5, [r0, #0]
 8013c16:	0c12      	lsrs	r2, r2, #16
 8013c18:	fb01 2205 	mla	r2, r1, r5, r2
 8013c1c:	4416      	add	r6, r2
 8013c1e:	b29b      	uxth	r3, r3
 8013c20:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8013c24:	f844 3b04 	str.w	r3, [r4], #4
 8013c28:	f850 5b04 	ldr.w	r5, [r0], #4
 8013c2c:	6822      	ldr	r2, [r4, #0]
 8013c2e:	0c2d      	lsrs	r5, r5, #16
 8013c30:	b293      	uxth	r3, r2
 8013c32:	fb01 3305 	mla	r3, r1, r5, r3
 8013c36:	eb03 4316 	add.w	r3, r3, r6, lsr #16
 8013c3a:	4584      	cmp	ip, r0
 8013c3c:	ea4f 4613 	mov.w	r6, r3, lsr #16
 8013c40:	d8e8      	bhi.n	8013c14 <__multiply+0xe8>
 8013c42:	45c3      	cmp	fp, r8
 8013c44:	f849 3007 	str.w	r3, [r9, r7]
 8013c48:	f109 0904 	add.w	r9, r9, #4
 8013c4c:	d8b6      	bhi.n	8013bbc <__multiply+0x90>
 8013c4e:	e9dd a702 	ldrd	sl, r7, [sp, #8]
 8013c52:	2f00      	cmp	r7, #0
 8013c54:	dc02      	bgt.n	8013c5c <__multiply+0x130>
 8013c56:	e005      	b.n	8013c64 <__multiply+0x138>
 8013c58:	3f01      	subs	r7, #1
 8013c5a:	d003      	beq.n	8013c64 <__multiply+0x138>
 8013c5c:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
 8013c60:	2b00      	cmp	r3, #0
 8013c62:	d0f9      	beq.n	8013c58 <__multiply+0x12c>
 8013c64:	9b01      	ldr	r3, [sp, #4]
 8013c66:	4618      	mov	r0, r3
 8013c68:	611f      	str	r7, [r3, #16]
 8013c6a:	b005      	add	sp, #20
 8013c6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013c70:	4b03      	ldr	r3, [pc, #12]	; (8013c80 <__multiply+0x154>)
 8013c72:	4804      	ldr	r0, [pc, #16]	; (8013c84 <__multiply+0x158>)
 8013c74:	9a01      	ldr	r2, [sp, #4]
 8013c76:	f44f 71b1 	mov.w	r1, #354	; 0x162
 8013c7a:	f000 fd49 	bl	8014710 <__assert_func>
 8013c7e:	bf00      	nop
 8013c80:	08015ac4 	.word	0x08015ac4
 8013c84:	08015b34 	.word	0x08015b34

08013c88 <__pow5mult>:
 8013c88:	f012 0303 	ands.w	r3, r2, #3
 8013c8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013c90:	4614      	mov	r4, r2
 8013c92:	4606      	mov	r6, r0
 8013c94:	d132      	bne.n	8013cfc <__pow5mult+0x74>
 8013c96:	460d      	mov	r5, r1
 8013c98:	10a4      	asrs	r4, r4, #2
 8013c9a:	d020      	beq.n	8013cde <__pow5mult+0x56>
 8013c9c:	f8d6 8040 	ldr.w	r8, [r6, #64]	; 0x40
 8013ca0:	f1b8 0f00 	cmp.w	r8, #0
 8013ca4:	d033      	beq.n	8013d0e <__pow5mult+0x86>
 8013ca6:	07e3      	lsls	r3, r4, #31
 8013ca8:	f04f 0700 	mov.w	r7, #0
 8013cac:	d407      	bmi.n	8013cbe <__pow5mult+0x36>
 8013cae:	1064      	asrs	r4, r4, #1
 8013cb0:	d015      	beq.n	8013cde <__pow5mult+0x56>
 8013cb2:	f8d8 0000 	ldr.w	r0, [r8]
 8013cb6:	b1a8      	cbz	r0, 8013ce4 <__pow5mult+0x5c>
 8013cb8:	4680      	mov	r8, r0
 8013cba:	07e3      	lsls	r3, r4, #31
 8013cbc:	d5f7      	bpl.n	8013cae <__pow5mult+0x26>
 8013cbe:	4642      	mov	r2, r8
 8013cc0:	4629      	mov	r1, r5
 8013cc2:	4630      	mov	r0, r6
 8013cc4:	f7ff ff32 	bl	8013b2c <__multiply>
 8013cc8:	b1b5      	cbz	r5, 8013cf8 <__pow5mult+0x70>
 8013cca:	6869      	ldr	r1, [r5, #4]
 8013ccc:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8013cce:	1064      	asrs	r4, r4, #1
 8013cd0:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 8013cd4:	602a      	str	r2, [r5, #0]
 8013cd6:	f843 5021 	str.w	r5, [r3, r1, lsl #2]
 8013cda:	4605      	mov	r5, r0
 8013cdc:	d1e9      	bne.n	8013cb2 <__pow5mult+0x2a>
 8013cde:	4628      	mov	r0, r5
 8013ce0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013ce4:	4642      	mov	r2, r8
 8013ce6:	4641      	mov	r1, r8
 8013ce8:	4630      	mov	r0, r6
 8013cea:	f7ff ff1f 	bl	8013b2c <__multiply>
 8013cee:	f8c8 0000 	str.w	r0, [r8]
 8013cf2:	6007      	str	r7, [r0, #0]
 8013cf4:	4680      	mov	r8, r0
 8013cf6:	e7e0      	b.n	8013cba <__pow5mult+0x32>
 8013cf8:	4605      	mov	r5, r0
 8013cfa:	e7d8      	b.n	8013cae <__pow5mult+0x26>
 8013cfc:	3b01      	subs	r3, #1
 8013cfe:	4a0f      	ldr	r2, [pc, #60]	; (8013d3c <__pow5mult+0xb4>)
 8013d00:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8013d04:	2300      	movs	r3, #0
 8013d06:	f7ff fe41 	bl	801398c <__multadd>
 8013d0a:	4605      	mov	r5, r0
 8013d0c:	e7c4      	b.n	8013c98 <__pow5mult+0x10>
 8013d0e:	2101      	movs	r1, #1
 8013d10:	4630      	mov	r0, r6
 8013d12:	f7ff fe0b 	bl	801392c <_Balloc>
 8013d16:	4680      	mov	r8, r0
 8013d18:	b140      	cbz	r0, 8013d2c <__pow5mult+0xa4>
 8013d1a:	2301      	movs	r3, #1
 8013d1c:	f240 2271 	movw	r2, #625	; 0x271
 8013d20:	e9c0 3204 	strd	r3, r2, [r0, #16]
 8013d24:	2300      	movs	r3, #0
 8013d26:	6430      	str	r0, [r6, #64]	; 0x40
 8013d28:	6003      	str	r3, [r0, #0]
 8013d2a:	e7bc      	b.n	8013ca6 <__pow5mult+0x1e>
 8013d2c:	4b04      	ldr	r3, [pc, #16]	; (8013d40 <__pow5mult+0xb8>)
 8013d2e:	4805      	ldr	r0, [pc, #20]	; (8013d44 <__pow5mult+0xbc>)
 8013d30:	4642      	mov	r2, r8
 8013d32:	f240 1145 	movw	r1, #325	; 0x145
 8013d36:	f000 fceb 	bl	8014710 <__assert_func>
 8013d3a:	bf00      	nop
 8013d3c:	08015c80 	.word	0x08015c80
 8013d40:	08015ac4 	.word	0x08015ac4
 8013d44:	08015b34 	.word	0x08015b34

08013d48 <__lshift>:
 8013d48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8013d4c:	460d      	mov	r5, r1
 8013d4e:	4614      	mov	r4, r2
 8013d50:	692f      	ldr	r7, [r5, #16]
 8013d52:	68ab      	ldr	r3, [r5, #8]
 8013d54:	6849      	ldr	r1, [r1, #4]
 8013d56:	eb07 1762 	add.w	r7, r7, r2, asr #5
 8013d5a:	1c7e      	adds	r6, r7, #1
 8013d5c:	429e      	cmp	r6, r3
 8013d5e:	4680      	mov	r8, r0
 8013d60:	ea4f 1962 	mov.w	r9, r2, asr #5
 8013d64:	dd04      	ble.n	8013d70 <__lshift+0x28>
 8013d66:	005b      	lsls	r3, r3, #1
 8013d68:	429e      	cmp	r6, r3
 8013d6a:	f101 0101 	add.w	r1, r1, #1
 8013d6e:	dcfa      	bgt.n	8013d66 <__lshift+0x1e>
 8013d70:	4640      	mov	r0, r8
 8013d72:	f7ff fddb 	bl	801392c <_Balloc>
 8013d76:	4684      	mov	ip, r0
 8013d78:	2800      	cmp	r0, #0
 8013d7a:	d052      	beq.n	8013e22 <__lshift+0xda>
 8013d7c:	f1b9 0f00 	cmp.w	r9, #0
 8013d80:	f100 0214 	add.w	r2, r0, #20
 8013d84:	dd0e      	ble.n	8013da4 <__lshift+0x5c>
 8013d86:	f109 0105 	add.w	r1, r9, #5
 8013d8a:	ea4f 0e81 	mov.w	lr, r1, lsl #2
 8013d8e:	4613      	mov	r3, r2
 8013d90:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8013d94:	2000      	movs	r0, #0
 8013d96:	f843 0b04 	str.w	r0, [r3], #4
 8013d9a:	428b      	cmp	r3, r1
 8013d9c:	d1fb      	bne.n	8013d96 <__lshift+0x4e>
 8013d9e:	f1ae 0314 	sub.w	r3, lr, #20
 8013da2:	441a      	add	r2, r3
 8013da4:	6929      	ldr	r1, [r5, #16]
 8013da6:	f105 0314 	add.w	r3, r5, #20
 8013daa:	f014 0e1f 	ands.w	lr, r4, #31
 8013dae:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8013db2:	d02e      	beq.n	8013e12 <__lshift+0xca>
 8013db4:	f1ce 0920 	rsb	r9, lr, #32
 8013db8:	4610      	mov	r0, r2
 8013dba:	f04f 0a00 	mov.w	sl, #0
 8013dbe:	681c      	ldr	r4, [r3, #0]
 8013dc0:	fa04 f40e 	lsl.w	r4, r4, lr
 8013dc4:	ea44 040a 	orr.w	r4, r4, sl
 8013dc8:	f840 4b04 	str.w	r4, [r0], #4
 8013dcc:	f853 4b04 	ldr.w	r4, [r3], #4
 8013dd0:	4299      	cmp	r1, r3
 8013dd2:	fa24 fa09 	lsr.w	sl, r4, r9
 8013dd6:	d8f2      	bhi.n	8013dbe <__lshift+0x76>
 8013dd8:	1b4b      	subs	r3, r1, r5
 8013dda:	3b15      	subs	r3, #21
 8013ddc:	f023 0303 	bic.w	r3, r3, #3
 8013de0:	3304      	adds	r3, #4
 8013de2:	f105 0015 	add.w	r0, r5, #21
 8013de6:	4281      	cmp	r1, r0
 8013de8:	bf38      	it	cc
 8013dea:	2304      	movcc	r3, #4
 8013dec:	f1ba 0f00 	cmp.w	sl, #0
 8013df0:	bf18      	it	ne
 8013df2:	4637      	movne	r7, r6
 8013df4:	f842 a003 	str.w	sl, [r2, r3]
 8013df8:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8013dfc:	686a      	ldr	r2, [r5, #4]
 8013dfe:	f8cc 7010 	str.w	r7, [ip, #16]
 8013e02:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013e06:	6029      	str	r1, [r5, #0]
 8013e08:	4660      	mov	r0, ip
 8013e0a:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 8013e0e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8013e12:	3a04      	subs	r2, #4
 8013e14:	f853 0b04 	ldr.w	r0, [r3], #4
 8013e18:	f842 0f04 	str.w	r0, [r2, #4]!
 8013e1c:	4299      	cmp	r1, r3
 8013e1e:	d8f9      	bhi.n	8013e14 <__lshift+0xcc>
 8013e20:	e7ea      	b.n	8013df8 <__lshift+0xb0>
 8013e22:	4b03      	ldr	r3, [pc, #12]	; (8013e30 <__lshift+0xe8>)
 8013e24:	4803      	ldr	r0, [pc, #12]	; (8013e34 <__lshift+0xec>)
 8013e26:	4662      	mov	r2, ip
 8013e28:	f44f 71ef 	mov.w	r1, #478	; 0x1de
 8013e2c:	f000 fc70 	bl	8014710 <__assert_func>
 8013e30:	08015ac4 	.word	0x08015ac4
 8013e34:	08015b34 	.word	0x08015b34

08013e38 <__mcmp>:
 8013e38:	690b      	ldr	r3, [r1, #16]
 8013e3a:	4684      	mov	ip, r0
 8013e3c:	6900      	ldr	r0, [r0, #16]
 8013e3e:	1ac0      	subs	r0, r0, r3
 8013e40:	d116      	bne.n	8013e70 <__mcmp+0x38>
 8013e42:	f10c 0c14 	add.w	ip, ip, #20
 8013e46:	3114      	adds	r1, #20
 8013e48:	eb0c 0283 	add.w	r2, ip, r3, lsl #2
 8013e4c:	b410      	push	{r4}
 8013e4e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8013e52:	e001      	b.n	8013e58 <__mcmp+0x20>
 8013e54:	4594      	cmp	ip, r2
 8013e56:	d208      	bcs.n	8013e6a <__mcmp+0x32>
 8013e58:	f852 4d04 	ldr.w	r4, [r2, #-4]!
 8013e5c:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8013e60:	428c      	cmp	r4, r1
 8013e62:	d0f7      	beq.n	8013e54 <__mcmp+0x1c>
 8013e64:	d205      	bcs.n	8013e72 <__mcmp+0x3a>
 8013e66:	f04f 30ff 	mov.w	r0, #4294967295
 8013e6a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8013e6e:	4770      	bx	lr
 8013e70:	4770      	bx	lr
 8013e72:	2001      	movs	r0, #1
 8013e74:	f85d 4b04 	ldr.w	r4, [sp], #4
 8013e78:	4770      	bx	lr
 8013e7a:	bf00      	nop

08013e7c <__mdiff>:
 8013e7c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013e80:	690f      	ldr	r7, [r1, #16]
 8013e82:	6913      	ldr	r3, [r2, #16]
 8013e84:	1aff      	subs	r7, r7, r3
 8013e86:	2f00      	cmp	r7, #0
 8013e88:	460e      	mov	r6, r1
 8013e8a:	4690      	mov	r8, r2
 8013e8c:	d17f      	bne.n	8013f8e <__mdiff+0x112>
 8013e8e:	f101 0514 	add.w	r5, r1, #20
 8013e92:	3214      	adds	r2, #20
 8013e94:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8013e98:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8013e9c:	e001      	b.n	8013ea2 <__mdiff+0x26>
 8013e9e:	429d      	cmp	r5, r3
 8013ea0:	d278      	bcs.n	8013f94 <__mdiff+0x118>
 8013ea2:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8013ea6:	f852 4d04 	ldr.w	r4, [r2, #-4]!
 8013eaa:	42a1      	cmp	r1, r4
 8013eac:	d0f7      	beq.n	8013e9e <__mdiff+0x22>
 8013eae:	d369      	bcc.n	8013f84 <__mdiff+0x108>
 8013eb0:	6871      	ldr	r1, [r6, #4]
 8013eb2:	f7ff fd3b 	bl	801392c <_Balloc>
 8013eb6:	4681      	mov	r9, r0
 8013eb8:	2800      	cmp	r0, #0
 8013eba:	d077      	beq.n	8013fac <__mdiff+0x130>
 8013ebc:	6935      	ldr	r5, [r6, #16]
 8013ebe:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8013ec2:	60c7      	str	r7, [r0, #12]
 8013ec4:	f108 0e14 	add.w	lr, r8, #20
 8013ec8:	f106 0014 	add.w	r0, r6, #20
 8013ecc:	f109 0a14 	add.w	sl, r9, #20
 8013ed0:	f106 0110 	add.w	r1, r6, #16
 8013ed4:	eb0e 0282 	add.w	r2, lr, r2, lsl #2
 8013ed8:	eb00 0785 	add.w	r7, r0, r5, lsl #2
 8013edc:	4656      	mov	r6, sl
 8013ede:	f04f 0c00 	mov.w	ip, #0
 8013ee2:	f85e 4b04 	ldr.w	r4, [lr], #4
 8013ee6:	f851 bf04 	ldr.w	fp, [r1, #4]!
 8013eea:	b2a3      	uxth	r3, r4
 8013eec:	fa1c fc8b 	uxtah	ip, ip, fp
 8013ef0:	ebac 0303 	sub.w	r3, ip, r3
 8013ef4:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8013ef8:	ebcc 4c1b 	rsb	ip, ip, fp, lsr #16
 8013efc:	eb0c 4c23 	add.w	ip, ip, r3, asr #16
 8013f00:	b29b      	uxth	r3, r3
 8013f02:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
 8013f06:	4572      	cmp	r2, lr
 8013f08:	f846 3b04 	str.w	r3, [r6], #4
 8013f0c:	ea4f 4c2c 	mov.w	ip, ip, asr #16
 8013f10:	d8e7      	bhi.n	8013ee2 <__mdiff+0x66>
 8013f12:	eba2 0108 	sub.w	r1, r2, r8
 8013f16:	3915      	subs	r1, #21
 8013f18:	f108 0815 	add.w	r8, r8, #21
 8013f1c:	4542      	cmp	r2, r8
 8013f1e:	f021 0403 	bic.w	r4, r1, #3
 8013f22:	f104 0404 	add.w	r4, r4, #4
 8013f26:	bf38      	it	cc
 8013f28:	2404      	movcc	r4, #4
 8013f2a:	4420      	add	r0, r4
 8013f2c:	f021 0203 	bic.w	r2, r1, #3
 8013f30:	bf38      	it	cc
 8013f32:	2200      	movcc	r2, #0
 8013f34:	4287      	cmp	r7, r0
 8013f36:	4452      	add	r2, sl
 8013f38:	4454      	add	r4, sl
 8013f3a:	d918      	bls.n	8013f6e <__mdiff+0xf2>
 8013f3c:	4626      	mov	r6, r4
 8013f3e:	4601      	mov	r1, r0
 8013f40:	f851 3b04 	ldr.w	r3, [r1], #4
 8013f44:	fa1c fc83 	uxtah	ip, ip, r3
 8013f48:	ea4f 422c 	mov.w	r2, ip, asr #16
 8013f4c:	eb02 4213 	add.w	r2, r2, r3, lsr #16
 8013f50:	fa1f fc8c 	uxth.w	ip, ip
 8013f54:	ea4c 4302 	orr.w	r3, ip, r2, lsl #16
 8013f58:	428f      	cmp	r7, r1
 8013f5a:	f846 3b04 	str.w	r3, [r6], #4
 8013f5e:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8013f62:	d8ed      	bhi.n	8013f40 <__mdiff+0xc4>
 8013f64:	3f01      	subs	r7, #1
 8013f66:	1a3f      	subs	r7, r7, r0
 8013f68:	f027 0703 	bic.w	r7, r7, #3
 8013f6c:	19e2      	adds	r2, r4, r7
 8013f6e:	b923      	cbnz	r3, 8013f7a <__mdiff+0xfe>
 8013f70:	f852 3d04 	ldr.w	r3, [r2, #-4]!
 8013f74:	3d01      	subs	r5, #1
 8013f76:	2b00      	cmp	r3, #0
 8013f78:	d0fa      	beq.n	8013f70 <__mdiff+0xf4>
 8013f7a:	f8c9 5010 	str.w	r5, [r9, #16]
 8013f7e:	4648      	mov	r0, r9
 8013f80:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013f84:	4633      	mov	r3, r6
 8013f86:	2701      	movs	r7, #1
 8013f88:	4646      	mov	r6, r8
 8013f8a:	4698      	mov	r8, r3
 8013f8c:	e790      	b.n	8013eb0 <__mdiff+0x34>
 8013f8e:	dbf9      	blt.n	8013f84 <__mdiff+0x108>
 8013f90:	2700      	movs	r7, #0
 8013f92:	e78d      	b.n	8013eb0 <__mdiff+0x34>
 8013f94:	2100      	movs	r1, #0
 8013f96:	f7ff fcc9 	bl	801392c <_Balloc>
 8013f9a:	4681      	mov	r9, r0
 8013f9c:	b168      	cbz	r0, 8013fba <__mdiff+0x13e>
 8013f9e:	2201      	movs	r2, #1
 8013fa0:	2300      	movs	r3, #0
 8013fa2:	e9c9 2304 	strd	r2, r3, [r9, #16]
 8013fa6:	4648      	mov	r0, r9
 8013fa8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013fac:	4b06      	ldr	r3, [pc, #24]	; (8013fc8 <__mdiff+0x14c>)
 8013fae:	4807      	ldr	r0, [pc, #28]	; (8013fcc <__mdiff+0x150>)
 8013fb0:	464a      	mov	r2, r9
 8013fb2:	f240 2145 	movw	r1, #581	; 0x245
 8013fb6:	f000 fbab 	bl	8014710 <__assert_func>
 8013fba:	4b03      	ldr	r3, [pc, #12]	; (8013fc8 <__mdiff+0x14c>)
 8013fbc:	4803      	ldr	r0, [pc, #12]	; (8013fcc <__mdiff+0x150>)
 8013fbe:	464a      	mov	r2, r9
 8013fc0:	f240 2137 	movw	r1, #567	; 0x237
 8013fc4:	f000 fba4 	bl	8014710 <__assert_func>
 8013fc8:	08015ac4 	.word	0x08015ac4
 8013fcc:	08015b34 	.word	0x08015b34

08013fd0 <__d2b>:
 8013fd0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8013fd4:	4688      	mov	r8, r1
 8013fd6:	b083      	sub	sp, #12
 8013fd8:	2101      	movs	r1, #1
 8013fda:	ec57 6b10 	vmov	r6, r7, d0
 8013fde:	4615      	mov	r5, r2
 8013fe0:	f7ff fca4 	bl	801392c <_Balloc>
 8013fe4:	4604      	mov	r4, r0
 8013fe6:	2800      	cmp	r0, #0
 8013fe8:	d051      	beq.n	801408e <__d2b+0xbe>
 8013fea:	f3c7 590a 	ubfx	r9, r7, #20, #11
 8013fee:	f3c7 0313 	ubfx	r3, r7, #0, #20
 8013ff2:	f1b9 0f00 	cmp.w	r9, #0
 8013ff6:	d001      	beq.n	8013ffc <__d2b+0x2c>
 8013ff8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8013ffc:	2e00      	cmp	r6, #0
 8013ffe:	9301      	str	r3, [sp, #4]
 8014000:	d118      	bne.n	8014034 <__d2b+0x64>
 8014002:	a801      	add	r0, sp, #4
 8014004:	f7ff fd34 	bl	8013a70 <__lo0bits>
 8014008:	9a01      	ldr	r2, [sp, #4]
 801400a:	6162      	str	r2, [r4, #20]
 801400c:	2201      	movs	r2, #1
 801400e:	f100 0320 	add.w	r3, r0, #32
 8014012:	6122      	str	r2, [r4, #16]
 8014014:	f1b9 0f00 	cmp.w	r9, #0
 8014018:	d025      	beq.n	8014066 <__d2b+0x96>
 801401a:	f2a9 4933 	subw	r9, r9, #1075	; 0x433
 801401e:	eb09 0203 	add.w	r2, r9, r3
 8014022:	4620      	mov	r0, r4
 8014024:	f1c3 0335 	rsb	r3, r3, #53	; 0x35
 8014028:	f8c8 2000 	str.w	r2, [r8]
 801402c:	602b      	str	r3, [r5, #0]
 801402e:	b003      	add	sp, #12
 8014030:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8014034:	4668      	mov	r0, sp
 8014036:	9600      	str	r6, [sp, #0]
 8014038:	f7ff fd1a 	bl	8013a70 <__lo0bits>
 801403c:	4603      	mov	r3, r0
 801403e:	b310      	cbz	r0, 8014086 <__d2b+0xb6>
 8014040:	e9dd 0200 	ldrd	r0, r2, [sp]
 8014044:	f1c3 0120 	rsb	r1, r3, #32
 8014048:	fa02 f101 	lsl.w	r1, r2, r1
 801404c:	4301      	orrs	r1, r0
 801404e:	40da      	lsrs	r2, r3
 8014050:	6161      	str	r1, [r4, #20]
 8014052:	9201      	str	r2, [sp, #4]
 8014054:	2a00      	cmp	r2, #0
 8014056:	61a2      	str	r2, [r4, #24]
 8014058:	bf14      	ite	ne
 801405a:	2202      	movne	r2, #2
 801405c:	2201      	moveq	r2, #1
 801405e:	6122      	str	r2, [r4, #16]
 8014060:	f1b9 0f00 	cmp.w	r9, #0
 8014064:	d1d9      	bne.n	801401a <__d2b+0x4a>
 8014066:	f2a3 4332 	subw	r3, r3, #1074	; 0x432
 801406a:	f8c8 3000 	str.w	r3, [r8]
 801406e:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8014072:	6918      	ldr	r0, [r3, #16]
 8014074:	f7ff fcdc 	bl	8013a30 <__hi0bits>
 8014078:	ebc0 1342 	rsb	r3, r0, r2, lsl #5
 801407c:	4620      	mov	r0, r4
 801407e:	602b      	str	r3, [r5, #0]
 8014080:	b003      	add	sp, #12
 8014082:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8014086:	9a00      	ldr	r2, [sp, #0]
 8014088:	6162      	str	r2, [r4, #20]
 801408a:	9a01      	ldr	r2, [sp, #4]
 801408c:	e7e2      	b.n	8014054 <__d2b+0x84>
 801408e:	4b03      	ldr	r3, [pc, #12]	; (801409c <__d2b+0xcc>)
 8014090:	4803      	ldr	r0, [pc, #12]	; (80140a0 <__d2b+0xd0>)
 8014092:	4622      	mov	r2, r4
 8014094:	f240 310f 	movw	r1, #783	; 0x30f
 8014098:	f000 fb3a 	bl	8014710 <__assert_func>
 801409c:	08015ac4 	.word	0x08015ac4
 80140a0:	08015b34 	.word	0x08015b34

080140a4 <_realloc_r>:
 80140a4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80140a8:	4617      	mov	r7, r2
 80140aa:	2900      	cmp	r1, #0
 80140ac:	f000 8098 	beq.w	80141e0 <_realloc_r+0x13c>
 80140b0:	460c      	mov	r4, r1
 80140b2:	f107 050b 	add.w	r5, r7, #11
 80140b6:	4680      	mov	r8, r0
 80140b8:	f7ff fc2c 	bl	8013914 <__malloc_lock>
 80140bc:	2d16      	cmp	r5, #22
 80140be:	f854 1c04 	ldr.w	r1, [r4, #-4]
 80140c2:	d85b      	bhi.n	801417c <_realloc_r+0xd8>
 80140c4:	2510      	movs	r5, #16
 80140c6:	462a      	mov	r2, r5
 80140c8:	42af      	cmp	r7, r5
 80140ca:	d85c      	bhi.n	8014186 <_realloc_r+0xe2>
 80140cc:	f021 0603 	bic.w	r6, r1, #3
 80140d0:	4296      	cmp	r6, r2
 80140d2:	f1a4 0908 	sub.w	r9, r4, #8
 80140d6:	da62      	bge.n	801419e <_realloc_r+0xfa>
 80140d8:	4bbc      	ldr	r3, [pc, #752]	; (80143cc <_realloc_r+0x328>)
 80140da:	f8d3 c008 	ldr.w	ip, [r3, #8]
 80140de:	eb09 0006 	add.w	r0, r9, r6
 80140e2:	4584      	cmp	ip, r0
 80140e4:	f000 8097 	beq.w	8014216 <_realloc_r+0x172>
 80140e8:	f8d0 c004 	ldr.w	ip, [r0, #4]
 80140ec:	f02c 0301 	bic.w	r3, ip, #1
 80140f0:	4403      	add	r3, r0
 80140f2:	685b      	ldr	r3, [r3, #4]
 80140f4:	07db      	lsls	r3, r3, #31
 80140f6:	d468      	bmi.n	80141ca <_realloc_r+0x126>
 80140f8:	f02c 0c03 	bic.w	ip, ip, #3
 80140fc:	eb06 030c 	add.w	r3, r6, ip
 8014100:	4293      	cmp	r3, r2
 8014102:	da47      	bge.n	8014194 <_realloc_r+0xf0>
 8014104:	07cb      	lsls	r3, r1, #31
 8014106:	d410      	bmi.n	801412a <_realloc_r+0x86>
 8014108:	f854 3c08 	ldr.w	r3, [r4, #-8]
 801410c:	eba9 0a03 	sub.w	sl, r9, r3
 8014110:	f8da 3004 	ldr.w	r3, [sl, #4]
 8014114:	f023 0103 	bic.w	r1, r3, #3
 8014118:	448c      	add	ip, r1
 801411a:	44b4      	add	ip, r6
 801411c:	4594      	cmp	ip, r2
 801411e:	f280 8111 	bge.w	8014344 <_realloc_r+0x2a0>
 8014122:	1873      	adds	r3, r6, r1
 8014124:	4293      	cmp	r3, r2
 8014126:	f280 80e8 	bge.w	80142fa <_realloc_r+0x256>
 801412a:	4639      	mov	r1, r7
 801412c:	4640      	mov	r0, r8
 801412e:	f7ff f92b 	bl	8013388 <_malloc_r>
 8014132:	4607      	mov	r7, r0
 8014134:	b1e0      	cbz	r0, 8014170 <_realloc_r+0xcc>
 8014136:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801413a:	f023 0301 	bic.w	r3, r3, #1
 801413e:	444b      	add	r3, r9
 8014140:	f1a0 0208 	sub.w	r2, r0, #8
 8014144:	4293      	cmp	r3, r2
 8014146:	f000 80d2 	beq.w	80142ee <_realloc_r+0x24a>
 801414a:	1f32      	subs	r2, r6, #4
 801414c:	2a24      	cmp	r2, #36	; 0x24
 801414e:	f200 80f5 	bhi.w	801433c <_realloc_r+0x298>
 8014152:	2a13      	cmp	r2, #19
 8014154:	f200 80ac 	bhi.w	80142b0 <_realloc_r+0x20c>
 8014158:	4603      	mov	r3, r0
 801415a:	4622      	mov	r2, r4
 801415c:	6811      	ldr	r1, [r2, #0]
 801415e:	6019      	str	r1, [r3, #0]
 8014160:	6851      	ldr	r1, [r2, #4]
 8014162:	6059      	str	r1, [r3, #4]
 8014164:	6892      	ldr	r2, [r2, #8]
 8014166:	609a      	str	r2, [r3, #8]
 8014168:	4621      	mov	r1, r4
 801416a:	4640      	mov	r0, r8
 801416c:	f7ff f806 	bl	801317c <_free_r>
 8014170:	4640      	mov	r0, r8
 8014172:	f7ff fbd5 	bl	8013920 <__malloc_unlock>
 8014176:	4638      	mov	r0, r7
 8014178:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801417c:	f025 0507 	bic.w	r5, r5, #7
 8014180:	2d00      	cmp	r5, #0
 8014182:	462a      	mov	r2, r5
 8014184:	daa0      	bge.n	80140c8 <_realloc_r+0x24>
 8014186:	230c      	movs	r3, #12
 8014188:	f8c8 3000 	str.w	r3, [r8]
 801418c:	2700      	movs	r7, #0
 801418e:	4638      	mov	r0, r7
 8014190:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014194:	461e      	mov	r6, r3
 8014196:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
 801419a:	60d3      	str	r3, [r2, #12]
 801419c:	609a      	str	r2, [r3, #8]
 801419e:	1b73      	subs	r3, r6, r5
 80141a0:	2b0f      	cmp	r3, #15
 80141a2:	d822      	bhi.n	80141ea <_realloc_r+0x146>
 80141a4:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80141a8:	f003 0301 	and.w	r3, r3, #1
 80141ac:	4333      	orrs	r3, r6
 80141ae:	444e      	add	r6, r9
 80141b0:	f8c9 3004 	str.w	r3, [r9, #4]
 80141b4:	6873      	ldr	r3, [r6, #4]
 80141b6:	f043 0301 	orr.w	r3, r3, #1
 80141ba:	6073      	str	r3, [r6, #4]
 80141bc:	4640      	mov	r0, r8
 80141be:	4627      	mov	r7, r4
 80141c0:	f7ff fbae 	bl	8013920 <__malloc_unlock>
 80141c4:	4638      	mov	r0, r7
 80141c6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80141ca:	07c9      	lsls	r1, r1, #31
 80141cc:	d4ad      	bmi.n	801412a <_realloc_r+0x86>
 80141ce:	f854 3c08 	ldr.w	r3, [r4, #-8]
 80141d2:	eba9 0a03 	sub.w	sl, r9, r3
 80141d6:	f8da 1004 	ldr.w	r1, [sl, #4]
 80141da:	f021 0103 	bic.w	r1, r1, #3
 80141de:	e7a0      	b.n	8014122 <_realloc_r+0x7e>
 80141e0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80141e4:	4611      	mov	r1, r2
 80141e6:	f7ff b8cf 	b.w	8013388 <_malloc_r>
 80141ea:	f8d9 2004 	ldr.w	r2, [r9, #4]
 80141ee:	eb09 0105 	add.w	r1, r9, r5
 80141f2:	f002 0201 	and.w	r2, r2, #1
 80141f6:	444e      	add	r6, r9
 80141f8:	f043 0301 	orr.w	r3, r3, #1
 80141fc:	432a      	orrs	r2, r5
 80141fe:	f8c9 2004 	str.w	r2, [r9, #4]
 8014202:	604b      	str	r3, [r1, #4]
 8014204:	6873      	ldr	r3, [r6, #4]
 8014206:	f043 0301 	orr.w	r3, r3, #1
 801420a:	3108      	adds	r1, #8
 801420c:	6073      	str	r3, [r6, #4]
 801420e:	4640      	mov	r0, r8
 8014210:	f7fe ffb4 	bl	801317c <_free_r>
 8014214:	e7d2      	b.n	80141bc <_realloc_r+0x118>
 8014216:	f8dc 0004 	ldr.w	r0, [ip, #4]
 801421a:	f020 0b03 	bic.w	fp, r0, #3
 801421e:	eb06 0c0b 	add.w	ip, r6, fp
 8014222:	f105 0010 	add.w	r0, r5, #16
 8014226:	4584      	cmp	ip, r0
 8014228:	da4d      	bge.n	80142c6 <_realloc_r+0x222>
 801422a:	07c9      	lsls	r1, r1, #31
 801422c:	f53f af7d 	bmi.w	801412a <_realloc_r+0x86>
 8014230:	f854 1c08 	ldr.w	r1, [r4, #-8]
 8014234:	eba9 0a01 	sub.w	sl, r9, r1
 8014238:	f8da 1004 	ldr.w	r1, [sl, #4]
 801423c:	f021 0103 	bic.w	r1, r1, #3
 8014240:	448b      	add	fp, r1
 8014242:	44b3      	add	fp, r6
 8014244:	4558      	cmp	r0, fp
 8014246:	f73f af6c 	bgt.w	8014122 <_realloc_r+0x7e>
 801424a:	4657      	mov	r7, sl
 801424c:	f8da 100c 	ldr.w	r1, [sl, #12]
 8014250:	f857 0f08 	ldr.w	r0, [r7, #8]!
 8014254:	1f32      	subs	r2, r6, #4
 8014256:	2a24      	cmp	r2, #36	; 0x24
 8014258:	60c1      	str	r1, [r0, #12]
 801425a:	6088      	str	r0, [r1, #8]
 801425c:	f200 80db 	bhi.w	8014416 <_realloc_r+0x372>
 8014260:	2a13      	cmp	r2, #19
 8014262:	f240 80d6 	bls.w	8014412 <_realloc_r+0x36e>
 8014266:	6821      	ldr	r1, [r4, #0]
 8014268:	f8ca 1008 	str.w	r1, [sl, #8]
 801426c:	6861      	ldr	r1, [r4, #4]
 801426e:	f8ca 100c 	str.w	r1, [sl, #12]
 8014272:	2a1b      	cmp	r2, #27
 8014274:	f200 80df 	bhi.w	8014436 <_realloc_r+0x392>
 8014278:	3408      	adds	r4, #8
 801427a:	f10a 0210 	add.w	r2, sl, #16
 801427e:	6821      	ldr	r1, [r4, #0]
 8014280:	6011      	str	r1, [r2, #0]
 8014282:	6861      	ldr	r1, [r4, #4]
 8014284:	6051      	str	r1, [r2, #4]
 8014286:	68a1      	ldr	r1, [r4, #8]
 8014288:	6091      	str	r1, [r2, #8]
 801428a:	eb0a 0105 	add.w	r1, sl, r5
 801428e:	ebab 0205 	sub.w	r2, fp, r5
 8014292:	f042 0201 	orr.w	r2, r2, #1
 8014296:	6099      	str	r1, [r3, #8]
 8014298:	604a      	str	r2, [r1, #4]
 801429a:	f8da 3004 	ldr.w	r3, [sl, #4]
 801429e:	f003 0301 	and.w	r3, r3, #1
 80142a2:	432b      	orrs	r3, r5
 80142a4:	4640      	mov	r0, r8
 80142a6:	f8ca 3004 	str.w	r3, [sl, #4]
 80142aa:	f7ff fb39 	bl	8013920 <__malloc_unlock>
 80142ae:	e76e      	b.n	801418e <_realloc_r+0xea>
 80142b0:	6823      	ldr	r3, [r4, #0]
 80142b2:	6003      	str	r3, [r0, #0]
 80142b4:	6863      	ldr	r3, [r4, #4]
 80142b6:	6043      	str	r3, [r0, #4]
 80142b8:	2a1b      	cmp	r2, #27
 80142ba:	d868      	bhi.n	801438e <_realloc_r+0x2ea>
 80142bc:	f104 0208 	add.w	r2, r4, #8
 80142c0:	f100 0308 	add.w	r3, r0, #8
 80142c4:	e74a      	b.n	801415c <_realloc_r+0xb8>
 80142c6:	eb09 0205 	add.w	r2, r9, r5
 80142ca:	609a      	str	r2, [r3, #8]
 80142cc:	ebac 0305 	sub.w	r3, ip, r5
 80142d0:	f043 0301 	orr.w	r3, r3, #1
 80142d4:	6053      	str	r3, [r2, #4]
 80142d6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80142da:	f003 0301 	and.w	r3, r3, #1
 80142de:	432b      	orrs	r3, r5
 80142e0:	4640      	mov	r0, r8
 80142e2:	f844 3c04 	str.w	r3, [r4, #-4]
 80142e6:	f7ff fb1b 	bl	8013920 <__malloc_unlock>
 80142ea:	4627      	mov	r7, r4
 80142ec:	e74f      	b.n	801418e <_realloc_r+0xea>
 80142ee:	f850 3c04 	ldr.w	r3, [r0, #-4]
 80142f2:	f023 0303 	bic.w	r3, r3, #3
 80142f6:	441e      	add	r6, r3
 80142f8:	e751      	b.n	801419e <_realloc_r+0xfa>
 80142fa:	4657      	mov	r7, sl
 80142fc:	f8da 100c 	ldr.w	r1, [sl, #12]
 8014300:	f857 0f08 	ldr.w	r0, [r7, #8]!
 8014304:	1f32      	subs	r2, r6, #4
 8014306:	2a24      	cmp	r2, #36	; 0x24
 8014308:	60c1      	str	r1, [r0, #12]
 801430a:	6088      	str	r0, [r1, #8]
 801430c:	d84c      	bhi.n	80143a8 <_realloc_r+0x304>
 801430e:	2a13      	cmp	r2, #19
 8014310:	d948      	bls.n	80143a4 <_realloc_r+0x300>
 8014312:	6821      	ldr	r1, [r4, #0]
 8014314:	f8ca 1008 	str.w	r1, [sl, #8]
 8014318:	6861      	ldr	r1, [r4, #4]
 801431a:	f8ca 100c 	str.w	r1, [sl, #12]
 801431e:	2a1b      	cmp	r2, #27
 8014320:	d856      	bhi.n	80143d0 <_realloc_r+0x32c>
 8014322:	3408      	adds	r4, #8
 8014324:	f10a 0210 	add.w	r2, sl, #16
 8014328:	461e      	mov	r6, r3
 801432a:	6823      	ldr	r3, [r4, #0]
 801432c:	6013      	str	r3, [r2, #0]
 801432e:	6863      	ldr	r3, [r4, #4]
 8014330:	6053      	str	r3, [r2, #4]
 8014332:	68a3      	ldr	r3, [r4, #8]
 8014334:	6093      	str	r3, [r2, #8]
 8014336:	46d1      	mov	r9, sl
 8014338:	463c      	mov	r4, r7
 801433a:	e730      	b.n	801419e <_realloc_r+0xfa>
 801433c:	4621      	mov	r1, r4
 801433e:	f7fd fea5 	bl	801208c <memmove>
 8014342:	e711      	b.n	8014168 <_realloc_r+0xc4>
 8014344:	e9d0 1302 	ldrd	r1, r3, [r0, #8]
 8014348:	4657      	mov	r7, sl
 801434a:	60cb      	str	r3, [r1, #12]
 801434c:	6099      	str	r1, [r3, #8]
 801434e:	f857 1f08 	ldr.w	r1, [r7, #8]!
 8014352:	f8da 300c 	ldr.w	r3, [sl, #12]
 8014356:	60cb      	str	r3, [r1, #12]
 8014358:	1f32      	subs	r2, r6, #4
 801435a:	2a24      	cmp	r2, #36	; 0x24
 801435c:	6099      	str	r1, [r3, #8]
 801435e:	d82d      	bhi.n	80143bc <_realloc_r+0x318>
 8014360:	2a13      	cmp	r2, #19
 8014362:	d929      	bls.n	80143b8 <_realloc_r+0x314>
 8014364:	6823      	ldr	r3, [r4, #0]
 8014366:	f8ca 3008 	str.w	r3, [sl, #8]
 801436a:	6863      	ldr	r3, [r4, #4]
 801436c:	f8ca 300c 	str.w	r3, [sl, #12]
 8014370:	2a1b      	cmp	r2, #27
 8014372:	d842      	bhi.n	80143fa <_realloc_r+0x356>
 8014374:	3408      	adds	r4, #8
 8014376:	f10a 0310 	add.w	r3, sl, #16
 801437a:	6822      	ldr	r2, [r4, #0]
 801437c:	601a      	str	r2, [r3, #0]
 801437e:	6862      	ldr	r2, [r4, #4]
 8014380:	605a      	str	r2, [r3, #4]
 8014382:	68a2      	ldr	r2, [r4, #8]
 8014384:	609a      	str	r2, [r3, #8]
 8014386:	4666      	mov	r6, ip
 8014388:	46d1      	mov	r9, sl
 801438a:	463c      	mov	r4, r7
 801438c:	e707      	b.n	801419e <_realloc_r+0xfa>
 801438e:	68a3      	ldr	r3, [r4, #8]
 8014390:	6083      	str	r3, [r0, #8]
 8014392:	68e3      	ldr	r3, [r4, #12]
 8014394:	60c3      	str	r3, [r0, #12]
 8014396:	2a24      	cmp	r2, #36	; 0x24
 8014398:	d026      	beq.n	80143e8 <_realloc_r+0x344>
 801439a:	f104 0210 	add.w	r2, r4, #16
 801439e:	f100 0310 	add.w	r3, r0, #16
 80143a2:	e6db      	b.n	801415c <_realloc_r+0xb8>
 80143a4:	463a      	mov	r2, r7
 80143a6:	e7bf      	b.n	8014328 <_realloc_r+0x284>
 80143a8:	4621      	mov	r1, r4
 80143aa:	4638      	mov	r0, r7
 80143ac:	461e      	mov	r6, r3
 80143ae:	46d1      	mov	r9, sl
 80143b0:	f7fd fe6c 	bl	801208c <memmove>
 80143b4:	463c      	mov	r4, r7
 80143b6:	e6f2      	b.n	801419e <_realloc_r+0xfa>
 80143b8:	463b      	mov	r3, r7
 80143ba:	e7de      	b.n	801437a <_realloc_r+0x2d6>
 80143bc:	4621      	mov	r1, r4
 80143be:	4638      	mov	r0, r7
 80143c0:	4666      	mov	r6, ip
 80143c2:	46d1      	mov	r9, sl
 80143c4:	f7fd fe62 	bl	801208c <memmove>
 80143c8:	463c      	mov	r4, r7
 80143ca:	e6e8      	b.n	801419e <_realloc_r+0xfa>
 80143cc:	240002dc 	.word	0x240002dc
 80143d0:	68a1      	ldr	r1, [r4, #8]
 80143d2:	f8ca 1010 	str.w	r1, [sl, #16]
 80143d6:	68e1      	ldr	r1, [r4, #12]
 80143d8:	f8ca 1014 	str.w	r1, [sl, #20]
 80143dc:	2a24      	cmp	r2, #36	; 0x24
 80143de:	d020      	beq.n	8014422 <_realloc_r+0x37e>
 80143e0:	3410      	adds	r4, #16
 80143e2:	f10a 0218 	add.w	r2, sl, #24
 80143e6:	e79f      	b.n	8014328 <_realloc_r+0x284>
 80143e8:	6923      	ldr	r3, [r4, #16]
 80143ea:	6103      	str	r3, [r0, #16]
 80143ec:	6961      	ldr	r1, [r4, #20]
 80143ee:	6141      	str	r1, [r0, #20]
 80143f0:	f104 0218 	add.w	r2, r4, #24
 80143f4:	f100 0318 	add.w	r3, r0, #24
 80143f8:	e6b0      	b.n	801415c <_realloc_r+0xb8>
 80143fa:	68a3      	ldr	r3, [r4, #8]
 80143fc:	f8ca 3010 	str.w	r3, [sl, #16]
 8014400:	68e3      	ldr	r3, [r4, #12]
 8014402:	f8ca 3014 	str.w	r3, [sl, #20]
 8014406:	2a24      	cmp	r2, #36	; 0x24
 8014408:	d021      	beq.n	801444e <_realloc_r+0x3aa>
 801440a:	3410      	adds	r4, #16
 801440c:	f10a 0318 	add.w	r3, sl, #24
 8014410:	e7b3      	b.n	801437a <_realloc_r+0x2d6>
 8014412:	463a      	mov	r2, r7
 8014414:	e733      	b.n	801427e <_realloc_r+0x1da>
 8014416:	4621      	mov	r1, r4
 8014418:	4638      	mov	r0, r7
 801441a:	f7fd fe37 	bl	801208c <memmove>
 801441e:	4b16      	ldr	r3, [pc, #88]	; (8014478 <_realloc_r+0x3d4>)
 8014420:	e733      	b.n	801428a <_realloc_r+0x1e6>
 8014422:	6922      	ldr	r2, [r4, #16]
 8014424:	f8ca 2018 	str.w	r2, [sl, #24]
 8014428:	6962      	ldr	r2, [r4, #20]
 801442a:	f8ca 201c 	str.w	r2, [sl, #28]
 801442e:	3418      	adds	r4, #24
 8014430:	f10a 0220 	add.w	r2, sl, #32
 8014434:	e778      	b.n	8014328 <_realloc_r+0x284>
 8014436:	68a1      	ldr	r1, [r4, #8]
 8014438:	f8ca 1010 	str.w	r1, [sl, #16]
 801443c:	68e1      	ldr	r1, [r4, #12]
 801443e:	f8ca 1014 	str.w	r1, [sl, #20]
 8014442:	2a24      	cmp	r2, #36	; 0x24
 8014444:	d00d      	beq.n	8014462 <_realloc_r+0x3be>
 8014446:	3410      	adds	r4, #16
 8014448:	f10a 0218 	add.w	r2, sl, #24
 801444c:	e717      	b.n	801427e <_realloc_r+0x1da>
 801444e:	6923      	ldr	r3, [r4, #16]
 8014450:	f8ca 3018 	str.w	r3, [sl, #24]
 8014454:	6963      	ldr	r3, [r4, #20]
 8014456:	f8ca 301c 	str.w	r3, [sl, #28]
 801445a:	3418      	adds	r4, #24
 801445c:	f10a 0320 	add.w	r3, sl, #32
 8014460:	e78b      	b.n	801437a <_realloc_r+0x2d6>
 8014462:	6922      	ldr	r2, [r4, #16]
 8014464:	f8ca 2018 	str.w	r2, [sl, #24]
 8014468:	6962      	ldr	r2, [r4, #20]
 801446a:	f8ca 201c 	str.w	r2, [sl, #28]
 801446e:	3418      	adds	r4, #24
 8014470:	f10a 0220 	add.w	r2, sl, #32
 8014474:	e703      	b.n	801427e <_realloc_r+0x1da>
 8014476:	bf00      	nop
 8014478:	240002dc 	.word	0x240002dc

0801447c <__ascii_wctomb>:
 801447c:	b149      	cbz	r1, 8014492 <__ascii_wctomb+0x16>
 801447e:	2aff      	cmp	r2, #255	; 0xff
 8014480:	d802      	bhi.n	8014488 <__ascii_wctomb+0xc>
 8014482:	700a      	strb	r2, [r1, #0]
 8014484:	2001      	movs	r0, #1
 8014486:	4770      	bx	lr
 8014488:	238a      	movs	r3, #138	; 0x8a
 801448a:	6003      	str	r3, [r0, #0]
 801448c:	f04f 30ff 	mov.w	r0, #4294967295
 8014490:	4770      	bx	lr
 8014492:	4608      	mov	r0, r1
 8014494:	4770      	bx	lr
 8014496:	bf00      	nop

08014498 <_wcrtomb_r>:
 8014498:	b570      	push	{r4, r5, r6, lr}
 801449a:	4605      	mov	r5, r0
 801449c:	b084      	sub	sp, #16
 801449e:	b15b      	cbz	r3, 80144b8 <_wcrtomb_r+0x20>
 80144a0:	461c      	mov	r4, r3
 80144a2:	b169      	cbz	r1, 80144c0 <_wcrtomb_r+0x28>
 80144a4:	4b0e      	ldr	r3, [pc, #56]	; (80144e0 <_wcrtomb_r+0x48>)
 80144a6:	4628      	mov	r0, r5
 80144a8:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
 80144ac:	4623      	mov	r3, r4
 80144ae:	47b0      	blx	r6
 80144b0:	1c43      	adds	r3, r0, #1
 80144b2:	d00f      	beq.n	80144d4 <_wcrtomb_r+0x3c>
 80144b4:	b004      	add	sp, #16
 80144b6:	bd70      	pop	{r4, r5, r6, pc}
 80144b8:	f500 7482 	add.w	r4, r0, #260	; 0x104
 80144bc:	2900      	cmp	r1, #0
 80144be:	d1f1      	bne.n	80144a4 <_wcrtomb_r+0xc>
 80144c0:	4a07      	ldr	r2, [pc, #28]	; (80144e0 <_wcrtomb_r+0x48>)
 80144c2:	4623      	mov	r3, r4
 80144c4:	f8d2 60e0 	ldr.w	r6, [r2, #224]	; 0xe0
 80144c8:	4628      	mov	r0, r5
 80144ca:	460a      	mov	r2, r1
 80144cc:	a901      	add	r1, sp, #4
 80144ce:	47b0      	blx	r6
 80144d0:	1c43      	adds	r3, r0, #1
 80144d2:	d1ef      	bne.n	80144b4 <_wcrtomb_r+0x1c>
 80144d4:	2200      	movs	r2, #0
 80144d6:	238a      	movs	r3, #138	; 0x8a
 80144d8:	6022      	str	r2, [r4, #0]
 80144da:	602b      	str	r3, [r5, #0]
 80144dc:	b004      	add	sp, #16
 80144de:	bd70      	pop	{r4, r5, r6, pc}
 80144e0:	24000170 	.word	0x24000170

080144e4 <_wcsrtombs_r>:
 80144e4:	b510      	push	{r4, lr}
 80144e6:	b082      	sub	sp, #8
 80144e8:	9c04      	ldr	r4, [sp, #16]
 80144ea:	e9cd 3400 	strd	r3, r4, [sp]
 80144ee:	f04f 33ff 	mov.w	r3, #4294967295
 80144f2:	f000 f9ed 	bl	80148d0 <_wcsnrtombs_r>
 80144f6:	b002      	add	sp, #8
 80144f8:	bd10      	pop	{r4, pc}
 80144fa:	bf00      	nop

080144fc <_fclose_r>:
 80144fc:	b570      	push	{r4, r5, r6, lr}
 80144fe:	2900      	cmp	r1, #0
 8014500:	d04b      	beq.n	801459a <_fclose_r+0x9e>
 8014502:	4606      	mov	r6, r0
 8014504:	460c      	mov	r4, r1
 8014506:	b110      	cbz	r0, 801450e <_fclose_r+0x12>
 8014508:	6b43      	ldr	r3, [r0, #52]	; 0x34
 801450a:	2b00      	cmp	r3, #0
 801450c:	d048      	beq.n	80145a0 <_fclose_r+0xa4>
 801450e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8014510:	07d8      	lsls	r0, r3, #31
 8014512:	d534      	bpl.n	801457e <_fclose_r+0x82>
 8014514:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014518:	2b00      	cmp	r3, #0
 801451a:	d03e      	beq.n	801459a <_fclose_r+0x9e>
 801451c:	4621      	mov	r1, r4
 801451e:	4630      	mov	r0, r6
 8014520:	f7fd f8ca 	bl	80116b8 <__sflush_r>
 8014524:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8014526:	4605      	mov	r5, r0
 8014528:	b133      	cbz	r3, 8014538 <_fclose_r+0x3c>
 801452a:	69e1      	ldr	r1, [r4, #28]
 801452c:	4630      	mov	r0, r6
 801452e:	4798      	blx	r3
 8014530:	2800      	cmp	r0, #0
 8014532:	bfb8      	it	lt
 8014534:	f04f 35ff 	movlt.w	r5, #4294967295
 8014538:	89a3      	ldrh	r3, [r4, #12]
 801453a:	061a      	lsls	r2, r3, #24
 801453c:	d43c      	bmi.n	80145b8 <_fclose_r+0xbc>
 801453e:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8014540:	b141      	cbz	r1, 8014554 <_fclose_r+0x58>
 8014542:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8014546:	4299      	cmp	r1, r3
 8014548:	d002      	beq.n	8014550 <_fclose_r+0x54>
 801454a:	4630      	mov	r0, r6
 801454c:	f7fe fe16 	bl	801317c <_free_r>
 8014550:	2300      	movs	r3, #0
 8014552:	6323      	str	r3, [r4, #48]	; 0x30
 8014554:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8014556:	b121      	cbz	r1, 8014562 <_fclose_r+0x66>
 8014558:	4630      	mov	r0, r6
 801455a:	f7fe fe0f 	bl	801317c <_free_r>
 801455e:	2300      	movs	r3, #0
 8014560:	6463      	str	r3, [r4, #68]	; 0x44
 8014562:	f7fd fa1f 	bl	80119a4 <__sfp_lock_acquire>
 8014566:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8014568:	2200      	movs	r2, #0
 801456a:	07db      	lsls	r3, r3, #31
 801456c:	81a2      	strh	r2, [r4, #12]
 801456e:	d51f      	bpl.n	80145b0 <_fclose_r+0xb4>
 8014570:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8014572:	f7fd fe67 	bl	8012244 <__retarget_lock_close_recursive>
 8014576:	f7fd fa1b 	bl	80119b0 <__sfp_lock_release>
 801457a:	4628      	mov	r0, r5
 801457c:	bd70      	pop	{r4, r5, r6, pc}
 801457e:	89a3      	ldrh	r3, [r4, #12]
 8014580:	0599      	lsls	r1, r3, #22
 8014582:	d4cb      	bmi.n	801451c <_fclose_r+0x20>
 8014584:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8014586:	f7fd fe5f 	bl	8012248 <__retarget_lock_acquire_recursive>
 801458a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801458e:	2b00      	cmp	r3, #0
 8014590:	d1c4      	bne.n	801451c <_fclose_r+0x20>
 8014592:	6e65      	ldr	r5, [r4, #100]	; 0x64
 8014594:	f015 0501 	ands.w	r5, r5, #1
 8014598:	d005      	beq.n	80145a6 <_fclose_r+0xaa>
 801459a:	2500      	movs	r5, #0
 801459c:	4628      	mov	r0, r5
 801459e:	bd70      	pop	{r4, r5, r6, pc}
 80145a0:	f7fd f9e2 	bl	8011968 <__sinit>
 80145a4:	e7b3      	b.n	801450e <_fclose_r+0x12>
 80145a6:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80145a8:	f7fd fe50 	bl	801224c <__retarget_lock_release_recursive>
 80145ac:	4628      	mov	r0, r5
 80145ae:	bd70      	pop	{r4, r5, r6, pc}
 80145b0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80145b2:	f7fd fe4b 	bl	801224c <__retarget_lock_release_recursive>
 80145b6:	e7db      	b.n	8014570 <_fclose_r+0x74>
 80145b8:	6921      	ldr	r1, [r4, #16]
 80145ba:	4630      	mov	r0, r6
 80145bc:	f7fe fdde 	bl	801317c <_free_r>
 80145c0:	e7bd      	b.n	801453e <_fclose_r+0x42>
 80145c2:	bf00      	nop

080145c4 <__smakebuf_r>:
 80145c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80145c8:	898b      	ldrh	r3, [r1, #12]
 80145ca:	460c      	mov	r4, r1
 80145cc:	0799      	lsls	r1, r3, #30
 80145ce:	b096      	sub	sp, #88	; 0x58
 80145d0:	d508      	bpl.n	80145e4 <__smakebuf_r+0x20>
 80145d2:	f104 0343 	add.w	r3, r4, #67	; 0x43
 80145d6:	2201      	movs	r2, #1
 80145d8:	e9c4 3204 	strd	r3, r2, [r4, #16]
 80145dc:	6023      	str	r3, [r4, #0]
 80145de:	b016      	add	sp, #88	; 0x58
 80145e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80145e4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80145e8:	2900      	cmp	r1, #0
 80145ea:	4606      	mov	r6, r0
 80145ec:	db25      	blt.n	801463a <__smakebuf_r+0x76>
 80145ee:	466a      	mov	r2, sp
 80145f0:	f000 f854 	bl	801469c <_fstat_r>
 80145f4:	2800      	cmp	r0, #0
 80145f6:	db1f      	blt.n	8014638 <__smakebuf_r+0x74>
 80145f8:	9d01      	ldr	r5, [sp, #4]
 80145fa:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
 80145fe:	f5a5 5500 	sub.w	r5, r5, #8192	; 0x2000
 8014602:	fab5 f585 	clz	r5, r5
 8014606:	f44f 6880 	mov.w	r8, #1024	; 0x400
 801460a:	096d      	lsrs	r5, r5, #5
 801460c:	f44f 6700 	mov.w	r7, #2048	; 0x800
 8014610:	4641      	mov	r1, r8
 8014612:	4630      	mov	r0, r6
 8014614:	f7fe feb8 	bl	8013388 <_malloc_r>
 8014618:	b1e0      	cbz	r0, 8014654 <__smakebuf_r+0x90>
 801461a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801461e:	f8c4 8014 	str.w	r8, [r4, #20]
 8014622:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8014626:	6020      	str	r0, [r4, #0]
 8014628:	6120      	str	r0, [r4, #16]
 801462a:	81a3      	strh	r3, [r4, #12]
 801462c:	bb35      	cbnz	r5, 801467c <__smakebuf_r+0xb8>
 801462e:	433b      	orrs	r3, r7
 8014630:	81a3      	strh	r3, [r4, #12]
 8014632:	b016      	add	sp, #88	; 0x58
 8014634:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014638:	89a3      	ldrh	r3, [r4, #12]
 801463a:	f013 0580 	ands.w	r5, r3, #128	; 0x80
 801463e:	d019      	beq.n	8014674 <__smakebuf_r+0xb0>
 8014640:	f04f 0840 	mov.w	r8, #64	; 0x40
 8014644:	2500      	movs	r5, #0
 8014646:	4641      	mov	r1, r8
 8014648:	4630      	mov	r0, r6
 801464a:	462f      	mov	r7, r5
 801464c:	f7fe fe9c 	bl	8013388 <_malloc_r>
 8014650:	2800      	cmp	r0, #0
 8014652:	d1e2      	bne.n	801461a <__smakebuf_r+0x56>
 8014654:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014658:	059a      	lsls	r2, r3, #22
 801465a:	d4c0      	bmi.n	80145de <__smakebuf_r+0x1a>
 801465c:	f023 0303 	bic.w	r3, r3, #3
 8014660:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8014664:	f043 0302 	orr.w	r3, r3, #2
 8014668:	2101      	movs	r1, #1
 801466a:	e9c4 2104 	strd	r2, r1, [r4, #16]
 801466e:	81a3      	strh	r3, [r4, #12]
 8014670:	6022      	str	r2, [r4, #0]
 8014672:	e7b4      	b.n	80145de <__smakebuf_r+0x1a>
 8014674:	f44f 6880 	mov.w	r8, #1024	; 0x400
 8014678:	462f      	mov	r7, r5
 801467a:	e7c9      	b.n	8014610 <__smakebuf_r+0x4c>
 801467c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8014680:	4630      	mov	r0, r6
 8014682:	f000 f821 	bl	80146c8 <_isatty_r>
 8014686:	b910      	cbnz	r0, 801468e <__smakebuf_r+0xca>
 8014688:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801468c:	e7cf      	b.n	801462e <__smakebuf_r+0x6a>
 801468e:	89a3      	ldrh	r3, [r4, #12]
 8014690:	f023 0303 	bic.w	r3, r3, #3
 8014694:	f043 0301 	orr.w	r3, r3, #1
 8014698:	b21b      	sxth	r3, r3
 801469a:	e7c8      	b.n	801462e <__smakebuf_r+0x6a>

0801469c <_fstat_r>:
 801469c:	b570      	push	{r4, r5, r6, lr}
 801469e:	460c      	mov	r4, r1
 80146a0:	4d08      	ldr	r5, [pc, #32]	; (80146c4 <_fstat_r+0x28>)
 80146a2:	4603      	mov	r3, r0
 80146a4:	2600      	movs	r6, #0
 80146a6:	4620      	mov	r0, r4
 80146a8:	4611      	mov	r1, r2
 80146aa:	461c      	mov	r4, r3
 80146ac:	602e      	str	r6, [r5, #0]
 80146ae:	f7f2 fb67 	bl	8006d80 <_fstat>
 80146b2:	1c43      	adds	r3, r0, #1
 80146b4:	d000      	beq.n	80146b8 <_fstat_r+0x1c>
 80146b6:	bd70      	pop	{r4, r5, r6, pc}
 80146b8:	682b      	ldr	r3, [r5, #0]
 80146ba:	2b00      	cmp	r3, #0
 80146bc:	d0fb      	beq.n	80146b6 <_fstat_r+0x1a>
 80146be:	6023      	str	r3, [r4, #0]
 80146c0:	bd70      	pop	{r4, r5, r6, pc}
 80146c2:	bf00      	nop
 80146c4:	24006180 	.word	0x24006180

080146c8 <_isatty_r>:
 80146c8:	b538      	push	{r3, r4, r5, lr}
 80146ca:	4d07      	ldr	r5, [pc, #28]	; (80146e8 <_isatty_r+0x20>)
 80146cc:	2200      	movs	r2, #0
 80146ce:	4604      	mov	r4, r0
 80146d0:	4608      	mov	r0, r1
 80146d2:	602a      	str	r2, [r5, #0]
 80146d4:	f7f2 fb5a 	bl	8006d8c <_isatty>
 80146d8:	1c43      	adds	r3, r0, #1
 80146da:	d000      	beq.n	80146de <_isatty_r+0x16>
 80146dc:	bd38      	pop	{r3, r4, r5, pc}
 80146de:	682b      	ldr	r3, [r5, #0]
 80146e0:	2b00      	cmp	r3, #0
 80146e2:	d0fb      	beq.n	80146dc <_isatty_r+0x14>
 80146e4:	6023      	str	r3, [r4, #0]
 80146e6:	bd38      	pop	{r3, r4, r5, pc}
 80146e8:	24006180 	.word	0x24006180

080146ec <_sbrk_r>:
 80146ec:	b538      	push	{r3, r4, r5, lr}
 80146ee:	4d07      	ldr	r5, [pc, #28]	; (801470c <_sbrk_r+0x20>)
 80146f0:	2200      	movs	r2, #0
 80146f2:	4604      	mov	r4, r0
 80146f4:	4608      	mov	r0, r1
 80146f6:	602a      	str	r2, [r5, #0]
 80146f8:	f7f2 fb58 	bl	8006dac <_sbrk>
 80146fc:	1c43      	adds	r3, r0, #1
 80146fe:	d000      	beq.n	8014702 <_sbrk_r+0x16>
 8014700:	bd38      	pop	{r3, r4, r5, pc}
 8014702:	682b      	ldr	r3, [r5, #0]
 8014704:	2b00      	cmp	r3, #0
 8014706:	d0fb      	beq.n	8014700 <_sbrk_r+0x14>
 8014708:	6023      	str	r3, [r4, #0]
 801470a:	bd38      	pop	{r3, r4, r5, pc}
 801470c:	24006180 	.word	0x24006180

08014710 <__assert_func>:
 8014710:	b500      	push	{lr}
 8014712:	4c0b      	ldr	r4, [pc, #44]	; (8014740 <__assert_func+0x30>)
 8014714:	6825      	ldr	r5, [r4, #0]
 8014716:	4614      	mov	r4, r2
 8014718:	68ee      	ldr	r6, [r5, #12]
 801471a:	461a      	mov	r2, r3
 801471c:	b085      	sub	sp, #20
 801471e:	4603      	mov	r3, r0
 8014720:	460d      	mov	r5, r1
 8014722:	b14c      	cbz	r4, 8014738 <__assert_func+0x28>
 8014724:	4907      	ldr	r1, [pc, #28]	; (8014744 <__assert_func+0x34>)
 8014726:	9500      	str	r5, [sp, #0]
 8014728:	e9cd 1401 	strd	r1, r4, [sp, #4]
 801472c:	4630      	mov	r0, r6
 801472e:	4906      	ldr	r1, [pc, #24]	; (8014748 <__assert_func+0x38>)
 8014730:	f000 f8e0 	bl	80148f4 <fiprintf>
 8014734:	f000 f8f2 	bl	801491c <abort>
 8014738:	4904      	ldr	r1, [pc, #16]	; (801474c <__assert_func+0x3c>)
 801473a:	460c      	mov	r4, r1
 801473c:	e7f3      	b.n	8014726 <__assert_func+0x16>
 801473e:	bf00      	nop
 8014740:	24000160 	.word	0x24000160
 8014744:	08015d90 	.word	0x08015d90
 8014748:	08015da0 	.word	0x08015da0
 801474c:	08015378 	.word	0x08015378

08014750 <_calloc_r>:
 8014750:	b538      	push	{r3, r4, r5, lr}
 8014752:	fba1 1402 	umull	r1, r4, r1, r2
 8014756:	bb8c      	cbnz	r4, 80147bc <_calloc_r+0x6c>
 8014758:	f7fe fe16 	bl	8013388 <_malloc_r>
 801475c:	4605      	mov	r5, r0
 801475e:	b1e0      	cbz	r0, 801479a <_calloc_r+0x4a>
 8014760:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8014764:	f022 0203 	bic.w	r2, r2, #3
 8014768:	3a04      	subs	r2, #4
 801476a:	2a24      	cmp	r2, #36	; 0x24
 801476c:	d817      	bhi.n	801479e <_calloc_r+0x4e>
 801476e:	2a13      	cmp	r2, #19
 8014770:	d91a      	bls.n	80147a8 <_calloc_r+0x58>
 8014772:	2a1b      	cmp	r2, #27
 8014774:	e9c0 4400 	strd	r4, r4, [r0]
 8014778:	d91d      	bls.n	80147b6 <_calloc_r+0x66>
 801477a:	2a24      	cmp	r2, #36	; 0x24
 801477c:	bf14      	ite	ne
 801477e:	f100 0210 	addne.w	r2, r0, #16
 8014782:	f100 0218 	addeq.w	r2, r0, #24
 8014786:	f04f 0300 	mov.w	r3, #0
 801478a:	e9c0 4402 	strd	r4, r4, [r0, #8]
 801478e:	bf04      	itt	eq
 8014790:	6104      	streq	r4, [r0, #16]
 8014792:	6144      	streq	r4, [r0, #20]
 8014794:	e9c2 3300 	strd	r3, r3, [r2]
 8014798:	6093      	str	r3, [r2, #8]
 801479a:	4628      	mov	r0, r5
 801479c:	bd38      	pop	{r3, r4, r5, pc}
 801479e:	4621      	mov	r1, r4
 80147a0:	f7fa f820 	bl	800e7e4 <memset>
 80147a4:	4628      	mov	r0, r5
 80147a6:	bd38      	pop	{r3, r4, r5, pc}
 80147a8:	4602      	mov	r2, r0
 80147aa:	2300      	movs	r3, #0
 80147ac:	e9c2 3300 	strd	r3, r3, [r2]
 80147b0:	6093      	str	r3, [r2, #8]
 80147b2:	4628      	mov	r0, r5
 80147b4:	bd38      	pop	{r3, r4, r5, pc}
 80147b6:	f100 0208 	add.w	r2, r0, #8
 80147ba:	e7f6      	b.n	80147aa <_calloc_r+0x5a>
 80147bc:	f7fa f8fc 	bl	800e9b8 <__errno>
 80147c0:	230c      	movs	r3, #12
 80147c2:	2500      	movs	r5, #0
 80147c4:	6003      	str	r3, [r0, #0]
 80147c6:	e7e8      	b.n	801479a <_calloc_r+0x4a>

080147c8 <_wcsnrtombs_l>:
 80147c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80147cc:	b08b      	sub	sp, #44	; 0x2c
 80147ce:	e9dd 8a15 	ldrd	r8, sl, [sp, #84]	; 0x54
 80147d2:	9f14      	ldr	r7, [sp, #80]	; 0x50
 80147d4:	9103      	str	r1, [sp, #12]
 80147d6:	4681      	mov	r9, r0
 80147d8:	9205      	str	r2, [sp, #20]
 80147da:	461e      	mov	r6, r3
 80147dc:	f1b8 0f00 	cmp.w	r8, #0
 80147e0:	d05c      	beq.n	801489c <_wcsnrtombs_l+0xd4>
 80147e2:	9b03      	ldr	r3, [sp, #12]
 80147e4:	2b00      	cmp	r3, #0
 80147e6:	d05e      	beq.n	80148a6 <_wcsnrtombs_l+0xde>
 80147e8:	9b05      	ldr	r3, [sp, #20]
 80147ea:	681d      	ldr	r5, [r3, #0]
 80147ec:	2f00      	cmp	r7, #0
 80147ee:	d06a      	beq.n	80148c6 <_wcsnrtombs_l+0xfe>
 80147f0:	1e74      	subs	r4, r6, #1
 80147f2:	b34e      	cbz	r6, 8014848 <_wcsnrtombs_l+0x80>
 80147f4:	9b03      	ldr	r3, [sp, #12]
 80147f6:	9304      	str	r3, [sp, #16]
 80147f8:	3d04      	subs	r5, #4
 80147fa:	2600      	movs	r6, #0
 80147fc:	9501      	str	r5, [sp, #4]
 80147fe:	e00b      	b.n	8014818 <_wcsnrtombs_l+0x50>
 8014800:	9b03      	ldr	r3, [sp, #12]
 8014802:	bb2b      	cbnz	r3, 8014850 <_wcsnrtombs_l+0x88>
 8014804:	9b01      	ldr	r3, [sp, #4]
 8014806:	681a      	ldr	r2, [r3, #0]
 8014808:	2a00      	cmp	r2, #0
 801480a:	d03a      	beq.n	8014882 <_wcsnrtombs_l+0xba>
 801480c:	45bc      	cmp	ip, r7
 801480e:	d25c      	bcs.n	80148ca <_wcsnrtombs_l+0x102>
 8014810:	3c01      	subs	r4, #1
 8014812:	1c63      	adds	r3, r4, #1
 8014814:	4666      	mov	r6, ip
 8014816:	d017      	beq.n	8014848 <_wcsnrtombs_l+0x80>
 8014818:	f8d8 3000 	ldr.w	r3, [r8]
 801481c:	9302      	str	r3, [sp, #8]
 801481e:	9b01      	ldr	r3, [sp, #4]
 8014820:	f8da 50e0 	ldr.w	r5, [sl, #224]	; 0xe0
 8014824:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8014828:	9301      	str	r3, [sp, #4]
 801482a:	a907      	add	r1, sp, #28
 801482c:	4643      	mov	r3, r8
 801482e:	4648      	mov	r0, r9
 8014830:	f8d8 b004 	ldr.w	fp, [r8, #4]
 8014834:	47a8      	blx	r5
 8014836:	1c42      	adds	r2, r0, #1
 8014838:	d03a      	beq.n	80148b0 <_wcsnrtombs_l+0xe8>
 801483a:	eb00 0c06 	add.w	ip, r0, r6
 801483e:	45bc      	cmp	ip, r7
 8014840:	d9de      	bls.n	8014800 <_wcsnrtombs_l+0x38>
 8014842:	9b02      	ldr	r3, [sp, #8]
 8014844:	e9c8 3b00 	strd	r3, fp, [r8]
 8014848:	4630      	mov	r0, r6
 801484a:	b00b      	add	sp, #44	; 0x2c
 801484c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014850:	2800      	cmp	r0, #0
 8014852:	dd0e      	ble.n	8014872 <_wcsnrtombs_l+0xaa>
 8014854:	9b04      	ldr	r3, [sp, #16]
 8014856:	9d01      	ldr	r5, [sp, #4]
 8014858:	4418      	add	r0, r3
 801485a:	1e5a      	subs	r2, r3, #1
 801485c:	a907      	add	r1, sp, #28
 801485e:	f100 3eff 	add.w	lr, r0, #4294967295
 8014862:	f811 3b01 	ldrb.w	r3, [r1], #1
 8014866:	f802 3f01 	strb.w	r3, [r2, #1]!
 801486a:	4572      	cmp	r2, lr
 801486c:	d1f9      	bne.n	8014862 <_wcsnrtombs_l+0x9a>
 801486e:	9501      	str	r5, [sp, #4]
 8014870:	9004      	str	r0, [sp, #16]
 8014872:	9b05      	ldr	r3, [sp, #20]
 8014874:	681a      	ldr	r2, [r3, #0]
 8014876:	3204      	adds	r2, #4
 8014878:	601a      	str	r2, [r3, #0]
 801487a:	9b01      	ldr	r3, [sp, #4]
 801487c:	681a      	ldr	r2, [r3, #0]
 801487e:	2a00      	cmp	r2, #0
 8014880:	d1c4      	bne.n	801480c <_wcsnrtombs_l+0x44>
 8014882:	9b03      	ldr	r3, [sp, #12]
 8014884:	b10b      	cbz	r3, 801488a <_wcsnrtombs_l+0xc2>
 8014886:	9b05      	ldr	r3, [sp, #20]
 8014888:	601a      	str	r2, [r3, #0]
 801488a:	f10c 36ff 	add.w	r6, ip, #4294967295
 801488e:	2200      	movs	r2, #0
 8014890:	4630      	mov	r0, r6
 8014892:	f8c8 2000 	str.w	r2, [r8]
 8014896:	b00b      	add	sp, #44	; 0x2c
 8014898:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801489c:	9b03      	ldr	r3, [sp, #12]
 801489e:	f500 7886 	add.w	r8, r0, #268	; 0x10c
 80148a2:	2b00      	cmp	r3, #0
 80148a4:	d1a0      	bne.n	80147e8 <_wcsnrtombs_l+0x20>
 80148a6:	9b05      	ldr	r3, [sp, #20]
 80148a8:	f04f 37ff 	mov.w	r7, #4294967295
 80148ac:	681d      	ldr	r5, [r3, #0]
 80148ae:	e79f      	b.n	80147f0 <_wcsnrtombs_l+0x28>
 80148b0:	4606      	mov	r6, r0
 80148b2:	218a      	movs	r1, #138	; 0x8a
 80148b4:	2200      	movs	r2, #0
 80148b6:	4630      	mov	r0, r6
 80148b8:	f8c9 1000 	str.w	r1, [r9]
 80148bc:	f8c8 2000 	str.w	r2, [r8]
 80148c0:	b00b      	add	sp, #44	; 0x2c
 80148c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80148c6:	463e      	mov	r6, r7
 80148c8:	e7be      	b.n	8014848 <_wcsnrtombs_l+0x80>
 80148ca:	4666      	mov	r6, ip
 80148cc:	e7bc      	b.n	8014848 <_wcsnrtombs_l+0x80>
 80148ce:	bf00      	nop

080148d0 <_wcsnrtombs_r>:
 80148d0:	b510      	push	{r4, lr}
 80148d2:	b084      	sub	sp, #16
 80148d4:	4c05      	ldr	r4, [pc, #20]	; (80148ec <_wcsnrtombs_r+0x1c>)
 80148d6:	9806      	ldr	r0, [sp, #24]
 80148d8:	9000      	str	r0, [sp, #0]
 80148da:	9807      	ldr	r0, [sp, #28]
 80148dc:	9001      	str	r0, [sp, #4]
 80148de:	4804      	ldr	r0, [pc, #16]	; (80148f0 <_wcsnrtombs_r+0x20>)
 80148e0:	6800      	ldr	r0, [r0, #0]
 80148e2:	9402      	str	r4, [sp, #8]
 80148e4:	f7ff ff70 	bl	80147c8 <_wcsnrtombs_l>
 80148e8:	b004      	add	sp, #16
 80148ea:	bd10      	pop	{r4, pc}
 80148ec:	24000170 	.word	0x24000170
 80148f0:	24000160 	.word	0x24000160

080148f4 <fiprintf>:
 80148f4:	b40e      	push	{r1, r2, r3}
 80148f6:	b510      	push	{r4, lr}
 80148f8:	b083      	sub	sp, #12
 80148fa:	ab05      	add	r3, sp, #20
 80148fc:	4c06      	ldr	r4, [pc, #24]	; (8014918 <fiprintf+0x24>)
 80148fe:	f853 2b04 	ldr.w	r2, [r3], #4
 8014902:	9301      	str	r3, [sp, #4]
 8014904:	4601      	mov	r1, r0
 8014906:	6820      	ldr	r0, [r4, #0]
 8014908:	f7fb fed0 	bl	80106ac <_vfiprintf_r>
 801490c:	b003      	add	sp, #12
 801490e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8014912:	b003      	add	sp, #12
 8014914:	4770      	bx	lr
 8014916:	bf00      	nop
 8014918:	24000160 	.word	0x24000160

0801491c <abort>:
 801491c:	b508      	push	{r3, lr}
 801491e:	2006      	movs	r0, #6
 8014920:	f000 f804 	bl	801492c <raise>
 8014924:	2001      	movs	r0, #1
 8014926:	f7f2 fa3f 	bl	8006da8 <_exit>
 801492a:	bf00      	nop

0801492c <raise>:
 801492c:	b538      	push	{r3, r4, r5, lr}
 801492e:	4b15      	ldr	r3, [pc, #84]	; (8014984 <raise+0x58>)
 8014930:	281f      	cmp	r0, #31
 8014932:	681d      	ldr	r5, [r3, #0]
 8014934:	d820      	bhi.n	8014978 <raise+0x4c>
 8014936:	f8d5 2118 	ldr.w	r2, [r5, #280]	; 0x118
 801493a:	4604      	mov	r4, r0
 801493c:	b162      	cbz	r2, 8014958 <raise+0x2c>
 801493e:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
 8014942:	b14b      	cbz	r3, 8014958 <raise+0x2c>
 8014944:	2b01      	cmp	r3, #1
 8014946:	d015      	beq.n	8014974 <raise+0x48>
 8014948:	1c59      	adds	r1, r3, #1
 801494a:	d00f      	beq.n	801496c <raise+0x40>
 801494c:	2500      	movs	r5, #0
 801494e:	f842 5020 	str.w	r5, [r2, r0, lsl #2]
 8014952:	4798      	blx	r3
 8014954:	4628      	mov	r0, r5
 8014956:	bd38      	pop	{r3, r4, r5, pc}
 8014958:	4628      	mov	r0, r5
 801495a:	f000 f82b 	bl	80149b4 <_getpid_r>
 801495e:	4622      	mov	r2, r4
 8014960:	4601      	mov	r1, r0
 8014962:	4628      	mov	r0, r5
 8014964:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8014968:	f000 b80e 	b.w	8014988 <_kill_r>
 801496c:	2316      	movs	r3, #22
 801496e:	602b      	str	r3, [r5, #0]
 8014970:	2001      	movs	r0, #1
 8014972:	bd38      	pop	{r3, r4, r5, pc}
 8014974:	2000      	movs	r0, #0
 8014976:	bd38      	pop	{r3, r4, r5, pc}
 8014978:	2316      	movs	r3, #22
 801497a:	602b      	str	r3, [r5, #0]
 801497c:	f04f 30ff 	mov.w	r0, #4294967295
 8014980:	bd38      	pop	{r3, r4, r5, pc}
 8014982:	bf00      	nop
 8014984:	24000160 	.word	0x24000160

08014988 <_kill_r>:
 8014988:	b570      	push	{r4, r5, r6, lr}
 801498a:	460c      	mov	r4, r1
 801498c:	4d08      	ldr	r5, [pc, #32]	; (80149b0 <_kill_r+0x28>)
 801498e:	4603      	mov	r3, r0
 8014990:	2600      	movs	r6, #0
 8014992:	4620      	mov	r0, r4
 8014994:	4611      	mov	r1, r2
 8014996:	461c      	mov	r4, r3
 8014998:	602e      	str	r6, [r5, #0]
 801499a:	f7f2 f9f9 	bl	8006d90 <_kill>
 801499e:	1c43      	adds	r3, r0, #1
 80149a0:	d000      	beq.n	80149a4 <_kill_r+0x1c>
 80149a2:	bd70      	pop	{r4, r5, r6, pc}
 80149a4:	682b      	ldr	r3, [r5, #0]
 80149a6:	2b00      	cmp	r3, #0
 80149a8:	d0fb      	beq.n	80149a2 <_kill_r+0x1a>
 80149aa:	6023      	str	r3, [r4, #0]
 80149ac:	bd70      	pop	{r4, r5, r6, pc}
 80149ae:	bf00      	nop
 80149b0:	24006180 	.word	0x24006180

080149b4 <_getpid_r>:
 80149b4:	f7f2 b9f6 	b.w	8006da4 <_getpid>
